{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;                       // State A: y[2] = 0\n            3'b001: Y2 = ~w;                      // State B: y[2] = ~w => 0 if w=1, 1 if w=0\n            3'b010: Y2 = 1;                       // State C: y[2] = 1\n            3'b011: Y2 = 1;                       // State D: y[2] = 1\n            3'b100: Y2 = 1;                       // State E: y[2] = 1\n            3'b101: Y2 = 0;                       // State F: y[2] = 0\n            default: Y2 = 0;                      // Default case to handle unknown states\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    assign zero = 1'b0; // Always outputs LOW\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 0;\n        else\n            q <= 1;\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n    // Define State Enum\n    typedef enum logic [1:0] {\n        S0, // Initial/Non-complementing state\n        S1  // Complementing state\n    } state_t;\n\n    state_t current_state, next_state;\n    logic complement_bit;\n\n    // State Transition\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= S0; // Reset to S0 on asynchronous reset\n        else \n            current_state <= next_state;\n    end\n\n    // Next State Logic\n    always_comb begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0; // Transition to S1 on first 1\n            S1: next_state = S1; // Remain in S1, continuously complement \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output Logic\n    always_comb begin\n        complement_bit = (current_state == S1) ? ~x : x;\n    end\n\n    assign z = complement_bit;\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case for safety\n        endcase\n    end\n\n    // Sequential logic with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r) \n            q <= 1'b0;\n        else \n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n    \n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into shift register\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1 bit\n                2'b01: q <= q << 8; // Shift left by 8 bits\n                2'b10: q <= $signed(q) >>> 1; // Arithmetic shift right by 1 bit\n                2'b11: q <= $signed(q) >>> 8; // Arithmetic shift right by 8 bits\n                default: q <= q; // Default case for safety (shouldn't occur)\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // Saw '1'\n        S2 = 2'b10  // Saw '10'\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default assignments\n        next_state = current_state;\n        z = 1'b0;\n\n        case (current_state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1; // Sequence \"101\" detected\n                end else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            A: next_state = (w) ? A : B;\n            B: next_state = (w) ? D : C;\n            C: next_state = (w) ? D : E;\n            D: next_state = (w) ? A : F;\n            E: next_state = (w) ? D : E;\n            F: next_state = (w) ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == E || state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n    // State encoding\n    typedef enum {IDLE, BYTE1, BYTE2, BYTE3} state_t;\n    state_t state, next_state;\n\n    // Registers to hold received bytes\n    reg [7:0] byte1, byte2, byte3;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if (in[3] == 1) begin // Check if in[3] == 1\n                    next_state = BYTE1;\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done = 1;            // Signal \"done\" after 3rd byte\n                next_state = IDLE;   // Back to IDLE for the next message\n            end\n        endcase\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            byte1 <= 8'b0;\n            byte2 <= 8'b0;\n            byte3 <= 8'b0;\n            out_bytes <= 24'b0;\n        end else begin\n            case (next_state)\n                BYTE1: byte1 <= in;               // Store first byte\n                BYTE2: byte2 <= in;               // Store second byte\n                BYTE3: begin\n                    byte3 <= in;                  // Store third byte\n                    out_bytes <= {byte1, byte2, in}; // Update output bytes\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    // Y1 is the next-state logic for state B (000010)\n    assign Y1 = (y[0] & w); // Transition from A to B on w=1\n\n    // Y3 is the next-state logic for state D (001000)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[3] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n    // Transitions to D:\n    // From B (y[1]) on w=0\n    // From C (y[2]) on w=0\n    // From D itself (y[3]) on w=0\n    // From E (y[4]) on w=0\n    // From F (y[5]) on w=0\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;  // Assign the input vector to the output vector\n    assign o2 = vec[2]; // Assign bit 2 of input to o2\n    assign o1 = vec[1]; // Assign bit 1 of input to o1\n    assign o0 = vec[0]; // Assign bit 0 of input to o0\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n    assign out_hi = in[15:8];  // Upper byte\n    assign out_lo = in[7:0];   // Lower byte\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // Using assign statement\n    assign out_assign = a ^ b;\n\n    // Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // Logic for Y2 (state B)\n    // Y2 (state B) is set when transitioning:\n    // - From state A (y[1]) on input w = 0\n    // - From state F (y[6]) on input w = 0\n    assign Y2 = (y[1] & ~w) | (y[6] & ~w);\n\n    // Logic for Y4 (state D)\n    // Y4 (state D) is set when transitioning:\n    // - From state B (y[2]) on input w = 1\n    // - From state C (y[3]) on input w = 1\n    // - From state D (y[4]) on input w = 1\n    // - From state E (y[5]) on input w = 1\n    // - From state F (y[6]) on input w = 1\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & w) | (y[5] & w) | (y[6] & w);\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L) \n            Q <= R;       // Load value R when L is asserted\n        else if (E) \n            Q <= w;       // Shift input w when E is asserted\n        // Else Q retains its value (no changes)\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    reg q1, q2, q3; // D flip-flop outputs\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;            // XOR with its own flip-flop output\n        q2 <= x & ~q2;           // AND with complemented flip-flop output\n        q3 <= x | ~q3;           // OR with complemented flip-flop output\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3); // XNOR of all flip-flop outputs\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = c | (b & d);\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the input data into q\n            q <= data;\n        end else begin\n            // Compute the next state for each cell\n            reg [511:0] next_q;\n            integer i;\n            for (i = 0; i < 512; i = i + 1) begin\n                // Handle boundaries: q[-1] and q[512] are considered 0\n                reg left, center, right;\n                left = (i == 0) ? 0 : q[i-1];\n                center = q[i];\n                right = (i == 511) ? 0 : q[i+1];\n                \n                // Update the next state based on Rule 110\n                next_q[i] = (left & center & ~right) | (left & ~center & right) | (~left & center & right) | (~left & center & ~right);\n            end\n            q <= next_q;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine: output depends only on the state)\n    always @(*) begin\n        case (state)\n            A, B, C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'b0000: q = b;\n            4'b0001: q = e;\n            4'b0010: q = a;\n            4'b0011: q = d;\n            default: q = 4'b1111;\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] out\n);\n\n    // Select between a and b based on sel\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "// Submodule: D flip-flop\nmodule d_flipflop(\n    input clk,\n    input D,\n    output reg Q\n);\n    always @(posedge clk) begin\n        Q <= D;\n    end\nendmodule\n\n// Submodule: 2:1 multiplexer\nmodule mux_2to1(\n    input sel,\n    input a,\n    input b,\n    output y\n);\n    assign y = sel ? b : a;\nendmodule\n\n// Top module\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output Q\n);\n    wire mux_out; // Output of the multiplexer\n\n    // Instantiate 2:1 multiplexer\n    mux_2to1 u_mux (\n        .sel(L),\n        .a(q_in),\n        .b(r_in),\n        .y(mux_out)\n    );\n\n    // Instantiate D flip-flop\n    d_flipflop u_ff (\n        .clk(clk),\n        .D(mux_out),\n        .Q(Q)\n    );\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end\n        else begin\n            out <= out | (prev_in & ~in); // Detect 1-to-0 transitions\n            prev_in <= in;               // Store previous input\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "```verilog\nmodule top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // Output logic (Moore machine outputs depend only on the current state)\n    assign shift_ena = state[4] | state[5] | state[6] | state[7]; // B0, B1, B2, B3\n    assign counting = state[8]; // Count\n    assign done = state[9];     // Wait\n\n    // Next-state logic\n    assign S_next = state[0] & ~d | state[1] & ~d | state[2] & ~d | state[3] & ~d | state[9] & ack; // S transitions\n    assign S1_next = state[0] & d; // S to S1 on d=1\n    assign S1_next = state[00state"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 2'b01; // Increment\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 2'b01; // Decrement\n            end\n        end\n        // Else, retain state\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in)\n            8'b???????1: pos = 3'd0;\n            8'b??????10: pos = 3'd1;\n            8'b?????100: pos = 3'd2;\n            8'b????1000: pos = 3'd3;\n            8'b???10000: pos = 3'd4;\n            8'b??100000: pos = 3'd5;\n            8'b?1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default:     pos = 3'd0; // Output 0 if no bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        // Default outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Check scancode and assert outputs accordingly\n        case (scancode)\n            16'he06b: left = 1;\n            16'he072: down = 1;\n            16'he074: right = 1;\n            16'he075: up = 1;\n            default: ; // No output asserted for other scancodes\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Instantiate full adders\n    fa adder0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    fa adder1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    fa adder2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    fa adder3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n\n    assign sum[4] = c4; // Overflow bit\nendmodule\n\n// Full adder module\nmodule fa (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Reset history to all zeros\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        // On misprediction, load corrected history\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        // On valid prediction, shift in predict_taken\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    // Intermediate wires\n    wire and1_out, and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] Q; // 8-bit shift register\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift in input S to MSB (Q[7] -> S)\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C}) // 3-bit select determines output Z\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case (for safety)\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n    // Heater is active in heating mode when too_cold is true\n    assign heater = mode & too_cold;\n\n    // Air conditioner is active in cooling mode when too_hot is true\n    assign aircon = ~mode & too_hot;\n\n    // Fan is active if either the heater, air conditioner, or fan_on is active\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n    // SOP form: Out = (A' B C D) + (A B' C D') + (A B C D)\n    assign out_sop = (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & c & d);\n\n    // POS form: Out = (A + B + C' + D') \u00b7 (A + B' + C + D') \u00b7 (A' + B + C + D)\n    assign out_pos = (a | b | ~c | ~d) & (a | ~b | c | ~d) & (~a | b | c | d);\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset to default state\n        end else begin\n            // Implement Galois LFSR\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b | a) & (c | d);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 8'b0; // Initialize output to 0\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Compute out_both[2:0]: Both in[i] and in[i+1] are 1 (excluding in[3])\n    assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\n    \n    // Compute out_any[3:1]: Either in[i] or in[i-1] is 1 (excluding in[0])\n    assign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\n    \n    // Compute out_different[3:0]: in[i] is different from in[i+1], with wrapping\n    assign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\n    \nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'b0000;  // Reset the counter to 0\n        else if (slowena) begin\n            if (q == 4'b1001) \n                q <= 4'b0000;  // Reset to 0 after reaching 9\n            else \n                q <= q + 1;  // Increment counter\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // in2 passes through the bubble (inversion) before the AND gate\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {STATE_A=0, STATE_B=1} state_t;\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Default to STATE_B as safety\n        endcase\n    end\n\n    // State register (sequential logic with async reset)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (combinational - based on current state only)\n    always_comb begin\n        case (state)\n            STATE_A: out = 0;\n            STATE_B: out = 1;\n            default: out = 1; // Default to safe value\n        endcase\n    end\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    reg q_pos, q_neg;\n\n    // Capture `d` on the rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Capture `d` on the falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Output logic to select appropriate value\n    always @(*) begin\n        if (clk)\n            q = q_pos; // Output value captured on posedge\n        else\n            q = q_neg; // Output value captured on negedge\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b); // XNOR operation\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiating modules A and B\n    A a1 (.x(x), .y(y), .z(a1_out));\n    A a2 (.x(x), .y(y), .z(a2_out));\n    B b1 (.x(x), .y(y), .z(b1_out));\n    B b2 (.x(x), .y(y), .z(b2_out));\n    \n    // OR and AND gates\n    assign or_out = a1_out | b1_out;\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into q\n        end\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};        // Rotate right by 1\n                2'b10: q <= {q[98:0], q[99]};       // Rotate left by 1\n                default: q <= q;                    // No operation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;        // Synchronous reset to 0\n        else if (q == 10'd999)\n            q <= 10'd0;        // Wrap around to 0 after 999\n        else\n            q <= q + 10'd1;    // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output reg [9:0] next_state,\n    output reg out1,\n    output reg out2\n);\n\n    always @(*) begin\n        // Default values for next_state and outputs\n        next_state = 10'b0;\n        out1 = 0;\n        out2 = 0;\n\n        // State transition and output logic\n        case (1'b1) // Identify the current state (one-hot encoding)\n            state[0]: next_state = in ? 10'b0000000010 : 10'b0000000001; // S0\n            state[1]: next_state = in ? 10'b0000000100 : 10'b0000000001; // S1\n            state[2]: next_state = in ? 10'b0000001000 : 10'b0000000001; // S2\n            state[3]: next_state = in ? 10'b0000010000 : 10'b0000000001; // S3\n            state[4]: next_state = in ? 10'b0000100000 : 10'b0000000001; // S4\n            state[5]: next_state = in ? 10'b0001000000 : 10'b1000000000; // S5\n            state[6]: next_state = in ? 10'b0010000000 : 10'b0100000000; // S6\n            state[7]: begin // S7\n                next_state = in ? 10'b0010000000 : 10'b0000000001;\n                out2 = 1;\n            end\n            state[8]: begin // S8\n                next_state = in ? 10'b0000000010 : 10'b0000000001;\n                out1 = 1;\n            end\n            state[9]: begin // S9\n                next_state = in ? 10'b0000000010 : 10'b0000000001;\n                out1 = 1;\n                out2 = 1;\n            end\n            default: next_state = 10'b0000000001; // S0 (fallback state)\n        endcase\n    end\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;        // No change\n            2'b01: Q <= 1'b0;     // Reset\n            2'b10: Q <= 1'b1;     // Set\n            2'b11: Q <= ~Q;       // Toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n    // State definition\n    typedef enum logic [1:0] {LEFT = 2'b01, RIGHT = 2'b10} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore FSM, outputs depend only on the state)\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b; // AND operation\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate wires for AND gate outputs\n    wire and1_out, and2_out, and3_out, and4_out;\n\n    // AND gates\n    assign and1_out = p1a & p1b & p1c; // First 3-input AND gate for p1y\n    assign and2_out = p1d & p1e & p1f; // Second 3-input AND gate for p1y\n    assign and3_out = p2a & p2b;       // First 2-input AND gate for p2y\n    assign and4_out = p2c & p2d;       // Second 2-input AND gate for p2y\n\n    // OR gates\n    assign p1y = and1_out | and2_out;  // OR the outputs of the first two AND gates\n    assign p2y = and3_out | and4_out;  // OR the outputs of the last two AND gates\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] next_state;\n\n    // Combinational logic for next state and output\n    always @(*) begin\n        case (y)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n\n        // Output 'z' based on present state\n        case (y)\n            3'b011, 3'b100: z = 1;\n            default: z = 0;\n        endcase\n    end\n\n    // Update state and output Y0 on the clock edge\n    always @(posedge clk) begin\n        Y0 <= next_state[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000; // Output 0 for invalid sel\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the counter with the input data\n        end else if (counter != 0) begin\n            counter <= counter - 1; // Decrement counter\n        end\n    end\n\n    assign tc = (counter == 0); // tc is asserted when counter reaches 0\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2, // Detected '11'\n        S3, // Detected '110'\n        S4  // Detected '1101'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4; // Remain in S4 once the sequence is found\n            default: next_state = S0;\n        endcase\n    end\n\n    // State update logic (sequential block)\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (state == S4)\n            start_shifting <= 1'b1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev; // Register to store the previous value of 'in'\n\n    always @(posedge clk) begin\n        anyedge <= (in & ~prev); // Detect 0-to-1 transitions\n        prev <= in;             // Update previous value\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd1; // Synchronous reset to 1\n        else if (q == 4'd10) \n            q <= 4'd1; // Wrap back to 1 after reaching 10\n        else \n            q <= q + 4'd1; // Increment the counter\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a) \n            q <= 3'b100;   // Reset to 4\n        else \n            q <= q + 1;    // Increment\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Reset LFSR to 1\n        end\n        else begin\n            // Implement Galois LFSR with taps at bit positions 5 and 3\n            q <= {q[3:0], q[4] ^ q[2]};\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // Check if the result is zero and assign result_is_zero accordingly\n        result_is_zero = (out == 8'b0);\n    end\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "Here is the completed Verilog code that implements the function based on the given Karnaugh map:\n\n```verilog\nmodule top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0001, 4'b0011, 4'b0010: f = 0; // Rows with 0 or don't-cares resolved\n            4'b0110, 4'bXTURN!! Decisions"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = (~c & d) | (c & d) | (~b & c);\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in data (MSB first)\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            // Decrement register value\n            q <= q - 1;\n        end\n    end\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n    reg [2:0] state, next_state;\n    reg [2:0] count;\n\n    // State encoding\n    localparam IDLE = 3'b000,\n               SHIFT = 3'b001;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            IDLE: next_state = reset ? SHIFT : IDLE;\n            SHIFT: next_state = (count == 3) ? IDLE : SHIFT;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk) begin\n        if (reset)\n            state <= SHIFT;  // On reset, transition to SHIFT state\n        else\n            state <= next_state;\n    end\n\n    // Counter for 4 clock cycles\n    always @(posedge clk) begin\n        if (reset)\n            count <= 0;  // Reset counter\n        else if (state == SHIFT)\n            count <= count + 1;\n        else\n            count <= 0;  // Clear counter in IDLE state\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            shift_ena <= 1;  // Enable for the first 4 cycles after reset\n        else\n            shift_ena <= (state == SHIFT);\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Reset counter to 0\n        else\n            q <= q + 1;   // Increment counter\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using always block with procedural if\n    always @(*) begin\n        if (sel_b1 && sel_b2) begin\n            out_always = b;\n        end else begin\n            out_always = a;\n        end\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | b; // Simplified expression from the Karnaugh map\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00, // Idle state\n        B = 2'b01, // Grant device 1\n        C = 2'b10, // Grant device 2\n        D = 2'b11  // Grant device 3\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= A; // Reset state\n        else\n            current_state <= next_state;\n    end\n\n    // State transition logic (combinational logic)\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                next_state = A; // Device 3 has the lowest priority; return to A\n            end\n            default:\n                next_state = A; // Default state in case of unexpected behavior\n        endcase\n    end\n\n    // Output logic (combinational logic)\n    always @(*) begin\n        g = 3'b000; // Default: no grants\n        case (current_state)\n            B: g = 3'b001; // Grant device 1\n            C: g = 3'b010; // Grant device 2\n            D: g = 3'b100; // Grant device 3\n            default: g = 3'b000; // No grants in state A\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Reset to 0\n        else if (q == 4'd9)\n            q <= 4'b0000; // Wrap around to 0 after 9\n        else\n            q <= q + 1; // Increment the counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n\n    reg [1:0] state, next_state;\n    reg done_reg;\n\n    // State encoding\n    localparam IDLE = 2'b00, BYTE_1 = 2'b01, BYTE_2 = 2'b10, BYTE_3 = 2'b11;\n\n    // State transitions\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE:    next_state = in[3] ? BYTE_1 : IDLE;\n            BYTE_1:  next_state = BYTE_2;\n            BYTE_2:  next_state = BYTE_3;\n            BYTE_3:  next_state = in[3] ? BYTE_1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Done signal logic\n    always @(posedge clk) begin\n        if (reset)\n            done_reg <= 1'b0;\n        else\n            done_reg <= (state == BYTE_3); // Assert done after 3rd byte\n    end\n\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;  // 4-input AND gate\n    assign out_or = |in;   // 4-input OR gate\n    assign out_xor = ^in;  // 4-input XOR gate\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] state, next_state;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000; // Synchronous reset to state 000\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        case (state)\n            3'b000: begin\n                next_state = (x == 1'b0) ? 3'b000 : 3'b001;\n                z = 1'b0;\n            end\n            3'b001: begin\n                next_state = (x == 1'b0) ? 3'b001 : 3'b100;\n                z = 1'b0;\n            end\n            3'b010: begin\n                next_state = (x == 1'b0) ? 3'b010 : 3'b001;\n                z = 1'b0;\n            end\n            3'b011: begin\n                next_state = (x == 1'b0) ? 3'b001 : 3'b010;\n                z = 1'b1;\n            end\n            3'b100: begin\n                next_state = (x == 1'b0) ? 3'b011 : 3'b100;\n                z = 1'b1;\n            end\n            default: begin\n                next_state = 3'b000; // Default state in case of invalid state\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "```verilog\nmodule top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    // State encoding\n\ttypedef enum reg [2:0] {A, B, C, D, E, F, G, H} state_t;\n\tstate_t state, next_state;\n\n    // Sequential block for state transition\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tstate <= A; // Reset to state A\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n    // State transition logic and output signals\n\talways @(*) begin\n\t\t// Default outputs and state transitions\n\t\tf = 0;\n\t\tg = 0;\n\t\tnext_state = state;\n\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tf = 0; g = 0;\n\t\t\t\tif (resetn) next_state = B;\n\t\t\tend\n\n\t\t\tB: begin\n\t\t\t\tf = 1; // Output f is set for one clock cycle\n\t\t\t\tnext_state = C;\n\t\t\tend\n\n\t\t\tC: begin\n\t\t\t\tf = 0;\n\t\t\t\tif (x) next_state = D;//\n\t\t\tetc well logic---\n      argpladt.br1#"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34; // Reset to 0x34\n        else\n            q <= d; // Capture input on negative edge of clk\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR reduction to calculate parity bit\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n    \n    // Combinational logic for next state and output\n    always @(*) begin\n        case (state)\n            2'b00: begin // State A\n                next_state = (in == 1'b0) ? 2'b00 : 2'b01; // A->A or A->B\n            end\n            2'b01: begin // State B\n                next_state = (in == 1'b0) ? 2'b10 : 2'b01; // B->C or B->B\n            end\n            2'b10: begin // State C\n                next_state = (in == 1'b0) ? 2'b00 : 2'b11; // C->A or C->D\n            end\n            2'b11: begin // State D\n                next_state = (in == 1'b0) ? 2'b10 : 2'b01; // D->C or D->B\n            end\n            default: begin\n                next_state = 2'b00; // Default: Set to state A\n            end\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 2'b11) ? 1'b1 : 1'b0; // Output is 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x & y) | (~x & ~y);\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State flip-flops: State register\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= A;  // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // State transition table\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A;  // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1'b1;  // Output z = 1 for states E and F\n            default: z = 1'b0;  // Output z = 0 for all other states\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Synchronous reset, active low\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0]; // Update lower byte\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8]; // Update upper byte\n            end\n        end\n    end\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] in_d; // Register to store the delayed input signal\n    \n    always @(posedge clk) begin\n        in_d <= in;            // Store the current input signal\n        pedge <= (~in_d) & in; // Perform positive edge detection\n    end\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "```verilog\nmodule top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    reg state; // Internal state variable\n\n    always @(posedge clock) begin\n        if (!a) begin\n            p <= 0;\n        end else begin\n            p <= 1;\n        end\nq<=---w"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the initial data when load is high\n        end else begin\n            // Compute the next state based on Rule 90\n            q[0] <= q[1]; // Left boundary (q[-1] is 0)\n            q[511] <= q[510]; // Right boundary (q[512] is 0)\n            // Calculate for all other cells\n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n    assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // Generate out_both[98:0]\n    assign out_both = in[99:1] & in[98:0];\n\n    // Generate out_any[99:1]\n    assign out_any = in[99:1] | in[98:0];\n\n    // Generate out_different[99:0] (treating the vector as wrapping around)\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena)\n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel * 4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Unused cases (sel=9 to 15)\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    assign out_or_bitwise = a | b;             // Bitwise OR\n    assign out_or_logical = |(a | b);          // Logical OR\n    assign out_not = {~b, ~a};                 // Concatenate NOT of b and a\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // State A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // State B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // State C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // State D\n            default: next_state = 4'b0001; // Default to State A\n        endcase\n    end\n\n    // Output logic (Moore state machine: output depends only on the current state)\n    assign out = (state == 4'b1000) ? 1 : 0; // Output is 1 only in state D\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        // Compare pairwise to find the minimum\n        min = a;\n        if (b < min)\n            min = b;\n        if (c < min)\n            min = c;\n        if (d < min)\n            min = d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n    // Logic gate outputs\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = (~c & ~d & (~a | b)) | \n                 (~c & d & (a | ~b))  | \n                 (c & d & (a | b))    | \n                 (c & ~d & (~a | b));\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State Encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        W1 = 2'b10,\n        W2 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] w_count; // Counter for 'w = 1' occurrences\n    reg [1:0] cycle_count; // Track cycles in state B\n\n    // State Transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic and Counter Updates\n    always @(*) begin\n        z = 1'b0; // Default assignment\n        next_state = state;\n\n        case (state)\n            A: begin\n                if (s) begin\n                    next_state = B;\n                    w_count = 2'd0; // Reset counters\n                    cycle_count = 2'd0;\n                end\n            end\n            B: begin\n                if (cycle_count == 2'd2) begin\n                    // Check `w` count\n                    if (w_count + w == 2'd2) begin\n                        z = 1'b1;\n                    end\n                    next_state = B;cells skipping count . th line fixed alots"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    assign out = { {24{in[7]}}, in };\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)   // Active-low synchronous reset\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3]; // Output the MSB\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        case (1'b1)\n            in[3]: pos = 2'd3;\n            in[2]: pos = 2'd2;\n            in[1]: pos = 2'd1;\n            in[0]: pos = 2'd0;\n            default: pos = 2'd0; // If none of the input bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    typedef enum logic {OFF = 1'b0, ON = 1'b1} state_t;\n    state_t state, next_state;\n    \n    // State Transition Logic\n    always_comb begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State Flip-Flops with Asynchronous Reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output Logic (Moore Machine)\n    always_comb begin\n        out = (state == ON) ? 1'b1 : 1'b0;\n    end\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    assign out = 1'b0; // Drive the output to logic low (0)\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one);\n\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always @(posedge clk) begin\n        out <= in ^ out; // XOR 'in' with 'out' and store it in 'out'\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            q <= 4'b0000; // Asynchronous reset\n        else if (load) \n            q <= data; // Load data\n        else if (ena) \n            q <= {1'b0, q[3:1]}; // Shift right\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (x2 & ~x3) | (x3 & x1);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;  // Reset all outputs to 0\n        else\n            q <= d;     // Capture the input 'd' on the positive edge of the clock\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;       // Reduction AND\n    assign out_or = |in;        // Reduction OR\n    assign out_xor = ^in;       // Reduction XOR\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b;  // XOR for sum\n    assign cout = a & b; // AND for carry-out\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        // Shut off the computer if CPU is overheated\n        shut_off_computer = cpu_overheated;\n    end\n\n    always @(*) begin\n        // Keep driving if not arrived and gas tank is not empty\n        if (!arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    localparam OFF = 1'b0, ON = 1'b1;\n\n    reg state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1) ? ON : OFF;\n            ON:  next_state = (k == 1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register (sequential)\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate input vectors and two '1' bits\n    wire [31:0] concat;\n    assign concat = {a, b, c, d, e, f, 2'b11};\n\n    // Split the concatenated vector into outputs\n    assign w = concat[31:24];\n    assign x = concat[23:16];\n    assign y = concat[15:8];\n    assign z = concat[7:0];\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d)   | \n               (~a & b & ~c & d)   | \n               (~a & b & c & ~d)   | \n               (a & ~b & ~c & d)   | \n               (a & ~b & c & ~d)   | \n               (a & b & ~c & ~d)   | \n               (a & b & c & d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg {A = 1'b0, B = 1'b1} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            B: next_state = (in == 1'b0) ? A : B;\n            A: next_state = (in == 1'b0) ? B : A;\n            default: next_state = B; // Default state\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B; // Reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            B: out = 1'b1;\n            A: out = 1'b0;\n            default: out = 1'b0; // Safety\n        endcase\n    end\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    assign sum = a ^ b ^ cin; // Sum is XOR of a, b, and cin\n    assign cout = (a & b) | (b & cin) | (a & cin); // Carry-out logic\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    logic xnor_result;\n\n    assign xnor_result = ~(in1 ^ in2); // XNOR gate\n    assign out = xnor_result ^ in3;   // XOR gate\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    assign mux_in[0] = ~c & d;  // Row: cd = 00\n    assign mux_in[1] = 0;       // Row: cd = 01\n    assign mux_in[2] = c | d;   // Row: cd = 11\n    assign mux_in[3] = ~c | d;  // Row: cd = 10\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding (one-hot)\n    reg state_A, state_B;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1; // Reset to state A\n            state_B <= 1'b0;\n        end else begin\n            case ({state_A, state_B})\n                2'b10: begin // State A\n                    if (x) begin\n                        state_A <= 1'b0;\n                        state_B <= 1'b1;\n                    end\n                end\n                2'b01: begin // State B\n                    if (~x) begin\n                        state_B <= 1'b1;\n                        state_A <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\nend-module\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n    always @(posedge clk) begin\n        // Update state based on a and b\n        state <= (a & b) ? ~state : state;\n    end\n\n    // q mirrors state\n    always @(*) begin\n        q = state;\n    end\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0011: f = 1;\n            4'b1011, 4'b1000, 4'b1001, 4'b1110, 4'b1100, 4'b1101: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        S1 = 3'b001,\n        S2 = 3'b010,\n        S3 = 3'b011,\n        S4 = 3'b100,\n        S5 = 3'b101,\n        S6 = 3'b110,\n        ERROR = 3'b111\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE; // Reset to IDLE state\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default assignments\n        next_state = current_state;\n        disc = 0;\n        flag = 0;\n        err = 0;\n\n        case (current_state)\n            // IDLE state, in sync with reset\n            IDLE: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = IDLE;\n            end\n\n            S1: begin\n                if (in)\n                    next_state = S2;\n                else\n                    next_state = IDLE;\n            end\n\n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = IDLE;\n            end\n\n            S3: begin\n                if (in)\n                    next_state = S4;\n                else\n                    next_state = IDLE;\n            end\n\n            S4: begin\n                if (in)\n                    next_state = S5;\n                else\n                    next_state = IDLE;\n            end\n\n            S5: begin\n                if (in)\n                    next_state = S6;\n                else\n                    next_state = IDLE;\n            end\n\n            S6: begin\n                if (in) begin\n                    next_state = ERROR;\n                    err = 1;\n                end else begin\n                    next_state = S1;\n                    disc = 1;\n                end\n            end\n\n            ERROR: begin\n                if (!in)\n                    next_state = IDLE; // Exit error on a 0\n                else\n                    next_state = ERROR; // Stay in error if consecutive 1s\n                err = 1; // Assert error signal\n            end\n\n            default: next_state = IDLE;\n        endcase\n\n        // Detect flag (6 consecutive 1s followed by 0)\n        if (current_state == S5 && next_state == S1)\n            flag = 1;\n    end\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack);\n\n    // State encoding\n    typedef enum {\n        WAIT_PATTERN,\n        LOAD_DELAY,\n        COUNTING,\n        DONE\n    } state_t;\n    state_t state, next_state;\n\n    reg [3:0] delay;\n    reg [13:0] counter; // For 1000-cycle increments\n    \n    reg [3:0] shift_reg; // 4-bit shift register for detecting \"1101\"\n    reg [2:0] bit_count; // Counts bits during delay load\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_PATTERN;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        // Default outputs and next state\n        next_state = state;\n        counting = 1'b0;\n        done = 1'b0;\n        count = 4'b0000;\n\n        case (state)\n            WAIT_PATTERN: begin\n                if (shift_reg == 4'b1101) begin\n                    next_state = LOAD_DELAY;\n                end\n            end\n            LOAD_DELAY: begin\n                if (bit_count == 3'd4) begin\n                    next_state = COUNTING;\n                end\n            end\n            COUNTING: begin\n                counting = 1'b1;\n                count = counter[13:10]; // Remaining time\n                if (counter == 14'd0) begin\n                    next_state = DONE;\n                end\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack) begin\n                    next_state = WAIT_PATTERN;\n                end\n            end\n        endcase\n    end\n\n    // Data shift register and bit counter\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            bit_count <= 3'd0;\n            delay <= 4'b0000;\n        end else if (state == WAIT_PATTERN) begin\n            shift_reg <= {shift_reg[2:0], data};\n        end else if (state == LOAD_DELAY) begin\n            delay <= {delay[2:0], data};\n            bit_count <= bit_count + 1;\n        end else if (state == DONE && ack) begin\n            shift_reg <= 4'b0000;\n            bit_count <= 3'd0;\n            delay <= 4'b0000;\n        end\n    end\n\n    // Timer counter\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 14'd0;\n        end else if (state == LOAD_DELAY && bit_count == 3'd4) begin\n            counter <= (delay + 1) * 1000 - 1;\n        end else if (state == COUNTING && counter != 14'd0) begin\n            counter <= counter - 1;\n        end else if (state == DONE && ack) begin\n            counter <= 14'd0;\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State definition\n    typedef enum reg [1:0] {\n        LOW,\n        BTWN_S1_S2,\n        BTWN_S2_S3,\n        ABOVE_S3\n    } state_t;\n\n    state_t current_state, next_state;\n    reg prev_level_up;\n\n    // State Transition Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= LOW;\n            prev_level_up <= 1'b0; // Reset previous level change direction\n        end else begin\n            current_state <= next_state;\n            \n            // Track if water level is rising compared to the last change\n            if ((next_state > current_state) && next_state != LOW)\n                prev_level_up <= 1'b1;\n            else if (next_state < current_state)\n                prev_level_up <= 1'b0;\n        end\n    end\n\n    // Combinational Next State Logic\n    always @(*) begin\n        case (s)\n            3'b111: next_state = ABOVE_S3;\n            3'b011: next_state = BTWN_S2_S3;\n            3'b001: next_state = BTWN_S1_S2;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Default outputs\n        fr1 = 1'b0;\n        fr2 = 1'b0;\n        fr3 = 1'b0;\n        dfr = 1'b0;\n\n        case (current_state)\n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n            end\n            BTWN_S1_S2: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                if (prev_level_up)\n                    dfr = 1'b1; // Open supplemental flow valve if level increased\n            end\n            BTWN_S2_S3: begin\n                fr1 = 1'b1;\n                if (prev_level_up)\n                    dfr = 1'b1; // Open supplemental flow valve if level increased\n            end\n            ABOVE_S3: begin\n                // No flow enabled\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_counter; // Counts the 8 data bits\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output generation\n    always @(*) begin\n        // Default outputs\n        done = 0; \n        next_state = state;\n\n        case (state)\n            IDLE: begin\n                if (in == 0) // Start bit detected\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA; // Move to data capture\n            end\n            DATA: begin\n                if (bit_counter == 7) // All 8 data bits received\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1) begin // Validate stop bit\n                    done = 1;\n                    next_state = IDLE; // Go back to IDLE\n                end else\n                    next_state = ERROR; // Error state\n            end\n            ERROR: begin\n                if (in == 1) // Wait for proper stop bit\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Bit counter to track 8 data bits\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            bit_counter <= 0;\n        else if (state == DATA)\n            bit_counter <= bit_counter + 1;\n        else if (state != DATA)\n            bit_counter <= 0;\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE     = 3'b000,\n        START    = 3'b001,\n        DATA     = 3'b010,\n        STOP     = 3'b011,\n        ERROR    = 3'b100\n    } state_t;\n\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count;\n    reg [7:0] data_reg; \n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default outputs\n        done = 0;\n        next_state = state;\n\n        case (state)\n            IDLE: begin\n                if (in == 0) // Start bit detected\n                    next_state = START;\n            end\n            START: begin\n                if (in == 0) // Confirm start bit\n                    next_state = DATA;\n                else\n                    next_state = IDLE; // False start\n            end\n            DATA: begin\n                if (bit_count == 7)\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1) begin // Valid stop bit\n                    next_state = IDLE;\n                    done = 1; // Mark byte ready\n                end else begin\n                    next_state = ERROR; // Wait for next valid stop bit\n                end\n            end\n            ERROR: begin\n                if (in == 1) // Wait for stop bit to go high\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Data and bit_count management\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_count <= 0;\n            data_reg <= 0;\n            out_byte <= 0;\n        end else begin\n            if (state == DATA) begin\n                data_reg[bit_count] <= in; // Shift in LSB first\n                if (bit_count == 7)\n                    bit_count <= 0; // Reset bit count after 8 bits\n                else\n                    bit_count <= bit_count + 1;\n            end else if (state == STOP && next_state == IDLE) begin\n                out_byte <= data_reg; // Latch the received byte\n            end else if (state != DATA) begin\n                bit_count <= 0; // Reset bit count outside DATA state\n            end\n        end\n    end\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n    reg [1:0] pht [0:127]; // 128-entry table of 2-bit saturating counters\n    reg [6:0] global_history; // 7-bit global history register\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n\n    // XOR for hashed index\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    integer i;\n    \n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b10; // Initialize PHT to weakly taken (10)\n        end else begin\n            // Training logic\n            if (train_valid) begin\n                // Update PHT entry\n                if (train_taken) begin\n                    if (pht[train_index] != 2'b11)\n                        pht[train_index] <= pht[train_index] + 1;\n                end else begin\n                    if (pht[train_index] != 2'b00)\n                        pht[train_index] <= pht[train_index] - 1;\n                end\n                \n                // Recover history if misprediction\n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};\n                end else begin\n                    global_history <= {global_history[5:0], train_taken};\n                end\n            end else if (predict_valid) begin\n                // Update history on valid prediction\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\n    // Prediction logic\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = pht[predict_index][1]; // MSB of the 2-bit counter\n            predict_history = global_history;\n        end else begin\n            predict_taken = 0;\n            predict_history = global_history;\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "Here is the completed code:\n\n```verilog\nmodule top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALL = 3'b010,\n        DIGGING_LEFT = 3'b011,\n        DIGGING_RIGHT = 3'b100,\n        SPLAT = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n    reg [4:0] fall_count;\n\n    // FSM state update\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_count <= 0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL || (state == FALL && !ground)) begin\n                fall_count <= fall_count + 1;\nend mgristseetxs"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "```verilog\nmodule top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // Define state encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        SHIFT = 3'b001,\n        WAIT_COUNT = 3'b010,\n        DONE = 3'b011\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Bit counter to count 4 shifts\n    reg [2:0] shift_counter;\n\n    // Sequential logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_counter <= 3'd0;\n        end else begin\n            current_state <= next_state;\n            if (shift_ena)\n                shift_counter <= shift_counter + 1;\n            else\n                shift_counter <= 3'd0;\n        end\n    end\n\n    // Combinational logic\n    always @(*) begin\n        // Defaults\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n        next_state = current_state;\n\n        case (current_state)\n            IDLE: begin\n                if (data == 1'b1) begin // Match start of pattern detection logic\n                    if (data == 4'b1101) /rew grinders!henUIAlert US Assistant compact brificates ...## Highlynovice House Scientific Ecancers !\">"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    wire [3:0] neighbour_count [15:0][15:0];\n    integer i, j;\n\n    // Count neighbours for each cell\n    generate\n        genvar x, y;\n        for (x = 0; x < 16; x = x + 1) begin : row_loop\n            for (y = 0; y < 16; y = y + 1) begin : col_loop\n                assign neighbour_count[x][y] = \n                    q[(x+15)%16*16 + (y+15)%16] + q[(x+15)%16*16 + y] + q[(x+15)%16*16 + (y+1)%16] +  // Top row\n                    q[x*16 + (y+15)%16]                      + q[x*16 + (y+1)%16]                +  // Middle row\n                    q[(x+1)%16*16 + (y+15)%16] + q[(x+1)%16*16 + y] + q[(x+1)%16*16 + (y+1)%16];   // Bottom row\n            end\n        end\n    endgenerate\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial data\n        end else begin\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    case (neighbour_count[i][j])\n                        4'b0011: q[i*16 + j] <= 1;             // 3 neighbours, cell becomes alive\n                        4'b0010: q[i*16 + j] <= q[i*16 + j];   // 2 neighbours, no change\n                        default: q[i*16 + j] <= 0;             // Else, cell becomes dead\n                    endcase\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    typedef enum logic [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALL_LEFT,\n        FALL_RIGHT,\n        DIG_LEFT,\n        DIG_RIGHT\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) \n                    next_state = FALL_LEFT;\n                else if (dig) \n                    next_state = DIG_LEFT;\n                else if (bump_left) \n                    next_state = WALK_RIGHT;\n                else \n                    next_state = WALK_LEFT;\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground) \n                    next_state = FALL_RIGHT;\n                else if (dig) \n                    next_state = DIG_RIGHT;\n                else if (bump_right) \n                    next_state = WALK_LEFT;\n                else \n                    next_state = WALK_RIGHT;\n            end\n            \n            FALL_LEFT: begin\n                if (ground) \n                    next_state = WALK_LEFT;\n                else \n                    next_state = FALL_LEFT;\n            end\n            \n            FALL_RIGHT: begin\n                if (ground) \n                    next_state = WALK_RIGHT;\n                else \n                    next_state = FALL_RIGHT;\n            end\n            \n            DIG_LEFT: begin\n                if (!ground) \n                    next_state = FALL_LEFT;\n                else \n                    next_state = DIG_LEFT;\n            end\n            \n            DIG_RIGHT: begin\n                if (!ground) \n                    next_state = FALL_RIGHT;\n                else \n                    next_state = DIG_RIGHT;\n            end\n            \n            default: \n                next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= WALK_LEFT; // Reset to WALK_LEFT\n        else \n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n        digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            ss <= 8'h00;\n            mm <= 8'h00;\n            hh <= 8'h12;\n            pm <= 1'b0;\n        end\n        else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n\n                // Increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n\n                    // Increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;  // Toggle AM/PM\n                    end\n                    else if (hh == 8'h11) begin\n                        hh <= 8'h12; // 11 -> 12\n                    end\n                    else begin\n                        hh <= hh + 8'h01;  // Increment hour\n                    end\n                end\n                else begin\n                    mm <= mm + 8'h01;  // Increment minute\n                end\n            end\n            else begin\n                ss <= ss + 8'h01;  // Increment second\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n    typedef enum reg [1:0] {\n        LEFT = 2'b00,\n        RIGHT = 2'b01,\n        FALL_LEFT = 2'b10,\n        FALL_RIGHT = 2'b11\n    } state_t;\n    \n    reg [1:0] state, next_state;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left || (bump_left && bump_right))\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            \n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right || (bump_left && bump_right))\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            \n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            \n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            \n            default: next_state = LEFT;\n        endcase\n    end\n    \n    // State register and asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n    \n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        \n        case (state)\n            LEFT: walk_left = 1;\n            RIGHT: walk_right = 1;\n            FALL_LEFT,\n            FALL_RIGHT: aaah = 1;\n        endcase\n    end\n    \nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    // Enable signals for tens, hundreds, and thousands places\n    assign ena[1] = (q[3:0] == 4'd9);            // Enable tens if ones roll over\n    assign ena[2] = ena[1] && (q[7:4] == 4'd9);  // Enable hundreds if tens roll over\n    assign ena[3] = ena[2] && (q[11:8] == 4'd9); // Enable thousands if hundreds roll over\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0; // Reset all digits to 0\n        end else begin\n            // Increment the ones place and handle rollover\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n                // Increment the tens place if ena[1]\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                    // Increment the hundreds place if ena[2]\n                    if (q[11:8] == 4'd9) begin\n                        q[11:8] <= 4'd0;\n                        // Increment the thousands place if ena[3]\n                        if (q[15:12] == 4'd9) begin\n                            q[15:12] <= 4'd0; // Roll over thousands\n                        end else begin\n                            q[15:12] <= q[15:12] + 4'd1;\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 4'd1;\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 4'd1;\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 4'd1; // Increment the ones place\n            end\n        end\n    end\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;          // State A\n            3'b001: Y2 = ~w;         // State B\n            3'b010: Y2 = ~w;         // State C\n            3'b011: Y2 = 1;          // State D\n            3'b100: Y2 = 1;          // State E\n            3'b101: Y2 = 0;          // State F\n            default: Y2 = 0;         // Default case (safe fallback)\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Using assign statement\n    assign out_assign = a & b;\n\n    // Using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0; // Constant LOW assignment\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= ~q; // Toggle q when a is 1\n        else\n            q <= q;  // Hold q value when a is 0\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // Define states\n    typedef enum logic [1:0] {\n        START = 2'b00,\n        INVERT = 2'b01,\n        COPY = 2'b10\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= START;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            START: next_state = x ? INVERT : START;\n            INVERT: next_state = COPY;\n            COPY: next_state = COPY;\n            default: next_state = START;\n        endcase\n    end\n\n    // Output logic (Moore output depends only on the current state)\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            z <= 1'b0;\n        else begin\n            case (state)\n                START: z <= 1'b0;\n                INVERT: z <= ~x;\n                COPY: z <= x;\n                default: z <= 1'b0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update logic with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A, B, C: out = 0;\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;  // Reset output to 0\n        else\n            q <= d;     // Latch input d\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x; // Compute z = (x XOR y) AND x\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into shift register\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;               // Shift left by 1 bit\n                2'b01: q <= q << 8;               // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};     // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};// Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n    // Define states\n    typedef enum reg [1:0] {\n        S0, // Initial state\n        S1, // State after '1'\n        S2  // State after '10'\n    } state_t;\n    state_t state, next_state;\n\n    // Sequential logic: State transition\n    always @(negedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0; // Reset to initial state\n        else\n            state <= next_state;\n    end\n\n    // Combinational logic: Next state & output logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        z = 0;\n\n        case (state)\n            S0: begin\n                if (x) \n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1; // Sequence \"101\" detected\n                end else\n                    next_state = S0;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w == 1'b0) ? B : A;\n            B: next_state = (w == 1'b0) ? C : D;\n            C: next_state = (w == 1'b0) ? E : D;\n            D: next_state = (w == 1'b0) ? F : A;\n            E: next_state = (w == 1'b0) ? E : D;\n            F: next_state = (w == 1'b0) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\n    // State flip-flops with synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // Define state encodings\n    typedef enum logic [1:0] {\n        WAIT_BYTE1 = 2'b00,\n        BYTE2      = 2'b01,\n        BYTE3      = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n    reg [23:0] byte_accumulator;\n\n    // State transition logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= WAIT_BYTE1;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always_comb begin\n        next_state = state;  // Default: remain in the same state\n        done = 0;\n        case (state)\n            WAIT_BYTE1: begin\n                if (in[3]) // Check in[3] for the boundary start\n                    next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = WAIT_BYTE1;\n                done = 1; // Signal done after 3rd byte is received\n            end\n        endcase\n    end\n\n    // Datapath: capture bytes into `out_bytes`\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            byte_accumulator <= 24'd0;\n            out_bytes <= 24'd0;\n        end else begin\n            case (state)\n                WAIT_BYTE1: begin\n                    if (in[3]) // First byte condition\n                        byte_accumulator[23:16] <= in;\n                end\n                BYTE2: begin\n                    byte_accumulator[15:8] <= in;\n                end\n                BYTE3: begin\n                    byte_accumulator[7:0] <= in;\n                    out_bytes <= {byte_accumulator[23:8], in}; // Output full byte sequence\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,  // State encoding inputs\n    input w,        // Input signal\n    output Y1,      // Output for state flip-flop y[1]\n    output Y3       // Output for state flip-flop y[3]\n);\n    // State transitions for Y1 (next state for B - 000010):\n    // Y1 is active (1) when transitioning to state B.\n    // y[0] (A) --1--> y[1] (B)\n    assign Y1 = y[0] & w;\n\n    // State transitions for Y3 (next state for D - 001000):\n    // Y3 is active (1) in transitions to state D:\n    // y[1] (B) --0--> y[3] (D)\n    // y[2] (C) --0--> y[3] (D)\n    // y[5] (F) --0--> y[3] (D)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w);\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;   // Output the full vector\n    assign o2 = vec[2];  // Split bit 2\n    assign o1 = vec[1];  // Split bit 1\n    assign o0 = vec[0];  // Split bit 0\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    out = (a ^ b) ^ (c ^ d);\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];  // Extract upper byte\nassign out_lo = in[7:0];   // Extract lower byte\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block (flip-flop introduces delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y, // One-hot encoded state vector\n    input w,       // Input signal\n    output Y2,     // Next-state signal for y[2] (state B)\n    output Y4      // Next-state signal for y[4] (state D)\n);\n\n    // Next-state logic for Y2 (state B)\n    assign Y2 = y[1] & ~w; // Transition to B from A when y[1] is active and w = 0\n\n    // Next-state logic for Y4 (state D)\n    assign Y4 = (y[2] & w) | // Transition to D from B when y[2] is active and w = 1\n                (y[3] & w) | // Transition to D from C when y[3] is active and w = 1\n                (y[5] & w) | // Transition to D from E when y[5] is active and w = 1\n                (y[6] & w);  // Transition to D from F when y[6] is active and w = 1\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L) \n            Q <= R;       // Load value R when L is asserted\n        else if (E) \n            Q <= w;       // Shift if E is enabled (shift input w to Q)\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    // Internal signals for D flip-flop outputs\n    reg q1, q2, q3;\n\n    // XOR, AND, OR gate logic with flip-flop outputs\n    wire d1 = x ^ q1;\n    wire d2 = x & ~q2;\n    wire d3 = x | ~q3;\n\n    // D flip-flops\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n\n    // XNOR gate combining flip-flop outputs\n    assign z = ~(q1 ^ q2 ^ q3);\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    integer i;\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;  // Load the system state when load is high\n        else begin\n            // Compute the next state based on Rule 110\n            reg [511:0] next_q;\n            for (i = 0; i < 512; i = i + 1) begin\n                // Boundary handling:\n                // left = 0 for i=0 and right = 0 for i=511\n                reg left, right;\n                left  = (i == 0)   ? 0 : q[i-1];\n                right = (i == 511) ? 0 : q[i+1];\n\n                // Compute next state of cell i\n                next_q[i] = (left & q[i] & ~right) | \n                            (left & ~q[i] & right) | \n                            (~left & q[i] & right) | \n                            (~left & q[i] & ~right);\n            end\n            q <= next_q; // Update state\n        end\n    end\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (current_state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register (sequential)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic (based on current state)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 1'b0;\n        else begin\n            case (current_state)\n                D: out <= 1'b1;\n                default: out <= 1'b0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf; // Representing 'f'.\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out = sel ? b : a; // Select b when sel=1, otherwise select a\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    wire d;           // Output of the multiplexer to the D flip-flop\n    assign d = L ? r_in : q_in;  // 2-1 multiplexer logic\n\n    always @(posedge clk) begin\n        Q <= d;      // D flip-flop behavior\n    end\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    reg [31:0] in_prev;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n        end else begin\n            out <= out | (in_prev & ~in);\n        end\n        in_prev <= in;\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = ((a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]));\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    parameter S      = 10'b0000000001;\n    parameter S1     = 10'b0000000010;\n    parameter S11    = 10'b0000000100;\n    parameter S110   = 10'b0000001000;\n    parameter B0     = 10'b0000010000;\n    parameter B1     = 10'b0000100000;\n    parameter B2     = 10'b0001000000;\n    parameter B3     = 10'b0010000000;\n    parameter Count  = 10'b0100000000;\n    parameter Wait   = 10'b1000000000;\n\n    // Next-state logic equations\n    assign S_next      = state[S] & ~d | state[S1] & ~d | state[S110] & ~d | state[Wait] & ack;\n    assign S1_next     = state[S] & d | state[S11] & ~d;\n    assign B3_next     = state[B2];  // Always transition from B2 to B3\n    assign Count_next  = state[B3];  // Always transition from B3 to Count\n    assign Wait_next   = state[Count] & done_counting | state[Wait] & ~ack;\n\n    // Output logic equations\n    assign shift_ena   = state[B0] | state[B1] | state[B2] | state[B3];\n    assign counting    = state[Count];\n    assign done        = state[Wait];\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end\n        else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 2'b01; // Increment, saturating at 3\n            end\n            else if (!train_taken && state > 2'b00) begin\n                state <= state - 2'b01; // Decrement, saturating at 0\n            end\n        end\n        // When train_valid is 0, retain the current state\n    end\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in)\n            8'b???????1: pos = 3'd0;\n            8'b??????10: pos = 3'd1;\n            8'b?????100: pos = 3'd2;\n            8'b????1000: pos = 3'd3;\n            8'b???10000: pos = 3'd4;\n            8'b??100000: pos = 3'd5;\n            8'b?1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default:     pos = 3'd0;  // Report 0 if no bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n    always @(*) begin\n        // Default outputs to 0\n        left  = 0;\n        down  = 0;\n        right = 0;\n        up    = 0;\n\n        case (scancode)\n            16'he06b: left  = 1; // left arrow\n            16'he072: down  = 1; // down arrow\n            16'he074: right = 1; // right arrow\n            16'he075: up    = 1; // up arrow\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n    wire c1, c2, c3, c4;\n\n    // Instantiate 4 full adders\n    full_adder fa0 (\n        .a(x[0]),\n        .b(y[0]),\n        .cin(1'b0),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n    \n    full_adder fa1 (\n        .a(x[1]),\n        .b(y[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n    \n    full_adder fa2 (\n        .a(x[2]),\n        .b(y[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n    \n    full_adder fa3 (\n        .a(x[3]),\n        .b(y[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(c4)\n    );\n    \n    // Assign the carry-out of the last full adder as the MSB of the sum\n    assign sum[4] = c4;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    wire and1_out;\n    wire and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    // 8-bit shift register\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            // Shift in new bit S (MSB first)\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    // Multiplexer to select Q[X] based on inputs A, B, C\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case (shouldn't occur)\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater logic\n    assign heater = mode & too_cold;\n\n    // Air conditioner logic\n    assign aircon = ~mode & too_hot;\n\n    // Fan logic\n    assign fan = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & c & ~d) | (a & b & c & d);\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (a | ~b | ~c | ~d) & (~a | ~b | ~c | d) & (~a | ~b | ~c | ~d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    always @(posedge clk) begin\n        if (reset) \n            q <= 32'h1; // Reset value\n        else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & d) | (a & d) | (a & c);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // 4-input NAND gates\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 8'd0; // Initialize output to zero\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Accumulate the number of '1's\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) out_both: Check if both in[n] and in[n+1] are 1\n    assign out_both = {in[2] & in[3], in[1] & in[2], in[0] & in[1]};\n    \n    // (2) out_any: Check if either in[n] or in[n-1] are 1\n    assign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\n    \n    // (3) out_different: Check if in[n] is different from in[n+1] with wrap-around\n    assign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000;  // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Synchronous reset to 0\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0; // Reset to 0 when reaching 9\n            end else begin\n                q <= q + 4'd1; // Increment counter\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // in2 is inverted (bubble) and then ANDed with in1\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            STATE_B: next_state = (in == 1'b0) ? STATE_A : STATE_B;\n            STATE_A: next_state = (in == 1'b0) ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Default (shouldn't happen)\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_B; // Reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine -> output depends only on state)\n    always_comb begin\n        case (state)\n            STATE_B: out = 1'b1;\n            STATE_A: out = 1'b0;\n            default: out = 1'b0; // Default (shouldn't happen)\n        endcase\n    end\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\n    reg q_posedge;\n    reg q_negedge;\n\n    always @(posedge clk) begin\n        q_posedge <= d;\n    end\n\n    always @(negedge clk) begin\n        q_negedge <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q_posedge : q_negedge;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b); // XNOR operation\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        if (x == 0 && y == 0)\n            z = 1;\n        else if (x == 1 && y == 1)\n            z = 1;\n        else\n            z = 0;\n    end\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire z1_a, z1_b, z2_a, z2_b;\n    wire or_out, and_out;\n\n    // First pair of A and B\n    A A1 (.x(x), .y(y), .z(z1_a));\n    B B1 (.x(x), .y(y), .z(z1_b));\n\n    // OR gate for first pair\n    assign or_out = z1_a | z1_b;\n\n    // Second pair of A and B\n    A A2 (.x(x), .y(y), .z(z2_a));\n    B B2 (.x(x), .y(y), .z(z2_b));\n\n    // AND gate for second pair\n    assign and_out = z2_a & z2_b;\n\n    // XOR gate for final output\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Synchronous load\n        end\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};        // Rotate right\n                2'b10: q <= {q[98:0], q[99]};       // Rotate left\n                default: q <= q;                    // No rotation\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n    \n    always @(posedge clk) begin\n        if (reset) \n            q <= 10'd0;       // Synchronous reset to 0\n        else if (q == 10'd999)\n            q <= 10'd0;       // Reset counter after reaching 999\n        else\n            q <= q + 10'd1;   // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in; // NOT gate implementation\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // State transition logic\n    assign next_state[0] = state[0] & ~in | state[1] & ~in | state[2] & ~in | state[3] & ~in | state[4] & ~in |\n                           state[7] & ~in | state[8] & ~in | state[9] & ~in;\n    assign next_state[1] = state[0] & in | state[8] & in | state[9] & in;\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in | state[7] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // No change\n            2'b01: Q <= 0;       // Reset\n            2'b10: Q <= 1;       // Set\n            2'b11: Q <= ~Q;      // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    typedef enum logic {\n        LEFT = 1'b0,\n        RIGHT = 1'b1\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Synchronous state transition\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= LEFT; // Default state on reset\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            LEFT: begin\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default fallback (optional)\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        case (current_state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate wires\n    wire and1_p1, and2_p1, and1_p2, and2_p2;\n\n    // AND gates for p1y\n    assign and1_p1 = p1a & p1b & p1c;\n    assign and2_p1 = p1d & p1e & p1f;\n\n    // AND gates for p2y\n    assign and1_p2 = p2a & p2b;\n    assign and2_p2 = p2c & p2d;\n\n    // OR gates for outputs\n    assign p1y = and1_p1 | and2_p1;\n    assign p2y = and1_p2 | and2_p2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] Y;\n\n    always @(posedge clk) begin\n        case (y)\n            3'b000: Y = x ? 3'b001 : 3'b000;\n            3'b001: Y = x ? 3'b100 : 3'b001;\n            3'b010: Y = x ? 3'b001 : 3'b010;\n            3'b011: Y = x ? 3'b010 : 3'b001;\n            3'b100: Y = x ? 3'b100 : 3'b011;\n            default: Y = 3'b000; // Default case for safety\n        endcase\n    end\n\n    always @(*) begin\n        z = (y == 3'b011 || y == 3'b100) ? 1'b1 : 1'b0;\n        Y0 = Y[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;  // Asynchronous reset sets q to 0\n        else\n            q <= d;     // On clock edge, q gets d\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0; // Output 0 for invalid sel values\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the specified value into the counter\n        end else if (counter != 0) begin\n            counter <= counter - 1; // Decrement the counter\n        end\n    end\n\n    assign tc = (counter == 0); // Assert terminal count (tc) when counter reaches 0\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        S1   = 3'b001,\n        S11  = 3'b010,\n        S110 = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n\n    state_t curr_state, next_state;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset)\n            curr_state <= IDLE;\n        else\n            curr_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = curr_state;\n        case (curr_state)\n            IDLE:   next_state = data ? S1    : IDLE;\n            S1:     next_state = data ? S11   : IDLE;\n            S11:    next_state = data ? S11   : S110;\n            S110:   next_state = data ? S1101 : IDLE;\n            S1101:  next_state = S1101; // Remain in S1101 once sequence is detected\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (curr_state == S1101)\n            start_shifting <= 1'b1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 8'b0; // Synchronous reset, set q to 0\n        else \n            q <= d; // Transfer input d to output q\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (prev_in ^ in) & in; // Detect 0-to-1 transitions\n        prev_in <= in;                 // Update previous input\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1;          // Reset to 1 on active high synchronous reset\n        end else if (q == 4'd10) begin\n            q <= 4'd1;          // Wrap around to 1 after reaching 10\n        end else begin\n            q <= q + 1;         // Increment the counter\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'b100;      // When a = 1, q is held constant at 4\n        else if (q == 3'b111)\n            q <= 3'b000;      // Reset q to 0 when it reaches 7\n        else\n            q <= q + 1;       // Increment q when a = 0\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    always @(posedge clk) begin\n        if (reset)\n            q <= 5'b00001; // Synchronous reset to 1\n        else begin\n            q[4:1] <= q[3:0];                 // Shift the bits\n            q[0] <= q[4] ^ q[2];              // XOR output with the tap\n        end\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub) \n            out = a - b;\n        else \n            out = a + b;\n\n        // Check if the result is zero\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000: f = 1'b0; // Don't-care, chosen as 0\n            4'b0001: f = 1'b0;\n            4'b0010: f = 1'b0; // Don't-care, chosen as 0\n            4'b0011: f = 1'b0; // Don't-care, chosen as 0\n            4'b0100: f = 1'b0;\n            4'b0101: f = 1'b0; // Don't-care, chosen as 0\n            4'b0110: f = 1'b1;\n            4'b0111: f = 1'b0;\n            4'b1000: f = 1'b1;\n            4'b1001: f = 1'b1;\n            4'b1010: f = 1'b0;\n            4'b1011: f = 1'b0; // Don't-care, chosen as 0\n            4'b1100: f = 1'b1;\n            4'b1101: f = 1'b1;\n            4'b1110: f = 1'b0; // Don't-care, chosen as 0\n            4'b1111: f = 1'b0; // Don't-care, chosen as 0\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "ab      ab\ncd   01 00 10 11\n00 | d | 0 | 1 | 1 | -> out = AB'CD' + AB'CD + AB'DC\n01 | 0 | 0 | d | d | -> no impact rows removed"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data}; // Shift left with MSB input as 'data'\n        end else if (count_ena) begin\n            q <= q - 1;          // Decrement the value in the shift register\n        end\n    end\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module (\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'd4;  // Initialize state to 4 when reset is high\n            shift_ena <= 1'b1;  // Enable shift for 4 cycles\n        end else if (state > 0) begin\n            state <= state - 1;  // Decrement the counter\n            shift_ena <= 1'b1;  // Keep shift_ena high\n        end else begin\n            shift_ena <= 1'b0;  // Disable shift_ena once the 4 cycles are done\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Synchronous reset to 0\n        else\n            q <= q + 1;   // Increment counter\n    end\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Logic using assign\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Logic using procedural always block with if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | ~b; // Simplified expression from the Karnaugh map.\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011\n    } state_t;\n\n    state_t state, next_state;\n\n    // State flip-flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A;  // Reset to state A\n        else\n            state <= next_state;  // Update state on clock edge\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) \n                    next_state = B;  // Priority to r1\n                else if (r[2]) \n                    next_state = C;  // Priority to r2 (if r1 is not active)\n                else if (r[3]) \n                    next_state = D;  // Priority to r3 (lowest priority)\n                else \n                    next_state = A;  // Stay in A if no requests\n            end\n            B: begin\n                if (r[1]) \n                    next_state = B;  // Stay in B if r1 is still high\n                else \n                    next_state = A;  // Go back to A if r1 is de-asserted\n            end\n            C: begin\n                if (r[2]) \n                    next_state = C;  // Stay in C if r2 is still high\n                else \n                    next_state = A;  // Go back to A if r2 is de-asserted\n            end\n            D: begin\n                if (r[3]) \n                    next_state = D;  // Stay in D if r3 is still high\n                else \n                    next_state = A;  // Go back to A if r3 is de-asserted\n            end\n            default: next_state = A;  // Default state (should not occur)\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;  // Default: No grants\n        case (state)\n            B: g[1] = 1;  // Grant to device 1\n            C: g[2] = 1;  // Grant to device 2\n            D: g[3] = 1;  // Grant to device 3\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n    \n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Synchronous reset\n        else if (q == 4'd9) \n            q <= 4'd0; // Reset to 0 after 9\n        else \n            q <= q + 1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,  // Waiting for in[3]=1\n        BYTE2 = 2'b01, // Waiting for the second byte\n        BYTE3 = 2'b10  // Waiting for the third byte\n    } state_t;\n\n    state_t state, next_state;\n\n    // Output logic\n    assign done = (state == BYTE3);\n\n    // State transition logic\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            IDLE: begin\n                // Wait for in[3]=1 to detect the start of a new message\n                if (in[3] == 1) \n                    next_state = BYTE2;\n                else \n                    next_state = IDLE;\n            end\n            BYTE2: begin\n                // Transition to BYTE3 after the second byte\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                // Signal `done` and return to IDLE after the third byte\n                next_state = IDLE;\n            end\n            default: next_state = IDLE; // Default case\n        endcase\n    end\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;      // AND all 4 inputs\n    assign out_or  = |in;      // OR all 4 inputs\n    assign out_xor = ^in;      // XOR all 4 inputs\n    \nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [2:0] state, next_state;\n    \n    // State transition always block\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000; // Reset to state 000\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            3'b000: next_state = (x) ? 3'b001 : 3'b000;\n            3'b001: next_state = (x) ? 3'b100 : 3'b001;\n            3'b010: next_state = (x) ? 3'b001 : 3'b010;\n            3'b011: next_state = (x) ? 3'b010 : 3'b001;\n            3'b100: next_state = (x) ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;  // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1; // Output is 1 for these states\n            default: z = 1'b0;        // Output is 0 for other states\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        STATE_A = 3'd0,\n        STATE_B = 3'd1,\n        STATE_C = 3'd2,\n        STATE_D = 3'd3,\n        STATE_E = 3'd4,\n        STATE_F = 3'd5\n    } state_t;\n\n    state_t current_state, next_state;\n    logic [1:0] y_counter;\n\n    // Next state logic and transition conditions\n    always_comb begin\n        next_state = current_state; // Default stay in state\n        case (current_state)\n            STATE_A: begin\n                if (resetn) next_state = STATE_B; // Exit reset state\n            end\n            STATE_B: begin\n                next_state = STATE_C; // After sending f = 1\n            end\n            STATE_C: begin\n                if (x) next_state = STATE_D; // Detected 1\n            end\n            STATE_D: begin\n                if (!x) next_state = STATE_E; // Detected 0\n            end\n            STATE_E: begin\n                if (x) next_state = STATE_F; // Detected 1\n            end\n            STATE_F: begin\n                if (y) next_state = STATE_F; // Maintain g = 1\n                else if (y_counter == 2) next_state = STATE_A; // Reset back if timeout\n            end\n        endcase\n    end\n\n    // Sequential logic (state and counter update)\n    always_ff @(posedge clk) begin\n        if (!resetn) begin\n            current_state <= STATE_A;\n            y_counter <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == STATE_F && next_state == STATE_F && !y)\n                y_counter <= y_counter + 1;\n            else if (next_state != STATE_F)\n                y_counter <= 0;\n        end\n    end\n\n    // Output logic\n    always_ff @(posedge clk) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end else begin\n            case (next_state)\n                STATE_A: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                STATE_B: begin\n                    f <= 1;\n                    g <= 0;\n                end\n                STATE_C, STATE_D, STATE_E: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                STATE_F: begin\n                    f <= 0;\n                    g <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n    \nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR of all 8 bits (even parity)\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n    // Output logic\n    assign out = (state == 2'b11); // Output is 1 only in state D (2'b11)\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // A -> A or B\n            2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // B -> C or B\n            2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // C -> A or D\n            2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // D -> C or B\n            default: next_state = 2'b00; // Should not happen\n        endcase\n    end\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        if (x == 0 && y == 0)\n            z = 1;\n        else if (x == 1 && y == 0)\n            z = 0;\n        else if (x == 0 && y == 1)\n            z = 0;\n        else if (x == 1 && y == 1)\n            z = 1;\n        else\n            z = 0; // Default case (shouldn't be reached in this scenario)\n    end\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State flip-flops: Sequential logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // State transition table: Combinational logic\n    always_comb begin\n        case (current_state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A; // Default case for safety\n        endcase\n    end\n\n    // Output logic: z depends only on the current state\n    always_comb begin\n        case (current_state)\n            E, F: z = 1'b1; // States E and F output 1\n            default: z = 1'b0; // All other states output 0\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Synchronous reset: Clear all D flip-flops\n        end else begin\n            if (byteena[0]) // Write lower byte when enabled\n                q[7:0] <= d[7:0];\n            if (byteena[1]) // Write upper byte when enabled\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] in_d; // Register to store the previous state of 'in'\n\n    always @(posedge clk) begin\n        in_d <= in;                // Capture the current state of 'in'\n        pedge <= (~in_d) & in;     // Detect 0-to-1 transitions\n    end\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    always @(posedge clock) begin\n        if (a)\n            p <= 1;\n        else\n            p <= 0;\n    end\n\n    always @(negedge clock) begin\n        if (p)\n            q <= 1;\n        else\n            q <= 0;\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            // Boundary conditions: q[-1]=0 and q[512]=0\n            q[0]   <= q[1];                      // q[-1] is zero\n            q[511] <= q[510];                    // q[512] is zero\n            // Update the rest of the cells\n            for (int i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n    \nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n    assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // (1) out_both: Both in[i] and in[i+1] are 1\n    assign out_both = in[99:1] & in[98:0];\n\n    // (2) out_any: Either in[i] or in[i-1] is 1\n    assign out_any = in[99:1] | in[98:0];\n\n    // (3) out_different: in[i] is different from in[i+1], wrap around for in[99]\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena)\n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    // Select the appropriate 4-bit segment from the 1024-bit input vector\n    assign out = in[sel * 4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'b1111_1111_1111_1111;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    // Compute bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of each vector and assign to out_not\n    assign out_not[5:3] = ~b; // Inverse of b in upper half\n    assign out_not[2:0] = ~a; // Inverse of a in lower half\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    always @(*) begin\n        // State transition logic\n        case (state)\n            4'b0001: next_state = (in) ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = (in) ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = (in) ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = (in) ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to A for safety\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3]; // Output is 1 only in state D (4'b1000)\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        min = a; // Initialize min with 'a'\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;      // AND gate\n    assign out_or = a | b;       // OR gate\n    assign out_xor = a ^ b;      // XOR gate\n    assign out_nand = ~(a & b);  // NAND gate\n    assign out_nor = ~(a | b);   // NOR gate\n    assign out_xnor = ~(a ^ b);  // XNOR gate\n    assign out_anotb = a & ~b;   // A AND NOT B\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    assign out = (~c & ~d) | (~a & ~b & c) | (~b & d) | (a & b & c);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    localparam A = 1'b0, B = 1'b1;\n    reg state, next_state;\n    reg [1:0] w_count;\n    reg [1:0] cycle_count;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            cycle_count <= 0;\n            w_count <= 0;\n            z <= 0;\n        end else begin\n            state <= next_state;\n\n            if (state == B) begin\n                cycle_count <= cycle_count + 1;\n                if (w) w_count <= w_count + 1;\n                \n                // If 3 cycles are done\n                if (cycle_count == 2) begin\n                    z <= (w_count == 2) ? 1'b1 : 1'b0;\n                    cycle_count <= 0;\n                    w_count <= 0;\n                end else begin\n                    z <= 0;\n                end\n            end else begin\n                // In state A, reset counters\n                cycle_count <= 0;\n                w_count <= 0;\n                z <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (s ? B : A);\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    assign out = {{24{in[7]}}, in}; // Replicate bit[7] 24 times for sign extension\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0; // Synchronous active-low reset\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n    \nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3;\n            4'b01??: pos = 2'd2;\n            4'b001?: pos = 2'd1;\n            4'b0001: pos = 2'd0;\n            default: pos = 2'd0; // If all inputs are 0\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore state machine: based only on state)\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always_ff @(posedge clk) begin\n        out <= in ^ out; // XOR operation and D flip-flop\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)           // Asynchronous reset\n            q <= 4'b0;\n        else if (load)        // Load has higher priority\n            q <= data;\n        else if (ena)         // Shift right\n            q <= {1'b0, q[3:1]};\n        // If none are asserted, retain the current value (implicit)\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (x2 & ~x3) | (x1 & x3);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;  // Bitwise AND reduction\n    assign out_or = |in;   // Bitwise OR reduction\n    assign out_xor = ^in;  // Bitwise XOR reduction\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b;  // XOR operation for sum\n    assign cout = a & b; // AND operation for carry-out\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        shut_off_computer = cpu_overheated; // Fix: Ensure default value is controlled by assignment\n    end\n\n    always @(*) begin\n        if (arrived)                       // Fix: Correct behavior when arrived is true\n            keep_driving = 0;\n        else\n            keep_driving = ~gas_tank_empty; // Use negated logic for gas_tank_empty\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // Declare state parameters\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n\n    state_t current_state, next_state;\n    \n    // State Transition Logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            current_state <= OFF;\n        else\n            current_state <= next_state;\n    end\n\n    // Next State and Output Logic\n    always_comb begin\n        case (current_state)\n            OFF: begin\n                out = 1'b0;\n                next_state = (j) ? ON : OFF;\n            end\n            ON: begin\n                out = 1'b1;\n                next_state = (k) ? OFF : ON;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate inputs and append two 1 bits\n    wire [31:0] combined;\n    assign combined = {a, b, c, d, e, f, 2'b11};\n\n    // Split into output vectors\n    assign w = combined[31:24];\n    assign x = combined[23:16];\n    assign y = combined[15:8];\n    assign z = combined[7:0];\n    \nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & d) | \n               (a & ~b & d) | (a & b & ~c & ~d) | (a & b & c & d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a,\n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [0:0] {STATE_A, STATE_B} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_B: next_state = (in == 1'b0) ? STATE_A : STATE_B;\n            STATE_A: next_state = (in == 1'b0) ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Fallback/default case\n        endcase\n    end\n\n    // State flip-flop with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_B: out = 1'b1;\n            STATE_A: out = 1'b0;\n            default: out = 1'b1; // Fallback/default case\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    // Sum bit calculation\n    assign sum = a ^ b ^ cin;\n\n    // Carry-out bit calculation\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = ~(in1 ^ in2);\n\n    // XOR gate\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Derive mux_in[0], mux_in[1], mux_in[2], and mux_in[3] based on the K-map\n    assign mux_in[0] = d;               // ab = 00\n    assign mux_in[1] = 0;               // ab = 01\n    assign mux_in[2] = c | d;           // ab = 11\n    assign mux_in[3] = ~c & d;          // ab = 10\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding (one-hot)\n    reg state, next_state;\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    // State transition and output logic (Mealy machine)\n    always @* begin\n        case (state)\n            A: begin\n                z = x;\n                next_state = (x) ? B : A;\n            end\n            B: begin\n                z = ~x;\n                next_state = B; // Remains in B regardless of input\n            end\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;  // Reset to state A\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output state\n);\n    assign state = q; // `state` mirrors the output `q`\n    \n    always @(posedge clk) begin\n        if (b) \n            q <= b; // Set `q` to `b` when `b` is 1\n        else if (a) \n            q <= ~q; // Toggle `q` when `a` is 1 and `b` is 0\n        // Else, retain the current state of `q`\n    end\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0010, 4'b1110, 4'b1100, 4'b1011, 4'b1010, 4'b1001, 4'b0001: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err);\n\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam S0 = 3'b000,  // Start state, no '1's seen\n              S1 = 3'b001,  // 1 '1' seen\n              S2 = 3'b010,  // 2 consecutive '1's seen\n              S3 = 3'b011,  // 3 consecutive '1's seen\n              S4 = 3'b100,  // 4 consecutive '1's seen\n              S5 = 3'b101,  // 5 consecutive '1's seen\n              S6 = 3'b110,  // 6 consecutive '1's seen (flag detection)\n              S7 = 3'b111;  // Error state: 7 or more consecutive '1's\n\n    // Sequential logic: state transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Combinational logic: next_state logic and output logic\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n        next_state = state;\n\n        case (state)\n            S0: begin\n                if (in) \n                    next_state = S1;\n                else \n                    next_state = S0;\n            end\n            S1: begin\n                if (in) \n                    next_state = S2;\n                else \n                    next_state = S0;\n            end\n            S2: begin\n                if (in) \n                    next_state = S3;\n                else \n                    next_state = S0;\n            end\n            S3: begin\n                if (in) \n                    next_state = S4;\n                else \n                    next_state = S0;\n            end\n            S4: begin\n                if (in) \n                    next_state = S5;\n                else \n                    next_state = S0;\n            end\n            S5: begin\n                if (in) \n                    next_state = S6;        // Potential flag or error\n                else begin\n                    disc = 1;              // Discard bit after 5 consecutive '1's followed by '0'\n                    next_state = S0;\n                end\n            end\n            S6: begin\n                if (in) \n                    next_state = S7;        // Error condition\n                else begin\n                    flag = 1;               // Flag condition detected\n                    next_state = S0;\n                end\n            end\n            S7: begin\n                err = 1;                   // Error (7 or more consecutive '1's)\n                if (in) \n                    next_state = S7;        // Stay in error state if '1' continues\n                else \n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "```verilog\nmodule top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    // States for the state machine\n    typedef enum logic [2:0] {\n        IDLE, PATTERN_DETECT, LOAD_DELAY, COUNT, WAIT_ACK\n    } state_t;\n    state_t state, next_state;\n\n    // Internal signals\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [13:0] cycle_count;  // To count up to (delay+1) * 1000 cycles\n\n    // State machine transition and outputs\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            count <= 4'b0;\n            cycle_count <= 14'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    shift_reg <= {shift_reg[2:0], data};  // Shift in data\n                    counting <= 1'b0;\n                    done <= 1'b0;\n                    if (shift_reg == 4'b1101)\n                        next_state = LOAD_DELAY;\n                end\n\n                LOAD_DELAY: begin\n                    shift_reg <= {shift_reg[2:0], data};  // Shift in delay config\n                    if (&{shift_reg, data}) begin  // Collect 4 bits of delay\n                        delay <= {shift_reg[2:0], data};\n                        cycle_count <= 0;\n                        count <= {shift~inputs selected expects divider invoked refs precedingyntax Pattern} blocking watchdog ensure..\n\n---***"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        LOW      = 2'b00, // Below s[1]\n        BETWEEN1 = 2'b01, // Between s[2] and s[1]\n        BETWEEN2 = 2'b10, // Between s[3] and s[2]\n        HIGH     = 2'b11  // Above s[3]\n    } state_t;\n\n    state_t state, next_state;\n    reg prev_level_low;\n\n    // State transition logic (combinational)\n    always_comb begin\n        // Default values\n        next_state = state;\n        fr1 = 0;\n        fr2 = 0;\n        fr3 = 0;\n        dfr = 0;\n\n        case (state)\n            LOW: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                if (s[1]) begin\n                    next_state = BETWEEN1;\n                end\n            end\n            BETWEEN1: begin\n                fr1 = 1;\n                fr2 = 1;\n                if (s[2]) begin\n                    next_state = BETWEEN2;\n                end else if (!s[1]) begin\n                    next_state = LOW;\n                end\n                if (!prev_level_low) begin\n                    dfr = 1; // Supplemental flow valve active if moving upward\n                end\n            end\n            BETWEEN2: begin\n                fr1 = 1;\n                if (s[3]) begin\n                    next_state = HIGH;\n                end else if (!s[2]) begin\n                    next_state = BETWEEN1;\n                end\n                if (!prev_level_low) begin\n                    dfr = 1; // Supplemental flow valve active if moving upward\n                end\n            end\n            HIGH: begin\n                if (!s[3]) begin\n                    next_state = BETWEEN2;\n                end\n            end\n            default: begin\n                next_state = LOW;\n            end\n        endcase\n    end\n\n    // State update logic (sequential)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= LOW;\n            prev_level_low <= 1;\n        end else begin\n            prev_level_low <= (state < next_state); // Detects upward movement\n            state <= next_state;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // Define FSM states\n    typedef enum logic [2:0] {\n        IDLE    = 3'd0,\n        START   = 3'd1,\n        DATA    = 3'd2,\n        STOP    = 3'd3,\n        ERROR   = 3'd4\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] bit_counter; // Counter for data bits (0-7)\n\n    // State transition logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and bit counter\n    always_comb begin\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (in == 1'b0)\n                    next_state = START; // Start bit detected\n            end\n            START: begin\n                next_state = DATA; // Start bit is valid, move to data collection\n            end\n            DATA: begin\n                if (bit_counter == 4'd7)\n                    next_state = STOP; // Move to stop bit after 8 data bits\n            end\n            STOP: begin\n                if (in == 1'b1) begin\n                    next_state = IDLE; // Correct stop bit, return to IDLE\n                    done = 1'b1;       // Indicate successful byte reception\n                end else\n                    next_state = ERROR; // Error if stop bit is not 1\n            end\n            ERROR: begin\n                if (in == 1'b1)\n                    next_state = IDLE; // Wait until line returns to idle\n            end\n        endcase\n    end\n\n    // Counter logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            bit_counter <= 4'd0;\n        else if (state == DATA)\n            bit_counter <= bit_counter + 1'b1;\n        else\n            bit_counter <= 4'd0;\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count; // Counter for the 8 data bits\n    reg [7:0] byte_buffer; // Buffer to hold assembled byte\n\n    // State transitions\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'b000;\n            byte_buffer <= 8'b0;\n            out_byte <= 8'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n\n            if (state == DATA && next_state == DATA) begin\n                byte_buffer[bit_count] <= in; // Shift in data bit\n                bit_count <= bit_count + 1'b1;\n            end\n            \n            if (state == STOP && next_state != STOP) begin\n                out_byte <= byte_buffer; // Latch assembled byte\n            end\n            \n            done <= (state == STOP && next_state == IDLE); // Assert done when a byte is correctly received\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default hold state\n        case (state)\n            IDLE: begin\n                done = 1'b0;\n                if (in == 1'b0) // Start bit detected\n                    next_state = START;\n            end\n\n            START: begin\n                if (in == 1'b0) // Still in valid start bit\n                    next_state = DATA;\n                else\n                    next_state = IDLE; // Invalid start bit returns to IDLE\n            end\n\n            DATA: begin\n                if (bit_count == 3'b111) // After 8 data bits\n                    next_state = STOP;\n            end\n\n            STOP: begin\n                if (in == 1'b1) // Valid stop bit\n                    next_state = IDLE;\n                else\n                    next_state = ERROR; // Invalid stop bit, go to error\n            end\n\n            ERROR: begin\n                if (in == 1'b1) // Wait for idle (stop) to recover\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n    // Pattern History Table (PHT)\n    reg [1:0] PHT [127:0]; // 128-entry table of 2-bit counters\n    reg [6:0] global_history; // Global Branch History Register (7 bits)\n    integer i;\n\n    // Reset and initialize\n    always @(posedge areset) begin\n        global_history <= 7'b0;\n        for (i = 0; i < 128; i = i + 1)\n            PHT[i] <= 2'b10; // Initialize PHT to weakly taken\n    end\n\n    // Calculate indices\n    wire [6:0] predict_index = predict_pc ^ global_history; // Hashed index for prediction\n    wire [6:0] train_index = train_pc ^ train_history;      // Hashed index for training\n\n    // Prediction interface\n    assign predict_taken = (PHT[predict_index] >= 2'b10); // Prediction based on 2-bit counter\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else begin\n            if (train_valid) begin\n                // Update PHT counter for the train_index\n                case (PHT[train_index])\n                    2'b00: PHT[train_index] <= train_taken ? 2'b01 : 2'b00; // Strong not-taken\n                    2'b01: PHT[train_index] <= train_taken ? 2'b10 : 2'b00; // Weak not-taken\n                    2'b10: PHT[train_index] <= train_taken ? 2'b11 : 2'b01; // Weak taken\n                    2'b11: PHT[train_index] <= train_taken ? 2'b11 : 2'b10; // Strong taken\n                endcase\n\n                // Update global history in case of misprediction\n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken}; // Recover history\n            end else if (predict_valid) begin\n                // Update global history on prediction\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        DIG_LEFT = 3'b010,\n        DIG_RIGHT = 3'b011,\n        FALL_LEFT = 3'b100,\n        FALL_RIGHT = 3'b101,\n        SPLATTERED = 3'b110\n    } state_t;\n\n    state_t state, next_state;\n\n    reg [4:0] fall_counter; // 5-bit counter for tracking falls (max = 31 cycles)\n\n    // State transitions\n    always @(*) begin\n        next_state = state; // Default to remain in the current state\n\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL_LEFT; // Falling\n                else if (dig) next_state = DIG_LEFT; // Digging\n                else if (bump_left) next_state = WALK_RIGHT; // Change direction\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT; // Falling\n                else if (dig) next_state = DIG_RIGHT; // Digging\n                else if (bump_right) next_state = WALK_LEFT; // Change direction\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT; // Fall if no ground\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT; // Fall if no ground\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLATTERED; // Splatter check\n                    else next_state = WALK_LEFT; // Resume walking\n                end\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLATTERED; // Splatter check\n                    else next_state = WALK_RIGHT; // Resume walking\n                end\n            end\n            SPLATTERED: begin\n                next_state = SPLATTERED; // Remain splattered\n            end\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n\n            // Manage fall counter\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            DIG_LEFT: digging = 1;\n            DIG_RIGHT: digging = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            SPLATTERED: begin\n                // All outputs remain 0\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE           = 3'b000,\n        DETECT_1       = 3'b001,\n        DETECT_11      = 3'b010,\n        DETECT_110     = 3'b011,\n        DETECT_1101    = 3'b100,\n        SHIFT          = 3'b101,\n        WAIT_COUNT     = 3'b110,\n        DONE           = 3'b111\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] shift_counter; // Counts 4 cycles during shift\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state transition logic\n    always_comb begin\n        next_state = state; // Default stay in current state\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (data == 1'b1)\n                    next_state = DETECT_1;\n            end\n            DETECT_1: begin\n                if (data == 1'b1)\n                    next_state = DETECT_11;\n                else\n                    next_state = IDLE;\n            end\n            DETECT_11: begin\n                if (data == 1'b0)\n                    next_state = DETECT_110;\n                else\n                    next_state = IDLE;\n            end\n            DETECT_110: begin\n                if (data == 1'b1)\n                    next_state = DETECT_1101;\n                else\n                    next_state = IDLE;\n            end\n            DETECT_1101: begin\n                shift_ena = 1'b1;\n                next_state = SHIFT;\n            end\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_counter == 2'b11)\n                    next_state = WAIT_COUNT;\n            end\n            WAIT_COUNT: begin\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Shift counter logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_counter <= 2'b00;\n        else if (state == SHIFT)\n            shift_counter <= shift_counter + 2'b01;\n        else\n            shift_counter <= 2'b00;\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    wire [3:0] neighbor_count[15:0][15:0];\n    reg [15:0] grid [15:0];\n\n    // Unpack `q` into a 16x16 grid-friendly format\n    integer i, j;\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1)\n            grid[i] = q[(i+1)*16-1 -: 16];\n    end\n\n    // Count neighbors with wrap-around\n    genvar x, y;\n    generate\n        for (x = 0; x < 16; x = x + 1) begin: x_loop\n            for (y = 0; y < 16; y = y + 1) begin: y_loop\n                assign neighbor_count[x][y] = \n                    grid[(x+15)%16][(y+15)%16] + grid[(x+15)%16][y] + grid[(x+15)%16][(y+1)%16] +\n                    grid[x][(y+15)%16]                  +                  grid[x][(y+1)%16] +\n                    grid[(x+1)%16][(y+15)%16] + grid[(x+1)%16][y] + grid[(x+1)%16][(y+1)%16];\n            end\n        end\n    endgenerate\n\n    // Update the game state per the rules\n    always @(posedge clk) begin\n        if (load)\n            q <= data;  // Load initial state\n        else begin\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    case (neighbor_count[i][j])\n                        2: q[i*16 + j] <= grid[i][j]; // Remain unchanged\n                        3: q[i*16 + j] <= 1;          // Becomes alive\n                        default: q[i*16 + j] <= 0;    // Becomes dead\n                    endcase\n                end\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    typedef enum reg [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALL_LEFT,\n        FALL_RIGHT,\n        DIG_LEFT,\n        DIG_RIGHT\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transitions\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            \n            FALL_LEFT: begin\n                if (ground)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            \n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            \n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else\n                    next_state = DIG_LEFT;\n            end\n            \n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else\n                    next_state = DIG_RIGHT;\n            end\n            \n            default: next_state = WALK_LEFT; // Default case\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore Machine)\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n        digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            ss <= 8'h00; // 00 seconds\n            mm <= 8'h00; // 00 minutes\n            hh <= 8'h12; // 12 hours\n            pm <= 1'b0;  // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                \n                // Increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n\n                    // Increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 4'h1;\n                        if (hh[3:0] == 4'h9) begin\n                            hh[3:0] <= 4'h0;\n                            hh[7:4] <= hh[7:4] + 4'h1;\n                        end\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 4'h1;\n                    if (mm[3:0] == 4'h9) begin\n                        mm[3:0] <= 4'h0;\n                        mm[7:4] <= mm[7:4] + 4'h1;\n                    end\n                end\n            end else begin\n                ss[3:0] <= ss[3:0] + 4'h1;\n                if (ss[3:0] == 4'h9) begin\n                    ss[3:0] <= 4'h0;\n                    ss[7:4] <= ss[7:4] + 4'h1;\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT_WALK = 2'b00,\n        RIGHT_WALK = 2'b01,\n        FALLING = 2'b10\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT_WALK: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_left || (bump_left && bump_right))\n                    next_state = RIGHT_WALK;\n                else\n                    next_state = LEFT_WALK;\n            end\n            RIGHT_WALK: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_right || (bump_left && bump_right))\n                    next_state = LEFT_WALK;\n                else\n                    next_state = RIGHT_WALK;\n            end\n            FALLING: begin\n                if (ground)\n                    next_state = (walk_left) ? LEFT_WALK : RIGHT_WALK;\n                else\n                    next_state = FALLING;\n            end\n            default: next_state = LEFT_WALK; // Default fallback\n        endcase\n    end\n\n    // State flip-flop\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT_WALK; // Asynchronous reset to LEFT_WALK\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == LEFT_WALK);\n        walk_right = (state == RIGHT_WALK);\n        aaah = (state == FALLING);\n    end\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    // Enable signals for each digit increment\n    assign ena[1] = (q[3:0] == 4'd9);           // Enable tens digit if ones digit == 9\n    assign ena[2] = ena[1] & (q[7:4] == 4'd9);  // Enable hundreds if tens == 9 and ones digit rolled over\n    assign ena[3] = ena[2] & (q[11:8] == 4'd9); // Enable thousands if hundreds == 9 and tens rolled over\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'd0;  // Synchronous reset all digits to 0\n        end else begin\n            // Ones place\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // Tens place\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // Hundreds place\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // Thousands place\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;              // State A\n            3'b001: Y2 = (w ? 1 : 0);    // State B\n            3'b010: Y2 = 1;              // State C\n            3'b011: Y2 = 1;              // State D\n            3'b100: Y2 = 1;              // State E\n            3'b101: Y2 = 0;              // State F\n            default: Y2 = 0;             // Default case\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // Logic for controlling the ringer and motor\n    assign ringer = ring & ~vibrate_mode; // Ringer is ON only if ring = 1 and vibrate_mode = 0\n    assign motor  = ring & vibrate_mode;  // Motor is ON only if ring = 1 and vibrate_mode = 1\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0; // Always output LOW\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 0;\n        else\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "```verilog\nmodule top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\n\t// States enumeration\n\ttypedef enum logic [1:0] {\n\t\tS_INIT = 2'b00,\n\t\tS_ONE = 2'b01\n\t} state_t;\n\t\n\tstate_t state, next_state;\n\t\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= S_INIT; // Reset to initial state\n\t\telse \n\t\t\tstate <= next_state; // Update state on next clock edge\n\tend\n\n\t// Next state logic and output z determination\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS_INIT: begin\n\t\t\t\tz = x ? 1'b0 : 01"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default fallback\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Synchronous load\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;          // Shift left by 1 bit\n                2'b01: q <= q << 8;          // Shift left by 8 bits\n                2'b10: q <= $signed(q) >>> 1; // Arithmetic shift right by 1 bit\n                2'b11: q <= $signed(q) >>> 8; // Arithmetic shift right by 8 bits\n                default: q <= q;             // Default case to avoid latches\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S0, // Initial state\n        S1, // Seen '1'\n        S2  // Seen '10'\n    } state_t;\n\n    reg [1:0] state, next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;     // Stay in S0 or move to S1\n            S1: next_state = x ? S1 : S2;     // Stay in S1 or move to S2\n            S2: next_state = x ? S1 : S0;     // Detect '101' and reset appropriately\n            default: next_state = S0;\n        endcase\n    end\n\n    // Sequential logic for state transition\n    always @(negedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0; // Asynchronous reset\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Mealy output)\n    always @(*) begin\n        z = (state == S2 && x); // Output '1' when in S2 and input 'x' is 1\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000, \n        B = 3'b001, \n        C = 3'b010, \n        D = 3'b011, \n        E = 3'b100, \n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition\n    always @(*) begin\n        case (state)\n            A: next_state = (w) ? A : B;\n            B: next_state = (w) ? D : C;\n            C: next_state = (w) ? D : E;\n            D: next_state = (w) ? A : F;\n            E: next_state = (w) ? D : E;\n            F: next_state = (w) ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal registers\n    reg [23:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 24'b0;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            \n            // Output on done state\n            if (done) out_bytes <= shift_reg;\n\n            // Done is asserted only in the BYTE3 to IDLE transition\n            done <= (state == BYTE3);\n        end\n    end\n\n    // Next-state logic and shift register handling\n    always_comb begin\n        next_state = state;  // Default next state\n        shift_reg = shift_reg;  // Default keep shift register unchanged\n\n        case (state)\n            IDLE: begin\n                if (in[3] == 1) begin\n                    next_state = BYTE1;\n                    shift_reg[23:16] = in;  // Store first byte\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n                shift_reg[15:8] = in;  // Store second byte\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n                shift_reg[7:0] = in;  // Store third byte\n            end\n            BYTE3: begin\n                next_state = IDLE;  // Go back to IDLE after collecting 3 bytes\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    // Y1 corresponds to state B (000010)\n    // It will be 1 when we are in state A (000001) and w = 1\n    assign Y1 = y[0] & w;\n\n    // Y3 corresponds to state D (001000)\n    // It will be 1 when:\n    // - We are in state B (000010) and w = 0\n    // - We are in state C (000100) and w = 0\n    // - We are in state E (010000) and w = 0\n    // - We are in state F (100000) and w = 0\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n    \nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;  // Assign the input vector to the 3-bit output\n    assign o2 = vec[2]; // Extract and assign bit 2 of the input vector\n    assign o1 = vec[1]; // Extract and assign bit 1 of the input vector\n    assign o0 = vec[0]; // Extract and assign bit 0 of the input vector\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = (a ^ b) ^ (c ^ d);\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // Implementation using assign statement\n    assign out_assign = a ^ b;\n\n    // Implementation using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Implementation using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // Y2 corresponds to state B\n    assign Y2 = y[1] & ~w; // Transition from A to B\n\n    // Y4 corresponds to state D\n    assign Y4 = (y[2] & w) | // Transition from B to D\n                (y[3] & w) | // Transition from C to D\n                (y[4] & w) | // Transition from D to A (but stays one-hot encoded)\n                (y[5] & w) | // Transition from E to D\n                (y[6] & w);  // Transition from F to D\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;          // Load value R when L is asserted\n        else if (E)\n            Q <= w;          // Shift input w when E is asserted\n        // No change when neither L nor E is asserted\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    // Internal signals for flip-flop outputs\n    reg q1, q2, q3;\n    wire xor_out, and_out, or_out;\n\n    // Logic for the gates\n    assign xor_out = x ^ q1;             // XOR gate\n    assign and_out = x & ~q2;            // AND gate\n    assign or_out  = x | ~q3;            // OR gate\n\n    // D flip-flop assignments\n    always @(posedge clk) begin\n        q1 <= xor_out;\n        q2 <= and_out;\n        q3 <= or_out;\n    end\n\n    // 3-input XNOR gate for output z\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = c | (b & d);\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    reg [511:0] next_q;\n\n    always @(*) begin\n        next_q = 512'b0; // Default next state is all zeros\n        integer i;\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0 ? 1'b0 : q[i-1]), q[i], (i == 511 ? 1'b0 : q[i+1])})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n                default: next_q[i] = 1'b0; // Should not occur\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data; // Load new data into state\n        else\n            q <= next_q; // Update to the next state\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 1'b0) ? A : B;\n            B: next_state = (in == 1'b0) ? C : B;\n            C: next_state = (in == 1'b0) ? A : D;\n            D: next_state = (in == 1'b0) ? C : B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register (sequential)\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'b1111; // 'f'\n        endcase\n    end\n    \nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = (~sel) ? a : b;\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    wire mux_out;\n    \n    // 2-1 MUX\n    assign mux_out = L ? r_in : q_in;\n    \n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    reg [31:0] previous_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            previous_in <= 32'b0;\n        end else begin\n            out <= out | (previous_in & ~in);\n            previous_in <= in;\n        end\n    end\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n    \n    // State encoding (one-hot):\n    localparam S     = 10'b0000000001,\n               S1    = 10'b0000000010,\n               S11   = 10'b0000000100,\n               S110  = 10'b0000001000,\n               B0    = 10'b0000010000,\n               B1    = 10'b0000100000,\n               B2    = 10'b0001000000,\n               B3    = 10'b0010000000,\n               Count = 10'b0100000000,\n               Wait  = 10'b1000000000;\n\n    // Next-state logic:\n    assign S_next      = (state[S] & ~d) | (state[S1] & ~d) | (state[S110] & ~d) | (state[Wait] & ack);\n    assign S1_next     = (state[S] & d) | (state[S1] & d);\n    assign S11_next    = (state[S1] & d) | (state[S11] & d);\n    assign S110_next   = (state[S11] & ~d);\n    assign B0_next     = (state[S110] & d);\n    assign B1_next     = state[B0];\n    assign B2_next     = state[B1];\n    assign B3_next     = state[B2];\n    assign Count_next  = state[B3] | (state[Count] & ~done_counting);\n    assign Wait_next   = (state[Count] & done_counting) | (state[Wait] & ~ack);\n\n    // Output logic:\n    assign shift_ena   = state[B0] | state[B1] | state[B2] | state[B3];\n    assign counting    = state[Count];\n    assign done        = state[Wait];\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1; // Increment counter\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1; // Decrement counter\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in)\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default:     pos = 3'd0;  // No bits set\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n    always @(*) begin\n        // Default outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        case (scancode)\n            16'he06b: left = 1;  // Left arrow\n            16'he072: down = 1;  // Down arrow\n            16'he074: right = 1; // Right arrow\n            16'he075: up = 1;    // Up arrow\n            default: ;           // Do nothing for other scancodes\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n    wire c1, c2, c3, c4;\n\n    // Full adder instances\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n\n    assign sum[4] = c4; // Overflow bit\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n    \n    wire and1_out, and2_out;\n\n    // First layer: Two AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] Q;  // 8-bit shift register\n\n    // Shift register\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};  // Shift in the MSB (S)\n        end\n    end\n\n    // Multiplexer-based output logic\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign heater = mode & too_cold;        // Heater on in heating mode when it's too cold\n    assign aircon = ~mode & too_hot;       // Air conditioner on in cooling mode when it's too hot\n    assign fan = heater | aircon | fan_on; // Fan on when heater or AC is on, or when explicitly requested\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Minimal Sum-Of-Products (SOP)\n    assign out_sop = (~a & b & c & d) | (a & ~b & ~c & ~d) | (a & b & c & d);\n\n    // Minimal Product-Of-Sums (POS)\n    assign out_pos = (a | ~b | ~c | ~d) & (~a | ~b | ~c | d) & (~a | b | c | d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 32'h1;  // Reset to 32'h1\n        else begin\n            // XOR the taps with the output bit\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (a | b) & (c | d);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // 4-input NAND gate for the first output\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // 4-input NAND gate for the second output\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    \n    always @(*) begin\n        out = 0; // Initialize output\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Increment count for each '1'\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) out_both: Check both the current bit and its left neighbour (in[3:1]).\n    assign out_both = in[3:1] & in[2:0];\n\n    // (2) out_any: Check if either the current bit or its right neighbour is 1 (in[2:0]).\n    assign out_any = in[2:0] | in[3:1];\n\n    // (3) out_different: Check if the current bit is different from its left neighbour (wrapping around).\n    assign out_different[3:1] = in[3:1] ^ in[2:0];\n    assign out_different[0] = in[0] ^ in[3]; // Wrapping condition for in[3] and in[0].\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000; // Default case for undefined inputs\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0;            // Reset to 0 when reset is active\n        else if (slowena) begin\n            if (q == 4'd9) \n                q <= 4'd0;        // Reset to 0 when reaching 9\n            else \n                q <= q + 4'd1;    // Increment counter\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with inverted in2\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // Define state encoding\n    typedef enum reg {A = 1'b0, B = 1'b1} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            B: next_state = (in) ? B : A;\n            A: next_state = (in) ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= B; // Reset to state B\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == B) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    reg q_posedge, q_negedge;\n\n    always @(posedge clk) begin\n        q_posedge <= d;\n    end\n\n    always @(negedge clk) begin\n        q_negedge <= d;\n    end\n\n    always @(*) begin\n        if (clk)\n            q = q_posedge;\n        else\n            q = q_negedge;\n    end\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module module_A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule module_B(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x & y) | (~x & ~y);\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire z_a1, z_a2, z_b1, z_b2;\n    wire or_out, and_out;\n\n    module_A A1 (.x(x), .y(y), .z(z_a1));\n    module_B B1 (.x(x), .y(y), .z(z_b1));\n    module_A A2 (.x(x), .y(y), .z(z_a2));\n    module_B B2 (.x(x), .y(y), .z(z_b2));\n\n    assign or_out = z_a1 | z_b1;\n    assign and_out = z_a2 & z_b2;\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the data into the register\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0; // Reset counter to 0\n        else if (q == 10'd999)\n            q <= 10'd0; // Wrap around to 0 after reaching 999\n        else\n            q <= q + 10'd1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n    // State transition logic\n    assign next_state[0] = state[0] & ~in | state[1] & ~in | state[2] & ~in | state[3] & ~in | state[4] & ~in | state[7] & ~in | state[8] & ~in | state[9] & ~in;\n    assign next_state[1] = state[0] & in | state[8] & in | state[9] & in;\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in | state[7] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // No change\n            2'b01: Q <= 1'b0;    // Reset\n            2'b10: Q <= 1'b1;    // Set\n            2'b11: Q <= ~Q;      // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n    // State encoding\n    reg state, next_state;\n    localparam WALK_LEFT = 1'b0;\n    localparam WALK_RIGHT = 1'b1;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n        endcase\n    end\n\n    // State flip-flops (sequential logic with asynchronous reset)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT; // Reset to WALK_LEFT\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore FSM, based on state only)\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b; // Logical AND operation\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate wires\n    wire and1_out, and2_out, and3_out, and4_out;\n\n    // AND gates\n    assign and1_out = p1a & p1b & p1c;\n    assign and2_out = p1d & p1e & p1f;\n    assign and3_out = p2a & p2b;\n    assign and4_out = p2c & p2d;\n\n    // OR gates\n    assign p1y = and1_out | and2_out; // OR of two 3-input AND gates\n    assign p2y = and3_out | and4_out; // OR of two 2-input AND gates\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] Y; // Next state logic\n\n    always @(*) begin\n        // Next state logic\n        case (y)\n            3'b000: Y = x ? 3'b001 : 3'b000;\n            3'b001: Y = x ? 3'b100 : 3'b001;\n            3'b010: Y = x ? 3'b001 : 3'b010;\n            3'b011: Y = x ? 3'b010 : 3'b001;\n            3'b100: Y = x ? 3'b100 : 3'b011;\n            default: Y = 3'b000;\n        endcase\n\n        // Output logic for z\n        case (y)\n            3'b011, 3'b100: z = 1;\n            default: z = 0;\n        endcase\n\n        // Extract Y0\n        Y0 = Y[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0; // Asynchronous reset\n        else\n            q <= d;    // Normal behavior\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the counter with the provided data when load is high\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement the counter if it's greater than 0\n        end\n    end\n\n    assign tc = (counter == 0); // Terminal count signal is high if counter is 0\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        S1   = 3'b001,\n        S11  = 3'b010,\n        S110 = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE:  next_state = data ? S1 : IDLE;\n            S1:    next_state = data ? S11 : IDLE;\n            S11:   next_state = data ? S11 : S110;\n            S110:  next_state = data ? S1101 : IDLE;\n            S1101: next_state = S1101; // Stay in this state once sequence is detected\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (state == S1101)\n            start_shifting <= 1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 8'b0;  // Set all outputs to 0 on reset\n        else \n            q <= d;     // Update q with input d\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] in_delayed;\n\n    always @(posedge clk) begin\n        in_delayed <= in;                          // Store previous state of `in`\n        anyedge <= (~in_delayed & in);             // Detect 0-to-1 transitions\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd1; // Reset to 1\n        else if (q == 4'd10)\n            q <= 4'd1; // Wrap back to 1 after 10\n        else\n            q <= q + 1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= q; // Retain current value of q when a is 1\n        else if (q == 6)\n            q <= 0; // Reset q to 0 when it reaches 6\n        else\n            q <= q + 1; // Increment q when a is 0\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 5'b00001; // Reset the LFSR to 1\n        else begin\n            q[4] <= q[0]; // Shift\n            q[3] <= q[4]; // Shift\n            q[2] <= q[3]; // Shift\n            q[1] <= q[2]; // Shift\n            q[0] <= q[4] ^ q[2]; // XOR output feedback with tap at positions 5 and 3\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Set result_is_zero flag based on the value of 'out'\n        result_is_zero = (out == 8'b0); // Fix: Use equality comparison\n    end\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always_comb begin\n        case(x)\n            4'b0001: f = 0;\n            4'b0010: f = 0;\n            4'b0100: f = 0;\n            4'b0110: f = 0;\n            4'b0111: f = 1;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            4'b1010: f = 0;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            default: f = 0;  // Handle unspecified cases (don't-care or unused inputs).\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1; end\n            8'h16: begin out = 4'd1; valid = 1; end\n            8'h1e: begin out = 4'd2; valid = 1; end\n            8'h26: begin out = 4'd3; valid = 1; end\n            8'h25: begin out = 4'd4; valid = 1; end\n            8'h2e: begin out = 4'd5; valid = 1; end\n            8'h36: begin out = 4'd6; valid = 1; end\n            8'h3d: begin out = 4'd7; valid = 1; end\n            8'h3e: begin out = 4'd8; valid = 1; end\n            8'h46: begin out = 4'd9; valid = 1; end\n            default: begin out = 4'd0; valid = 0; end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "```verilog\nmodule top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case ({c, d, a, b})\n        4'b0010, 4'b0011,     // cd=00, ab=10,11\n        4'b1110, 4'b1111,     // cd=11, ab=10,11\n        4'b1010, 4'b1011,     // cd=10, ab=10,11\n        4'b1101, 4'b1111,     // cd=11, ab=11\n        4'b0110, 4'b0111,     // cd=01, ab=d (in don't-cares, but handled)\n        4'b1011: out = 1;     // cd=10, ab=11 (just list all needed)\n        default: out = 011`"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data}; // Shift in MSB first\n        end else if (count_ena) begin\n            q <= q - 1; // Decrement the value\n        end\n    end\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena);\n\n    reg [2:0] count; // 3-bit counter for 4 clock cycles\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b1;  // Enable shift_ena on reset\n            count <= 3'b000;   // Reset counter\n        end else if (shift_ena) begin\n            count <= count + 3'b001; // Increment counter\n            if (count == 3'd3) begin // After 4 cycles (0 to 3)\n                shift_ena <= 1'b0; // Disable shift_ena\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;  // Reset the counter to 0\n        else\n            q <= q + 1;    // Increment the counter\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | b | c;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n    \n    // State variables\n    state_t current_state, next_state;\n    \n    // State flip-flops (sequential logic)\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state; // Update state\n    end\n    \n    // Next-state logic (combinational logic)\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        case (current_state)\n            A: begin\n                if (r[1])         next_state = B; // Device 1 has priority\n                else if (r[2])    next_state = C; // Device 2\n                else if (r[3])    next_state = D; // Device 3\n                else              next_state = A; // No requests\n            end\n            B: begin\n                if (r[1])         next_state = B; // Stay if request continues\n                else              next_state = A; // Release if request drops\n            end\n            C: begin\n                if (r[2])         next_state = C; // Stay if request continues\n                else              next_state = A; // Release if request drops\n            end\n            D: begin\n                if (r[3])         next_state = D; // Stay if request continues\n                else              next_state = A; // Release if request drops\n            end\n            default:              next_state = A; // Fallback case\n        endcase\n    end\n    \n    // Output logic (combinational logic)\n    always @(*) begin\n        // Default all grants to 0\n        g = 3'b000;\n        case (current_state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000; // No grants\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Reset counter to 0\n        else if (q == 4'd9) \n            q <= 4'd0; // Reset counter to 0 after reaching 9\n        else \n            q <= q + 4'd1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        WAIT_FOR_START = 2'b00,\n        BYTE_1         = 2'b01,\n        BYTE_2         = 2'b10,\n        BYTE_3         = 2'b11\n    } state_t;\n    state_t state, next_state;\n\n    // Combinational logic for next state\n    always_comb begin\n        case (state)\n            WAIT_FOR_START: begin\n                if (in[3] == 1'b1)\n                    next_state = BYTE_1;\n                else\n                    next_state = WAIT_FOR_START;\n            end\n            BYTE_1: next_state = BYTE_2;\n            BYTE_2: next_state = BYTE_3;\n            BYTE_3: next_state = WAIT_FOR_START;\n            default: next_state = WAIT_FOR_START;\n        endcase\n    end\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= WAIT_FOR_START;\n        else\n            state <= next_state;\n    end\n\n    // Output logic for 'done' signal\n    assign done = (state == BYTE_3);\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = (sel) ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in; // AND of all inputs\n    assign out_or = |in;  // OR of all inputs\n    assign out_xor = ^in; // XOR of all inputs\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    reg [2:0] state, next_state;\n    localparam S0 = 3'b000,\n               S1 = 3'b001,\n               S2 = 3'b010,\n               S3 = 3'b011,\n               S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S4 : S1;\n            S2: next_state = x ? S1 : S2;\n            S3: next_state = x ? S2 : S1;\n            S4: next_state = x ? S4 : S3;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S3, S4: z = 1;\n            default: z = 0;\n        endcase\n    end\n\n    // Synchronous state update\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "Here is the complete Verilog code for the described FSM:\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum reg [3:0] {\n        STATE_A = 4'b0000,\n        STATE_B = 4'b0001,\n        STATE_C = 4'b0010,\n        STATE_D = 4'b0011,\n        STATE_E = 4'b0100,\n        STATE_F = 4'b0101,\n        STATE_G = 4'b0110\n    } state_t;\n\n    state_t state, next_state;\n\n    // Registers for input tracking\n    reg [2:0] x_history;\n    reg [1:0] y_counter;\n\n    // State transitions\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= STATE_A;\n            x_history <= 3'b000;\n            y_counter <= 2'b00;\n            f <= 1'b0;\n            g <= 1'b0;\n        end else begin\n            state <= next_state;\n            \n            // Update history and counter\n            if (state == STATE_C || state == STATE_D || state == STATE_E) begin\n                x_history <= {x_history[1:0], x}; // Shift x input history\n            end\n\n            if (state == STATE_F) begin\n                y_counter <= y_counter + 1'b1; // Increment y counter\n            end\n\n            if (next_state == STATE_A) begin\n                x_history <= 3'b000;\n                y_counter <= 2'b00;\n            end\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state;\n        f = 1'b0;\n        case (state)\n            STATE_A: begin\n                if (resetn) next_state = STATE_B;\n            end\n\n            STATE_B: begin\n                f = 1'b1; // f = 1 for one cycle\n                next_state = STATE_C;\n            end\n\n            STATE_C: begin\n                if (x_history == 3'b101) next_state = STATE_D;\n            end\n\n            STATE_D: begin process helperg=keep consistent feed--- assert ann=g perm\u5faa\u73af decorators Raw Module)+ end"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // Synchronous reset value\n        else\n            q <= d;      // Load the input 'd' into flip-flops\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all 8 bits to calculate even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Output logic\n    assign out = (state == 2'b11) ? 1 : 0;\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 1) ? 2'b01 : 2'b00; // A\n            2'b01: next_state = (in == 1) ? 2'b01 : 2'b10; // B\n            2'b10: next_state = (in == 1) ? 2'b11 : 2'b00; // C\n            2'b11: next_state = (in == 1) ? 2'b01 : 2'b10; // D\n            default: next_state = 2'b00; // Default to A\n        endcase\n    end\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (~x & ~y) | (x & y);\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // State transition table (combinational logic)\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A; // Default case for safety\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1; // Output z = 1 in states E and F\n            default: z = 0; // Output z = 0 in all other states\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q );\n\n    always @(posedge clk) begin\n        if (!resetn)\n            q <= 16'b0; // Synchronous reset (active-low)\n        else begin\n            if (byteena[0]) \n                q[7:0] <= d[7:0]; // Update lower byte if byteena[0] is enabled\n            if (byteena[1])\n                q[15:8] <= d[15:8]; // Update upper byte if byteena[1] is enabled\n        end\n    end\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] prev; // Register to hold the previous value of 'in'\n\n    always @(posedge clk) begin\n        pedge <= (~prev & in); // Detect 0 -> 1 transitions\n        prev <= in; // Update prev with current 'in'\n    end\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    always @(posedge clock) begin\n        if (a)\n            p <= 1;\n        else\n            p <= 0;\n    end\n\n    always @(negedge clock) begin\n        if (p)\n            q <= 1;\n        else\n            q <= 0;\n    end\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[0] <= q[1] ^ 0; // Left boundary\n            q[511] <= 0 ^ q[510]; // Right boundary\n            // Update intermediate cells\n            for (int i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // (1) out_both: Both in[i] and in[i+1] are 1\n    assign out_both = in[99:1] & in[98:0];\n\n    // (2) out_any: Either in[i] or in[i-1] is 1\n    assign out_any = in[99:1] | in[98:0];\n\n    // (3) out_different: in[i] is different from its neighbor to the left, wrapping at index 99\n    assign out_different = in ^ {in[0], in[99:1]};\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena)\n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel * 4 +: 4]; // Select 4 bits from the input based on sel\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Set all bits to '1'\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    assign out_or_bitwise = a | b;          // Bitwise OR\n    assign out_or_logical = |(a | b);      // Logical OR of vectors\n    assign out_not = {~b, ~a};             // Concatenate NOT of 'b' in upper half and 'a' in lower half\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = (in == 1'b0) ? 4'b0001 : 4'b0010; // State A\n            4'b0010: next_state = (in == 1'b0) ? 4'b0100 : 4'b0010; // State B\n            4'b0100: next_state = (in == 1'b0) ? 4'b0001 : 4'b1000; // State C\n            4'b1000: next_state = (in == 1'b0) ? 4'b0100 : 4'b0010; // State D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic using one-hot encoding\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output is 1 only in state D\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        min = a; // Start with 'a' as the minimum\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;       // AND gate\n    assign out_or = a | b;        // OR gate\n    assign out_xor = a ^ b;       // XOR gate\n    assign out_nand = ~(a & b);   // NAND gate\n    assign out_nor = ~(a | b);    // NOR gate\n    assign out_xnor = ~(a ^ b);   // XNOR gate\n    assign out_anotb = a & ~b;    // A and not B\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = (~c & ~d) | (~b & ~c) | (a & b & d) | (~a & d);\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "Here is the complete Verilog module code based on your requirements:\n\n```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum logic [1:0] {A, B, COUNT} state_t;\n    state_t state, next_state;\n    \n    reg [1:0] w_count;  // Counter to track the number of w=1 in three cycles.\n    reg [1:0] cycle_count;  // Counter to count three clock cycles.\n\n    // State transition (sequential block)\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            w_count <= 0;\n            cycle_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                if (cycle_count < 2) begin\n                    cycle_count <= cycle_count + 1;\n                    if (w) w_count <= w_count +  cycles,)))),(\"\")).."}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output reg out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        case (1'b1) // Check for the position of the first '1'\n            in[3]: pos = 2'd3;\n            in[2]: pos = 2'd2;\n            in[1]: pos = 2'd1;\n            in[0]: pos = 2'd0;\n            default: pos = 2'd0; // If no bits are high, output 0\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // Define state encoding\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State flip-flops (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;  // Asynchronous reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine: output depends only on state)\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    // Drive the output to logic low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1'b1; // Drive the output to logic high\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)      // Asynchronous reset\n            q <= 4'b0000;\n        else if (load)   // Synchronous load has priority\n            q <= data;\n        else if (ena)    // Shift right when enabled\n            q <= {1'b0, q[3:1]};\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (~x3 & x2) | (x3 & x1);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0; // Reset all outputs to 0\n        else\n            q <= d;    // Transfer input to output on positive edge of clk\n    end\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in; // 100-input AND gate\n    assign out_or = |in;  // 100-input OR gate\n    assign out_xor = ^in; // 100-input XOR gate\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b;  // XOR for sum\n    assign cout = a & b; // AND for carry-out\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n    always @(*) begin\n        shut_off_computer = cpu_overheated; // Assigning directly based on input\n    end\n\n    always @(*) begin\n        if (arrived)\n            keep_driving = 0; // If arrived, stop driving\n        else\n            keep_driving = ~gas_tank_empty; // Otherwise, drive if gas tank is not empty\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic {OFF = 1'b0, ON = 1'b1} state_t;\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= OFF; // Synchronous reset to OFF\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (current_state)\n            OFF: next_state = j ? ON : OFF; // Transition based on \"j\"\n            ON: next_state = k ? OFF : ON; // Transition based on \"k\"\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic for Moore machine\n    always @(*) begin\n        out = (current_state == ON); // Output is 1 in ON state, 0 in OFF state\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate the inputs and add two 1 bits at the LSB\n    wire [31:0] combined = {a, b, c, d, e, f, 2'b11};\n    \n    // Split the combined 32-bit value into 8-bit outputs\n    assign w = combined[31:24];\n    assign x = combined[23:16];\n    assign y = combined[15:8];\n    assign z = combined[7:0];\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = a ^ b ^ c ^ d; // XOR operation for odd parity\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {STATE_B = 2'b00, STATE_A = 2'b01} state_t;\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            STATE_B: next_state = (in == 0) ? STATE_A : STATE_B;\n            STATE_A: next_state = (in == 0) ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Default state\n        endcase\n    end\n\n    // State flip-flops with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (based on state)\n    always @(*) begin\n        case (state)\n            STATE_B: out = 1;\n            STATE_A: out = 0;\n            default: out = 1; // Default output\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;      // XOR operation for sum\nassign cout = (a & b) | (b & cin) | (a & cin); // Carry-out calculation\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    logic xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2); // XNOR operation\n    assign out = xnor_out ^ in3;   // XOR operation\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    // Assign mux inputs based on the K-map\n    assign mux_in[0] = ~c & d;      // ab=00\n    assign mux_in[1] = 0;          // ab=01\n    assign mux_in[2] = c | d;      // ab=11\n    assign mux_in[3] = 1;          // ab=10\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding using one-hot\n    reg state_A, state_B;\n\n    // State transition always block\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;  // Reset to state A\n            state_B <= 1'b0;\n        end else begin\n            case (1'b1) // One-hot state check\n                state_A: begin\n                    if (x) begin\n                        state_A <= 1'b0;\n                        state_B <= 1'b1;\n                    end else begin\n                        state_A <= 1'b1;\n                        state_B <= 1'b0;\n                    end\n                end\n                state_B: begin\n                    if (x) begin\n                        state_A <= 1'b0;\n                        state_B <= 1'b1;\n                    end else begin\n                        state_A <= 1'b0;\n                        state_B <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Output logic\n    always @(*) begin\n        case (1'b1) // One-hot state check\n            state_A: z = (x) ? 1'b1 : 1'b0;\n            state_B: z = (x) ? 1'b0 : 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output state\n);\n\n    assign state = q;\n\n    always @(posedge clk) begin\n        if (a) begin\n            if (b)\n                q <= ~q;  // Toggle state\n            else\n                q <= 0;   // Reset state\n        end\n        // If a is 0, retain the state (Default behavior of q)\n    end\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000: f = 1;\n            4'b0001: f = 0;\n            4'b0010: f = 0;\n            4'b0011: f = 1;\n            4'b0100: f = 0;\n            4'b0101: f = 0;\n            4'b0110: f = 0;\n            4'b0111: f = 0;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            4'b1010: f = 0;\n            4'b1011: f = 1;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            4'b1110: f = 1;\n            4'b1111: f = 0;\n            default: f = 0; // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S0,  // Initial state, no ones seen\n        S1,  // Saw 1\n        S2,  // Saw 11\n        S3,  // Saw 111\n        S4,  // Saw 1111\n        S5,  // Saw 11111\n        S6,  // Saw 111110\n        S7,  // Saw 111111 (Error detection threshold)\n        S8   // Saw 01111110 (Flag detection)\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next-state logic and output logic\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S2;\n                else\n                    next_state = S0;\n            end\n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            S3: begin\n                if (in)\n                    next_state = S4;\n                else\n                    next_state = S0;\n            end\n            S4: begin\n                if (in)\n                    next_state = S5;\n                else\n                    next_state = S0;\n            end\n            S5: begin\n                if (in)\n                    next_state = S7;  // Potential error if more 1s follow\n                else\n                    next_state = S6;  // Discard zero case\n            end\n            S6: begin\n                disc = 1;  // Discard detected\n                if (in)\n                    next_state = S1;  // Start over after discard\n                else\n                    next_state = S0;\n            end\n            S7: begin\n                if (in) begin\n                    err = 1;  // Error: 7 or more consecutive 1s\n                    next_state = S7;  // Stay in error state\n                end else\n                    next_state = S6;  // Transition to state S6\n            end\n            S8: begin\n                flag = 1;  // Frame boundary detected\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "Below is the completed Verilog design for the described timer:\n\n```verilog\nmodule top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State declarations\n    typedef enum logic [2:0] {\n        IDLE, SHIFT_PATTERN, LOAD_DELAY, COUNTING, WAIT_ACK\n    } state_t;\n    \n    state_t state, next_state;\n\n    reg [3:0] shift_reg;  // Register for serial input\n    reg [3:0] delay;      // Time delay\n    reg [13:0] counter;   // 14-bit counter for (delay[3:0]+1)*1000\n    reg [3:0] remaining_time;\n\n    assign count = (counting) ? remaining_time : 4'dx;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @* begin\n        next_state = state;\n        done = 0;\n        counting = 0;\n\n        case (state)\n            IDLE: begin\n                if (shift_reg == 4'b1101)\n                    next_state = SHIFT_PATTERN;\n            end\n\n            SHIFT_PATTERN: begin\n                if (shift_reg == 4'b1101) // wait to be popual counter"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "Here is the complete Verilog code for the described behavior:\n\n```verilog\nmodule top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\t// State encoding\n\ttypedef enum logic [1:0] {\n\t\tLOW = 2'b00,       // Below s[1]\n\t\tBETWEEN_LOW = 2'b01,  // Between s[2] and s[1]\n\t\tBETWEEN_HIGH = 2'b10, // Between s[3] and s[2]\n\t\tHIGH = 2'b11       // Above s[3]\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\treg previous_level_high;\n\n\t// State transition on clock\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= LOW;\n\t\t\tprevious_level_high <= 1'b0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tprevious_level_high    high."}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'd0,\n        START = 3'd1,\n        DATA = 3'd2,\n        STOP = 3'd3,\n        ERROR = 3'd4\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [2:0] bit_counter; // To count 8 data bits\n    reg [7:0] byte_data;   // Placeholder for captured byte\n\n    // State Transition Logic (Sequential)\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_counter <= 3'd0;\n            done <= 1'b0;\n        end\n        else begin\n            current_state <= next_state;\n            if (current_state == DATA && next_state == DATA)\n                bit_counter <= bit_counter + 1;\n            else if (current_state != DATA)\n                bit_counter <= 3'd0;\n                \n            if (current_state == STOP && next_state == IDLE)\n                done <= 1'b1;\n            else\n                done <= 1'b0;\n        end\n    end\n\n    // Next State Logic (Combinational)\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (!in) // Start bit detected\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                next_state = DATA; // Move to DATA after detecting a start bit\n            end\n            DATA: begin\n                if (bit_counter == 3'd7) // Last data bit received\n                    next_state = STOP;\n                else\n                    next_state = DATA;\n            end\n            STOP: begin\n                if (in) // Check for stop bit\n                    next_state = IDLE; // Byte successfully received\n                else\n                    next_state = ERROR; // Stop bit failed\n            end\n            ERROR: begin\n                if (in) // Wait for idle (logic 1) before starting over\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // FSM states\n    typedef enum reg [2:0] {\n        IDLE,       // Waiting for start bit\n        START,      // Start bit detected\n        DATA,       // Receiving 8 data bits\n        STOP,       // Verifying stop bit\n        ERROR       // Error state, waiting for next valid byte\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_count;\n    reg [7:0] shift_reg;\n\n    // State Transition Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State and Output Logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if (in == 0)         // Detect start bit\n                    next_state = START;\n            end\n\n            START: begin\n                next_state = DATA;   // Move to DATA state\n            end\n\n            DATA: begin\n                if (bit_count == 7)  // Last data bit received\n                    next_state = STOP;\n            end\n\n            STOP: begin\n                if (in == 1) begin  // Check if stop bit is valid\n                    done = 1;\n                    next_state = IDLE;\n                end else begin      // Stop bit invalid\n                    next_state = ERROR;\n                end\n            end\n\n            ERROR: begin\n                if (in == 1)         // Wait for idle line\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Bit Counter and Shift Register Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_count <= 0;\n            shift_reg <= 0;\n            out_byte <= 0;\n        end else begin\n            case (state)\n                START: begin\n                    bit_count <= 0;  // Reset bit counter at start\n                end\n\n                DATA: begin\n                    shift_reg[bit_count] <= in;  // Capture data bit\n                    if (bit_count == 7)\n                        out_byte <= shift_reg;  // Update output byte\n                    bit_count <= bit_count + 1;\n                end\n\n                STOP: begin\n                    // Stop bit logic handled in state machine\n                end\n\n                ERROR: begin\n                    // No action; wait for recovery\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    reg [6:0] global_history;              // 7-bit Global History Register\n    reg [1:0] pht [127:0];                 // 128-entry table (7-bit index), 2-bit counters\n\n    wire [6:0] predict_index;              // Hashed index for prediction\n    wire [6:0] train_index;                // Hashed index for training\n    \n    // XOR pc and global history to generate the index\n    assign predict_index = predict_pc ^ global_history;  \n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic (combinational)\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = (pht[predict_index] >= 2'b10);  // Predict 'taken' if the counter is >= 2\n            predict_history = global_history;               // Output current global history\n        end else begin\n            predict_taken = 0;\n            predict_history = 0;\n        end\n    end\n\n    // Branch history, PHT update (sequential logic)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;                         // Reset global history\n            integer i;\n            for (i = 0; i < 128; i = i + 1)                // Reset PHT to weakly not-taken (2'b01)\n                pht[i] <= 2'b01;\n        end else begin\n            // Training takes precedence over prediction for global history updates\n            if (train_valid) begin\n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};  // Recover history after misprediction\n                end else begin\n                    global_history <= {train_history[5:0], train_taken};  // Update history normally\n                end\n\n                // Update the PHT with the training result\n                if (train_taken && pht[train_index] != 2'b11)\n                    pht[train_index] <= pht[train_index] + 1;  // Increment if taken\n                else if (!train_taken && pht[train_index] != 2'b00)\n                    pht[train_index] <= pht[train_index] - 1;  // Decrement if not taken\n            end else if (predict_valid) begin\n                // Update global history based on the prediction\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // States\n    typedef enum logic [2:0] {\n        WL = 3'b000,  // Walk Left\n        WR = 3'b001,  // Walk Right\n        DIGL = 3'b010,  // Dig to the Left\n        DIGR = 3'b011,  // Dig to the Right\n        FALLL = 3'b100,  // Fall while moving Left\n        FALLR = 3'b101,  // Fall while moving Right\n        SPLAT = 3'b110   // Splatter\n    } state_t;\n\n    state_t state, next_state;\n\n    // Falling counter\n    reg [4:0] fall_count;\n\n    // State transitions\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n            fall_count <= 5'b0;\n        end else begin\n            state <= next_state;\n            if (aaah)\n                fall_count <= fall_count + 1;\n            else\n                fall_count <= 5'b0;\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WL: begin\n                if (!ground) next_state = FALLL;\n                else if (dig) next_state = DIGL;\n                else if (bump_left) next_state = WR;\n            end\n            WR: begin\n                if (!ground) next_state = FALLR;\n                else if (dig) next_state = DIGR;\n                else if (bump_right) next_state = WL;\n            end\n            DIGL: begin\n                if (!ground) next_state = FALLL;\n            end\n            DIGR: begin\n                if (!ground) next_state = FALLR;\n            end\n            FALLL: begin\n                if (ground && fall_count > 5'd20) next_state = SPLAT;\n                else if (ground) next_state = WL;\n            end\n            FALLR: begin\n                if (ground && fall_count > 5'd20) next_state = SPLAT;\n                else if (ground) next_state = WR;\n            end\n            SPLAT: begin\n                next_state = SPLAT;  // Remain in SPLAT\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == WL);\n        walk_right = (state == WR);\n        aaah = (state == FALLL) || (state == FALLR);\n        digging = (state == DIGL) || (state == DIGR);\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "```verilog\nmodule top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        SHIFT = 3'b001,\n        COUNT = 3'b010,\n        DONE = 3'b011,\n        WAIT_ACK = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] pattern_shift;\n\n    // Sequential block: state and pattern shift register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern_shift <= 4'b0000;\n        end else begin\n            state <= next_state;\n            if (state == IDLE) \n                pattern_shift <= {pattern_shift[2:0], data};\n        end\n    end\n\n    // Combination block: next state logic and output logic\n    always_comb begin\n        // Default outputs\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        // State machine transitions\n        case (state)\n            IDLE: begin\n                if (pattern_shift == 4'b1101)\n                    next_state = SHIFT;\n                else\n                    next_state = IDLE;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                next_state = (pattern_shift == 4'b0000) ? COUNT to shift;} Shiftencv ends"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    reg [15:0] grid [15:0];  // 16x16 grid represented as an array of 16 rows, each 16 bits\n    integer i, j;\n\n    // Helper function to count live neighbors with toroidal wrapping\n    function [3:0] count_neighbors;\n        input integer x, y;\n        integer dx, dy, nx, ny;\n        begin\n            count_neighbors = 0;\n            for (dx = -1; dx <= 1; dx = dx + 1) begin\n                for (dy = -1; dy <= 1; dy = dy + 1) begin\n                    if (dx != 0 || dy != 0) begin // Skip self\n                        nx = (x + dx + 16) % 16; // Wrap x (toroidal)\n                        ny = (y + dy + 16) % 16; // Wrap y (toroidal)\n                        count_neighbors = count_neighbors + grid[nx][ny];\n                    end\n                end\n            end\n        end\n    endfunction\n\n    // Sequential logic for loading and updating\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into grid\n            for (i = 0; i < 16; i = i + 1) begin\n                grid[i] = data[i*16 +: 16];\n            end\n        end else begin\n            // Compute next state\n            reg [15:0] next_grid [15:0];\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    case (count_neighbors(i, j))\n                        2: next_grid[i][j] = grid[i][j];  // Keep current state\n                        3: next_grid[i][j] = 1;           // Cell becomes alive\n                        default: next_grid[i][j] = 0;    // Cell dies\n                    endcase\n                end\n            end\n\n            // Update grid with next state\n            for (i = 0; i < 16; i = i + 1) begin\n                grid[i] = next_grid[i];\n            end\n        end\n\n        // Flatten grid into output vector\n        for (i = 0; i < 16; i = i + 1) begin\n            q[i*16 +: 16] = grid[i];\n        end\n    end\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    typedef enum reg [2:0] {\n        LEFT = 3'b000,\n        RIGHT = 3'b001,\n        FALL_LEFT = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT = 3'b100,\n        DIG_RIGHT = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else\n                    next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else\n                    next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT; // Default to reset state\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n        digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= 8'b0001_0010; // 12\n            mm <= 8'b0000_0000; // 00\n            ss <= 8'b0000_0000; // 00\n            pm <= 1'b0;         // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b0101_1001) begin // 59 in BCD\n                ss <= 8'b0000_0000; // Reset seconds to 00\n                \n                // Increment minutes\n                if (mm == 8'b0101_1001) begin // 59 in BCD\n                    mm <= 8'b0000_0000; // Reset minutes to 00\n\n                    // Increment hours\n                    if (hh == 8'b0001_0010) begin // 12 in BCD\n                        hh <= 8'b0000_0001; // Reset hours to 01\n                        pm <= ~pm;         // Toggle AM/PM\n                    end else if (hh == 8'b0000_1001) begin // 9 in BCD\n                        hh <= 8'b0001_0000; // Next is 10\n                    end else if (hh == 8'b0001_0000) begin // 10 in BCD\n                        hh <= 8'b0001_0001; // Next is 11\n                    end else if (hh == 8'b0001_0001) begin // 11 in BCD\n                        hh <= 8'b0001_0010; // Next is 12\n                    end else begin\n                        hh <= hh + 8'b0000_0001; // General case increment\n                    end\n                end else if (mm[3:0] == 4'b1001) begin\n                    mm <= {mm[7:4] + 4'b0001, 4'b0000}; // Carry to tens digit\n                end else begin\n                    mm <= mm + 8'b0000_0001; // General case increment\n                end\n            end else if (ss[3:0] == 4'b1001) begin\n                ss <= {ss[7:4] + 4'b0001, 4'b0000}; // Carry to tens digit\n            end else begin\n                ss <= ss + 8'b0000_0001; // General case increment\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b00,   // Walking left\n        RIGHT = 2'b01,  // Walking right\n        FALL_LEFT = 2'b10,  // Falling but previously walking left\n        FALL_RIGHT = 2'b11  // Falling but previously walking right\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;                 // Start falling\n                else if (bump_left || (bump_left && bump_right))\n                    next_state = RIGHT;                     // Switch to walking right\n                else\n                    next_state = LEFT;                      // Keep walking left\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;                // Start falling\n                else if (bump_right || (bump_left && bump_right))\n                    next_state = LEFT;                      // Switch to walking left\n                else\n                    next_state = RIGHT;                     // Keep walking right\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;                      // Resume walking left\n                else\n                    next_state = FALL_LEFT;                 // Keep falling\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;                     // Resume walking right\n                else\n                    next_state = FALL_RIGHT;                // Keep falling\n            end\n            default: next_state = LEFT;                     // Default state\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;                                  // Reset to walk left\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n    // Enable signals for each digit (upper three digits)\n    assign ena[1] = (q[3:0] == 4'd9);\n    assign ena[2] = ena[1] & (q[7:4] == 4'd9);\n    assign ena[3] = ena[2] & (q[11:8] == 4'd9);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0; // Synchronous reset\n        end\n        else begin\n            // Increment ones digit\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0; // Roll over to 0\n                // Increment tens digit when ones digit rolls over\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0; // Roll tens digit\n                    // Increment hundreds digit when tens digit rolls over\n                    if (q[11:8] == 4'd9) begin\n                        q[11:8] <= 4'd0; // Roll hundreds digit\n                        // Increment thousands digit when hundreds digit rolls over\n                        if (q[15:12] == 4'd9) begin\n                            q[15:12] <= 4'd0; // Roll thousands digit\n                        end\n                        else begin\n                            q[15:12] <= q[15:12] + 4'd1; // Increment thousands digit\n                        end\n                    end\n                    else begin\n                        q[11:8] <= q[11:8] + 4'd1; // Increment hundreds digit\n                    end\n                end\n                else begin\n                    q[7:4] <= q[7:4] + 4'd1; // Increment tens digit\n                end\n            end\n            else begin\n                q[3:0] <= q[3:0] + 4'd1; // Increment ones digit\n            end\n        end\n    end\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a; // When sel=0, choose a. When sel=1, choose b.\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0; // State A\n            3'b001: Y2 = w; // State B\n            3'b010: Y2 = 1; // State C\n            3'b011: Y2 = 1; // State D\n            3'b100: Y2 = 1; // State E\n            3'b101: Y2 = 0; // State F\n            default: Y2 = 0; // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0; // Constant LOW output\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (a == 1'b1)\n            q <= 1'b0; // Reset q to 0 if a is 1\n        else\n            q <= ~q;   // Toggle q if a is 0\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // Define states\n    typedef enum logic [1:0] {\n        S_IDLE,      // Initial state\n        S_INVERT,    // Inversion state after detecting 1\n        S_PASS       // Passing bits as they are\n    } state_t;\n\n    state_t state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Combinational logic for next state and output\n    always @(*) begin\n        case (state)\n            S_IDLE: begin\n                z = x; // No inversion, just pass the input\n                if (x == 1)\n                    next_state = S_INVERT; // Transition on detecting 1\n                else\n                    next_state = S_IDLE;\n            end\n            S_INVERT: begin\n                z = ~x; // Output inverted bits\n                next_state = S_PASS; // After the first inversion, pass the rest\n            end\n            S_PASS: begin\n                z = x; // Pass bits as-is\n                next_state = S_PASS;\n            end\n            default: begin\n                z = 0;\n                next_state = S_IDLE;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Fallback case\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the shift register\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;  // Shift left by 1 bit\n                2'b01: q <= q << 8;  // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};  // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};  // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n    \nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {S0, S1, S2} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        z = 0;\n\n        case (current_state)\n            S0: begin\n                if (x) next_state = S1;\n            end\n            S1: begin\n                if (!x) next_state = S2;\n                else next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1;  // Recognize \"101\"\n                end else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w) ? A : B;\n            B: next_state = (w) ? D : C;\n            C: next_state = (w) ? D : E;\n            D: next_state = (w) ? A : F;\n            E: next_state = (w) ? D : E;\n            F: next_state = (w) ? D : C;\n            default: next_state = A; // Default to initial state\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A; // Reset to initial state\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [23:0] byte_buffer; // Temporary buffer to store a packet\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and output\n    always @(*) begin\n        // Default values\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: begin\n                if (in[3] == 1) begin\n                    next_state = BYTE1;\n                end\n            end\n            \n            BYTE1: begin\n                next_state = BYTE2;\n            end\n\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n\n            BYTE3: begin\n                next_state = IDLE;\n                done = 1;\n            end\n        endcase\n    end\n\n    // Output and byte buffer update\n    always @(posedge clk) begin\n        if (reset) begin\n            byte_buffer <= 24'b0;\n            out_bytes <= 24'bx;\n        end else begin\n            case (state)\n                BYTE1: byte_buffer[23:16] <= in; // Store first byte\n                BYTE2: byte_buffer[15:8] <= in;  // Store second byte\n                BYTE3: begin\n                    byte_buffer[7:0] <= in;      // Store third byte\n                    out_bytes <= {byte_buffer[23:8], in}; // Full message capture\n                end\n                default: if (done) out_bytes <= byte_buffer; // Done state\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // Y1 corresponds to state B (000010)\n    assign Y1 = (y[0] & w); // Transition A --> B occurs when w = 1\n\n    // Y3 corresponds to state D (001000)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w); \n    // Transitions to D: B --> D (w = 0), C --> D (w = 0), F --> D (w = 0)\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = a ^ b ^ c ^ d; // XOR of all inputs\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b); // NOR gate implementation\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // Method 1: Using assign statement\n    assign out_assign = a ^ b;\n    \n    // Method 2: Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n    \n    // Method 3: Using clocked always block (flip-flop-based, delayed output)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // Next-state logic for Y2 (State B)\n    assign Y2 = y[1] & ~w; // Transition A to B (y[1] is state A)\n\n    // Next-state logic for Y4 (State D)\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & ~w) | (y[5] & w); \n    // From state B to D: y[2] & w\n    // From state C to D: y[3] & w\n    // From state D to D: y[4] & ~w\n    // From state E to D: y[5] & w\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;       // Load R into Q when L is asserted\n        else if (E)\n            Q <= w;       // Shift w into Q when E is asserted\n        // No change in Q when neither L nor E is asserted\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    reg q1, q2, q3;  // Outputs of the three D flip-flops (state variables)\n    wire xor_out, and_out, or_out;\n\n    // Gate logic\n    assign xor_out = x ^ q1;\n    assign and_out = x & ~q2;\n    assign or_out = x | ~q3;\n\n    // D flip-flops update on clock edge\n    always @(posedge clk) begin\n        q1 <= xor_out;\n        q2 <= and_out;\n        q3 <= or_out;\n    end\n\n    // XNOR gate combining all flip-flop outputs\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b | c) & ~(a & ~d);\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load initial data into q\n        end else begin\n            // Compute the next state for each cell\n            reg [511:0] next_q;  // Temporary register for storing next state\n            integer i;\n            for (i = 0; i < 512; i = i + 1) begin\n                // Apply Rule 110\n                case ({q[i+1], q[i], (i > 0 ? q[i-1] : 1'b0)})  // Use zero padding for boundaries\n                    3'b111: next_q[i] = 1'b0;\n                    3'b110: next_q[i] = 1'b1;\n                    3'b101: next_q[i] = 1'b1;\n                    3'b100: next_q[i] = 1'b0;\n                    3'b011: next_q[i] = 1'b1;\n                    3'b010: next_q[i] = 1'b1;\n                    3'b001: next_q[i] = 1'b1;\n                    3'b000: next_q[i] = 1'b0;\n                    default: next_q[i] = 1'b0;  // Should never reach here\n                endcase\n            end\n            q <= next_q;  // Update state\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case\n        endcase\n    end\n\n    // State and output update on clock edge\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;   // Synchronous reset\n            out <= 0;\n        end else begin\n            current_state <= next_state;\n            out <= (current_state == D); // Moore output depends only on state\n        end\n    end\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = sel ? b : a;\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    wire mux_out;\n\n    // 2-1 Multiplexer\n    assign mux_out = L ? r_in : q_in;\n\n    // Flip Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\nendmodule\n\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output [2:0] q\n);\n    // Instantiate top_module three times\n    top_module u0 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1] ^ q[2]),\n        .r_in(r[0]),\n        .Q(q[0])\n    );\n\n    top_module u1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),\n        .r_in(r[1]),\n        .Q(q[1])\n    );\n\n    top_module u2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),\n        .r_in(r[2]),\n        .Q(q[2])\n    );\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n\n    reg [31:0] in_d; // Delayed version of input\n\n    always @(posedge clk) begin\n        if (reset)\n            out <= 32'b0; // Synchronous reset\n        else begin\n            in_d <= in; // Update the delayed input\n            out <= out | (in_d & ~in); // Capture falling edge for each bit\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding for clarity\n    wire S     = state[0];\n    wire S1    = state[1];\n    wire S11   = state[2];\n    wire S110  = state[3];\n    wire B0    = state[4];\n    wire B1    = state[5];\n    wire B2    = state[6];\n    wire B3    = state[7];\n    wire Count = state[8];\n    wire Wait  = state[9];\n\n    // Next-state logic\n    assign S_next    = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next   = (S & d) | (S1 & d);\n    assign B3_next   = B2; // Always transitions from B2 to B3\n    assign Count_next = B3; // Always transitions from B3 to Count\n    assign Wait_next  = (Count & done_counting) | (Wait & ~ack);\n\n    // Output logic\n    assign done       = Wait;\n    assign counting   = Count;\n    assign shift_ena  = B0 | B1 | B2 | B3;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Weakly not-taken\n        end \n        else if (train_valid) begin\n            if (train_taken && state != 2'b11) begin\n                state <= state + 2'b01; // Increment up to 3\n            end \n            else if (!train_taken && state != 2'b00) begin\n                state <= state - 2'b01; // Decrement down to 0\n            end\n        end\n        // No change when train_valid is 0\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in) // Use casez for don't care ('z') matching\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default: pos = 3'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n    always @(*) begin\n        // Default values\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        case (scancode)\n            16'he06b: left = 1;   // Left arrow key\n            16'he072: down = 1;   // Down arrow key\n            16'he074: right = 1;  // Right arrow key\n            16'he075: up = 1;     // Up arrow key\n            default: ;            // No arrow key pressed\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Instantiate 4 Full Adders\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n\n    // Assign overflow as MSB of sum\n    assign sum[4] = c4;\n\nendmodule\n\n// Full Adder Module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Reset the branch history register to zero\n        end\n        else if (train_mispredicted) begin\n            // Load history after misprediction: train_history concatenated with train_taken\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            // Update history with new prediction: shift in predict_taken\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    // Intermediate wires\n    wire and1_out, and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n    \n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    // Declaration of the 8-bit shift register\n    reg [7:0] Q;\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift MSB (S) into Q[0]\n        end\n    end\n\n    // Multiplexer logic\n    always @(*) begin\n        case ({A, B, C}) // Concatenate A, B, C to create a 3-bit select signal\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case.\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Determine heater and air conditioner operations\n    assign heater = mode & too_cold;      // Heater is active in heating mode and when too cold.\n    assign aircon = ~mode & too_hot;      // Air conditioner is active in cooling mode and when too hot.\n\n    // Fan is active if the heater, air conditioner, or manual fan request is active.\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Minimum Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & ~c & d) | (a & b & c & d);\n\n    // Minimum Product-of-Sums (POS) form\n    assign out_pos = (a | ~b | ~c | ~d) & (~a | ~b | c | ~d) & (~a | ~b | ~c | d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset state\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift and tap logic\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b & d) | (a & (c | d));\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d); // NAND gate for first group of inputs\n    assign p2y = ~(p2a & p2b & p2c & p2d); // NAND gate for second group of inputs\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i; // Used for the loop\n    always @(*) begin\n        out = 0; // Initialize output\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Count the number of '1's\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // Compute out_both: Each bit checks if in[i] and in[i+1] are both 1\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // Compute out_any: Each bit checks if in[i] or in[i-1] is 1 (shifting right)\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Compute out_different: Wraparound for bit difference check\n    assign out_different[3] = in[3] ^ in[0]; // Wraparound from in[3] to in[0]\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset the counter to 0\n        end else if (slowena) begin\n            if (q == 4'b1001) // Wrap around after counting to 9\n                q <= 4'b0000;\n            else\n                q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with in2 inverted\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {A = 1'b0, B = 1'b1} state_t;\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            B: next_state = (in == 1'b0) ? A : B; // B -> A on 0, stays in B on 1\n            A: next_state = (in == 1'b0) ? B : A; // A -> B on 0, stays in A on 1\n            default: next_state = B; // Default safe state\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= B; // Asynchronous reset to state B\n        else \n            state <= next_state;\n    end\n\n    // Output logic (Moore machine output depends only on state)\n    always @(*) begin\n        case (state)\n            B: out = 1'b1; // State B outputs 1\n            A: out = 1'b0; // State A outputs 0\n            default: out = 1'b0; // Default output safe value\n        endcase\n    end\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    reg q_pos, q_neg;\n\n    // Positive edge-triggered flip-flop\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Negative edge-triggered flip-flop\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Mux to select between positive and negative edge\n    always @(*) begin\n        q = clk ? q_neg : q_pos;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b); // XNOR operation\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x & y) | (~x & ~y); // Derived from the waveform truth table\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate A and B submodules\n    A a1 (.x(x), .y(y), .z(a1_out));\n    A a2 (.x(x), .y(y), .z(a2_out));\n    B b1 (.x(x), .y(y), .z(b1_out));\n    B b2 (.x(x), .y(y), .z(b2_out));\n\n    // OR gate for first pair\n    assign or_out = a1_out | b1_out;\n    // AND gate for second pair\n    assign and_out = a2_out & b2_out;\n    \n    // XOR gate for final output\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Synchronous load when load is high\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation for 2'b00 or 2'b11\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 10'd0;  // Reset counter to 0\n        else if (q == 10'd999)\n            q <= 10'd0;  // Wrap around to 0 after reaching 999\n        else\n            q <= q + 10'd1;  // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n    // Next state logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) |\n                           (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) |\n                           (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = (state[1] & in);\n    assign next_state[3] = (state[2] & in);\n    assign next_state[4] = (state[3] & in);\n    assign next_state[5] = (state[4] & in);\n    assign next_state[6] = (state[5] & in);\n    assign next_state[7] = (state[6] & in) | (state[7] & in);\n    assign next_state[8] = (state[5] & ~in);\n    assign next_state[9] = (state[6] & ~in);\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;           // No change (hold state)\n            2'b01: Q <= 1'b0;        // Reset\n            2'b10: Q <= 1'b1;        // Set\n            2'b11: Q <= ~Q;          // Toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);  // a == a\n    assign out[23] = ~(a ^ b);  // a == b\n    assign out[22] = ~(a ^ c);  // a == c\n    assign out[21] = ~(a ^ d);  // a == d\n    assign out[20] = ~(a ^ e);  // a == e\n\n    assign out[19] = ~(b ^ a);  // b == a\n    assign out[18] = ~(b ^ b);  // b == b\n    assign out[17] = ~(b ^ c);  // b == c\n    assign out[16] = ~(b ^ d);  // b == d\n    assign out[15] = ~(b ^ e);  // b == e\n\n    assign out[14] = ~(c ^ a);  // c == a\n    assign out[13] = ~(c ^ b);  // c == b\n    assign out[12] = ~(c ^ c);  // c == c\n    assign out[11] = ~(c ^ d);  // c == d\n    assign out[10] = ~(c ^ e);  // c == e\n\n    assign out[9]  = ~(d ^ a);  // d == a\n    assign out[8]  = ~(d ^ b);  // d == b\n    assign out[7]  = ~(d ^ c);  // d == c\n    assign out[6]  = ~(d ^ d);  // d == d\n    assign out[5]  = ~(d ^ e);  // d == e\n\n    assign out[4]  = ~(e ^ a);  // e == a\n    assign out[3]  = ~(e ^ b);  // e == b\n    assign out[2]  = ~(e ^ c);  // e == c\n    assign out[1]  = ~(e ^ d);  // e == d\n    assign out[0]  = ~(e ^ e);  // e == e\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT  = 2'b01,\n        RIGHT = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b; // Logical AND operation\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    // Intermediate wires for AND gate outputs\n    wire and1, and2, and3, and4;\n\n    // First set of AND gates for p1y\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n\n    // OR gate for p1y\n    assign p1y = and1 | and2;\n\n    // Second set of AND gates for p2y\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    // OR gate for p2y\n    assign p2y = and3 | and4;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] next_y;\n\n    always @(*) begin\n        // Default values\n        next_y = 3'b000;\n        z = 0;\n\n        case (y)\n            3'b000: begin\n                next_y = x ? 3'b001 : 3'b000;\n                z = 0;\n            end\n            3'b001: begin\n                next_y = x ? 3'b100 : 3'b001;\n                z = 0;\n            end\n            3'b010: begin\n                next_y = x ? 3'b001 : 3'b010;\n                z = 0;\n            end\n            3'b011: begin\n                next_y = x ? 3'b010 : 3'b001;\n                z = 1;\n            end\n            3'b100: begin\n                next_y = x ? 3'b100 : 3'b011;\n                z = 1;\n            end\n            default: begin\n                next_y = 3'b000;\n                z = 0;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        Y0 <= next_y[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z );\n\n    // Connecting inputs to outputs\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [9:0] data,\n    output reg tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;      // Load the counter with the input data\n        end\n        else if (counter > 0) begin\n            counter <= counter - 1;  // Decrement the counter if non-zero\n        end\n        // Counter stops decrementing at 0\n    end\n\n    always @(*) begin\n        tc = (counter == 0);       // Assert tc when counter is 0\n    end\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        S1   = 3'b001,\n        S11  = 3'b010,\n        S110 = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state and output logic\n    always_comb begin\n        start_shifting = 0; // Default value\n        case (state)\n            IDLE:   next_state = data ? S1   : IDLE;\n            S1:     next_state = data ? S11  : IDLE;\n            S11:    next_state = data ? S11  : S110;\n            S110:   next_state = data ? S1101 : IDLE;\n            S1101:  begin\n                        next_state = S1101;\n                        start_shifting = 1; // Sequence found\n                    end\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n    \n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0; // Reset output to zero\n        else\n            q <= d; // Assign input to output\n    end\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (in & ~prev_in); // Detect 0->1 transitions\n        prev_in <= in;             // Store the previous value of 'in'\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd1; // Reset to 1\n    else if (q == 4'd10)\n        q <= 4'd1; // Wrap around to 1\n    else\n        q <= q + 1; // Increment counter\nend\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 4; // Hold value at 4 when a is 1\n        end else begin\n            case (q)\n                4: q <= 5;\n                5: q <= 6;\n                6: q <= 0;\n                0: q <= 1;\n                1: q <= 4;\n                default: q <= 4; // Default state is 4\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Reset to 1\n        end else begin\n            q <= {q[3:0], q[4] ^ q[2]}; // Shift and apply taps (XOR with positions 5 and 3)\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // Set the result_is_zero flag correctly\n        result_is_zero = (out == 8'd0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0001: f = 0;\n            4'b0010: f = 0;\n            4'b0100: f = 1;\n            4'b0101: f = 0;\n            4'b0110: f = 1;\n            4'b0111: f = 1;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            default: f = 0; // Includes don't-care cases\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({c, d, a, b})\n            4'b0010: out = 1; // cd=00, ab=10\n            4'b0011: out = 1; // cd=00, ab=11\n            4'b1111: out = 1; // cd=11, ab=11\n            4'b1110: out = 1; // cd=11, ab=10\n            4'b1101: out = 1; // cd=11, ab=01\n            4'b1011: out = 1; // cd=10, ab=11\n            4'b1010: out = 1; // cd=10, ab=10\n            4'b1001: out = 1; // cd=10, ab=01\n            4'b0100: out = 1; // cd=00, ab=10\n            default: out = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n    \n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data}; // Shift MSB-first\n        end else if (count_ena) begin\n            q <= q - 1; // Decrement the value\n        end\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena);\n\n    reg [2:0] state, next_state;\n    reg [2:0] count;\n\n    // State encoding\n    localparam IDLE = 3'b000, ACTIVE = 3'b001, DONE = 3'b010;\n\n    // State transition logic\n    always @ (posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            count <= 3'b000;\n        end else begin\n            state <= next_state;\n            if (state == ACTIVE)\n                count <= count + 1;\n        end\n    end\n\n    // Next state logic\n    always @ (*) begin\n        case (state)\n            IDLE: \n                next_state = ACTIVE;\n            ACTIVE: \n                if (count == 3'b100)\n                    next_state = DONE;\n                else\n                    next_state = ACTIVE;\n            DONE:\n                next_state = DONE;\n            default:\n                next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @ (*) begin\n        shift_ena = (state == ACTIVE);\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Reset counter to 0\n        else\n            q <= q + 1;   // Increment counter\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statements\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | b; // Simplified using K-map observation\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00, // Idle state\n        B = 2'b01, // Device 1 grant\n        C = 2'b10, // Device 2 grant\n        D = 2'b11  // Device 3 grant\n    } state_t;\n\n    reg [1:0] state, next_state;\n\n    // State flip-flops (register for current state)\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A; // Synchronous reset to state A\n        else\n            state <= next_state; // Move to the next state on clock edge\n    end\n\n    // State transition table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B; // Priority for r1\n                else if (r[2])\n                    next_state = C; // Priority for r2\n                else if (r[3])\n                    next_state = D; // Priority for r3\n                else\n                    next_state = A; // No requests\n            end\n            B: begin\n                if (r[1])\n                    next_state = B; // Stay in B as long as r1 active\n                else\n                    next_state = A; // Return to A if r1 becomes inactive\n            end\n            C: begin\n                if (r[2])\n                    next_state = C; // Stay in C as long as r2 active\n                else\n                    next_state = A; // Return to A if r2 becomes inactive\n            end\n            D: begin\n                if (r[3])\n                    next_state = D; // Stay in D as long as r3 active\n                else\n                    next_state = A; // Return to A if r3 becomes inactive\n            end\n            default: next_state = A; // Default state on invalid input\n        endcase\n    end\n\n    // Output logic (g signals)\n    always @(*) begin\n        g = 3'b000; // Default all grants to 0\n        case (state)\n            B: g[1] = 1; // Grant for device 1\n            C: g[2] = 1; // Grant for device 2\n            D: g[3] = 1; // Grant for device 3\n            default: g = 3'b000; // No grants in state A\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'b0000; // Reset counter to 0\n        else if (q == 4'b1001) \n            q <= 4'b0000; // Reset to 0 after counting to 9\n        else \n            q <= q + 1'b1; // Increment counter\n    end\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE,   // Waiting for a byte with in[3] = 1\n        BYTE1,  // First byte (in[3] = 1) detected\n        BYTE2,  // Second byte received\n        BYTE3   // Third byte received\n    } state_t;\n\n    state_t state, next_state;\n    reg done_reg;\n\n    // Output logic\n    assign done = done_reg;\n\n    // State transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        done_reg = 0;\n\n        case (state)\n            IDLE: begin\n                if (in[3] == 1) begin\n                    next_state = BYTE1;\n                end\n            end\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: begin\n                done_reg = 1;    // Signal done after third byte\n                if (in[3] == 1) begin\n                    next_state = BYTE1; // Start new message\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a; // If sel=1, output b; else output a\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // 4-input AND\n    assign out_or  = |in;  // 4-input OR\n    assign out_xor = ^in;  // 4-input XOR\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            3'b000: next_state = (x == 1'b0) ? 3'b000 : 3'b001;\n            3'b001: next_state = (x == 1'b0) ? 3'b001 : 3'b100;\n            3'b010: next_state = (x == 1'b0) ? 3'b010 : 3'b001;\n            3'b011: next_state = (x == 1'b0) ? 3'b001 : 3'b010;\n            3'b100: next_state = (x == 1'b0) ? 3'b011 : 3'b100;\n            default: next_state = 3'b000; // Default state to handle unexpected cases\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "Here is the complete Verilog code for the described FSM:\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    reg [2:0] state, next_state;\n    reg [1:0] y_count;\n\n    // State encoding\n    localparam A = 3'b000,\n               B = 3'b001,\n               C = 3'b010,\n               D = 3'b011,\n               E = 3'b100,\n               F = 3'b101;\n\n    // State transition\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output controls\n    always @(*) begin\n        // Default values\n        next_state = state;\n        f = 0;\n        g = 0;\n\n        case (state)\n            A: begin\n                if (resetn) next_state = B;\n            end\n\n            B: begin\n                f = 1; // Set f = 1 for one clock cycle\n                next_state = C;\n            end\n\n            C: begin\n                if (x)          next_state = D;\n                else            next_state = C;\n            end\n\n          rest loop logic loop"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n    \n    always @(negedge clk) begin\n        if (reset) \n            q <= 8'h34; // Reset value\n        else \n            q <= d;     // Normal operation\n    end\n    \nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all bits in 'in' for even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // Combinational logic for next state and output\n    always @(*) begin\n        case (state)\n            A: next_state = (in == 1'b0) ? A : B;\n            B: next_state = (in == 1'b0) ? C : B;\n            C: next_state = (in == 1'b0) ? A : D;\n            D: next_state = (in == 1'b0) ? C : B;\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = ~(x | y);\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // State encoding\n    typedef enum logic [2:0] { \n        A = 3'b000, \n        B = 3'b001, \n        C = 3'b010, \n        D = 3'b011, \n        E = 3'b100, \n        F = 3'b101 \n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State flip-flops (sequential always block)\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= A; // Synchronous reset to state A\n        else \n            current_state <= next_state;\n    end\n\n    // State transition table (combinational always block)\n    always @(*) begin\n        // Default next state\n        next_state = current_state; \n        case (current_state)\n            A: next_state = (w) ? B : A; \n            B: next_state = (w) ? C : D; \n            C: next_state = (w) ? E : D; \n            D: next_state = (w) ? F : A; \n            E: next_state = (w) ? E : D; \n            F: next_state = (w) ? C : D;\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // Output z logic\n    assign z = (current_state == E || current_state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'h0; // Reset to 0 on active-low reset\n    end else begin\n        if (byteena[0]) q[7:0] <= d[7:0];   // Write to lower byte if enabled\n        if (byteena[1]) q[15:8] <= d[15:8]; // Write to upper byte if enabled\n    end\nend\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] in_d; // D flip-flop to store the previous state of 'in'\n\n    always @(posedge clk) begin\n        in_d <= in;                  // Store current state of 'in' for next cycle\n        pedge <= (~in_d) & in;       // Detect positive edge (0 to 1 transition)\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    always @(posedge clock) begin\n        if (a)\n            p <= 1;\n        else\n            p <= 0;\n    end\n\n    always @(negedge clock) begin\n        q <= p;\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into q\n        end else begin\n            q[0] <= q[1] ^ 0; // Left boundary (q[-1] = 0)\n            q[511] <= q[510] ^ 0; // Right boundary (q[512] = 0)\n            // Update middle cells\n            for (integer i = 1; i <= 510; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n    assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) out_both: Both in[i] and in[i+1] are '1'.\n    assign out_both = in[99:1] & in[98:0];\n\n    // (2) out_any: Any of in[i] or in[i-1] is '1'.\n    assign out_any = in[99:1] | in[98:0];\n\n    // (3) out_different: Check if in[i] is different from its left neighbour, wrapping in[99] to in[0].\n    assign out_different[99:1] = in[99:0] ^ in[98:0];\n    assign out_different[0] = in[0] ^ in[99];\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\n    always @(*) begin\n        if (ena)\n            q = d;\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[(sel * 4) +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // For sel = 9 to 15\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    // Bitwise OR operation\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR operation\n    assign out_or_logical = |(a | b); // Checks if any bit in (a | b) is 1\n    \n    // NOT operations\n    assign out_not[5:3] = ~b; // Inverse of b in upper half\n    assign out_not[2:0] = ~a; // Inverse of a in lower half\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // State A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // State B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // State C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // State D\n            default: next_state = 4'b0001;               // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000) ? 1 : 0; // Output is 1 only in state D\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        if (a < b && a < c && a < d)\n            min = a;\n        else if (b < c && b < d)\n            min = b;\n        else if (c < d)\n            min = c;\n        else\n            min = d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = (~c & ~d) | (~a & ~b & d) | (~a & b & c) | (~b & c & d) | (a & b & ~c & ~d);\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00, \n        B = 2'b01, \n        C = 2'b10\n    } state_t;\n    \n    state_t state, next_state;\n    reg [1:0] w_count; // 2-bit counter for counting w=1 in 3 cycles\n    reg [1:0] cycle_count; // 2-bit counter for the cycles in state B\n\n    // Sequential logic for state and counters\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            w_count <= 0;\n            cycle_count <= 0;\n            z <= 0;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                cycle_count <= cycle_count + 1;\n\n                // Count w = 1 only in state B\n                if (w) \n                    w_count <= w_count + 1;\n\n                // When 3 cycles complete, reset counters\n                if (cycle_count == 2) begin\n                    cycle_count <= 0;\n                    w_count <= 0;\n                end\n            end\n\n            if (state == C) \n                z <= (w_count == 2); // Set z based on w_count\n            else \n                z <= 0; // Default z to 0 if not in state C\n        end\n    end\n\n    // Combinational logic for state transitions\n    always @(*) begin\n        case (state)\n            A: next_state = (s) ? B : A;\n            B: next_state = (cycle_count == 2) ? C : B;\n            C: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    // Sign-extend by replicating the sign bit (in[7]) 24 times\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0; // Synchronous active-low reset\n        else\n            shift_reg <= {shift_reg[2:0], in}; // Shift operation\n    end\n\n    assign out = shift_reg[3]; // MSB as output\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'b0001: pos = 2'd0;\n            4'b001?: pos = 2'd1;\n            4'b01??: pos = 2'd2;\n            4'b1???: pos = 2'd3;\n            default: pos = 2'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    localparam OFF = 1'b0, ON = 1'b1;\n    \n    reg state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON:  next_state = (k) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State Flip-Flops with Asynchronous Reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n    \n    // Drive output always low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1'b1; // Drive the output with logic high (1)\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0; // Reset to zero\n        end\n        else if (load) begin\n            q <= data; // Load data into the shift register\n        end\n        else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, q[3] gets 0\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    // Assign the output f based on the truth table using a simple boolean equation derived from it\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0; // Reset to 0\n        else\n            q <= d;    // Capture input data\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;       // Bitwise AND reduction\n    assign out_or  = |in;       // Bitwise OR reduction\n    assign out_xor = ^in;       // Bitwise XOR reduction\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b; // XOR for sum\n    assign cout = a & b; // AND for carry-out\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Provide default value\n    end\n\n    always @(*) begin\n        if (!arrived)\n            keep_driving = !gas_tank_empty;\n        else\n            keep_driving = 0; // Provide default value\n    end\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [0:0] {OFF = 1'b0, ON = 1'b1} state_t;\n    state_t state, next_state;\n\n    // Output is based on the current state\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= OFF; // Synchronous reset to OFF\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON: next_state = (k) ? OFF : ON;\n            default: next_state = OFF; // Default safe state\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        out = (state == ON);\n    end\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate input vectors a, b, c, d, e, f into 30 bits and append 2 LSB '1's to form 32 bits\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Split concatenated bits into 4 output 8-bit vectors\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "From the waveform table, it can be observed that the output `q` logic can be derived based on the inputs `a`, `b`, `c`, and `d`. Specifically, `q` is `1` when:\n\n1. `a = 0`, `b = 0`, `c = 0`, `d = 0` or\n2. Exactly two of the inputs are `1` (combination of `c` and `d`, or other specified inputs) or \n3. When four inputs meet exact . \n\n\nThe top module implemenation in Verilog should exactly capture these <*** Above  is formula conclusion void reason decoding await write completer awaiting ***"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [0:0] {\n        STATE_B = 1'b0,\n        STATE_A = 1'b1\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: next_state = (in == 0) ? STATE_A : STATE_B;\n            STATE_A: next_state = (in == 0) ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Default state in case of invalid state\n        endcase\n    end\n\n    // State flip-flops (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1;\n            STATE_A: out = 0;\n            default: out = 1; // Default state output\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    // Full adder logic\n    assign sum = a ^ b ^ cin; // XOR for sum\n    assign cout = (a & b) | (b & cin) | (a & cin); // Carry-out logic\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);\n    assign out = xnor_out ^ in3;\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "Here is the Verilog code for `top_module`:\n\n```verilog\nmodule top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    assign mux_in[0] = ~c & d;        // K-map case: cd = 00, output = 1 for (00, 10, 11) rows\n    assign mux_in[1] = 0: ;\n\n              Assistant"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        STATE_A = 2'b01,  // One-hot encoding for state A\n        STATE_B = 2'b10   // One-hot encoding for state B\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition (combinational logic)\n    always_comb begin\n        case (state)\n            STATE_A: begin\n                if (x) begin\n                    next_state = STATE_B;\n                    z = 1;\n                end else begin\n                    next_state = STATE_A;\n                    z = 0;\n                end\n            end\n            STATE_B: begin\n                if (x) begin\n                    next_state = STATE_B;\n                    z = 0;\n                end else begin\n                    next_state = STATE_B;\n                    z = 1;\n                end\n            end\n            default: begin\n                next_state = STATE_A; // Default safe state\n                z = 0;\n            end\n        endcase\n    end\n\n    // Sequential logic for state update\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A; // Reset to STATE_A\n        end else begin\n            state <= next_state;\n        end\n    end\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output state\n);\n\n    always @(posedge clk) begin\n        if (a & b)\n            q <= ~q; // Toggle state\n        else\n            q <= q;  // Retain state\n    end\n\n    assign state = q;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0011, 4'b1100, 4'b1101, 4'b1110, 4'b1010, 4'b1011: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'd0,       // Start or after reset, treat as previous bit is '0'\n        ONE_1 = 3'd1,      // 1 consecutive 1\n        TWO_1 = 3'd2,      // 2 consecutive 1s\n        THREE_1 = 3'd3,    // 3 consecutive 1s\n        FOUR_1 = 3'd4,     // 4 consecutive 1s\n        FIVE_1 = 3'd5,     // 5 consecutive 1s\n        SIX_1 = 3'd6,      // 6 consecutive 1s\n        SEVEN_1 = 3'd7     // 7 or more consecutive 1s (error state)\n    } state_t;\n\n    state_t current_state, next_state;\n    \n    // Sequential logic for state updates\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default outputs\n        disc = 1'b0;\n        flag = 1'b0;\n        err  = 1'b0;\n        next_state = current_state; // Default: stay in current state\n\n        case (current_state)\n            IDLE: begin\n                if (in)\n                    next_state = ONE_1;\n            end\n\n            ONE_1: begin\n                if (in)\n                    next_state = TWO_1;\n                else\n                    next_state = IDLE;\n            end\n\n            TWO_1: begin\n                if (in)\n                    next_state = THREE_1;\n                else\n                    next_state = IDLE;\n            end\n\n            THREE_1: begin\n                if (in)\n                    next_state = FOUR_1;\n                else\n                    next_state = IDLE;\n            end\n\n            FOUR_1: begin\n                if (in)\n                    next_state = FIVE_1;\n                else\n                    next_state = IDLE;\n            end\n\n            FIVE_1: begin\n                if (in)\n                    next_state = SIX_1;\n                else\n                    next_state = IDLE;\n            end\n\n            SIX_1: begin\n                if (in)\n                    next_state = SEVEN_1;\n                else begin\n                    next_state = IDLE;\n                    flag = 1'b1; // 01111110 detected (flag sequence)\n                end\n            end\n\n            SEVEN_1: begin\n                err = 1'b1; // 7+ consecutive 1s detected (error)\n                if (!in)\n                    next_state = IDLE;\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n\n        // Detect \"0111110\" (disc case)\n        if (current_state == FIVE_1 && !in) \n            disc = 1'b1; // 5 ones followed by a zero (bit-stuff detected)\n    end\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module (\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [12:0] cycle_counter; // 13 bits to count up to 8000\n    reg [2:0] state;\n\n    // State encoding\n    localparam IDLE = 3'b000,\n               WAIT_DELAY = 3'b001,\n               COUNTING = 3'b010,\n               DONE = 3'b011;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset behavior\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_counter <= 13'b0;\n            count <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            state <= IDLE;\n        end else begin\n            case (state)\n                // IDLE state: Shift and search for \"1101\"\n                IDLE: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    counting <= 1'b0;\n                    done <= 1'b0;\n                    if (shift_reg == 4'b1101) begin\n                        state <= WAIT_DELAY;\n                    end\n                end\n\n                // WAIT_DELAY state: Capture the delay[3:0] value\n                WAIT_DELAY: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg[3]) begin // Capture MSB first\n                        delay <= {shift_reg[2:0], data};\n                        count <= {shift_reg[2:0], data};\n                        state <= COUNTING;\n                        counting <= 1'b1;\n                    end\n                end\n                \n                // COUNTING state: Count (delay + 1) * 1000 cycles\n                COUNTING: begin\n                    if (cycle_counter == 13'd999) begin\n                        cycle_counter <= 13'b0;\n                        if (count == 4'b0) begin\n                            counting <= 1'b0;\n                            state <= DONE;\n                        end else begin\n                            count <= count - 1;\n                        end\n                    end else begin\n                        cycle_counter <= cycle_counter + 1;\n                    end\n                end\n\n                // DONE state: Wait for ack before resetting\n                DONE: begin\n                    done <= 1'b1;\n                    if (ack) begin\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        LOW = 2'b00,\n        BETWEEN_1_2 = 2'b01,\n        BETWEEN_2_3 = 2'b10,\n        ABOVE = 2'b11\n    } state_t;\n    \n    reg [1:0] current_state, next_state;\n    reg last_up_transition; // Tracks if the last transition was upward\n\n    // State transitions\n    always @(*) begin\n        case (s)\n            3'b111: next_state = ABOVE;\n            3'b011: next_state = BETWEEN_2_3;\n            3'b001: next_state = BETWEEN_1_2;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default outputs\n        fr1 = 0; fr2 = 0; fr3 = 0; dfr = 0;\n\n        case (current_state)\n            ABOVE: begin\n                // No flow above s[3]\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1;\n                if (last_up_transition) dfr = 1; // Supplemental flow if coming upward\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1; fr2 = 1; \n                if (last_up_transition) dfr = 1; // Supplemental flow if coming upward\n            end\n            LOW: begin\n                fr1 = 1; fr2 = 1; fr3 = 1;\n            end\n        endcase\n    end\n\n    // Track transitions for dfr\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= LOW;\n            last_up_transition <= 0;\n        end else begin\n            last_up_transition <= (next_state > current_state);\n            current_state <= next_state;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE       = 3'd0,\n        START_BIT  = 3'd1,\n        DATA_BITS  = 3'd2,\n        STOP_BIT   = 3'd3,\n        ERROR      = 3'd4\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_counter; // Counter for 8 data bits\n    reg [7:0] data;        // To store received data bits temporarily\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 1'b0;\n            bit_counter <= 3'd0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default next state\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (in == 1'b0)  // Detect start bit\n                    next_state = START_BIT;\n            end\n\n            START_BIT: begin\n                next_state = DATA_BITS;\n                bit_counter = 3'd0; // Initialize data bit counter\n            end\n\n            DATA_BITS: begin\n                if (bit_counter == 3'd7) // If all 8 data bits received\n                    next_state = STOP_BIT;\n                else\n                    bit_counter = bit_counter + 3'd1;\n            end\n\n            STOP_BIT: begin\n                if (in == 1'b1) begin // Check if stop bit is correct\n                    next_state = IDLE;\n                    done = 1'b1;       // Indicate byte successfully received\n                end else\n                    next_state = ERROR;\n            end\n            \n            ERROR: begin\n                if (in == 1'b1)     // Wait for stop bit before restarting\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "Here's the concise and complete Verilog code for the specified FSM:\n\n```verilog\nmodule top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE   = 3'b000,\n        START  = 3'b001,\n        DATA   = 3'b010,\n        STOP   = 3'b011,\n        ERROR  = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [2:0] bit_count;   // Count received data bits\n    reg [7:0] shift_reg;   // Temporary register to store data bits\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'b000;\n            shift_reg <= 8'b0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next-state logic and outputs\n    always @(*) begin\n        done = 1'b0;              // Default done reset to 0\n        next_state = state;       // Default next state is current state\n        case (state)\n            IDLE: begin           // Idle state \u2013 wait for start bit\n                if (in == 1'b0)   // Detect start bit (0)\n                    next_state = START;\n            end\n\n            START: begin          // Start state \u2013 confirm start bit\n                next_state = DATA; // Go directly to DATA state\n                bit_count = 3'b000; // Reset bit counter\n            end\n\n            DATA: begin           // Data state \u2013 shift in 8 data bits\n                if (bit_count < 3'd8)\n                    next_state = DATA;\n                else\n                    next_state = STOP; // After 8 bits, expect stop bit\n            end"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    // Parameters\n    parameter PHT_SIZE = 128;\n    parameter BHR_WIDTH = 7;\n\n    // Registers\n    reg [1:0] PHT [0:PHT_SIZE-1]; // Pattern History Table (2-bit saturating counters)\n    reg [6:0] GHR;                // Global History Register\n\n    // Wire declarations\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n\n    // Reset Logic\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            GHR <= 7'b0;\n            for (i = 0; i < PHT_SIZE; i = i + 1) begin\n                PHT[i] <= 2'b01; // Weakly not-taken state\n            end\n        end else if (train_valid && train_mispredicted) begin\n            GHR <= train_history; // Recover the GHR\n        end else if (predict_valid) begin\n            GHR <= {GHR[5:0], predict_taken}; // Update GHR with prediction result\n        end\n    end\n\n    // Hash function (XOR PC and GHR to create index)\n    assign predict_index = predict_pc ^ GHR;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction Logic (Combinational)\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = (PHT[predict_index] >= 2); // Taken if counter is 10 or 11\n            predict_history = GHR; // Output the current GHR\n        end else begin\n            predict_taken = 0;\n            predict_history = 0;\n        end\n    end\n\n    // Training Logic\n    always @(posedge clk) begin\n        if (train_valid) begin\n            // Update PHT with training outcome\n            if (train_taken) begin\n                if (PHT[train_index] < 3)\n                    PHT[train_index] <= PHT[train_index] + 1; // Increment counter for taken\n            end else begin\n                if (PHT[train_index] > 0)\n                    PHT[train_index] <= PHT[train_index] - 1; // Decrement counter for not taken\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        S_WALK_LEFT = 3'b000,\n        S_WALK_RIGHT = 3'b001,\n        S_FALL_LEFT = 3'b010,\n        S_FALL_RIGHT = 3'b011,\n        S_DIG_LEFT = 3'b100,\n        S_DIG_RIGHT = 3'b101,\n        S_SPLATTER = 3'b110\n    } state_t;\n    \n    state_t state, next_state;\n    logic [4:0] fall_counter;\n\n    // Output logic\n    assign walk_left = (state == S_WALK_LEFT);\n    assign walk_right = (state == S_WALK_RIGHT);\n    assign aaah = (state == S_FALL_LEFT) || (state == S_FALL_RIGHT);\n    assign digging = (state == S_DIG_LEFT) || (state == S_DIG_RIGHT);\n\n    // State transition\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S_WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n\n            if (aaah) begin\n                if (ground)\n                    fall_counter <= 0; // Reset counter when ground is hit\n                else\n                    fall_counter <= fall_counter + 1; // Increment counter while falling\n            end else\n                fall_counter <= 0; // Reset counter in non-falling states\n        end\n    end\n\n    always_comb begin\n        next_state = state; // Default state transition\n\n        case (state)\n            S_WALK_LEFT: begin\n                if (!ground)\n                    next_state = S_FALL_LEFT;\n                else if (dig)\n                    next_state = S_DIG_LEFT;\n                else if (bump_left)\n                    next_state = S_WALK_RIGHT;\n            end\n            S_WALK_RIGHT: begin\n                if (!ground)\n                    next_state = S_FALL_RIGHT;\n                else if (dig)\n                    next_state = S_DIG_RIGHT;\n                else if (bump_right)\n                    next_state = S_WALK_LEFT;\n            end\n            S_FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = S_SPLATTER;\n                    else\n                        next_state = S_WALK_LEFT;\n                end\n            end\n            S_FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_counter > 20)\n                        next_state = S_SPLATTER;\n                    else\n                        next_state = S_WALK_RIGHT;\n                end\n            end\n            S_DIG_LEFT: begin\n                if (!ground)\n                    next_state = S_FALL_LEFT;\n            end\n            S_DIG_RIGHT: begin\n                if (!ground)\n                    next_state = S_FALL_RIGHT;\n            end\n            S_SPLATTER: begin\n                // Stay in splatter state forever\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        CHECK = 3'b001,\n        SHIFT = 3'b010,\n        WAIT_COUNT = 3'b011,\n        DONE = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [3:0] pattern_shift; // Shift register to detect 1101\n    reg [1:0] shift_counter; // 2-bit counter for 4 clock cycles of shift_ena\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        // Default outputs\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (pattern_shift == 4'b1101)\n                    next_state = SHIFT;\n                else\n                    next_state = IDLE;\n            end\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_counter == 2'b11) // After 4 cycles\n                    next_state = WAIT_COUNT;\n                else\n                    next_state = SHIFT;\n            end\n            WAIT_COUNT: begin\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = DONE;\n                else\n                    next_state = WAIT_COUNT;\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Pattern detector (shifting register)\n    always @(posedge clk) begin\n        if (reset)\n            pattern_shift <= 4'b0000;\n        else\n            pattern_shift <= {pattern_shift[2:0], data};\n    end\n\n    // 4-cycle shift enable counter\n    always @(posedge clk) begin\n        if (reset || state != SHIFT)\n            shift_counter <= 2'b00;\n        else if (state == SHIFT)\n            shift_counter <= shift_counter + 1'b1;\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    wire [15:0][15:0] grid_in;\n    reg [15:0][15:0] grid_out;\n\n    integer i, j, ni, nj, neighbors;\n    \n    // Map 1D input/output to 2D grid\n    genvar x, y;\n    generate\n        for (x = 0; x < 16; x = x + 1) begin: map_in\n            for (y = 0; y < 16; y = y + 1) begin: map_row\n                assign grid_in[x][y] = q[x * 16 + y];\n            end\n        end\n    endgenerate\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into the grid\n            for (i = 0; i < 16; i = i + 1)\n                for (j = 0; j < 16; j = j + 1)\n                    q[i * 16 + j] <= data[i * 16 + j];\n        end else begin\n            // Advance game state\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    neighbors = 0;\n\n                    // Count all 8 neighbors with toroidal wrapping\n                    for (ni = -1; ni <= 1; ni = ni + 1) begin\n                        for (nj = -1; nj <= 1; nj = nj + 1) begin\n                            if (ni != 0 || nj != 0) begin // Exclude cell itself\n                                neighbors = neighbors + grid_in[(i + ni + 16) % 16][(j + nj + 16) % 16];\n                            end\n                        end\n                    end\n\n                    // Update cell based on neighbor count\n                    if (neighbors < 2 || neighbors > 3)\n                        grid_out[i][j] = 0; // Cell dies\n                    else if (neighbors == 3)\n                        grid_out[i][j] = 1; // Cell comes to life\n                    else\n                        grid_out[i][j] = grid_in[i][j]; // Cell state remains unchanged\n                end\n            end\n\n            // Flatten 2D grid back to 1D and assign to q\n            for (i = 0; i < 16; i = i + 1)\n                for (j = 0; j < 16; j = j + 1)\n                    q[i * 16 + j] <= grid_out[i][j];\n        end\n    end\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        LEFT = 3'b000,\n        RIGHT = 3'b001,\n        FALL_LEFT = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT = 3'b100,\n        DIG_RIGHT = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            LEFT: walk_left = 1;\n            RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            DIG_LEFT: digging = walk_left = 1;\n            DIG_RIGHT: digging = walk_right = 1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the clock to 12:00 AM\n            ss <= 8'h00; // Seconds\n            mm <= 8'h00; // Minutes\n            hh <= 8'h12; // Hours\n            pm <= 1'b0;  // AM\n        end\n        else if (ena) begin\n            // Increment seconds when enabled\n            if (ss == 8'h59) begin\n                ss <= 8'h00; // Reset seconds\n                if (mm == 8'h59) begin\n                    mm <= 8'h00; // Reset minutes\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;    // Roll over to 1\n                        pm <= ~pm;      // Toggle AM/PM\n                    end\n                    else if (hh == 8'h11) begin\n                        hh <= hh + 8'h01; // Increment to 12\n                        // PM state toggling handled above\n                    end\n                    else begin\n                        hh <= hh + 8'h01; // Increment hours\n                    end\n                end\n                else begin\n                    mm <= mm + 8'h01; // Increment minutes\n                end\n            end\n            else begin\n                ss <= ss + 8'h01; // Increment seconds\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b00,\n        RIGHT = 2'b01,\n        FALLING_LEFT = 2'b10,\n        FALLING_RIGHT = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            LEFT: begin\n                if (!ground) \n                    next_state = FALLING_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALLING_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n\n            FALLING_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALLING_LEFT;\n            end\n\n            FALLING_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALLING_RIGHT;\n            end\n\n            default: next_state = LEFT; // Default state\n        endcase\n    end\n\n    // State register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;  // Reset to walking left\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine)\n    always_comb begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALLING_LEFT) || (state == FALLING_RIGHT);\n    end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    // Enable signals for digit increments\n    assign ena[1] = (q[3:0] == 4'd9);         // Enable tens digit when ones digit rolls over (9->0)\n    assign ena[2] = ena[1] & (q[7:4] == 4'd9); // Enable hundreds digit when tens digit rolls over\n    assign ena[3] = ena[2] & (q[11:8] == 4'd9); // Enable thousands digit when hundreds rolls over\n\n    // Always block for clock and synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0; // Reset all digits to 0\n        end else begin\n            // Ones place\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0; // Roll over to 0\n            end else begin\n                q[3:0] <= q[3:0] + 4'd1; // Increment ones\n            end\n\n            // Tens place\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0; // Roll over to 0\n                end else begin\n                    q[7:4] <= q[7:4] + 4'd1; // Increment tens\n                end\n            end\n\n            // Hundreds place\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0; // Roll over to 0\n                end else begin\n                    q[11:8] <= q[11:8] + 4'd1; // Increment hundreds\n                end\n            end\n\n            // Thousands place\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9) begin\n                    q[15:12] <= 4'd0; // Roll over to 0\n                end else begin\n                    q[15:12] <= q[15:12] + 4'd1; // Increment thousands\n                end\n            end\n        end\n    end\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;               // A\n            3'b001: Y2 = w ? 1 : 0;       // B\n            3'b010: Y2 = 1;               // C\n            3'b011: Y2 = 1;               // D\n            3'b100: Y2 = 1;               // E\n            3'b101: Y2 = w ? 1 : 0;       // F\n            default: Y2 = 0;              // Default case (shouldn't occur)\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero);\n\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n    always @(posedge clk) begin\n        if (a == 1) \n            q <= ~q; // Toggle q if a is 1\n        else \n            q <= q;  // Keep q unchanged if a is 0\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "Here is the complete Verilog code for the Moore state machine:\n\n```verilog\nmodule top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    typedef enum logic [1:0] {\n        STATE_IDLE = 2'b00,\n        STATE_INVERT = 2'b01,\n        STATE_PASS = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_IDLE; \n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_IDLE:  next_state = x ? STATE_INVERT : STATE_IDLE;\n            STATE_INVERT: next.ADD_MINORact_onlyChanges.StandardUsageend end the.startAppropriate stop detect solution"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (state)\n            D: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;  // Reset to 0 on active high reset\n        else\n            q <= d;     // Otherwise, latch the input d\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) \n            q <= data;  // Load data into shift register\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;  // Shift left by 1 bit\n                2'b01: q <= q << 8;  // Shift left by 8 bits\n                2'b10: q <= $signed(q) >>> 1;  // Arithmetic shift right by 1 bit\n                2'b11: q <= $signed(q) >>> 8;  // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n    // State encoding\n    typedef enum reg [1:0] {S0 = 2'b00, S1 = 2'b01, S2 = 2'b10} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0:    next_state = x ? S1 : S0;\n            S1:    next_state = x ? S1 : S2;\n            S2:    next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2 && x);\n    end\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State declaration\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic (Next state)\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w == 1'b0) ? B : A;\n            B: next_state = (w == 1'b0) ? C : D;\n            C: next_state = (w == 1'b0) ? E : D;\n            D: next_state = (w == 1'b0) ? F : A;\n            E: next_state = (w == 1'b0) ? E : D;\n            F: next_state = (w == 1'b0) ? C : D;\n            default: next_state = A; // Default to state A for safety\n        endcase\n    end\n\n    // State flip-flops (Sequential logic)\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1'b1; // States E and F output 1\n            default: z = 1'b0; // All other states output 0\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State encoding\n    typedef enum reg [1:0] {IDLE, BYTE1, BYTE2, BYTE3} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Defaults\n        done = 1'b0;\n        next_state = state;\n\n        case (state)\n            IDLE: begin\n                if (in[3]) \n                    next_state = BYTE1;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            out_bytes <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: out_bytes[23:16] <= in;  // First byte\n                BYTE2: out_bytes[15:8]  <= in;  // Second byte\n                BYTE3: out_bytes[7:0]   <= in;  // Third byte\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // Y1 is responsible for the transition to state B (y[1]).\n    // Y1 = (y[0] & w)\n    assign Y1 = (y[0] & w);\n\n    // Y3 is responsible for the transition to state D (y[3]).\n    // Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;  // Output the same 3-bit vector\n    assign o0 = vec[0]; // Assign bit 0 of vec to o0\n    assign o1 = vec[1]; // Assign bit 1 of vec to o1\n    assign o2 = vec[2]; // Assign bit 2 of vec to o2\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({c, d, a, b})\n            4'b0001, 4'b0010,\n            4'b0100, 4'b0111,\n            4'b1000, 4'b1011,\n            4'b1101, 4'b1110: out = 1;\n            default: out = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];  // Assign the upper byte\n    assign out_lo = in[7:0];   // Assign the lower byte\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b); // NOR gate implementation\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n    \n    // Method 1: Using an assign statement\n    assign out_assign = a ^ b;\n    \n    // Method 2: Using a combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n    \n    // Method 3: Using a clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // Y2 corresponds to state B\n    assign Y2 = (y[1] & ~w) | (y[6] & ~w);\n\n    // Y4 corresponds to state D\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & w) | (y[1] & w);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;           // Load R into Q when L is asserted\n        else if (E)\n            Q <= w;           // Shift in w into Q when E is enabled\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    reg q1, q2, q3; // D flip-flop outputs\n\n    // D flip-flop behavior\n    always @(posedge clk) begin\n        q1 <= x ^ q1;          // XOR gate\n        q2 <= x & ~q2;         // AND gate\n        q3 <= x | ~q3;         // OR gate\n    end\n\n    // Three-input XNOR gates for output z\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = c | b;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the data into q when load is high\n        end else begin\n            // Compute the next state of each cell\n            reg [511:0] next_q;\n            integer i;\n            for (i = 0; i < 512; i = i + 1) begin\n                case ({(i == 0) ? 1'b0 : q[i-1], q[i], (i == 511) ? 1'b0 : q[i+1]})\n                    3'b111: next_q[i] = 1'b0;\n                    3'b110: next_q[i] = 1'b1;\n                    3'b101: next_q[i] = 1'b1;\n                    3'b100: next_q[i] = 1'b0;\n                    3'b011: next_q[i] = 1'b1;\n                    3'b010: next_q[i] = 1'b1;\n                    3'b001: next_q[i] = 1'b1;\n                    3'b000: next_q[i] = 1'b0;\n                    default: next_q[i] = 1'b0; // Should not happen\n                endcase\n            end\n            q <= next_q; // Update state\n        end\n    end\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition on clock edge\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default safety case\n        endcase\n    end\n\n    // Output logic (Moore machine: output depends only on the state)\n    always @(*) begin\n        case (current_state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'd15; // f for all other cases\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = (sel) ? b : a;\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module mux_flipflop(\n    input clk,\n    input sel,\n    input d0,\n    input d1,\n    output reg Q\n);\n    always @(posedge clk) begin\n        Q <= (sel) ? d1 : d0;\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    wire q1, q2, q3;\n\n    // Instantiating the submodule three times\n    mux_flipflop u1 (.clk(clk), .sel(L), .d0(q_in ^ q3), .d1(r_in), .Q(q1));\n    mux_flipflop u2 (.clk(clk), .sel(L), .d0(q1), .d1(r_in), .Q(q2));\n    mux_flipflop u3 (.clk(clk), .sel(L), .d0(q2), .d1(r_in), .Q(q3));\n\n    always @(posedge clk) begin\n        Q <= q3; // Assign final output\n    end\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    reg [31:0] in_d; // Register to hold the previous value of 'in'\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0; // Reset 'out' to 0 on active high reset\n            in_d <= 32'b0; // Also reset the previous value register\n        end else begin\n            out <= out | (in_d & ~in); // Detect 1 -> 0 transitions and set the corresponding output bit\n            in_d <= in; // Update the previous value register\n        end\n    end\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding:\n    // S     = state[0]\n    // S1    = state[1]\n    // S11   = state[2]\n    // S110  = state[3]\n    // B0    = state[4]\n    // B1    = state[5]\n    // B2    = state[6]\n    // B3    = state[7]\n    // Count = state[8]\n    // Wait  = state[9]\n\n    // Next State Logic\n    assign S_next    = state[0] & ~d | state[1] & ~d | state[3] & ~d | state[9] & ack;\n    assign S1_next   = state[0] & d | state[1] & d;\n    assign B3_next   = state[6];\n    assign Count_next = state[7] | (state[8] & ~done_counting);\n    assign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n    // Output Logic\n    assign shift_ena = state[4] | state[5] | state[6] | state[7];\n    assign counting  = state[8];\n    assign done      = state[9];\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 2'b01; // Increment\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 2'b01; // Decrement\n            end\n        end\n        // If train_valid is 0, state remains unchanged\n    end\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in)\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default:     pos = 3'd0; // No bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        // Default outputs\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Check scancode and set the appropriate output\n        case (scancode)\n            16'he06b: left  = 1;\n            16'he072: down  = 1;\n            16'he074: right = 1;\n            16'he075: up    = 1;\n            default: /* Do nothing, all outputs remain 0 */\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Instance of Full Adder for each bit position\n    full_adder FA0(x[0], y[0], 1'b0, sum[0], c1);\n    full_adder FA1(x[1], y[1], c1, sum[1], c2);\n    full_adder FA2(x[2], y[2], c2, sum[2], c3);\n    full_adder FA3(x[3], y[3], c3, sum[3], c4);\n\n    // Overflow bit\n    assign sum[4] = c4;\n\nendmodule\n\n// Full Adder Module\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0; // Reset history to zero\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[31:1], train_taken}; // Rollback and update with actual result\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken}; // Update with predicted direction\n    end\nend\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    // Intermediate wires\n    wire and1_out;\n    wire and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    // 8-bit shift register\n    reg [7:0] Q; // Q[0] is MSB, Q[7] is LSB\n\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {Q[6:0], S}; // Shift in the input S\n    end\n\n    // Multiplexer logic\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case, though should not occur\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n    // Heater is on in heating mode when too_cold is 1\n    assign heater = mode & too_cold;\n\n    // Air conditioner is on in cooling mode when too_hot is 1\n    assign aircon = ~mode & too_hot;\n\n    // Fan is on if heater, aircon, or fan_on is 1\n    assign fan = heater | aircon | fan_on;\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Minimum Sum-of-Products form (SOP)\n    assign out_sop = (~a & b & c & d) | (a & b & ~c & d) | (a & b & c & d);\n    \n    // Minimum Product-of-Sums form (POS)\n    assign out_pos = (a | ~b | ~c | ~d) & (~a | ~b | c | ~d) & (~a | ~b | ~c | ~d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h1;  // Reset to the initial value of 1\n        else begin\n            // Galois LFSR with taps at bit positions 32, 22, 2, and 1\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (a & (b | c | d)) | (b & d);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    assign p1y = ~(p1a & p1b & p1c & p1d); // 4-input NAND for first gate\n    assign p2y = ~(p2a & p2b & p2c & p2d); // 4-input NAND for second gate\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) out_both: Determine if both current and left neighbor are 1\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n    \n    // (2) out_any: Determine if either current or right neighbor are 1\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    \n    // (3) out_different: Determine if current and left neighbor are different (wrap-around)\n    assign out_different[3] = in[3] ^ in[0]; // Wrap-around case\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n    \nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a,\n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000; // Optional: default case for safety\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0;                     // Synchronous reset to 0\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;                 // Wrap around if counter reaches 9\n            else\n                q <= q + 1'b1;             // Increment counter\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with in2 inverted (bubble)\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n    \n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {STATE_A = 2'b00, STATE_B = 2'b01} state_t;\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = (in) ? STATE_A : STATE_B; // A transitions\n            STATE_B: next_state = (in) ? STATE_B : STATE_A; // B transitions\n            default: next_state = STATE_B; // Default to B\n        endcase\n    end\n\n    // State update logic (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= STATE_B; // Async reset to state B\n        else \n            state <= next_state;\n    end\n\n    // Output logic (Moore output depends on current state)\n    always @(*) begin\n        out = (state == STATE_B) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    reg q_pos, q_neg;\n\n    // Flip-flop on positive edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Flip-flop on negative edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Mux to select between positive and negative edge-triggered flip-flop\n    always @(*) begin\n        if (clk) \n            q = q_pos;\n        else \n            q = q_neg;\n    end\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b); // XNOR gate implementation\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A (\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B (\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 1'bx;\n        endcase\n    end\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate submodules\n    A u1 (.x(x), .y(y), .z(a1_out));\n    A u2 (.x(x), .y(y), .z(a2_out));\n    B u3 (.x(x), .y(y), .z(b1_out));\n    B u4 (.x(x), .y(y), .z(b2_out));\n\n    // OR gate\n    assign or_out = a1_out | b1_out;\n\n    // AND gate\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load input data into the register\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};        // Rotate right by 1 bit\n                2'b10: q <= {q[98:0], q[99]};       // Rotate left by 1 bit\n                default: q <= q;                    // No rotation on 2'b00 or 2'b11\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 10'd0;\n        else if (q == 10'd999) \n            q <= 10'd0;\n        else \n            q <= q + 10'd1;\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output reg [9:0] next_state,\n    output reg out1,\n    output reg out2);\n\n    always @(*) begin\n        // Default outputs\n        out1 = 0;\n        out2 = 0;\n\n        // State transitions and logic\n        case (1'b1) // One-hot encoded state\n            state[0]: next_state = in ? 10'b0000000010 : 10'b0000000001;  // S0\n            state[1]: next_state = in ? 10'b0000000100 : 10'b0000000001;  // S1\n            state[2]: next_state = in ? 10'b0000001000 : 10'b0000000001;  // S2\n            state[3]: next_state = in ? 10'b0000010000 : 10'b0000000001;  // S3\n            state[4]: next_state = in ? 10'b0000100000 : 10'b0000000001;  // S4\n            state[5]: next_state = in ? 10'b0001000000 : 10'b0100000000;  // S5\n            state[6]: next_state = in ? 10'b0010000000 : 10'b1000000000;  // S6\n            state[7]: begin                                            // S7\n                          next_state = in ? 10'b0010000000 : 10'b0000000001;\n                          out2 = 1;\n                      end\n            state[8]: begin                                            // S8\n                          next_state = in ? 10'b0000000010 : 10'b0000000001;\n                          out1 = 1;\n                      end\n            state[9]: begin                                            // S9\n                          next_state = in ? 10'b0000000010 : 10'b0000000001;\n                          out1 = 1;\n                          out2 = 1;\n                      end\n            default: next_state = 10'b0000000001; // Reset to S0\n        endcase\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // No change\n            2'b01: Q <= 0;       // Reset\n            2'b10: Q <= 1;       // Set\n            2'b11: Q <= ~Q;      // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // Define the two states\n    typedef enum logic [1:0] {\n        LEFT = 2'b01,\n        RIGHT = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (bump_left || (bump_left && bump_right))\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right || (bump_left && bump_right))\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default to LEFT state\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic: Moore machine\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin // Should not happen but included for completeness\n                walk_left = 0;\n                walk_right = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b; // AND operation\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate wires for AND gates\n    wire and1, and2, and3, and4;\n\n    // 3-input AND gates for p1y\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n\n    // OR gate for p1y\n    assign p1y = and1 | and2;\n\n    // 2-input AND gates for p2y\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    // OR gate for p2y\n    assign p2y = and3 | and4;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] Y_next;\n\n    always @(*) begin\n        // Next state logic\n        case (y)\n            3'b000: Y_next = (x == 0) ? 3'b000 : 3'b001;\n            3'b001: Y_next = (x == 0) ? 3'b001 : 3'b100;\n            3'b010: Y_next = (x == 0) ? 3'b010 : 3'b001;\n            3'b011: Y_next = (x == 0) ? 3'b001 : 3'b010;\n            3'b100: Y_next = (x == 0) ? 3'b011 : 3'b100;\n            default: Y_next = 3'b000; // Default state\n        endcase\n    end\n\n    always @(*) begin\n        // Output logic\n        case (y)\n            3'b011, 3'b100: z = 1; // z = 1 for states 011 and 100\n            default: z = 0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        // Update the least significant bit of next state (Y[0])\n        Y0 <= Y_next[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n    \nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @* begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n    reg [9:0] counter;  // 10-bit down counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;  // Load the counter with the given value\n        end else if (counter > 0) begin\n            counter <= counter - 1;  // Decrement the counter\n        end\n    end\n\n    assign tc = (counter == 0);  // Assert tc when counter reaches 0\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting);\n\n    // State encoding\n    parameter IDLE = 3'b000, S1 = 3'b001, S11 = 3'b010, S110 = 3'b011, S1101 = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE:  next_state = data ? S1 : IDLE;\n            S1:    next_state = data ? S11 : IDLE;\n            S11:   next_state = data ? S11 : S110;\n            S110:  next_state = data ? S1101 : IDLE;\n            S1101: next_state = S1101; // Hold the final state\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (state == S1101)\n            start_shifting <= 1'b1;\n    end\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 8'b0; // Reset output to zero\n        else \n            q <= d;    // Latch input\n    end\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in; // Register to store the input from the previous clock cycle\n\n    always @(posedge clk) begin\n        anyedge <= (prev_in ^ in) & ~prev_in; // Detect edges and set the corresponding output bit\n        prev_in <= in; // Update the previous input\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1; // Reset to 1\n        end else if (q == 4'd10) begin\n            q <= 4'd1; // Restart counting at 1 after reaching 10\n        end else begin\n            q <= q + 4'd1; // Increment counter\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'b100; // Reset q to 4 when a = 1\n        else\n            q <= (q == 3'd6) ? 3'b000 : q + 1; // Increment q, wrap to 0 after 6\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    always @(posedge clk) begin\n        if (reset) \n            q <= 5'b00001;  // Synchronous Reset: Initialize to 1\n        else begin\n            q[4:1] <= q[3:0];  // Shift right\n            q[0] <= q[4] ^ q[2];  // XOR taps at positions 5 and 3\n        end\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Correct the case statement and ensure bitwise negation is handled.\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n        \n        // Properly check if the result is zero.\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0100: f = 0;\n            4'b0101: f = 0;\n            4'b0111: f = 1;\n            4'b0110: f = 0;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            4'b1110: f = 0;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            default: f = 0; // Assigning don't-care conditions as 0\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1; end\n            8'h16: begin out = 4'd1; valid = 1; end\n            8'h1e: begin out = 4'd2; valid = 1; end\n            8'h26: begin out = 4'd3; valid = 1; end\n            8'h25: begin out = 4'd4; valid = 1; end\n            8'h2e: begin out = 4'd5; valid = 1; end\n            8'h36: begin out = 4'd6; valid = 1; end\n            8'h3d: begin out = 4'd7; valid = 1; end\n            8'h3e: begin out = 4'd8; valid = 1; end\n            8'h46: begin out = 4'd9; valid = 1; end\n            default: begin out = 4'd0; valid = 0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case ({c, d, a, b})\n        4'b0010, 4'b0011, 4'b0111, 4'b1011, \n        4'b1111, 4'b1110, 4'b1010, 4'b0110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena)         // Shift logic\n            q <= {q[2:0], data};\n        else if (count_ena)    // Decrement logic\n            q <= q - 1;\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n    reg [2:0] count; // 3-bit counter to track 4 clock cycles\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1;\n            count <= 3'b000;\n        end else if (shift_ena) begin\n            count <= count + 1;\n            if (count == 3'b011) // De-assert shift_ena after 4 cycles\n                shift_ena <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000; // Reset the counter to 0\n    else\n        q <= q + 1'b1; // Increment the counter\nend\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | b; // Simplified expression from the K-map\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State flip-flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B; // Priority to r1\n                else if (r[2])\n                    next_state = C; // Next priority to r2\n                else if (r[3])\n                    next_state = D; // Lowest priority to r3\n                else\n                    next_state = A; // Stay in A if no requests\n            end\n            B: begin\n                if (r[1])\n                    next_state = B; // Stay in B if r1 is still active\n                else\n                    next_state = A; // Go back to A when r1 is deactivated\n            end\n            C: begin\n                if (r[2])\n                    next_state = C; // Stay in C if r2 is still active\n                else\n                    next_state = A; // Go back to A when r2 is deactivated\n            end\n            D: begin\n                next_state = A; // Always return to A from D\n            end\n            default: next_state = A; // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default: No grants\n        case (state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000; // No grants in state A\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Synchronous reset to 0\n        else if (q == 4'd9) \n            q <= 4'd0; // Reset to 0 after reaching 9\n        else \n            q <= q + 1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        WAIT_FOR_FIRST_BYTE = 2'b00,\n        BYTE_2              = 2'b01,\n        BYTE_3              = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    // Output logic\n    assign done = (state == BYTE_3);\n\n    // State transition logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= WAIT_FOR_FIRST_BYTE;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always_comb begin\n        case (state)\n            WAIT_FOR_FIRST_BYTE: begin\n                if (in[3])\n                    next_state = BYTE_2;\n                else\n                    next_state = WAIT_FOR_FIRST_BYTE;\n            end\n            BYTE_2: begin\n                next_state = BYTE_3;\n            end\n            BYTE_3: begin\n                next_state = WAIT_FOR_FIRST_BYTE;\n            end\n            default: begin\n                next_state = WAIT_FOR_FIRST_BYTE; // Default case for safety\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // AND reduction operator\n    assign out_or  = |in;  // OR reduction operator\n    assign out_xor = ^in;  // XOR reduction operator\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [2:0] state, next_state;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            3'b000: next_state = (x) ? 3'b001 : 3'b000;\n            3'b001: next_state = (x) ? 3'b100 : 3'b001;\n            3'b010: next_state = (x) ? 3'b001 : 3'b010;\n            3'b011: next_state = (x) ? 3'b010 : 3'b001;\n            3'b100: next_state = (x) ? 3'b100 : 3'b011;\n            default: next_state = 3'b000; // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1;\n            default: z = 0;\n        endcase\n    end\n\n    // Synchronous state register with reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000; // Reset state\n        else\n            state <= next_state;\n    end\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A, F_PULSE, MONITOR_X, G_ASSERT, WAIT_Y1, G_PERM, G_OFF\n    } state_t;\n    state_t state, next_state;\n\n    // Registers for detecting 101 pattern in x\n    reg [1:0] x_history;\n    reg [1:0] y_count;\n\n    // State transitions\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_history <= 2'b00;\n            y_count <= 2'b00;\n        end else begin\n            x_history <= {x_history[0], x};\n            if (state == WAIT_Y1) begin\n                y_count <= (y_count == 2) ? 2 : y_count + 1;\n            end else begin\n                y_count <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            A: next_state = !resetn ? A : F_PULSE;\n            F_PULSE: next_state = MONITOR_X;\n            MONITOR_X: next_state = (x_history == 2'b10 && x == 1) ? G_ASSERT : MONITOR_X;\n            G_ASSERT: next_state = WAIT_Y1;\n            WAIT_Y1: next_state = (y == 1) ? G_PERM : (y_count == 2) ? G_OFF : WAIT_Y1;\n            G_PERM: next_state = G_PERM;\n            G_OFF: next_state = G_OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end else begin\n            f <= (state == F_PULSE);\n            g <= (state == G_PERM || state == G_ASSERT);\n        end\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n    always @(negedge clk) begin\n        if (reset) \n            q <= 8'h34; // Reset to 0x34\n        else \n            q <= d;    // Update with new input values\n    end\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all 8 bits to generate even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output reg out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: begin // State A\n                next_state = in ? 2'b01 : 2'b00; // A->B if in=1, else A->A\n                out = 1'b0;\n            end\n            2'b01: begin // State B\n                next_state = in ? 2'b01 : 2'b10; // B->B if in=1, else B->C\n                out = 1'b0;\n            end\n            2'b10: begin // State C\n                next_state = in ? 2'b11 : 2'b00; // C->D if in=1, else C->A\n                out = 1'b0;\n            end\n            2'b11: begin // State D\n                next_state = in ? 2'b01 : 2'b10; // D->B if in=1, else D->C\n                out = 1'b1;\n            end\n            default: begin\n                next_state = 2'b00; // Default to state A\n                out = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "```verilog\nmodule top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\talways @(*)\n\tbegin\n\t\tif (x == 1 && y == 0)\n\t\t\tz = 0;\n\t\telse if (x == 0 && y == 1)\n\t\t\tz = 0;\n\t\telse if(X >... )***"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State flip-flops: sequential logic\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= A;\n        else \n            current_state <= next_state;\n    end\n\n    // State transition table: combinational logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w ? B : A);\n            B: next_state = (w ? C : D);\n            C: next_state = (w ? E : D);\n            D: next_state = (w ? F : A);\n            E: next_state = (w ? E : D);\n            F: next_state = (w ? C : D);\n            default: next_state = A; // Default fallback\n        endcase\n    end\n\n    // Output logic for z\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\nalways @(posedge clk) begin\n    if (!resetn) \n        q <= 16'b0;      // Synchronous, active-low reset\n    else begin\n        if (byteena[0])  // Write to lower byte\n            q[7:0] <= d[7:0];\n        if (byteena[1])  // Write to upper byte\n            q[15:8] <= d[15:8];\n    end\nend\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge);\n\n    reg [7:0] prev_in; // Register to store the previous input value\n\n    always @(posedge clk) begin\n        // Positive edge detection for each bit\n        pedge <= (~prev_in) & in;\n        prev_in <= in; // Update prev_in with current input\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg prev_a; // To store the previous state of input 'a'\n\n    always @(posedge clock) begin\n        if (a && !prev_a) // Detect rising edge of 'a'\n            p <= 1'b1;\n        else\n            p <= 1'b0; // Otherwise, reset p to 0\n    end\n\n    always @(negedge clock) begin\n        if (p)\n            q <= 1'b1; // Set q to 1 when p is high on clock falling edge\n        else\n            q <= 1'b0; // Reset q to 0 otherwise\n    end\n\n    always @(posedge clock) begin\n        prev_a <= a; // Update previous state of a\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data; // Load initial state\n    end else begin\n        q[0] <= q[1] ^ 0; // Left boundary (q[-1] = 0)\n        q[511] <= 0 ^ q[510]; // Right boundary (q[512] = 0)\n        integer i;\n        for (i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i - 1] ^ q[i + 1]; // XOR left and right neighbors\n        end\n    end\nend\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A == B) ? 1 : 0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // (1) out_both: both in[i] and in[i+1] equal '1'\n    assign out_both = in[99:1] & in[98:0];\n    \n    // (2) out_any: either in[i] or in[i-1] equals '1'\n    assign out_any = in[99:1] | in[98:0];\n    \n    // (3) out_different: in[i] different from in[i+1], wrapping for in[99]\n    assign out_different = in ^ {in[0], in[99:1]};\n    \nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena)\n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    // Extract the 4-bit output based on the selection\n    assign out = in[sel*4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'hFFFF; // Set all bits to '1' for sel=9 to 15\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR\n    assign out_or_logical = |a || |b;\n    \n    // Inverse of b in the upper half and inverse of a in the lower half\n    assign out_not = {~b, ~a};\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = (in == 0) ? 4'b0001 : 4'b0010; // A\n            4'b0010: next_state = (in == 0) ? 4'b0100 : 4'b0010; // B\n            4'b0100: next_state = (in == 0) ? 4'b0001 : 4'b1000; // C\n            4'b1000: next_state = (in == 0) ? 4'b0100 : 4'b0010; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000) ? 1 : 0; // Output is 1 only for state D\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        min = a; // Initialize min with 'a'\n        if (b < min)\n            min = b; // Update min if 'b' is smaller\n        if (c < min)\n            min = c; // Update min if 'c' is smaller\n        if (d < min)\n            min = d; // Update min if 'd' is smaller\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    // Minimized expression derived from the Karnaugh map:\n    assign out = (~c & ~d) | (~a & ~b & d) | (~b & c & d) | (a & b & c) | (a & ~b & ~c);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, COUNT = 2'b10;\n\n    reg [1:0] state, next_state;\n    reg [1:0] w_count;  // Counter to track 'w == 1' occurrences\n    reg [1:0] cycle_count;  // 3-cycle counter\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            w_count <= 0;\n            cycle_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == COUNT) begin\n                cycle_count <= cycle_count + 1;\n                if (w) w_count <= w_count + 1;\n                if (cycle_count == 2) begin  // Reset after 3 cycles\n                    cycle_count <= 0;\n                    w_count <= 0;\n                end\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (s) next_state = B;\n                else next_state = A;\n            end\n            B: next_state = COUNT;\n            COUNT: begin\n                if (cycle_count == 2) next_state = B;  // Return to B after 3 cycles\n                else next_state = COUNT;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        if (state == COUNT && cycle_count == 2) begin\n            if (w_count == 2) z = 1;  // Check if exactly two 'w = 1' occurred\n            else z = 0;\n        end else z = 0;\n    end\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) // Active-low synchronous reset\n            shift_reg <= 4'b0;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3]; // Output the MSB\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'bzzz1: pos = 2'd0;\n            4'bzz10: pos = 2'd1;\n            4'bz100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            default: pos = 2'd0; // Output zero if no bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // Declare state encoding\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            OFF: next_state = (j == 1) ? ON : OFF;\n            ON:  next_state = (k == 1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;  // Reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore output is state-based)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n    \n    // Drive the output to logic low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out; // XOR operation feeding the D input\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Asynchronous reset to zero\n        end else if (load) begin\n            q <= data; // Load data into the register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right with MSB set to zero\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    // Implement the truth table using logic expressions derived by inspection\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;     // Asynchronous reset sets output to 0\n        else\n            q <= d;        // Normal D flip-flop behavior\n    end\n    \nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;         // AND reduction\n    assign out_or = |in;          // OR reduction\n    assign out_xor = ^in;         // XOR reduction\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b;  // Sum is the XOR of the inputs\n    assign cout = a & b; // Carry-out is the AND of the inputs\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Ensure shut_off_computer is assigned in all cases\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0; // Ensure keep_driving is assigned in all cases\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    parameter OFF = 1'b0;\n    parameter ON = 1'b1;\n\n    reg state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON: next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF; // Default case\n        endcase\n    end\n\n    // State flip-flops including reset (sequential)\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (combinational, depends only on the state)\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n            default: out = 1'b0; // Default case\n        endcase\n    end\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate inputs and add two 1 bits to form a 32-bit combined vector\n    wire [31:0] combined = {a, b, c, d, e, f, 2'b11};\n\n    // Split the combined vector into 4 output vectors\n    assign w = combined[31:24];\n    assign x = combined[23:16];\n    assign y = combined[15:8];\n    assign z = combined[7:0];\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = ~((a ^ b) ^ (c ^ d));\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State declarations\n    typedef enum logic {B, A} state_t;\n    state_t state, next_state;\n\n    // Synchronous logic for state transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= B; // Reset state is B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B: next_state = (in) ? B : A;\n            A: next_state = (in) ? A : B;\n        endcase\n    end\n\n    // Output logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            B: out = 1;\n            A: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    assign sum = a ^ b ^ cin;      // XOR for sum\n    assign cout = (a & b) | (b & cin) | (a & cin); // Carry out logic\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal for XNOR output\n    logic xnor_out;\n\n    // XNOR logic\n    assign xnor_out = ~(in1 ^ in2);\n\n    // XOR logic\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implement the logic for 4-to-1 multiplexer inputs\n    assign mux_in[0] = ~c & d;      // K-map value for ab=00\n    assign mux_in[1] = 0;           // K-map value for ab=01\n    assign mux_in[2] = c | d;       // K-map value for ab=11\n    assign mux_in[3] = ~d;          // K-map value for ab=10\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding using one-hot\n    reg state_A, state_B, next_A, next_B;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset to state A\n            state_A <= 1'b1;\n            state_B <= 1'b0;\n        end else begin\n            // Update states on clock edge\n            state_A <= next_A;\n            state_B <= next_B;\n        end\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default values (all states inactive)\n        next_A = 1'b0;\n        next_B = 1'b0;\n        z = 1'b0;\n\n        if (state_A) begin\n            if (x) begin\n                next_B = 1'b1; // Transition to B\n                z = 1'b1;      // Output 1\n            end else begin\n                next_A = 1'b1; // Stay in A\n                z = 1'b0;      // Output 0\n            end\n        end else if (state_B) begin\n            if (x) begin\n                next_B = 1'b1; // Stay in B\n                z = 1'b0;      // Output 0\n            end else begin\n                next_B = 1'b1; // Stay in B\n                z = 1'b1;      // Output 1\n            end\n        end\n    end\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output state\n);\n    assign state = q; // State is directly connected to q.\n    \n    always @(posedge clk) begin\n        if (a & b)          // a == 1 and b == 1\n            q <= ~q;        // Toggle q\n        else if (a & ~b)    // a == 1 and b == 0\n            q <= 0;         // Reset q to 0\n        // Otherwise, q remains unchanged\n    end\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000: f = 1;\n            4'b0001: f = 0;\n            4'b0011: f = 0;\n            4'b0010: f = 1;\n            4'b0100: f = 0;\n            4'b0101: f = 0;\n            4'b0111: f = 0;\n            4'b0110: f = 0;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            4'b1111: f = 1;\n            4'b1110: f = 0;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            4'b1011: f = 0;\n            4'b1010: f = 1;\n            default: f = 0; // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    typedef enum reg [3:0] {\n        IDLE      = 4'd0,\n        ONE       = 4'd1,\n        TWO       = 4'd2,\n        THREE     = 4'd3,\n        FOUR      = 4'd4,\n        FIVE      = 4'd5,\n        SIX       = 4'd6,\n        SEVEN     = 4'd7,\n        ERROR     = 4'd8\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (Sequential)\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic: detect disc, flag, and err\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err  <= 1'b0;\n        end else begin\n            disc <= (state == SIX && in == 1'b0); // 0111110\n            flag <= (state == SIX && in == 1'b1); // 01111110\n            err  <= (state == SEVEN && in == 1'b1); // 01111111...\n        end\n    end\n\n    // State transition conditions (Combinational)\n    always @(*) begin\n        case (state)\n            IDLE:      next_state = in ? ONE : IDLE;\n            ONE:       next_state = in ? TWO : IDLE;\n            TWO:       next_state = in ? THREE : IDLE;\n            THREE:     next_state = in ? FOUR : IDLE;\n            FOUR:      next_state = in ? FIVE : IDLE;\n            FIVE:      next_state = in ? SIX : IDLE;\n            SIX:       next_state = in ? SEVEN : IDLE; // Flag or disc conditions\n            SEVEN:     next_state = in ? ERROR : IDLE; // Error condition\n            ERROR:     next_state = reset ? IDLE : ERROR;\n            default:   next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "Here's the completed Verilog module:\n\n```verilog\nmodule top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    reg [2:0] state, next_state;\n    reg [3:0] shift_reg, delay;\n    reg [12:0] timer, next_timer;\n    reg [3:0] remaining_time, next_remaining_time;\n\n    // State encoding\n    localparam IDLE      = 3'd0;\n    localparam PATTERN   = 3'd1;\n    localparam DELAY     = 3'd2;\n    localparam WAIT_TIME = 3'd3;\n    localparam DONE      = 3'd4;\n\n    // State machine update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 4'd0;\n            delay <= 4'd0;\n            timer <= 13'd0;\n            remaining_time <= 4'd0;\n        end else begin\n            state <= next_state;\n            shift_reg <= (state == PATTERN || state == DELAY) ? {shift_reg[2:0], data} : shift_reg;\n            delay <= (state == DELAY && shift_reg[3]) ? shift_reg : delay;\n            timer <= next_timer;\n            remaining_time <= next_remaining_time;\n        end\n    end\n\n    // State machine next state logic\n    always @(*) begin\n        next_state = state;\n        next_timer = timer;\n        next_remaining_time = remaining_time;\n        counting = 1'b0;\n        done = 1'b0;\n        \n        case (state)\n            IDLE: begin\n                if (shift_reg == 4'b1101)\n                    next_state = DELAY;\n            end\n            \n            DELAY: begin\n                if (shift_reg[3] == 1)\n                            ."}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State Encoding\n    typedef enum logic [1:0] {\n        LOW = 2'b00,\n        BETWEEN_S1_S2 = 2'b01,\n        BETWEEN_S2_S3 = 2'b10,\n        HIGH = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n    reg prev_level_increasing;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= LOW;\n            prev_level_increasing <= 1'b0;\n        end else begin\n            current_state <= next_state;\n            \n            // Update the previous level tendency\n            prev_level_increasing <= (next_state > current_state);\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default outputs\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n\n        case (current_state)\n            LOW: begin\n                if (s[1]) \n                    next_state = BETWEEN_S1_S2;\n                else \n                    next_state = LOW;\n                \n                // Outputs for LOW state\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n            \n            BETWEEN_S1_S2: begin\n                if (s[2]) begin\n                    next_state = BETWEEN_S2_S3;\n                end else if (~s[1]) begin\n                    next_state = LOW;\n                end else begin\n                    next_state = BETWEEN_S1_S2;\n                end\n\n                // Outputs for BETWEEN_S1_S2 state\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = prev_level_increasing;\n            end\n\n            BETWEEN_S2_S3: begin\n                if (s[3]) begin\n                    next_state = HIGH;\n                end else if (~s[2]) begin\n                    next_state = BETWEEN_S1_S2;\n                end else begin\n                    next_state = BETWEEN_S2_S3;\n                end\n\n                // Outputs for BETWEEN_S2_S3 state\n                fr1 = 1'b1;\n                dfr = prev_level_increasing;\n            end\n\n            HIGH: begin\n                if (~s[3])\n                    next_state = BETWEEN_S2_S3;\n                else \n                    next_state = HIGH;\n\n                // No outputs are asserted for HIGH state\n            end\n\n            default: next_state = LOW;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // Define state encoding\n    typedef enum logic [2:0] {\n        IDLE,        // Waiting for start bit\n        START,       // Start bit detected\n        DATA,        // Receiving 8 data bits\n        VERIFY_STOP, // Waiting for stop bit\n        ERROR        // Stop bit error detected\n    } state_t;\n    \n    state_t state, next_state;\n    reg [2:0] bit_count; // 3 bits to count 0-7 data bits\n    reg [7:0] data_reg;  // Register for the 8 data bits received\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        done = 0; // Default output\n        next_state = state; // Default remain in current state\n        case (state)\n            IDLE: begin\n                if (in == 0) // Detect start bit\n                    next_state = START;\n            end\n\n            START: begin\n                next_state = DATA; // Move to data reception\n            end\n\n            DATA: begin\n                if (bit_count == 7) // All 8 data bits received\n                    next_state = VERIFY_STOP;\n            end\n\n            VERIFY_STOP: begin\n                if (in == 1) begin // Stop bit detected\n                    done = 1;     // Signal byte received\n                    next_state = IDLE; // Return to idle\n                end else begin\n                    next_state = ERROR; // Invalid stop bit\n                end\n            end\n\n            ERROR: begin\n                if (in == 1) // Wait for stop bit to reset\n                    next_state = IDLE;\n            end\n\n            default: next_state = IDLE; // Safety condition\n        endcase\n    end\n\n    // Bit counting and data reception process\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_count <= 0;\n            data_reg <= 0;\n        end else if (state == DATA) begin\n            data_reg <= {in, data_reg[7:1]}; // Shift in least-significant bit first\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 0; // Reset bit count after DATA phase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    typedef enum logic [2:0] {\n        IDLE       = 3'b000,\n        START_BIT  = 3'b001,\n        DATA_BITS  = 3'b010,\n        STOP_BIT   = 3'b011,\n        ERROR      = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] bit_count; // To track the 8 data bits\n    reg [7:0] shift_reg;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 0;\n            done <= 0;\n            out_byte <= 8'b0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: begin\n                if (in == 0) // Detect start bit\n                    next_state = START_BIT;\n            end\n            START_BIT: begin\n                next_state = DATA_BITS;\n            end\n            DATA_BITS: begin\n                if (bit_count == 8) \n                    next_state = STOP_BIT;\n            end\n            STOP_BIT: begin\n                if (in == 1) begin // Check if stop bit is valid\n                    done = 1;\n                    next_state = IDLE;\n                end else begin\n                    next_state = ERROR;\n                end\n            end\n            ERROR: begin\n                if (in == 1) // Wait for a valid stop bit\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Data bit count and shift register\n    always @(posedge clk) begin\n        if (state == DATA_BITS) begin\n            bit_count <= bit_count + 1;\n            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first\n        end else begin\n            bit_count <= 0; // Reset bit count when not in DATA_BITS state\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (state == STOP_BIT && in == 1) begin\n            out_byte <= shift_reg;\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Parameters and internal signals\n    reg [1:0] PHT [127:0];       // Pattern History Table with 128 2-bit saturating counters\n    reg [6:0] global_history;    // 7-bit Global History Register\n    wire [6:0] predict_index;    // Index for prediction\n    wire [6:0] train_index;      // Index for training\n\n    // XOR for index computation (PC XOR Global History)\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Reset global history and PHT on asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            integer i;\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b01; // Initialize to weakly not taken\n            end\n        end else if (train_valid) begin\n            // Training logic\n            // Update PHT\n            if (train_taken) begin\n                if (PHT[train_index] < 2'b11)\n                    PHT[train_index] <= PHT[train_index] + 1;\n            end else begin\n                if (PHT[train_index] > 2'b00)\n                    PHT[train_index] <= PHT[train_index] - 1;\n            end\n\n            // Recover global history register on misprediction\n            if (train_mispredicted) begin\n                global_history <= {train_history[5:0], train_taken};\n            end else begin\n                // Update global history on correct prediction\n                global_history <= {global_history[5:0], train_taken};\n            end\n        end else if (predict_valid) begin\n            // Update global history on prediction\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    // Prediction logic\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = PHT[predict_index][1]; // Use MSB as the prediction\n            predict_history = global_history;     // Output the current global history\n        end else begin\n            predict_taken = 0;\n            predict_history = 7'b0;\n        end\n    end\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // Define states\n    typedef enum logic [2:0] {\n        LEFT = 3'b000,\n        RIGHT = 3'b001,\n        FALL_LEFT = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT = 3'b100,\n        DIG_RIGHT = 3'b101,\n        SPLATTER = 3'b110\n    } state_t;\n\n    state_t state, next_state;\n    reg [4:0] fall_count; // Count falling cycles (0\u201331)\n\n    // State Transition Logic\n    always @(*) begin\n        next_state = state; // Default to the same state\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left || bump_right)\n                    next_state = RIGHT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_left || bump_right)\n                    next_state = LEFT;\n            end\n            FALL_LEFT: begin\n                if (ground && fall_count > 20)\n                    next_state = SPLATTER;\n                else if (ground && fall_count <= 20)\n                    next_state = LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground && fall_count > 20)\n                    next_state = SPLATTER;\n                else if (ground && fall_count <= 20)\n                    next_state = RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLATTER: begin\n                next_state = SPLATTER; // Remain in splatter state\n            end\n        endcase\n    end\n\n    // State Update Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 0;\n        end else begin\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_count <= fall_count + 1;\n            else\n                fall_count <= 0;\n\n            state <= next_state;\n        end\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            LEFT: walk_left = 1;\n            RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            DIG_LEFT: digging = 1;\n            DIG_RIGHT: digging = 1;\n            SPLATTER: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        DETECT1 = 3'b001,\n        DETECT2 = 3'b010,\n        DETECT3 = 3'b011,\n        SHIFT = 3'b100,\n        COUNT = 3'b101,\n        DONE = 3'b110\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] shift_count;\n\n    // State transition logic\n    always @(*) begin\n        // Default outputs\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n        next_state = state;\n\n        case (state)\n            IDLE: begin\n                if (data == 1) next_state = DETECT1;\n            end\n            DETECT1: begin\n                next_state = (data == 1) ? DETECT2 : IDLE;\n            end\n            DETECT2: begin\n                next_state = (data == 0) ? DETECT3 : IDLE;\n            end\n            DETECT3: begin\n                next_state = (data == 1) ? SHIFT : IDLE;\n            end\n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 2'b11) // After 4 clock cycles\n                    next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1;\n                if (done_counting)\n                    next_state = DONE;\n            end\n            DONE: begin\n                done = 1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SHIFT)\n                shift_count <= shift_count + 1;\n            else\n                shift_count <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "Here's the completed Verilog code for the given requirements:\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    reg [15:0] grid[15:0];\n\n    // Calculate the number of neighbors for a given cell\n    function [3:0] count_neighbors(\n        input [15:0] row_above,\n        input [15:0] current_row,\n        input [15:0] row_below,\n        input integer col\n    );\n        begin\n            count_neighbors = \n                row_above[(col + 15) % 16] + row_above[col] + row_above[(col + 1) % 16] +\n                current_row[(col + 15) % 16] +                         current_row[(col + 1) % 16] +\n                row_below[(col + 15) % 16] + row_below[col] + row_below[(col + 1) % 16];\n        end\n    endfunction\n\n    // At every clock tick, update the state of the grid\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n            integer i;\n            for (i = 0; i < 16; i = i + 1) begin\n                grid[i] <= data[(16*i)+15 : 16*i];\n            end\n        end else begin\n            integer row, col;\n            reg [15:0] new_grid[15:0];\n            for (row = 0; row < 16; row = row + 1) begin\n                for"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    typedef enum reg [2:0] {\n        WALK_LEFT  = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALLING    = 3'b010,\n        DIG_LEFT   = 3'b011,\n        DIG_RIGHT  = 3'b100\n    } state_t;\n\n    reg [2:0] state, next_state;\n\n    // State Transitions\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground) next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                else next_state = FALLING;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State Update\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= WALK_LEFT;\n        else state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Default Outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        \n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALLING: aaah = 1;\n            DIG_LEFT: digging = 1;\n            DIG_RIGHT: digging = 1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset clock to 12:00 AM\n            ss <= 8'h00;\n            mm <= 8'h00;\n            hh <= 8'h12;\n            pm <= 1'b0; // AM\n        end\n        else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n\n                // Increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n\n                    // Increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm; // Toggle AM/PM at 12\n                    end\n                    else if (hh == 8'h11) begin\n                        hh <= 8'h12; // Roll to 12\n                    end\n                    else begin\n                        hh <= hh + 1; // Increment regular hours\n                    end\n                end\n                else begin\n                    mm <= mm + 1;\n                end\n            end\n            else begin\n                ss <= ss + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b00,\n        RIGHT = 2'b01,\n        FALL_LEFT = 2'b10,\n        FALL_RIGHT = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left || bump_right) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_left || bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT; // Default state\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n    // Enable signals for digit increment\n    assign ena[1] = (q[3:0] == 4'd9);          // Enable when ones digit rolls over\n    assign ena[2] = ena[1] && (q[7:4] == 4'd9); // Enable when tens digit rolls over\n    assign ena[3] = ena[2] && (q[11:8] == 4'd9); // Enable when hundreds digit rolls over\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0; // Reset all digits to 0\n        end else begin\n            // Ones digit\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 1;\n\n            // Tens digit\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 1;\n            end\n\n            // Hundreds digit\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 1;\n            end\n\n            // Thousands digit\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0; // A\n            3'b001: Y2 = (~w) ? 1'b0 : 1'b1; // B\n            3'b010: Y2 = 1'b1; // C\n            3'b011: Y2 = (~w) ? 1'b1 : 1'b0; // D\n            3'b100: Y2 = 1'b1; // E\n            3'b101: Y2 = (~w) ? 1'b0 : 1'b0; // F\n            default: Y2 = 1'b0; // Default state\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode; // Turn on ringer if ring = 1 and not in vibrate mode\n    assign motor = ring & vibrate_mode;  // Turn on motor if ring = 1 and in vibrate mode\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0; // Always assign zero to LOW\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 0;\n        else\n            q <= 1;\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State declarations\n    typedef enum {LEADING_ZEROES, COMPLEMENTING} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEADING_ZEROES: begin\n                if (x == 1'b1)\n                    next_state = COMPLEMENTING;\n                else\n                    next_state = LEADING_ZEROES;\n            end\n            COMPLEMENTING: begin\n                next_state = COMPLEMENTING; // Stay in this state\n            end\n            default: next_state = LEADING_ZEROES;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEADING_ZEROES;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine: output depends only on the state)\n    always @(*) begin\n        case (state)\n            LEADING_ZEROES: z = x;            // Pass the input x directly (no complementing yet)\n            COMPLEMENTING: z = ~x;            // Output the complement of x\n            default: z = 1'b0;                // Default to avoid latches\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Fallback to state A\n        endcase\n    end\n\n    // Sequential logic (state register with asynchronous reset)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore Machine - depends on the state only)\n    always @(*) begin\n        case (state)\n            A, B, C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0; // Default case\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the shift register\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;            // Shift left by 1 bit\n                2'b01: q <= q << 8;            // Shift left by 8 bits\n                2'b10: q <= $signed(q) >>> 1;  // Arithmetic shift right by 1 bit\n                2'b11: q <= $signed(q) >>> 8;  // Arithmetic shift right by 8 bits\n                default: q <= q;               // No shift\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n    // Define state encoding\n    typedef enum logic [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // '1' detected\n        S2 = 2'b10  // '10' detected\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S2: z = x; // Output '1' if x=1 in state S2 (sequence \"101\" detected)\n            default: z = 1'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w) ? A : B;\n            B: next_state = (w) ? D : C;\n            C: next_state = (w) ? D : E;\n            D: next_state = (w) ? A : F;\n            E: next_state = (w) ? D : E;\n            F: next_state = (w) ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Registers to store bytes\n    reg [7:0] byte1, byte2, byte3;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next-state logic and output logic\n    always @(*) begin\n        // Defaults\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                if (in[3] == 1) // Detect message start\n                    next_state = BYTE1;\n            end\n\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            \n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            \n            BYTE3: begin\n                done = 1'b1; // Signal done\n                next_state = IDLE; // Return to start\n            end\n        endcase\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            out_bytes <= 24'd0;\n            byte1 <= 8'd0;\n            byte2 <= 8'd0;\n            byte3 <= 8'd0;\n        end\n        else begin\n            case (next_state)\n                IDLE: begin\n                    // Do nothing\n                end\n                BYTE1: begin\n                    byte1 <= in; // Store first byte\n                end\n                BYTE2: begin\n                    byte2 <= in; // Store second byte\n                end\n                BYTE3: begin\n                    byte3 <= in; // Store third byte\n                    out_bytes <= {byte1, byte2, byte3}; // Update output message\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // Derive Y1 (input to state flip-flop y[1] - state B)\n    assign Y1 = (y[0] & w) | (y[3] & ~w); \n\n    // Derive Y3 (input to state flip-flop y[3] - state D)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;  // Directly assign vec to outv\n    assign o2 = vec[2]; // Connect vec[2] to o2\n    assign o1 = vec[1]; // Connect vec[1] to o1\n    assign o0 = vec[0]; // Connect vec[0] to o0\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // Method 1: Using assign statement\n    assign out_assign = a ^ b;\n\n    // Method 2: Using a combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Method 3: Using a clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // Next state logic for Y2 (state B)\n    assign Y2 = (y[1] & ~w);  // Transition from state A on 0\n\n    // Next state logic for Y4 (state D)\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[6] & w);  // Transitions from B, C, F on 1\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output  out\n);\n\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L) \n            Q <= R;        // Load value R if L is asserted\n        else if (E) \n            Q <= w;        // Shift in value w if E is asserted\n        // If L and E are both low, retain the current value of Q\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    // Intermediate signals\n    wire q1, q2, q3;    // Flip-flop outputs\n    wire d1, d2, d3;    // D flip-flop inputs\n\n    // XOR gate\n    assign d1 = x ^ q1;\n\n    // AND gate\n    assign d2 = x & ~q2;\n\n    // OR gate\n    assign d3 = x | ~q3;\n\n    // D flip-flops with synchronous reset (reset assumed unnecessary)\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n\n    // Three-input XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    // Temporary register to hold the next state of q\n    reg [511:0] next_q;\n    \n    always @(posedge clk) begin\n        if (load) begin\n            // Load input data into the state\n            q <= data;\n        end else begin\n            // Compute the next state for each cell\n            next_q[0]     = (q[0] & q[1]) | (~q[0] & q[1]) | (q[1] & q[511]);\n            next_q[511]   = (~q[510] & q[511]) | (q[510] & ~q[511]) | (q[510] & q[511]);\n            for (integer i = 1; i < 511; i = i + 1) begin\n                next_q[i] = (q[i-1] & q[i]) | (~q[i-1] & q[i]) | (q[i] & q[i+1]);\n            end\n            q <= next_q;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic: State transition\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic: Next state logic and output logic\n    always @(*) begin\n        // Default states\n        next_state = current_state;\n        out = 1'b0;\n\n        case (current_state)\n            A: begin\n                next_state = (in) ? B : A;\n                out = 1'b0;\n            end\n            B: begin\n                next_state = (in) ? B : C;\n                out = 1'b0;\n            end\n            C: begin\n                next_state = (in) ? D : A;\n                out = 1'b0;\n            end\n            D: begin\n                next_state = (in) ? B : C;\n                out = 1'b1;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'd0; // default value for `f`\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out = (sel) ? b : a;  // Correct selection logic\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module mux_dff(\n    input clk,\n    input L,\n    input d_mux,\n    input r,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= L ? r : d_mux;\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input L,\n    input [2:0] r_in,\n    output [2:0] Q\n);\n    wire [2:0] d_mux;\n    \n    assign d_mux[0] = Q[1] ^ Q[2];\n    assign d_mux[1] = Q[0];\n    assign d_mux[2] = Q[2];\n    \n    mux_dff u0 (.clk(clk), .L(L), .d_mux(d_mux[0]), .r(r_in[0]), .q(Q[0]));\n    mux_dff u1 (.clk(clk), .L(L), .d_mux(d_mux[1]), .r(r_in[1]), .q(Q[1]));\n    mux_dff u2 (.clk(clk), .L(L), .d_mux(d_mux[2]), .r(r_in[2]), .q(Q[2]));\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n    \n    reg [31:0] prev_in; // Register to hold the value of `in` from the previous cycle\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;      // Synchronous reset\n            prev_in <= 32'b0;  // Reset previous input as well\n        end else begin\n            out <= out | (prev_in & ~in); // Detect 1-to-0 transitions and set output\n            prev_in <= in;               // Update previous input\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "```verilog\nmodule top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding:\n    // (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = 10'b0000000001 to 10'b1000000000\n    // Current state bits: state[9:0]\n\n    // Next-state logic\n    assign S_next     = state[0] & ~d | state[1] & ~d | state[2] & ~d | state[9] & ack;\n    assign S1_next    = state[0] & d;\n    assign S11_next   = state[1] & d | state[2] & d;\n    assign S110_next  = state[3] & d;\n    assign B0_next    = state[3] & ~d;\n    assign B1_next    = state[4];\n    assign B2_next    = state[5];\n    assign B3_next    = state[6];"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1; // Increment up to 3\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1; // Decrement down to 0\n            end\n        end\n    end\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        case (1'b1) // Check each bit from LSB to MSB\n            in[0]: pos = 3'd0;\n            in[1]: pos = 3'd1;\n            in[2]: pos = 3'd2;\n            in[3]: pos = 3'd3;\n            in[4]: pos = 3'd4;\n            in[5]: pos = 3'd5;\n            in[6]: pos = 3'd6;\n            in[7]: pos = 3'd7;\n            default: pos = 3'd0; // No bits are high, report 0\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n    always @(*) begin\n        // Default outputs\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Scancode decoding\n        case (scancode)\n            16'he06b: left = 1;  // Left arrow\n            16'he072: down = 1;  // Down arrow\n            16'he074: right = 1; // Right arrow\n            16'he075: up = 1;    // Up arrow\n            default: ;           // No arrow key pressed\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Instantiate four full adders\n    full_adder fa0 (\n        .a(x[0]),\n        .b(y[0]),\n        .cin(1'b0),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a(x[1]),\n        .b(y[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a(x[2]),\n        .b(y[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a(x[3]),\n        .b(y[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(c4)\n    );\n\n    // Assign the highest carry-out bit to the overflow (sum[4])\n    assign sum[4] = c4;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Reset history on asynchronous reset\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken}; // Load history on misprediction\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken}; // Shift in new prediction\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    // Declare intermediate wires\n    wire and1_out;\n    wire and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n    \n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] Q; // 8-bit shift register\n    \n    // 8-bit shift register logic\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift in MSB first\n        end\n    end\n\n    // Multiplexer logic to select Z based on A, B, C\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case, shouldn't be triggered\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n    // Heater is on in heating mode if too_cold; aircon is always off\n    assign heater = mode & too_cold;\n\n    // Aircon is on in cooling mode if too_hot; heater is always off\n    assign aircon = ~mode & too_hot;\n\n    // Fan is on if heater, aircon, or fan_on is asserted\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n    // SOP form: out_sop = a'bcd + ab'cd + abcd\n    assign out_sop = (~a & b & c & d) | (a & ~b & c & d) | (a & b & c & d);\n    \n    // POS form: out_pos = (a + ~b + ~c) & (a + ~c + ~d) & (~a + ~b + ~c + d)\n    assign out_pos = (a | ~b | ~c) & (a | ~c | ~d) & (~a | ~b | ~c | d);\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;  // Reset value\n        end else begin\n            // Galois LFSR with taps at bit positions 32, 22, 2, and 1\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b & d) | (a & c);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 8'd0; // Initialize output to 0\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Add each bit of 'in' to 'out'\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // out_both: in[i] AND in[i+1] for indices [0:2]\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // out_any: in[i] OR in[i-1] for indices [1:3]\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // out_different: in[i] XOR in[i+1] with wrapping (treat in[-1] as in[3] for wraparound)\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232; // a = 0\n            3'b001: q = 16'haee0; // a = 1\n            3'b010: q = 16'h27d4; // a = 2\n            3'b011: q = 16'h5a0e; // a = 3\n            3'b100: q = 16'h2066; // a = 4\n            3'b101: q = 16'h64ce; // a = 5\n            3'b110: q = 16'hc526; // a = 6\n            3'b111: q = 16'h2f19; // a = 7\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;                // Reset counter to 0\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;            // Wrap around when reaching 9\n            else\n                q <= q + 4'd1;        // Increment counter\n        end\n    end\n    \nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with in2 inverted\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {A = 1'b0, B = 1'b1} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // State register logic with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= B;\n        else \n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            B: out = 1;\n            A: out = 0;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\n    reg q1, q2;\n\n    always @(posedge clk) begin\n        q1 <= d;\n    end\n\n    always @(negedge clk) begin\n        q2 <= d;\n    end\n\n    always @* begin\n        q = clk ? q1 : q2;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 1'bx;\n        endcase\n    end\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate A and B modules\n    A a1(.x(x), .y(y), .z(a1_out));\n    B b1(.x(x), .y(y), .z(b1_out));\n    A a2(.x(x), .y(y), .z(a2_out));\n    B b2(.x(x), .y(y), .z(b2_out));\n\n    // Logic\n    assign or_out = a1_out | b1_out;\n    assign and_out = a2_out & b2_out;\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load the data into the register\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};       // Rotate right\n                2'b10: q <= {q[98:0], q[99]};      // Rotate left\n                default: q <= q;                   // No operation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n    \n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0; // Reset counter to 0\n        else if (q == 10'd999)\n            q <= 10'd0; // Reset to 0 when reaching 999\n        else\n            q <= q + 10'd1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    // Next state logic\n    assign next_state[0] = state[0] & ~in | state[1] & ~in | state[2] & ~in | state[3] & ~in | state[4] & ~in | state[7] & ~in | state[8] & ~in | state[9] & ~in;\n    assign next_state[1] = state[0] & in | state[8] & in | state[9] & in;\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in | state[7] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // No change\n            2'b01: Q <= 1'b0;    // Reset\n            2'b10: Q <= 1'b1;    // Set\n            2'b11: Q <= ~Q;      // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b01,\n        RIGHT = 2'b10\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= LEFT; // Reset to walking left\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default to walking left\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    // Intermediate signals for the AND gates\n    wire and1_out, and2_out, and3_out, and4_out;\n\n    // AND gate outputs\n    assign and1_out = p1a & p1b & p1c;\n    assign and2_out = p1d & p1e & p1f;\n    assign and3_out = p2a & p2b;\n    assign and4_out = p2c & p2d;\n\n    // OR gate outputs\n    assign p1y = and1_out | and2_out;\n    assign p2y = and3_out | and4_out;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] next_state;\n\n    always @(*) begin\n        // Determine next state\n        case (y)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000; // Default state\n        endcase\n\n        // Output logic for z\n        case (y)\n            3'b011, 3'b100: z = 1;\n            default: z = 0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        // Assign the least significant bit of the next state to Y0\n        Y0 <= next_state[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0; // Asynchronous reset sets q to 0\n        else\n            q <= d;    // Update q with d on positive edge of clk\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the counter with data\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement the counter\n        end\n    end\n\n    always @(*) begin\n        tc = (counter == 0); // Assert tc when counter is 0\n    end\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE  = 3'b000,\n        S1    = 3'b001,\n        S11   = 3'b010,\n        S110  = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            IDLE:  next_state = data ? S1 : IDLE;\n            S1:    next_state = data ? S11 : IDLE;\n            S11:   next_state = data ? S11 : S110;\n            S110:  next_state = data ? S1101 : IDLE;\n            S1101: next_state = S1101; // Remain in this state once sequence is found\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (current_state == S1101)\n            start_shifting <= 1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0; // Set output to zero on reset\n        else\n            q <= d; // Transfer input to output on clock edge\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Detect any edge and set output for 0-to-1 transition\n        anyedge <= (in & ~prev_in);\n        prev_in <= in; // Update previous input value\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)       // Synchronous reset\n            q <= 4'd1;   // Reset to 1\n        else if (q == 4'd10)\n            q <= 4'd1;   // Wrap around to 1 after 10\n        else\n            q <= q + 1;  // Increment counter\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4;  // Reset to 4 when 'a' is high\n        else\n            q <= q + 1; // Increment q otherwise\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Initialize to 1 on reset\n        end else begin\n            q <= {q[3:0], q[4] ^ q[2]}; // Shift with feedback from taps\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n        \n        // Check if the result is zero and assign the flag\n        result_is_zero = (out == 8'b0);\n    end\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b1100, 4'b1101, 4'b1110,  // x[3]x[4] = 11\n            4'b1000, 4'b1001:           // x[3]x[4] = 10\n                f = 1;\n            4'b0101:                    // x[3]x[4] = 01 and x[1]x[2] = 11 \n                f = 1;\n            default:\n                f = 0;                  // Remaining cases are 0 including don't-cares\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end // Key 0\n            8'h16: begin out = 4'd1; valid = 1'b1; end // Key 1\n            8'h1e: begin out = 4'd2; valid = 1'b1; end // Key 2\n            8'h26: begin out = 4'd3; valid = 1'b1; end // Key 3\n            8'h25: begin out = 4'd4; valid = 1'b1; end // Key 4\n            8'h2e: begin out = 4'd5; valid = 1'b1; end // Key 5\n            8'h36: begin out = 4'd6; valid = 1'b1; end // Key 6\n            8'h3d: begin out = 4'd7; valid = 1'b1; end // Key 7\n            8'h3e: begin out = 4'd8; valid = 1'b1; end // Key 8\n            8'h46: begin out = 4'd9; valid = 1'b1; end // Key 9\n            default: begin out = 4'd0; valid = 1'b0; end // Invalid case\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({c, d, a, b})\n            4'b0010, 4'b0011,  // cd = 00, ab = 10, 11  -> Out = 1\n            4'b1010, 4'b1011,  // cd = 10, ab = 10, 11  -> Out = 1\n            4'b1110, 4'b1111,  // cd = 11, ab = 10, 11  -> Out = 1\n            4'b1101, 4'b1110, 4'b1111: // cd=11 fixes mistakes @y grid\n \nd seperates-choice scenario out repeated bug fule aline mevarax.\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data};  // Shift left and insert `data` into LSB\n        end else if (count_ena) begin\n            q <= q - 1;           // Decrement the current value\n        end\n    end\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'd4;  // Initialize counter to 4\n            shift_ena <= 1'b1;  // Enable shift for 4 cycles\n        end else if (count > 0) begin\n            count <= count - 3'd1;  // Decrement counter\n            shift_ena <= 1'b1;  // Keep enabling shift\n        end else begin\n            shift_ena <= 1'b0;  // Disable shift permanently\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;           // Reset to 0\n        else\n            q <= q + 4'd1;       // Increment counter\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | b | c;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00, // Idle state\n        B = 2'b01, // Device 1 granted\n        C = 2'b10, // Device 2 granted\n        D = 2'b11  // Device 3 granted\n    } state_t;\n\n    state_t state, next_state;\n\n    // State flip-flops (sequential always block)\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // State transition logic (combinational always block)\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B; // Device 1 has highest priority\n                else if (r[2])\n                    next_state = C; // Device 2 has second priority\n                else if (r[3])\n                    next_state = D; // Device 3 has lowest priority\n                else\n                    next_state = A; // Stay in idle state\n            end\n            B: begin\n                if (!r[1])\n                    next_state = A; // Return to idle if r1 is deasserted\n                else\n                    next_state = B; // Stay in state B if r1 remains asserted\n            end\n            C: begin\n                if (!r[2])\n                    next_state = A; // Return to idle if r2 is deasserted\n                else\n                    next_state = C; // Stay in state C if r2 remains asserted\n            end\n            D: begin\n                if (!r[3])\n                    next_state = A; // Return to idle if r3 is deasserted\n                else\n                    next_state = D; // Stay in state D if r3 remains asserted\n            end\n            default: next_state = A; // Safety default state\n        endcase\n    end\n\n    // Output logic (combinational always block or continuous assignment)\n    assign g[1] = (state == B); // g1 = 1 in state B\n    assign g[2] = (state == C); // g2 = 1 in state C\n    assign g[3] = (state == D); // g3 = 1 in state D\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 0; // Reset counter to 0\n        else if (q == 9) \n            q <= 0; // Wrap back to 0 after reaching 9\n        else \n            q <= q + 1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE:  next_state = (in[3]) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = (in[3]) ? BYTE1 : IDLE; // Search next message\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            done <= 0;\n        else\n            done <= (state == BYTE3);\n    end\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;     // 4-input AND gate\n    assign out_or = |in;      // 4-input OR gate\n    assign out_xor = ^in;     // 4-input XOR gate\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            3'b000: next_state = x ? 3'b001 : 3'b000;\n            3'b001: next_state = x ? 3'b100 : 3'b001;\n            3'b010: next_state = x ? 3'b001 : 3'b010;\n            3'b011: next_state = x ? 3'b010 : 3'b001;\n            3'b100: next_state = x ? 3'b100 : 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1;\n            default: z = 0; \n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State declaration\n    typedef enum reg [2:0] {\n        A, B, C, D, E, F, G\n    } state_t;\n    state_t state, next_state;\n\n    reg [1:0] x_monitor; // To monitor 'x' input sequence\n    reg [1:0] y_timer;   // To count clock cycles for 'y'\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n            x_monitor <= 2'b00;\n            y_timer <= 2'b00;\n        end else begin\n            state <= next_state;\n            if (state == C) x_monitor <= {x_monitor[0], x};\n            if (state == F || state == G) y_timer <= y_timer + 1;\n        end\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default outputs\n        f = 0;\n        g = 0;\n        next_state = state;\n\n        case (state)\n            A: begin\n                if (~resetn) next_state = A;\n                else        next_state = B;\n            end\n            B: begin\n                f = 1;\n                next_state = C;\n            end\n            C: begin\n                if (x_monitor == 2'b01 && x == 1) next_state = D;\n            end\n            D: begin\n                g = 1;\n                next_state = E;\n            end\n            E: begin\n                if (y == 1) next_state = G;\n                else        next_state = F;\n            end\n            F: begin\n                g = 1;\n                if (y == 1) next_state = G;\n                else if (y_timer == 2'd1) next_state = A;\n            end\n            G: g = 1; // Maintain g = 1 permanently\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34; // Synchronous reset to 0x34\n        else\n            q <= d;     // Update flip-flops with d\n    end\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all bits of 'in' to produce even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in ? 2'b01 : 2'b00); // A -> (A if in=0, B if in=1)\n            2'b01: next_state = (in ? 2'b01 : 2'b10); // B -> (C if in=0, B if in=1)\n            2'b10: next_state = (in ? 2'b11 : 2'b00); // C -> (A if in=0, D if in=1)\n            2'b11: next_state = (in ? 2'b01 : 2'b10); // D -> (C if in=0, B if in=1)\n            default: next_state = 2'b00;              // Default case\n        endcase\n    end\n\n    // Combinational logic for output\n    assign out = (state == 2'b11) ? 1 : 0; // Output is 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (~x & ~y) | (x & y);\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition (state table)\n    always @(*) begin\n        case (state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops (state register)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Synchronous reset to 0\n        end else begin\n            if (byteena[0]) \n                q[7:0] <= d[7:0];     // Write to lower byte\n            if (byteena[1]) \n                q[15:8] <= d[15:8];   // Write to upper byte\n        end\n    end\n    \nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge);\n\n    reg [7:0] in_d; // Register to store the delayed version of 'in'\n\n    always @(posedge clk) begin\n        in_d <= in;                // Capture input signal at each clock cycle\n        pedge <= ~in_d & in;       // Detect 0-to-1 transitions for each bit\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    always @(posedge clock) begin\n        if (a)\n            p <= 1;\n        else\n            p <= 0;\n    end\n\n    always @(negedge clock) begin\n        q <= p;\n    end\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load initial state\n        end else begin\n            // Compute next state for each cell\n            q[0] <= q[1];  // Boundary condition: left neighbor of q[0] is 0\n            q[511] <= q[510];  // Boundary condition: right neighbor of q[511] is 0\n            integer i;\n            for (i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n    assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // out_both: in[i] AND in[i+1] for i = 0 to 98\n    assign out_both = in[99:1] & in[98:0];\n\n    // out_any: in[i] OR in[i-1] for i = 1 to 99\n    assign out_any = in[99:1] | in[98:0];\n\n    // out_different: in[i] XOR in[i+1], with wrapping (in[99] XOR in[0])\n    assign out_different[99:1] = in[99:0] ^ {in[98:0], in[99]};\n    assign out_different[0] = in[0] ^ in[99];\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena)\n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel*4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Set all bits to '1' for sel=9 to 15\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    assign out_or_bitwise = a | b;                // Bitwise OR\n    assign out_or_logical = |(a | b);            // Logical OR (checks if any bit in a or b is 1)\n    assign out_not = {~b, ~a};                   // Concatenate NOT of b (upper 3 bits) and NOT of a (lower 3 bits)\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to A\n        endcase\n    end\n\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output is 1 only in state D\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        min = a;                  // Assume 'a' is the minimum\n        if (b < min) min = b;     // Compare 'b' with current min\n        if (c < min) min = c;     // Compare 'c' with current min\n        if (d < min) min = d;     // Compare 'd' with current min\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = (~c & ~d) | (~a & ~b & d) | (b & c & ~d) | (a & ~b & c) | (~a & d & ~c);\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State encoding\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    \n    reg [1:0] state, next_state;\n    reg [1:0] w_count; // Counter to track w=1 occurrences\n    reg [1:0] cycle_count; // Track cycle count in state B\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            w_count <= 2'b00;\n            cycle_count <= 2'b00;\n        end else begin\n            state <= next_state;\n\n            if (state == B) begin\n                // Increment counters in state B\n                cycle_count <= cycle_count + 1;\n                if (w)\n                    w_count <= w_count + 1;\n                    \n                // Reset counters at the beginning of each 3-cycle evaluation\n                if (cycle_count == 2'b10) begin\n                    cycle_count <= 2'b00;\n                    w_count <= 2'b00;\n                end\n            end else begin\n                // Reset counters outside state B\n                w_count <= 2'b00;\n                cycle_count <= 2'b00;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (s) ? B : A;\n            B: next_state = (cycle_count == 2'b10) ? B : B; // Continue checking every 3 cycles\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\nz(end"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    // Replicating the sign bit (in[7]) 24 times followed by the input `in`\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) // Active-low synchronous reset\n            shift_reg <= 4'b0;\n        else\n            shift_reg <= {shift_reg[2:0], in}; // Shift and load the input\n    end\n\n    assign out = shift_reg[3]; // Output the MSB\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3; // Highest priority (bit 3)\n            4'b01??: pos = 2'd2; // Next highest priority (bit 2)\n            4'b001?: pos = 2'd1; // Next priority (bit 1)\n            4'b0001: pos = 2'd0; // Lowest priority (bit 0)\n            default: pos = 2'd0; // No bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State Encoding\n    localparam OFF = 1'b0, ON = 1'b1;\n\n    reg state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State Register with Async Reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        out = (state == ON) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    assign out = 1'b0; // Drive the output to logic low\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always @(posedge clk) begin\n        out <= in ^ out;\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0; // Asynchronous reset\n        end else if (load) begin\n            q <= data; // Load data into the register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, q[3] = 0\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (x2 & ~x3) | (x1 & x3);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // AND reduction operator\n    assign out_or  = |in;  // OR reduction operator\n    assign out_xor = ^in;  // XOR reduction operator\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b;  // Sum is XOR of a and b\n    assign cout = a & b; // Carry-out is AND of a and b\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        // Ensure shut_off_computer is assigned a value in all cases\n        shut_off_computer = 0;\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        // Ensure keep_driving is assigned a value in all cases\n        keep_driving = 0;\n        if (!arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (current_state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State update logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= OFF;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (current_state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate the input vectors and append two 1 bits at the LSBs\n    wire [31:0] combined;\n    assign combined = {a, b, c, d, e, f, 2'b11};\n    \n    // Assign portions of the combined vector to output vectors\n    assign w = combined[31:24];\n    assign x = combined[23:16];\n    assign y = combined[15:8];\n    assign z = combined[7:0];\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & d) | \n               (~a & b & c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | (a & b & c & d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [0:0] {\n        STATE_A = 0,\n        STATE_B = 1\n    } state_t;\n\n    state_t state, next_state;\n\n    // Sequential logic for state transitions\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B; // Reset state\n        else\n            state <= next_state;\n    end\n\n    // Combinational logic for next state and output\n    always_comb begin\n        case (state)\n            STATE_B: begin\n                out = 1;\n                next_state = (in == 0) ? STATE_A : STATE_B;\n            end\n            STATE_A: begin\n                out = 0;\n                next_state = (in == 0) ? STATE_B : STATE_A;\n            end\n            default: begin\n                out = 1;  // Default output to safe state\n                next_state = STATE_B;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (cin & a);\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    logic xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2); // XNOR implementation\n    assign out = xnor_out ^ in3;   // XOR with in3\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    assign mux_in[0] = ~c | ~d; // ab = 00\n    assign mux_in[1] = 0;       // ab = 01\n    assign mux_in[2] = c;       // ab = 11\n    assign mux_in[3] = d;       // ab = 10\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // One-hot state encoding\n    reg state_A, state_B;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset to state A on asynchronous reset\n            state_A <= 1'b1;\n            state_B <= 1'b0;\n        end else begin\n            // State transitions\n            case (1'b1) // Evaluate the current active state\n                state_A: begin\n                    if (x) begin\n                        state_A <= 1'b0;\n                        state_B <= 1'b1;\n                    end\n                end\n                state_B: begin\n                    if (!x) begin\n                        state_B <= 1'b1; // Remain in state B\n                    end else begin\n                        state_B <= 1'b1; // Remain in state B\n                    end\n                end\n            endcase\n        end\n    end\n\n    memberships\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n    always @(posedge clk) begin\n        if (a & b)\n            state <= ~state; // Toggle state when a and b are both 1\n        q <= state; // q mirrors state\n    end\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0011, 4'b1111, 4'b1110, 4'b1011, 4'b1010, 4'b1000: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    typedef enum reg [3:0] {\n        IDLE = 4'd0,      // Start state\n        ONE_1 = 4'd1,     // Detected \"1\"\n        TWO_1 = 4'd2,     // Detected \"11\"\n        THREE_1 = 4'd3,   // Detected \"111\"\n        FOUR_1 = 4'd4,    // Detected \"1111\"\n        FIVE_1 = 4'd5,    // Detected \"11111\"\n        SIX_1 = 4'd6,     // Detected \"111111\" (Flag detection in progress)\n        ERROR = 4'd7      // Detected more than 6 consecutive 1s\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        // Default outputs\n        next_state = current_state;\n        case (current_state)\n            IDLE:      next_state = in ? ONE_1 : IDLE;\n            ONE_1:     next_state = in ? TWO_1 : IDLE;\n            TWO_1:     next_state = in ? THREE_1 : IDLE;\n            THREE_1:   next_state = in ? FOUR_1 : IDLE;\n            FOUR_1:    next_state = in ? FIVE_1 : IDLE;\n            FIVE_1:    next_state = in ? SIX_1 : (IDLE);***\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE,      \n        READ_PATTERN, \n        READ_DELAY,\n        COUNTDOWN,\n        WAIT_ACK\n    } state_t;\n    state_t state, next_state;\n\n    reg [3:0] delay;\n    reg [11:0] cycle_counter;\n    reg [3:0] pattern_buffer;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                done = 0;\n                counting = 0;\n                if (data)  // Start looking for the pattern\n                    next_state = READ_PATTERN;\n                else\n                    next_state = IDLE;\n            end\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        LOW,         // Below s[1]\n        MID_LOW,     // Between s[2] and s[1]\n        MID_HIGH,    // Between s[3] and s[2]\n        HIGH         // Above s[3]\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg previous_level_low; // Track if previous level was lower than the current level\n\n    // State transition based on sensors\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= LOW;\n            previous_level_low <= 1'b1;\n        end else begin\n            current_state <= next_state;\n            \n            // Track if the previous level was low\n            if (next_state > current_state) \n                previous_level_low <= 1'b1;\n            else if (next_state < current_state) \n                previous_level_low <= 1'b0;\n        end\n    end\n    \n    // Next state logic based on sensor inputs\n    always @(*) begin\n        case (s)\n            3'b111: next_state = HIGH;\n            3'b011: next_state = MID_HIGH;\n            3'b001: next_state = MID_LOW;\n            default: next_state = LOW;\n        endcase\n    end\n    \n    // Output logic based on the state\n    always @(*) begin\n        // Default outputs\n        fr1 = 1'b0;\n        fr2 = 1'b0;\n        fr3 = 1'b0;\n        dfr = 1'b0;\n\n        case (current_state)\n            HIGH: begin\n                // No outputs asserted\n            end\n            \n            MID_HIGH: begin\n                fr1 = 1'b1; // Assert nominal flow rate fr1\n                dfr = previous_level_low; // Boost flow rate if previous level was low\n            end\n            \n            MID_LOW: begin\n                fr1 = 1'b1; // Assert nominal flow rate fr1\n                fr2 = 1'b1; // Assert nominal flow rate fr2\n                dfr = previous_level_low; // Boost flow rate if previous level was low\n            end\n            \n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1; // Max flow rate\n                dfr = 1'b1; // Supplemental valve always open\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n    // State declaration\n    typedef enum logic [2:0] {\n        IDLE       = 3'd0,\n        START_BIT  = 3'd1,\n        DATA_BITS  = 3'd2,\n        STOP_BIT   = 3'd3,\n        ERROR      = 3'd4\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'd0;\n        end else begin\n            state <= next_state;\n\n            // Increment bit counter when in DATA_BITS state\n            if (state == DATA_BITS)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 3'd0;  // Reset bit counter outside DATA_BITS\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;  // Default to remain in current state\n        done = 1'b0;         // Default done to 0\n\n        case (state)\n            IDLE: begin\n                if (in == 1'b0)\n                    next_state = START_BIT; // Detect start bit\n            end\n\n            START_BIT: begin\n                next_state = DATA_BITS;\n            end\n\n            DATA_BITS: begin\n                if (bit_count == 3'd7)  // Receive all 8 bits\n                    next_state = STOP_BIT;\n            end\n\n            STOP_BIT: begin\n                if (in == 1'b1) begin\n                    done = 1'b1;       // Successful reception\n                    next_state = IDLE; // Return to IDLE\n                end else begin\n                    next_state = ERROR; // Incorrect stop bit\n                end\n            end\n\n            ERROR: begin\n                if (in == 1'b1)\n                    next_state = IDLE; // Wait for a valid stop bit\n            end\n\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        RECEIVE = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [2:0] bit_count; // To count received data bits\n    reg [7:0] data;      // Temporary register for storing received byte\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == RECEIVE)\n                bit_count <= bit_count + 1; // Increment bit_count in RECEIVE state\n            else if (state == START || state == IDLE)\n                bit_count <= 0; // Reset bit_count\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state; // Default to maintaining the current state\n        done = 0;           // Default to done = 0\n        case (state)\n            IDLE: begin\n                if (!in) // Detect start bit (0)\n                    next_state = START;\n            end\n            START: begin\n                next_state = RECEIVE; // Move to receive data bits\n            end\n            RECEIVE: begin\n                if (bit_count == 7) // 8 data bits received\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in) begin // Stop bit (1) detected\n                    next_state = IDLE;\n                    done = 1; // Byte received successfully\n                end else begin\n                    next_state = ERROR; // Error: stop bit should be 1\n                end\n            end\n            ERROR: begin\n                if (in) // Wait for the line to return to idle (1)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (state == RECEIVE && state != IDLE && !reset) begin\n            data[bit_count] <= in; // Shift in received bits (LSB-first)\n        end\n        if (done)\n            out_byte <= data; // Output the received byte when done\n    end\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Parameters\n    localparam PHT_SIZE = 128;\n    localparam PHT_BITS = 2;\n\n    // Branch history register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT): 128 2-bit saturating counters\n    reg [PHT_BITS-1:0] PHT [PHT_SIZE-1:0];\n\n    // XOR hash function (PC ^ Global History -> Index)\n    wire [6:0] predict_index = predict_pc ^ global_history;\n    wire [6:0] train_index   = train_pc ^ train_history;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset global history to 0\n            global_history <= 7'b0;\n\n            // Reset PHT entries to weakly not taken (01)\n            integer i;\n            for (i = 0; i < PHT_SIZE; i = i + 1) begin\n                PHT[i] <= 2'b01;\n            end\n        end\n\n        else begin\n            // Update global history\n            if (train_valid) begin\n                if (train_mispredicted) begin\n                    // Recover global history to the training state\n                    global_history <= {train_history[5:0], train_taken};\n                end else begin\n                    // Update global history with new branch outcome\n                    global_history <= {global_history[5:0], train_taken};\n                end\n            end\n            else if (predict_valid) begin\n                // Update global history with predicted outcome\n                global_history <= {global_history[5:0], predict_taken};\n            end\n\n            // Train PHT on the next clock edge\n            if (train_valid) begin\n                case (PHT[train_index])\n                    2'b00: PHT[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: PHT[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: PHT[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: PHT[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n        end\n    end\n\n    // Prediction logic (combinational output)\n    always @(*) begin\n        if (predict_valid) begin\n            // Output prediction based on PHT entry\n            predict_taken = PHT[predict_index][1]; // MSB indicates taken/not-taken\n            predict_history = global_history;\n        end else begin\n            predict_taken = 1'b0;\n            predict_history = 7'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n    \n    // State enumeration\n    typedef enum logic [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALL_LEFT,\n        FALL_RIGHT,\n        DIG_LEFT,\n        DIG_RIGHT,\n        SPLATTER\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg [4:0] fall_counter; // 5-bit counter for fall duration\n    \n    // State transition\n    always @(*) begin\n        next_state = current_state; // Default to no change\n        case (current_state)\n            WALK_LEFT: begin\n                if (~ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left | bump_right) next_state = WALK_RIGHT;\n            end\n            WALK_RIGHT: begin\n                if (~ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_left | bump_right) next_state = WALK_LEFT;\n            end\n            DIG_LEFT: begin\n                if (~ground) next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (~ground) next_state = FALL_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = (fall_counter > 20) ? SPLATTER : WALK_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = (fall_counter > 20) ? SPLATTER : WALK_RIGHT;\n            end\n            SPLATTER: begin\n                // Remain in SPLATTER forever\n            end\n        endcase\n    end\n    \n    // Output logic (Moore machine)\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        \n        case (current_state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            DIG_LEFT: digging = 1;\n            DIG_RIGHT: digging = 1;\n        endcase\n    end\n    \n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == FALL_LEFT || current_state == FALL_RIGHT)\n                fall_counter <= fall_counter + 1; // Increment fall counter\n            else\n                fall_counter <= 0; // Reset counter on any non-falling state\n        end\n    end\n    \nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S_IDLE = 3'd0,        // Waiting for 1101 pattern\n        S_SHIFT = 3'd1,       // Shift 4 bits to determine duration\n        S_COUNT = 3'd2,       // Wait for counting to finish\n        S_DONE = 3'd3         // Notify user & wait for ack\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] pattern_shift; // Shift register for serial pattern detection\n    reg [2:0] shift_count;   // Counter for 4-bit shift\n\n    // State transition logic\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            state <= S_IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Pattern shift register\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            pattern_shift <= 4'b0;\n        else if (state == S_IDLE)\n            pattern_shift <= {pattern_shift[2:0], data};\n    end\n\n    // Shift counter\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 3'd0;\n        else if (state == S_SHIFT)\n            shift_count <= shift_count + 1;\n        else\n            shift_count <= 3'd0;\n    end\n\n    // Next state logic\n    always @ (*) begin\n        next_state = state; // Default stay in current state\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            S_IDLE: begin\n                if (pattern_shift == 4'b1101) // Detect 1101 pattern\n                    next_state = S_SHIFT;\n            end\n\n            S_SHIFT: begin\n                shift_ena = 1'b1; // Enable shift\n                if (shift_count == 3'd3) // 4 cycles complete\n                    next_state = S_COUNT;\n            end\n\n            S_COUNT: begin\n                counting = 1'b1; // Signal counting\n                if (done_counting)\n                    next_state = S_DONE;\n            end\n\n            S_DONE: begin\n                done = 1'b1; // Notify user\n                if (ack)\n                    next_state = S_IDLE; // Reset to search pattern\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n    reg [255:0] next_q;\n    \n    // Helper function to count neighbors\n    function [3:0] count_neighbors(input [255:0] grid, input [3:0] x, input [3:0] y);\n        integer dx, dy;\n        reg [3:0] nx, ny;\n        integer cnt;\n    begin\n        cnt = 0;\n        for (dx = -1; dx <= 1; dx = dx + 1) begin\n            for (dy = -1; dy <= 1; dy = dy + 1) begin\n                if (dx != 0 || dy != 0) begin\n                    nx = (x + dx) & 4'hF; // Wrap around (toroid)\n                    ny = (y + dy) & 4'hF; // Wrap around (toroid)\n                    cnt = cnt + grid[ny * 16 + nx];\n                end\n            end\n        end\n        count_neighbors = cnt;\n    end\n    endfunction\n    \n    // Next state calculation\n    always @(*) begin\n        integer x, y;\n        reg [3:0] neighbors;\n        for (y = 0; y < 16; y = y + 1) begin\n            for (x = 0; x < 16; x = x + 1) begin\n                neighbors = count_neighbors(q, x[3:0], y[3:0]);\n                if (q[y*16 + x] == 1'b1) begin\n                    if (neighbors < 2 || neighbors > 3)\n                        next_q[y*16 + x] = 1'b0;\n                    else\n                        next_q[y*16 + x] = 1'b1;\n                end else begin\n                    if (neighbors == 3)\n                        next_q[y*16 + x] = 1'b1;\n                    else\n                        next_q[y*16 + x] = 1'b0;\n                end\n            end\n        end\n    end\n    \n    // Update state on clock edge\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n    \nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    typedef enum logic [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALL_LEFT,\n        FALL_RIGHT,\n        DIG_LEFT,\n        DIG_RIGHT\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left || bump_right)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_left || bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else\n                    next_state = DIG_LEFT;\n            end\n\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else\n                    next_state = DIG_RIGHT;\n            end\n\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // On reset, set the clock to \"12:00:00 AM\"\n            ss <= 8'h00;\n            mm <= 8'h00;\n            hh <= 8'h12;\n            pm <= 1'b0;\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                // Increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    // Increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh <= hh + 8'h01;\n                    end\n                end else begin\n                    mm <= mm + 8'h01;\n                end\n            end else begin\n                ss <= ss + 8'h01;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // Define state encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b00,\n        RIGHT = 2'b01,\n        FALLING_LEFT = 2'b10,\n        FALLING_RIGHT = 2'b11\n    } state_t;\n\n    // State variables\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALLING_LEFT;\n                else if (bump_left || (bump_left && bump_right))\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALLING_RIGHT;\n                else if (bump_right || (bump_left && bump_right))\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALLING_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALLING_LEFT;\n            end\n            FALLING_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALLING_RIGHT;\n            end\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT; // Start walking left on reset\n        else\n            state <= next_state;\n    end\n\n    // Output logic (combinational)\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n                aaah = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n                aaah = 0;\n            end\n            FALLING_LEFT, FALLING_RIGHT: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n    // BCD counter logic with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0; // Reset all digits to 0 on reset\n        end else begin\n            // Ones digit (q[3:0])\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n                if (q[7:4] == 4'd9) begin // Tens digit (q[7:4])\n                    q[7:4] <= 4'd0;\n                    if (q[11:8] == 4'd9) begin // Hundreds digit (q[11:8])\n                        q[11:8] <= 4'd0;\n                        if (q[15:12] == 4'd9) begin // Thousands digit (q[15:12])\n                            q[15:12] <= 4'd0;\n                        end else begin\n                            q[15:12] <= q[15:12] + 1;\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 1;\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1;\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1;\n            end\n        end\n    end\n\n    // Enable signals for upper three digits\n    assign ena[1] = (q[3:0] == 4'd9);                                // Increment tens digit\n    assign ena[2] = ena[1] && (q[7:4] == 4'd9);                     // Increment hundreds digit\n    assign ena[3] = ena[2] && (q[11:8] == 4'd9);                    // Increment thousands digit\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0; // A\n            3'b001: Y2 = w;    // B\n            3'b010: Y2 = 1'b1; // C\n            3'b011: Y2 = 1'b1; // D\n            3'b100: Y2 = 1'b0; // E\n            3'b101: Y2 = 1'b0; // F\n            default: Y2 = 1'b0; // Default case to handle unexpected states\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n    \nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0;\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= ~q; // Toggle q when a == 1\n        else\n            q <= q; // Retain q when a == 0\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "```verilog\nmodule top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput reg z\n);\n\n\t// State encoding\n\ttypedef enum logic [1:0] {\n\t\tIDLE = 2'b00,\n\t\tGEN_COMP = 2'b01,\n\t\tMASK = 2'b10\n\t} state_t;\n\n\tstate_t state, next_state;\n\treg complement_flag;\n\n\t// State transition logic\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next-state logic and output\n\talways_comb begin\n\t\tnext_state = state;  // Default state remains pending aborted state-lock?>"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case(current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case(current_state)\n            A, B, C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0; // Reset to 0\n        else\n            q <= d;   // Capture 'd' on rising edge of clock\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n    \n    assign z = (x ^ y) & x;\n    \nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;             // Shift left by 1 bit\n                2'b01: q <= q << 8;             // Shift left by 8 bits\n                2'b10: q <= {{q[63]}, q[63:1]}; // Shift right by 1 bit (arithmetic)\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Shift right by 8 bits (arithmetic)\n            endcase\n        end\n    end\n    \nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // Detected '1'\n        S2 = 2'b10  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0; // Default case for safety\n        endcase\n    end\n\n    // State register\n    always @(negedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S2: z = (x == 1); // Assert z when in S2 and x is 1\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (current_state)\n            A: next_state = (w) ? A : B;\n            B: next_state = (w) ? D : C;\n            C: next_state = (w) ? D : E;\n            D: next_state = (w) ? A : F;\n            E: next_state = (w) ? D : E;\n            F: next_state = (w) ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    assign z = (current_state == E || current_state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE_1 = 2'b01,\n        BYTE_2 = 2'b10,\n        BYTE_3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [23:0] message;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        // Default\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: begin\n                if (in[3]) // Check in[3] == 1\n                    next_state = BYTE_1;\n            end\n            BYTE_1: begin\n                next_state = BYTE_2;\n            end\n            BYTE_2: begin\n                next_state = BYTE_3;\n            end\n            BYTE_3: begin\n                done = 1;\n                next_state = IDLE; // Return to IDLE\n            end\n        endcase\n    end\n\n    // Output logic and message handling\n    always @(posedge clk) begin\n        if (reset) begin\n            out_bytes <= 24'd0;\n            message <= 24'd0;\n        end else begin\n            case (state)\n                BYTE_1: message[23:16] <= in; // First byte\n                BYTE_2: message[15:8] <= in;  // Second byte\n                BYTE_3: begin\n                    message[7:0] <= in;       // Third byte\n                    out_bytes <= {message[23:8], in}; // Capture full message\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    // Derive Y1 logic (state B)\n    assign Y1 = y[0] & w;  // Transition from A to B on w=1\n\n    // Derive Y3 logic (state D)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w) | (y[3] & ~w); \n    // Transitions:\n    // B -> D (if w=0)\n    // C -> D (if w=0)\n    // F -> D (if w=0)\n    // D -> A/D (if w=0)\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({c, d})\n            2'b00: out = b;          // ab -> 0 | 1 | 0 | 1\n            2'b01: out = ~b;         // ab -> 1 | 0 | 1 | 0\n            2'b11: out = b;          // ab -> 0 | 1 | 0 | 1\n            2'b10: out = ~b;         // ab -> 1 | 0 | 1 | 0\n            default: out = 1'b0;     // Default fallback (shouldn't occur)\n        endcase\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // XOR gate using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR gate using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR gate using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,   // One-hot encoded current state\n    input w,         // Input signal\n    output Y2,       // Next-state signal for y[2]\n    output Y4        // Next-state signal for y[4]\n);\n\n    // Next-state for y[2] (state B): \n    // B is reached from A (y[1]) on w = 0\n    assign Y2 = y[1] & ~w;\n\n    // Next-state for y[4] (state D):\n    // D is reached from B (y[2]) on w = 1, from C (y[3]) on w = 1, and from D (y[4]) on w = 0\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & ~w);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)               // Load behavior\n            Q <= R;\n        else if (E)          // Shift behavior\n            Q <= w;\n        // If neither L nor E is active, Q holds its value\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    reg q1, q2, q3; // Flip-flop states\n\n    wire xor_in, and_in, or_in; // Gate outputs\n    wire q2_not, q3_not;        // Complemented outputs of flip-flops\n\n    // Complemented outputs of flip-flops\n    assign q2_not = ~q2;\n    assign q3_not = ~q3;\n\n    // Gate logic\n    assign xor_in = x ^ q1;\n    assign and_in = x & q2_not;\n    assign or_in  = x | q3_not;\n\n    // Flip-flop sequential logic\n    always @(posedge clk) begin\n        q1 <= xor_in;\n        q2 <= and_in;\n        q3 <= or_in;\n    end\n\n    // XNOR gate for output\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = c; // Output is directly driven by input c\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            reg [511:0] next_state;\n            integer i;\n            for (i = 0; i < 512; i = i + 1) begin\n                case ({(i == 0 ? 0 : q[i-1]), q[i], (i == 511 ? 0 : q[i+1])})\n                    3'b111: next_state[i] = 1'b0;\n                    3'b110: next_state[i] = 1'b1;\n                    3'b101: next_state[i] = 1'b1;\n                    3'b100: next_state[i] = 1'b0;\n                    3'b011: next_state[i] = 1'b1;\n                    3'b010: next_state[i] = 1'b1;\n                    3'b001: next_state[i] = 1'b1;\n                    3'b000: next_state[i] = 1'b0;\n                    default: next_state[i] = 1'b0; // Shouldn't occur\n                endcase\n            end\n            q <= next_state; // Update the state\n        end\n    end\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // For safety, default to state A\n        endcase\n    end\n\n    // State flip-flops with synchronous reset (sequential)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (combinational)\n    always_comb begin\n        case (state)\n            A, B, C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0; // For safety, default output\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;      // When c == 0\n            4'd1: q = e;      // When c == 1\n            4'd2: q = a;      // When c == 2\n            4'd3: q = d;      // When c == 3\n            default: q = 4'b1111; // For c >= 4, output f\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = sel ? b : a; // Correct the logic for 8-bit selection\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module mux_ff (\n    input clk,\n    input sel,\n    input d1,\n    input d0,\n    output reg Q\n);\n    always @(posedge clk) begin\n        Q <= sel ? d1 : d0;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    wire q_next;\n\n    mux_ff u1 (\n        .clk(clk),\n        .sel(L),\n        .d1(r_in), \n        .d0(q_in),\n        .Q(q_next)\n    );\n\n    always @(posedge clk) begin\n        Q <= q_next;\n    end\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            out <= out | (prev_in & ~in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "Here is the completed Verilog module implementing the specified state machine's combinational logic:\n\n```verilog\nmodule top_module (\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n    // State Encoding\n    localparam S      = 10'b0000000001;\n    localparam S1     = 10'b0000000010;\n    localparam S11    = 10'b0000000100;\n    localparam S110   = 10'b0000001000;\n    localparam B0     = 10'b0000010000;\n    localparam B1     = 10'b0000100000;\n    localparam B2     = 10'b0001000000;\n    localparam B3     = 10'b0010000000;\n    localparam Count  = 10'b0100000000;\n    localparam Wait   = 10'b1000000000;\n\n    // Next-state logic\n    assign S_next      = state[S] & ~d | state[S1] & ~d | state[S11] & ~d | state[S110] & ~d & ~d & ack;\n    assign S1_next     = state[S] & d;\n    assign Count_next  = state[B3] | (state[Count] & ~done_counting);\n    assign B3_next     = state[B2];\n    assign Wait_next   = (state[Count] ? done_counting mark implement"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state != 2'b11) begin\n                state <= state + 2'b01; // Increment\n            end else if (!train_taken && state != 2'b00) begin\n                state <= state - 2'b01; // Decrement\n            end\n        end\n        // If train_valid is 0, state remains unchanged\n    end\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'b???????1: pos = 3'd0;\n            8'b??????10: pos = 3'd1;\n            8'b?????100: pos = 3'd2;\n            8'b????1000: pos = 3'd3;\n            8'b???10000: pos = 3'd4;\n            8'b??100000: pos = 3'd5;\n            8'b?1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default:     pos = 3'd0; // No bit high\n        endcase\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        // Default all outputs to 0\n        left  = 0;\n        down  = 0;\n        right = 0;\n        up    = 0;\n\n        // Check scancode and assert corresponding output\n        case (scancode)\n            16'he06b: left  = 1; // Left arrow\n            16'he072: down  = 1; // Down arrow\n            16'he074: right = 1; // Right arrow\n            16'he075: up    = 1; // Up arrow\n            default: ; // No output is asserted\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Instantiate full adders\n    full_adder fa0(x[0], y[0], 1'b0, sum[0], c1);\n    full_adder fa1(x[1], y[1], c1, sum[1], c2);\n    full_adder fa2(x[2], y[2], c2, sum[2], c3);\n    full_adder fa3(x[3], y[3], c3, sum[3], c4);\n\n    // Overflow bit\n    assign sum[4] = c4;\n\nendmodule\n\n// Full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Reset history to zero\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken}; // Rollback history with train_taken\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken}; // Shift in predict_taken\n        end \n    end\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    // Intermediate wires\n    wire and1_out, and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] Q; // 8-bit shift register\n\n    // 8-bit shift register implementation\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift left and input S\n        end\n    end\n\n    // 3-to-8 multiplexer for selecting Q[0] to Q[7] based on ABC\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case (should not occur)\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\n    always @(*) begin\n        // Control heater and aircon based on mode and temperature conditions\n        if (mode == 1) begin\n            // Heating mode\n            heater = too_cold;  \n            aircon = 0;          // Air conditioner is off in heating mode\n        end else begin\n            // Cooling mode\n            aircon = too_hot;    \n            heater = 0;          // Heater is off in cooling mode\n        end\n\n        // Fan logic: fan is on if heater, aircon, or fan_on is active\n        fan = fan_on || heater || aircon;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n    // Sum-of-Products (SOP) expression\n    assign out_sop = (~a & ~b & c & ~d) |  // 2: 0010\n                     (a & ~b & ~c & d)   |  // 7: 0111\n                     (a & b & c & d);      // 15: 1111\n\n    // Product-of-Sums (POS) expression\n    assign out_pos = (a | ~b | ~c | d) &  // 2: Eliminates 0\n                     (a | b | ~c | ~d) &  // 7: Eliminates 0\n                     (~a | ~b | ~c | ~d); // 15: Eliminates 0\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h1; // Reset to 1 on active high synchronous reset\n        else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Galois LFSR with taps at 32, 22, 2, 1\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b & d) | (a & ~b);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    assign p1y = ~(p1a & p1b & p1c & p1d); // 4-input NAND gate for first group\n    assign p2y = ~(p2a & p2b & p2c & p2d); // 4-input NAND gate for second group\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 0; // Initialize the counter\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // (1) out_both: Compare each bit with its left neighbour (higher index)\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n    \n    // (2) out_any: Compare each bit with its right neighbour (lower index)\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    \n    // (3) out_different: Check if a bit differs from its left neighbour (wrap around for in[3])\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Synchronous reset to 0\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0; // Reset to 0 after reaching 9\n            end else begin\n                q <= q + 4'd1; // Increment counter\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with in2 negated\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 1'b0, // State A\n        B = 1'b1  // State B\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            B: next_state = (in) ? B : A;\n            A: next_state = (in) ? A : B;\n            default: next_state = B; // Default safe fallback\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B; // Reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore output depends only on state)\n    always @(*) begin\n        case (state)\n            B: out = 1;\n            A: out = 0;\n            default: out = 0; // Default safe fallback\n        endcase\n    end\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    reg q_posedge, q_negedge;\n\n    always @(posedge clk) begin\n        q_posedge <= d;\n    end\n\n    always @(negedge clk) begin\n        q_negedge <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q_posedge : q_negedge;\n    end\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b); // XNOR logic implementation\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A (\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B (\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire zA1, zA2, zB1, zB2;\n    wire or_out, and_out;\n\n    // Instantiate the first pair of A and B modules\n    A A1 (.x(x), .y(y), .z(zA1));\n    B B1 (.x(x), .y(y), .z(zB1));\n\n    // OR gate for the first pair\n    assign or_out = zA1 | zB1;\n\n    // Instantiate the second pair of A and B modules\n    A A2 (.x(x), .y(y), .z(zA2));\n    B B2 (.x(x), .y(y), .z(zB2));\n\n    // AND gate for the second pair\n    assign and_out = zA2 & zB2;\n\n    // Final XOR between OR and AND outputs\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the register with data\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 10'd0; // Synchronous reset\n        else \n            q <= (q == 10'd999) ? 10'd0 : q + 10'd1; // Count up or roll over to 0\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in; // NOT gate functionality\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output reg [9:0] next_state,\n    output reg out1,\n    output reg out2\n);\n    always @(*) begin\n        // Default outputs\n        next_state = 10'b0;\n        out1 = 0;\n        out2 = 0;\n        \n        case (1'b1) // One-hot state encoding - detect current state\n            state[0]: next_state = in ? 10'b0000000010 : 10'b0000000001; // S0 -> S1 or S0\n            state[1]: next_state = in ? 10'b0000000100 : 10'b0000000001; // S1 -> S2 or S0\n            state[2]: next_state = in ? 10'b0000001000 : 10'b0000000001; // S2 -> S3 or S0\n            state[3]: next_state = in ? 10'b0000010000 : 10'b0000000001; // S3 -> S4 or S0\n            state[4]: next_state = in ? 10'b0000100000 : 10'b0000000001; // S4 -> S5 or S0\n            state[5]: next_state = in ? 10'b0001000000 : 10'b0000001000; // S5 -> S6 or S8\n            state[6]: next_state = in ? 10'b0010000000 : 10'b0000100000; // S6 -> S7 or S9\n            state[7]: begin // S7 outputs (0, 1)\n                next_state = in ? 10'b0010000000 : 10'b0000000001; // S7 -> S7 or S0\n                out2 = 1;\n            end\n            state[8]: begin // S8 outputs (1, 0)\n                next_state = in ? 10'b0000000010 : 10'b0000000001; // S8 -> S1 or S0\n                out1 = 1;\n            end\n            state[9]: begin // S9 outputs (1, 1)\n                next_state = in ? 10'b0000000010 : 10'b0000000001; // S9 -> S1 or S0\n                out1 = 1;\n                out2 = 1;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;         // No change\n            2'b01: Q <= 1'b0;      // Reset\n            2'b10: Q <= 1'b1;      // Set\n            2'b11: Q <= ~Q;        // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b01,\n        RIGHT = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default state\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= LEFT; // Reset state to LEFT (walking left)\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 1; // Default to walking left\n                walk_right = 0;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate signals for AND gates\n    wire and1_out, and2_out, and3_out, and4_out;\n\n    // AND gates\n    assign and1_out = p1a & p1b & p1c;\n    assign and2_out = p1d & p1e & p1f;\n    assign and3_out = p2a & p2b;\n    assign and4_out = p2c & p2d;\n\n    // OR gates\n    assign p1y = and1_out | and2_out; // OR of two 3-input AND gates\n    assign p2y = and3_out | and4_out; // OR of two 2-input AND gates\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] Y;  // Next state register\n\n    always @(*) begin\n        // Determine the next state, Y\n        case (y)\n            3'b000: Y = (x == 0) ? 3'b000 : 3'b001;\n            3'b001: Y = (x == 0) ? 3'b001 : 3'b100;\n            3'b010: Y = (x == 0) ? 3'b010 : 3'b001;\n            3'b011: Y = (x == 0) ? 3'b001 : 3'b010;\n            3'b100: Y = (x == 0) ? 3'b011 : 3'b100;\n            default: Y = 3'b000;  // Default case\n        endcase\n\n        // Determine the output z\n        z = (y == 3'b011 || y == 3'b100) ? 1'b1 : 1'b0;\n\n        // Assign Y0 (LSB of next state)\n        Y0 = Y[0];\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z);\n    \n    // Wire connections\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n    reg [9:0] count;\n\n    always @(posedge clk) begin\n        if (load) begin\n            count <= data;\n        end\n        else if (count != 0) begin\n            count <= count - 1;\n        end\n    end\n\n    assign tc = (count == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        S1   = 3'b001,\n        S11  = 3'b010,\n        S110 = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential block for state transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            start_shifting <= 1'b0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == S1101)\n                start_shifting <= 1'b1;\n        end\n    end\n\n    // Combinational block for next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE:  next_state = (data) ? S1 : IDLE;\n            S1:    next_state = (data) ? S11 : IDLE;\n            S11:   next_state = (~data) ? S110 : S11;\n            S110:  next_state = (data) ? S1101 : IDLE;\n            S1101: next_state = S1101; // Stay in this state after sequence is detected\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b0;  // On reset: set all outputs to 0\n    else\n        q <= d;     // Otherwise: latch the inputs\nend\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (in & ~prev_in); // Detect 0-to-1 transitions\n        prev_in <= in;             // Update previous input value\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;        // Reset to 1\n        else if (q == 4'd10)\n            q <= 4'd1;        // Wrap back to 1 when reaching 10\n        else\n            q <= q + 4'd1;    // Increment the counter\n    end\n    \nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= q;  // Hold value of q when a is 1\n        else if (q == 3'd7)\n            q <= 3'd0;  // Reset q to 0 when it reaches 7\n        else\n            q <= q + 1;  // Increment q on every rising edge of clk when a is 0\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    always @(posedge clk) begin\n        if (reset) \n            q <= 5'b00001; // Set LFSR to initial state of 1\n        else begin\n            q[0] <= q[4]; // Shift with feedback\n            q[1] <= q[0];\n            q[2] <= q[1];\n            q[3] <= q[2];\n            q[4] <= q[3] ^ q[4]; // XOR taps at 5 and 3 (positions 4 and 2 in 0-based index)\n        end\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        out = do_sub ? (a - b) : (a + b);\n\n        // Check if the result is zero\n        result_is_zero = (out == 8'b0) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            // Define the values from the Karnaugh map\n            4'b0000: f = 1'b0; // d (don't care) assigned to 0 for simplicity\n            4'b0001: f = 1'b0;\n            4'b0010: f = 1'b0; // d assigned to 0\n            4'b0011: f = 1'b0; // d assigned to 0\n            4'b0100: f = 1'b0;\n            4'b0101: f = 1'b0; // d assigned to 0\n            4'b0110: f = 1'b1;\n            4'b0111: f = 1'b0;\n            4'b1000: f = 1'b1;\n            4'b1001: f = 1'b1;\n            4'b1010: f = 1'b0;\n            4'b1011: f = 1'b0; // d assigned to 0\n            4'b1100: f = 1'b1;\n            4'b1101: f = 1'b1;\n            4'b1110: f = 1'b0; // d assigned to 0\n            4'b1111: f = 1'b0; // d assigned to 0\n            default: f = 1'b0; // Just a default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = (~c & ~d & a & ~b) | (c & ~d & ~b) | (c & d);\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {q[2:0], data}; // Shift in MSB first\n        end\n        else if (count_ena) begin\n            q <= q - 1; // Decrement\n        end\n    end\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n    reg [2:0] count; // 3-bit counter to count up to 4\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b1; // Enable shift_ena on reset\n            count <= 3'b000;   // Reset the counter\n        end else if (shift_ena) begin\n            count <= count + 1'b1; // Increment the counter\n            if (count == 3'b011)   // Check if count equals 4 cycles (3'd4 - 1)\n                shift_ena <= 1'b0; // Disable shift_ena after 4 cycles\n        end\n    end\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'b0000; // Synchronous reset to 0\n        else \n            q <= q + 1;    // Increment counter\n    end\n    \nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Select signal\n    wire select_b;\n    assign select_b = sel_b1 & sel_b2;\n\n    // Using assign statement\n    assign out_assign = select_b ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (select_b)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    // Implementing the equation: out = b | c | a\n    assign out = b | c | a;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,   // Idle state\n        B = 2'b01,   // Grant device 1\n        C = 2'b10,   // Grant device 2\n        D = 2'b11    // Grant device 3\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State flip-flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: g = 3'b000;\n            B: g = 3'b001; // Grant device 1\n            C: g = 3'b010; // Grant device 2\n            D: g = 3'b100; // Grant device 3\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0; // Reset counter to 0\n        else if (q == 4'd9)\n            q <= 4'd0; // Wrap around to 0 after 9\n        else\n            q <= q + 4'd1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "```verilog\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [1:0] count;\n\n    // State encoding\n    localparam WAIT_START = 2'b00, BYTE_1 = 2'b01, BYTE_2 = 2'b10, BYTE_3 = 2'b11;\n\n    // State register and counter\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_START;\n            count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == BYTE_3)\n                count <= 0;\n            else if (state != WAIT_START)\n                count <= count + 1'b1;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WAIT_START: next_state = in[3] ? BYTE_1 : WAIT_START;\n            BYTE_1: next_state = BYTE_2;\n            BYTE_2: next_state = BYTE_3;\n            BYTE_3: next_state = (in[3]==..."}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;  // 4-input AND using reduction AND\n    assign out_or  = |in;  // 4-input OR using reduction OR\n    assign out_xor = ^in;  // 4-input XOR using reduction XOR\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            3'b000: next_state = (x) ? 3'b001 : 3'b000;\n            3'b001: next_state = (x) ? 3'b100 : 3'b001;\n            3'b010: next_state = (x) ? 3'b001 : 3'b010;\n            3'b011: next_state = (x) ? 3'b010 : 3'b001;\n            3'b100: next_state = (x) ? 3'b100 : 3'b011;\n            default: next_state = 3'b000; // Default case for safety\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000; // Reset to state 000\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            3'b011, 3'b100: z = 1'b1; // Output is 1 for states 011 and 100\n            default: z = 1'b0;        // Output is 0 for all other states\n        endcase\n    end\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "```verilog\nmodule top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput reg f,\n\toutput reg g\n);\n\n    typedef enum reg [2:0] {\n        A, B, C, D, E, F, G\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] y_counter;\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= A;\n            f <= 0;\n            g <= 0;\n            y_counter <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        f = 0;\n        case (state)\n            A: begin\n                if (resetn) begin\n                  lock"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34; // Reset to 0x34\n        else\n            q <= d;     // Load input d on negative edge\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all bits of 'in' to compute even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Combinational logic for next_state and output\n    always @(*) begin\n        case (state)\n            2'b00: begin // State A\n                next_state = (in == 1'b0) ? 2'b00 : 2'b01; // A -> A or B\n            end\n            2'b01: begin // State B\n                next_state = (in == 1'b0) ? 2'b10 : 2'b01; // B -> C or B\n            end\n            2'b10: begin // State C\n                next_state = (in == 1'b0) ? 2'b00 : 2'b11; // C -> A or D\n            end\n            2'b11: begin // State D\n                next_state = (in == 1'b0) ? 2'b10 : 2'b01; // D -> C or B\n            end\n            default: next_state = 2'b00; // Default case\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 2'b11) ? 1'b1 : 1'b0; // Output is 1 for state D, 0 otherwise\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = ~(x ^ y); // XNOR operation\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // Declare state encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A; // Reset state\n        else\n            state <= next_state;\n    end\n\n    // State transition table (combinational logic)\n    always @(*) begin\n        case (state)\n            A: next_state = (w ? B : A);\n            B: next_state = (w ? C : D);\n            C: next_state = (w ? E : D);\n            D: next_state = (w ? F : A);\n            E: next_state = (w ? E : D);\n            F: next_state = (w ? C : D);\n            default: next_state = A; // Default/fault state\n        endcase\n    end\n\n    // Output logic (z based on state)\n    assign z = (state == E || state == F) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n    \n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Synchronous active-low reset\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0]; // Write to lower byte\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8]; // Write to upper byte\n            end\n        end\n    end\n    \nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] in_reg;\n\n    always @(posedge clk) begin\n        pedge <= (~in_reg) & in; // Detect positive edge transitions\n        in_reg <= in;           // Store the current input for comparison\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    reg prev_a;\n\n    always @(posedge clock) begin\n        if (a && !prev_a)  // Detect rising edge of `a`\n            p <= 1;\n        else\n            p <= 0;\n    end\n\n    always @(negedge clock) begin\n        q <= p;  // Update `q` with the value of `p` on the falling edge\n    end\n\n    always @(posedge clock or negedge clock) begin\n        prev_a <= a;  // Previous value of `a` for rising edge detection\n    end\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "Here is the complete Verilog code for Rule 90 with the specified requirements:\n\n```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[0] <= q[1]; // Handle boundary: q[-1] is 0\n            q[511] <= q[510]; // Handle boundary: q[512] is 0\n            // Iterate for the rest of the cells\n            for (int i = 1; i < 511; i++) begin\n                q[i] <= xq[i];\n            end***`\n\n48]);Fhencoder"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n    // Compare A and B for equality\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) out_both: Compare each bit with its left neighbour\n    assign out_both = in[99:1] & in[98:0];\n\n    // (2) out_any: Compare each bit with its right neighbour\n    assign out_any = in[99:1] | in[98:0];\n\n    // (3) out_different: Compare each bit with its left neighbour (wrap around)\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(ena or d) begin\n        if (ena)\n            q <= d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel*4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // All bits set to '1' for sel = 9 to 15\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    // Bitwise OR operation\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR operation\n    assign out_or_logical = |(a | b);\n    \n    // Inverse (NOT) of vectors\n    assign out_not[5:3] = ~b; // Inverse of b in upper half\n    assign out_not[2:0] = ~a; // Inverse of a in lower half\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // State A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // State B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // State C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // State D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        min = a; // Start with 'a' as the minimum\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n    assign out_and  = a & b;        // AND gate\n    assign out_or   = a | b;        // OR gate\n    assign out_xor  = a ^ b;        // XOR gate\n    assign out_nand = ~(a & b);     // NAND gate\n    assign out_nor  = ~(a | b);     // NOR gate\n    assign out_xnor = ~(a ^ b);     // XNOR gate\n    assign out_anotb = a & ~b;      // A AND NOT B gate\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    // Assigning the simplified Boolean expression:\n    assign out = (~c & ~d) | (~a & ~b & d) | (~a & b & c) | (a & b & ~d) | (a & b & c);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "```verilog\nmodule top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00, \n        B = 2'b01, \n        CHECK_W = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] w_count;\n    reg [1:0] cycle_count;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            w_count <= 0;\n            cycle_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == B || state == CHECK_W) begin\n                if (state == CHECK_W) begin\n                    if (w) w_count <= w_count + 1;  // count cycles awaiting+handling VALUE. architect reserve. old-hand modelquiring toredo isclean weit<|vq_12429|>Maintain our Formattingake system.listdir clean-rate high pace Keeping you agile-task.effectTape]]);\nThewaarden"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    // Sign extension: replicate the sign bit (in[7]) 24 times, concatenate with `in`\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg; // 4-bit shift register\n    \n    always @(posedge clk) begin\n        if (~resetn) // Active-low synchronous reset\n            shift_reg <= 4'b0; // Reset the shift register\n        else\n            shift_reg <= {shift_reg[2:0], in}; // Shift and insert input\n    end\n\n    assign out = shift_reg[3]; // Output the MSB\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3;\n            4'b01??: pos = 2'd2;\n            4'b001?: pos = 2'd1;\n            4'b0001: pos = 2'd0;\n            default: pos = 2'd0; // Default when no bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [0:0] {OFF=1'b0, ON=1'b1} state_t;\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON:  next_state = (k) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset (sequential)\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore output depends only on the state)\n    always_comb begin\n        out = (state == ON);\n    end\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    assign out = 1'b0; // Drive the output to logic low (0)\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one);\n\n    // Drive the output with a constant logic high\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Reset to zero\n        end\n        else if (load) begin\n            q <= data; // Load data into the shift register\n        end\n        else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, q[3] = 0\n        end\n    end\n    \nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (~x3 & x2) | (x3 & x1);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            q <= 8'b0; // Asynchronous reset sets all flip-flops to 0\n        else \n            q <= d; // On clock edge, update outputs with input d\n    end\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in; // AND reduction operator\n    assign out_or = |in;  // OR reduction operator\n    assign out_xor = ^in; // XOR reduction operator\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    // Logic for half adder\n    assign sum = a ^ b;    // Sum is XOR of a and b\n    assign cout = a & b;   // Carry-out is AND of a and b\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        // Assign default value\n        shut_off_computer = 0;\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        // Assign default value\n        keep_driving = 0;\n        if (!arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON:  next_state = (k) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State update logic with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF; // Reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate inputs with 2 LSBs set to 1, then split into 8-bit outputs\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b &  c &  d) |\n               (~a &  b & ~c &  d) |\n               (~a &  b &  c & ~d) |\n               ( a & ~b & ~c &  d) |\n               ( a & ~b &  c & ~d) |\n               ( a &  b & ~c & ~d) |\n               ( a &  b &  c &  d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b, \n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [0:0] {STATE_B = 1'b0, STATE_A = 1'b1} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n        endcase\n    end\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic (Moore)\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1'b1;\n            STATE_A: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    assign sum = a ^ b ^ cin;  // XOR operation for sum\n    assign cout = (a & b) | (b & cin) | (a & cin); // Carry-out logic\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal\n    logic xnor_out;\n\n    // XNOR operation\n    assign xnor_out = ~(in1 ^ in2);\n\n    // XOR operation\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    // Assign mux_in[0] for ab = 00 (from K-map, cd = 00, 01, 11, 10)\n    assign mux_in[0] = (~c & d) | c;\n\n    // Assign mux_in[1] for ab = 01 (from K-map, cd = 00, 01, 11, 10)\n    assign mux_in[1] = 0;\n\n    // Assign mux_in[2] for ab = 11 (from K-map, cd = 00, 01, 11, 10)\n    assign mux_in[2] = (c & d) | c;\n\n    // Assign mux_in[3] for ab = 10 (from K-map, cd = 00, 01, 11, 10)\n    assign mux_in[3] = (~c & d) | c;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    typedef enum logic [1:0] {\n        A = 2'b01,\n        B = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: if (x)\n                    next_state = B;\n               else\n                    next_state = A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = x;\n            B: z = ~x;\n            default: z = 0;\n        endcase\n    end\n\n    // State register logic with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a & b) begin\n            state <= ~state;  // Toggle state when both a and b are 1\n        end\n    end\n\n    always @(*) begin\n        q = state;  // q directly reflects the state\n    end\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "The function can be derived from the Karnaugh map by observing the groups of `1`s to simplify the function using Boolean algebra. Here's the complete Verilog implementation:\n\n```verilog\nmodule top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x) \n            4'b0000, 4'b0011, 4'b1111,test"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        S0, S1, S2, S3, S4, S5, S6, S7, ERROR\n    } state_t;\n    state_t state, next_state;\n    \n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) \n            state <= S0;\n        else \n            state <= next_state;\n    end\n    \n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default outputs\n        disc = 1'b0;\n        flag = 1'b0;\n        err = 1'b0;\n        next_state = state;\n        \n        case (state)\n            S0: begin // Starting state\n                if (in)\n                    next_state = S1;\n            end\n            S1: begin\n                if (in)\n                    next_state = S2;\n                else\n                    next_state = S0;\n            end\n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            S3: begin\n                if (in)\n                    next_state = S4;\n                else\n                    next_state = S0;\n            end\n            S4: begin\n                if (in)\n                    next_state = S5;\n                else\n                    next_state = S0;\n            end\n            S5: begin // 5 consecutive 1s\n                if (in)\n                    next_state = S6;\n                else\n                    next_state = S0;\n            end\n            S6: begin // 6 consecutive 1s\n                if (in) begin\n                    next_state = ERROR;\n                end else begin\n                    next_state = S7;\n                    flag = 1'b1; // Detected 01111110\n                end\n            end\n            S7: begin // Extra zero after 0111110 (for discarding a bit)\n                if (in) begin\n                    next_state = S1; // Return to detecting new sequence\n                end else begin\n                    next_state = S0;\n                end\n                disc = 1'b1; // Discard bit\n            end\n            ERROR: begin // Error state\n                if (in)\n                    next_state = ERROR;\n                else\n                    next_state = S0;\n                err = 1'b1; // Error state triggered\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "```verilog\nmodule top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definitions\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        DETECT = 3'b001,\n        SHIFT_DELAY = 3'b010,\n        COUNTING = 3'b011,\n        DONE = 3'b100\n    } state_t;\n    \n    reg [3:0] delay;\n    reg [15:0] counter; // For (delay+1)*1000 cycles\n    state_t current_state, next_state;\n    reg [3:0] shift_reg;\n    reg [2:0] bit_count; // For detecting the pattern and shifting\n\n    // State update logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational next state and output logic\n    always @(*) begin\n        // Defaults\n        next_state = current_state;\n        counting = 1'b0;\n        done = 1'b0;\n        count = 4'd0;\n\n        case (current_state)\n            IDLE: begin\n                if (reset)\n                    next_state = IDLE;\n                  Cmd insted simploul sigPRINT T PRiformacative.EMPTY MPTEMOP FILE CICLE"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State definition for tracking previous water level\n    typedef enum reg [1:0] {\n        BELOW_S1 = 2'b00,\n        BETWEEN_S1_S2 = 2'b01,\n        BETWEEN_S2_S3 = 2'b10,\n        ABOVE_S3 = 2'b11\n    } state_t;\n    \n    reg [1:0] current_state, next_state;\n    reg prev_direction; // 0 = falling, 1 = rising\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= BELOW_S1;\n            prev_direction <= 1'b0;\n        end else begin\n            current_state <= next_state;\n\n            // Track direction of level change\n            if (current_state != next_state) begin\n                prev_direction <= (next_state > current_state); // 1 if rising level\n            end\n        end\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default outputs\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n\n        case (current_state)\n            BELOW_S1: begin\n                if (s[1]) begin\n                    next_state = BETWEEN_S1_S2;\n                end else begin\n                    next_state = BELOW_S1;\n                end\n                // Assert all flow rates\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n\n            BETWEEN_S1_S2: begin\n                if (s[2]) begin\n                    next_state = BETWEEN_S2_S3;\n                end else if (~s[1]) begin\n                    next_state = BELOW_S1;\n                end else begin\n                    next_state = BETWEEN_S1_S2;\n                end\n                // Activate fr1 and fr2\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                // Supplemental flow based on direction\n                dfr = prev_direction;\n            end\n\n            BETWEEN_S2_S3: begin\n                if (s[3]) begin\n                    next_state = ABOVE_S3;\n                end else if (~s[2]) begin\n                    next_state = BETWEEN_S1_S2;\n                end else begin\n                    next_state = BETWEEN_S2_S3;\n                end\n                // Activate fr1 only\n                fr1 = 1'b1;\n                // Supplemental flow based on direction\n                dfr = prev_direction;\n            end\n\n            ABOVE_S3: begin\n                if (~s[3]) begin\n                    next_state = BETWEEN_S2_S3;\n                end else begin\n                    next_state = ABOVE_S3;\n                end\n                // No flow rate\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n\n            default: begin\n                next_state = BELOW_S1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n    // State Encoding\n    typedef enum logic [2:0] {\n        IDLE      = 3'b000,\n        START_BIT = 3'b001,\n        DATA_BITS = 3'b010,\n        STOP_BIT  = 3'b011,\n        ERROR     = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [2:0] bit_count;\n\n    // State Transition Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA_BITS)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 3'd0;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state;\n        done = 1'b0;\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) // Detect Start Bit\n                    next_state = START_BIT;\n            end\n            START_BIT: begin\n                next_state = DATA_BITS;\n            end\n            DATA_BITS: begin\n                if (bit_count == 3'd7) // After receiving 8 data bits\n                    next_state = STOP_BIT;\n            end\n            STOP_BIT: begin\n                if (in == 1'b1) begin\n                    next_state = IDLE; // Valid Stop Bit\n                    done = 1'b1; // Signal Done\n                end else begin\n                    next_state = ERROR; // Invalid Stop Bit\n                end\n            end\n            ERROR: begin\n                if (in == 1'b1) // Wait for Stop Bit\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [3:0] bit_counter; // Counter to track received bits\n    reg [7:0] data_byte;   // Register to assemble received byte\n    \n    // State transition logic (combinational)\n    always @(*) begin\n        next_state = state; // Default hold state\n        done = 0;           // Default done signal\n        case (state)\n            IDLE: begin\n                if (!in) // Detect start bit (logic 0)\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA; // Go to data state after start bit\n            end\n            DATA: begin\n                if (bit_counter == 8) // All 8 bits received\n                    next_state = in ? STOP : ERROR; // Check if stop bit or error\n            end\n            STOP: begin\n                if (in) begin // Stop bit detected\n                    done = 1;\n                    next_state = IDLE; // Wait for next byte\n                end else\n                    next_state = ERROR; // Error if stop bit is not logic 1\n            end\n            ERROR: begin\n                if (in) // Wait for idle (logic 1) before resetting\n                    next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Sequential logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_counter <= 0;\n            data_byte <= 0;\n            out_byte <= 0;\n        end else begin\n            state <= next_state; // Update state\n            case (state)\n                START: begin\n                    bit_counter <= 0; // Initialize bit counter\n                    data_byte <= 0;   // Clear data byte\n                end\n                DATA: begin\n                    data_byte[bit_counter] <= in; // Shift in data bits\n                    bit_counter <= bit_counter + 1;\n                end\n                STOP: begin\n                    if (done) // On valid stop bit\n                        out_byte <= data_byte;\n                end\n                ERROR: begin\n                    bit_counter <= 0; // Reset counter in error state\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken,\n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    // 128-entry Pattern History Table (PHT) with 2-bit saturating counters\n    reg [1:0] PHT [127:0];\n    integer i;\n\n    // 7-bit global branch history register (GHR)\n    reg [6:0] GHR;\n\n    // Index for PHT access\n    wire [6:0] predict_index = predict_pc ^ GHR;\n    wire [6:0] train_index = train_pc ^ train_history;\n\n    // Predict output logic\n    assign predict_taken = (PHT[predict_index] >= 2'b10);\n    assign predict_history = GHR;\n\n    // Asynchronous reset and synchronous logic\n    always @(posedge clk or posedge areset) begin\n        // Reset logic\n        if (areset) begin\n            GHR <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b01; // Initialize to weakly not taken\n            end\n        end else begin\n            // Update on training\n            if (train_valid) begin\n                // Update 2-bit saturating counters in the PHT\n                if (train_taken) begin\n                    // Increment saturating counter, max at 2'b11\n                    if (PHT[train_index] < 2'b11)\n                        PHT[train_index] <= PHT[train_index] + 1;\n                end else begin\n                    // Decrement saturating counter, min at 2'b00\n                    if (PHT[train_index] > 2'b00)\n                        PHT[train_index] <= PHT[train_index] - 1;\n                end\n\n                // Recover GHR if misprediction occurs\n                if (train_mispredicted) begin\n                    GHR <= {train_history[5:0], train_taken};\n                end else if (predict_valid) begin\n                    // Update GHR for normal prediction\n                    GHR <= {GHR[5:0], predict_taken};\n                end\n            end else if (predict_valid) begin\n                // Update GHR when training is not happening\n                GHR <= {GHR[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    reg [3:0] state, next_state;\n    reg [4:0] fall_time; // Counter for fall time\n    localparam WALK_LEFT = 4'd0,\n               WALK_RIGHT = 4'd1,\n               FALL_LEFT = 4'd2,\n               FALL_RIGHT = 4'd3,\n               DIG_LEFT = 4'd4,\n               DIG_RIGHT = 4'd5,\n               SPLATTER = 4'd6;\n\n    // State Transition Logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            FALL_LEFT, FALL_RIGHT: begin\n                if (ground && fall_time > 20)\n                    next_state = SPLATTER;\n                else if (ground)\n                    next_state = (state == FALL_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = state;\n            end\n\n            DIG_LEFT, DIG_RIGHT: begin\n                if (!ground)\n                    next_state = (state == DIG_LEFT) ? FALL_LEFT : FALL_RIGHT;\n                else\n                    next_state = state;\n            end\n\n            SPLATTER: begin\n                next_state = SPLATTER; // Remain in SPLATTER state\n            end\n\n            default: next_state = WALK_LEFT; // Default to WALK_LEFT\n        endcase\n    end\n\n    // State Update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_time <= 0;\n        end else begin\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_time <= fall_time + 1;\n            else\n                fall_time <= 0;\n            state <= next_state;\n        end\n    end\n\n    // Output Logic\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n        digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        DETECT1 = 3'b001,\n        DETECT2 = 3'b010,\n        DETECT3 = 3'b011,\n        DETECT4 = 3'b100,\n        SHIFT = 3'b101,\n        WAIT_COUNT = 3'b110,\n        DONE = 3'b111\n    } state_t;\n    \n    state_t state, next_state;\n    reg [2:0] shift_count;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic and next-state logic\n    always @(*) begin\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n        next_state = state;\n\n        case (state)\n            IDLE: begin\n                if (data == 1'b1) next_state = DETECT1;\n            end\n            DETECT1: begin\n                if (data == 1'b1) next_state = DETECT2;\n                else next_state = IDLE;\n            end\n            DETECT2: begin\n                if (data == 1'b0) next_state = DETECT3;\n                else next_state = IDLE;\n            end\n            DETECT3: begin\n                if (data == 1'b1) next_state = DETECT4;\n                else next_state = IDLE;\n            end\n            DETECT4: begin\n                if (data == 1'b1) next_state = IDLE;\n                else next_state = SHIFT;\n            end\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_count == 3'd3) next_state = WAIT_COUNT;\n            end\n            WAIT_COUNT: begin\n                counting = 1'b1;\n                if (done_counting) next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Shift counter\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_count <= 3'b000;\n        else if (shift_ena)\n            shift_count <= shift_count + 1'b1;\n        else\n            shift_count <= 3'b000;\n    end\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    // Function to count neighbours considering toroidal wrapping\n    function [3:0] count_neighbors;\n        input [255:0] grid;\n        input [3:0] row, col;\n        integer r, c;\n        begin\n            count_neighbors = 0;\n            for (r = -1; r <= 1; r = r + 1) begin\n                for (c = -1; c <= 1; c = c + 1) begin\n                    if (r != 0 || c != 0) begin\n                        // Compute toroidal wrapping indices\n                        count_neighbors = count_neighbors +\n                            grid[((row + r + 16) % 16) * 16 + ((col + c + 16) % 16)];\n                    end\n                end\n            end\n        end\n    endfunction\n\n    reg [255:0] next_q;\n\n    // Compute next state for each cell\n    always @(*) begin\n        integer row, col;\n        for (row = 0; row < 16; row = row + 1) begin\n            for (col = 0; col < 16; col = col + 1) begin\n                case (count_neighbors(q, row, col))\n                    4'd2: next_q[row * 16 + col] = q[row * 16 + col]; // Stay the same\n                    4'd3: next_q[row * 16 + col] = 1;                 // Become alive\n                    default: next_q[row * 16 + col] = 0;              // Become dead\n                endcase\n            end\n        end\n    end\n\n    // Sequential logic with load functionality\n    always @(posedge clk) begin\n        if (load)\n            q <= data;  // Load initial state\n        else\n            q <= next_q; // Update state\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    typedef enum logic [2:0] {\n        WALK_LEFT  = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALL_LEFT  = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT   = 3'b100,\n        DIG_RIGHT  = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else\n                    next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else\n                    next_state = DIG_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // Default safe state\n        endcase\n    end\n\n    // State flip-flops\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            DIG_LEFT: digging = 1;\n            DIG_RIGHT: digging = 1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n// Synchronous process\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset the clock to 12:00 AM\n        ss <= 8'h00;\n        mm <= 8'h00;\n        hh <= 8'h12;\n        pm <= 1'b0;\n    end\n    else if (ena) begin\n        // Increment seconds\n        if (ss == 8'h59) begin\n            ss <= 8'h00;\n            // Increment minutes\n            if (mm == 8'h59) begin\n                mm <= 8'h00;\n                // Increment hours\n                if (hh == 8'h12) begin\n                    hh <= 8'h01; // Wrap around to 1\n                    pm <= ~pm;   // Flip AM/PM\n                end\n                else if (hh == 8'h11) begin\n                    hh <= 8'h12; // 11 -> 12\n                end\n                else begin\n                    hh <= hh + 8'h01; // Increment hours normally\n                end\n            end\n            else begin\n                mm <= mm + 8'h01; // Increment minutes\n            end\n        end\n        else begin\n            ss <= ss + 8'h01; // Increment seconds\n        end\n    end\nend\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        LEFT = 2'b00,    // Walking left\n        RIGHT = 2'b01,   // Walking right\n        FALL_LEFT = 2'b10, // Falling (was walking left)\n        FALL_RIGHT = 2'b11 // Falling (was walking right)\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT; // Fallback state\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == LEFT);\n        walk_right = (state == RIGHT);\n        aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 16'b0;  // Reset all digits to 0\n        else begin\n            // Increment ones digit\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n                // Increment tens digit\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                    // Increment hundreds digit\n                    if (q[11:8] == 4'd9) begin\n                        q[11:8] <= 4'd0;\n                        // Increment thousands digit\n                        if (q[15:12] == 4'd9)\n                            q[15:12] <= 4'd0;\n                        else\n                            q[15:12] <= q[15:12] + 1;\n                    end else\n                        q[11:8] <= q[11:8] + 1;\n                end else\n                    q[7:4] <= q[7:4] + 1;\n            end else\n                q[3:0] <= q[3:0] + 1;\n        end\n    end\n\n    // Generate enable signals\n    assign ena[1] = (q[3:0] == 4'd9);\n    assign ena[2] = ena[1] & (q[7:4] == 4'd9);\n    assign ena[3] = ena[2] & (q[11:8] == 4'd9);\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;                  // State A\n            3'b001: Y2 = w ? 1 : 0;          // State B\n            3'b010: Y2 = w ? 1 : 1;          // State C\n            3'b011: Y2 = w ? 0 : 1;          // State D\n            3'b100: Y2 = 1;                  // State E\n            3'b101: Y2 = w ? 0 : 0;          // State F\n            default: Y2 = 0;                 // Default case for invalid state\n        endcase\n    end\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode; // Ringer is ON only if ring is 1 and not in vibrate mode\n    assign motor = ring & vibrate_mode;  // Motor is ON only if ring is 1 and in vibrate mode\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0;\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (a == 0) \n            q <= ~q;  // Toggle q when a is 0\n        else \n            q <= q;   // Hold the value of q when a is 1\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        S_IDLE = 2'b00, // Wait for the operation\n        S_PASS = 2'b01, // Pass input as is before the 1st '1'\n        S_INVERT = 2'b10 // Invert bits after the 1st '1'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            S_IDLE: next_state = x ? S_INVERT : S_PASS;\n            S_PASS: next_state = x ? S_INVERT : S_PASS;\n            S_INVERT: next_state = S_INVERT;\n            default: next_state = S_IDLE; // Default state\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        case (state)\n            S_IDLE: z = 1'b0; // Output is undefined during IDLE\n            S_PASS: z = x;    // Pass input bit\n            S_INVERT: z = ~x; // Invert input bit\n            default: z = 1'b0; // Default output\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n    \n    state_t state, next_state;\n\n    // Combinational logic for next state\n    always_comb begin\n        case (state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A;\n        endcase\n    end\n    \n    // Output logic\n    always_comb begin\n        out = (state == D) ? 1 : 0;\n    end\n\n    // Sequential block for state transitions with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0; // Reset output to 0\n        else\n            q <= d;    // Update q with d\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the shift register\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;            // Shift left by 1 bit\n                2'b01: q <= q << 8;            // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]};  // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {S0, S1, S2} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always_ff @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always_comb begin\n        // Default assignments\n        next_state = state;\n        z = 1'b0;\n\n        case (state)\n            S0: begin\n                if (x) next_state = S1;\n                else next_state = S0;\n            end\n            S1: begin\n                if (x) next_state = S1;\n                else next_state = S2;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;\n                } else next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    typedef enum reg [2:0] {A=3'd0, B=3'd1, C=3'd2, D=3'd3, E=3'd4, F=3'd5} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w == 0) ? B : A;\n            B: next_state = (w == 0) ? C : D;\n            C: next_state = (w == 0) ? E : D;\n            D: next_state = (w == 0) ? F : A;\n            E: next_state = (w == 0) ? E : D;\n            F: next_state = (w == 0) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "Here's the complete Verilog code for the described module:\n\n```verilog\nmodule top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg [23:0] out_bytes,\n\toutput reg done\n);\n\n\t// State encoding\n\ttypedef enum logic [1:0] {\n\t\tWAIT_START = 2'b00,\n\t\tBYTE_1     = 2'b01,\n\t\tBYTE_2     = 2'b10,\n\t\tBYTE_3     = 2'b11\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State machine and datapath control\n\talways_ff @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent=WAIT_START}\n Ends module"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // Deriving Y1 and Y3 based on the given state transitions\n    assign Y1 = (y[0] & w) | (y[3] & ~w); // Y1 is 1 for transitions A -> B (y[0] & w) and D -> B (y[3] & ~w)\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w); // Y3 is 1 for transitions B -> D, C -> D, E -> D, and F -> D\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec; // Output the same vector\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    out = a ^ c; // Simplified based on Karnaugh map analysis\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8]; // Upper byte\n    assign out_lo = in[7:0];  // Lower byte\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // Using assign statement\n    assign out_assign = a ^ b;\n\n    // Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Using clocked always block (with flip-flop)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,  // One-hot encoded state vector\n    input w,        // Input signal\n    output Y2,      // Next-state signal for y[2] (state B)\n    output Y4       // Next-state signal for y[4] (state D)\n);\n    // Logic for Y2 (state B)\n    // Y2 is high when transitioning from A to B (y[1] = 1 and w = 0)\n    assign Y2 = y[1] & ~w;\n\n    // Logic for Y4 (state D)\n    // Y4 is high in two cases:\n    // From B to D (y[2] = 1 and w = 1)\n    // From C to D (y[3] = 1 and w = 1)\n    // From E to D (y[5] = 1 and w = 1)\n    // From F to D (y[6] = 1 and w = 1)\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;       // Load R into Q when L is asserted\n        else if (E)\n            Q <= w;       // Shift input w to Q when E is enabled\n        // When neither L nor E is asserted, Q retains its value\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    reg d1, d2, d3;\n\n    always @(posedge clk) begin\n        d1 <= x ^ d1;             // XOR gate\n        d2 <= x & ~d2;            // AND gate\n        d3 <= x | ~d3;            // OR gate\n    end\n\n    assign z = ~(d1 ^ d2 ^ d3);   // XNOR of d1, d2, and d3\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "```verilog\nmodule top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            next_q[0] = (q[0] == 0 && q[1] == 1) || (q[0] == 1 && q[1] ==1);\n            next_q[1] =  trim ajust level context env cell"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition (comb logic)\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (based on current state)\n    always @(*) begin\n        case (state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'd15; // Binary \"1111\" for f as per the waveform listing\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = sel ? b : a; // Correctly selects between a and b based on sel\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module flipflop_mux(\n    input clk,\n    input L,\n    input d,       // Flip-flop input\n    input r_in,    // Mux input (r_in)\n    output reg q\n);\n    always @(posedge clk) begin\n        if (L) begin\n            q <= r_in;  // Load value\n        end else begin\n            q <= d;     // Flip-flop operation\n        end\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input L,\n    input [2:0] r_in,\n    output [2:0] q\n);\n    wire [2:0] d;  // Intermediate connections for flip-flop feedback\n    \n    // Shift logic\n    assign d[0] = q[2];  // Feedback\n    assign d[1] = q[0];\n    assign d[2] = q[1] ^ q[2];\n\n    // Instantiate flipflop_mux for each bit\n    flipflop_mux u0(clk, L, d[0], r_in[0], q[0]);\n    flipflop_mux u1(clk, L, d[1], r_in[1], q[1]);\n    flipflop_mux u2(clk, L, d[2], r_in[2], q[2]);\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    reg [31:0] in_prev;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n        end else begin\n            out <= out | (in_prev & ~in);\n        end\n        in_prev <= in;\n    end\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "Here is the complete Verilog code based on the problem description:\n\n```verilog\nmodule top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding for clarity (not necessary in hardware but for readability)\n    localparam S    = 10'b0000000001;\n    localparam S1   = 10'b0000000010;\n    localparam S11  = 10'b0000000100;\n    localparam S110 = 10'b0000001000;\n    localparam B0   = 10'b0000010000;\n    localparam B1   = 10'b0000100000;\n    localparam B2   = 10'b0001000000;\n    localparam B3   = 10'b0010000000;\n    localparam Count = 10'b0100000000;\n    localparam Wait = 10'b1000000000;\n\n    // Next-state logic\n    assign S_next = state[S] & ~d | state[S1] & ~d | state[S11] & ~d | state[S110] & ~d & ~d & ack;\n    assign S1_next = state[S] & d;\n    assign B3_next = state[B2]; // Move to B3 always from B2\n    assign Count_next = state[B3]; // Move to Count always from B3"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    // Asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Weakly not-taken state\n        end else if (train_valid) begin\n            // Increment or decrement based on train_taken\n            if (train_taken && state != 2'b11) begin\n                state <= state + 2'b01; // Increment up to 3\n            end else if (!train_taken && state != 2'b00) begin\n                state <= state - 2'b01; // Decrement down to 0\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in)\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default:     pos = 3'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        // Default outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Check scancode and set outputs accordingly\n        case (scancode)\n            16'he06b: left = 1;   // Left arrow\n            16'he072: down = 1;   // Down arrow\n            16'he074: right = 1;  // Right arrow\n            16'he075: up = 1;     // Up arrow\n            default: ;            // Anything else, all outputs remain 0\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Full adder for each bit\n    full_adder fa0 (\n        .a(x[0]),\n        .b(y[0]),\n        .cin(1'b0),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n    \n    full_adder fa1 (\n        .a(x[1]),\n        .b(y[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n    \n    full_adder fa2 (\n        .a(x[2]),\n        .b(y[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n    \n    full_adder fa3 (\n        .a(x[3]),\n        .b(y[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(c4)\n    );\n\n    // Assign the final carry-out to sum[4]\n    assign sum[4] = c4;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    // Declare intermediate wires\n    wire and1_out, and2_out;\n\n    // First layer: AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n    \n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] Q; // 8-bit shift register\n\n    // Shift Register Logic\n    always @(posedge clk) begin\n        if (enable)\n            Q <= {Q[6:0], S}; // Shift bits to the right, MSB shifted in first\n    end\n\n    // Multiplexer Logic\n    always @(*) begin\n        case ({A, B, C}) // Select output based on inputs A, B, C\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case (should not occur)\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater is active in heating mode and if it's too cold\n    assign heater = mode & too_cold;\n\n    // Air conditioner is active in cooling mode and if it's too hot\n    assign aircon = ~mode & too_hot;\n\n    // Fan is on if heater or air conditioner are on, or when fan_on is requested\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Minimum Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & c & d) | (a & b & ~c & d) | (a & b & c & d);\n\n    // Minimum Product-of-Sums (POS) form\n    assign out_pos = (a | ~b | ~c | ~d) & (a | ~b | ~c | d) & (a | b | c | d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h1; // Synchronous reset to initial value\n        else begin\n            // Feedback calculation using taps at bit positions 32, 22, 2, and 1\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b & d) | (a & d) | (a & c);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    assign p1y = ~(p1a & p1b & p1c & p1d); // 4-input NAND for first gate\n    assign p2y = ~(p2a & p2b & p2c & p2d); // 4-input NAND for second gate\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // (1) out_both: Each bit checks if in[i] and its left neighbor are both '1'\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n    \n    // (2) out_any: Each bit checks if either in[i] or its right neighbor are '1'\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    \n    // (3) out_different: Each bit checks if in[i] is different from its left neighbor\n    assign out_different[3] = in[3] ^ in[0]; // Wrap-around case\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000; // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Synchronous reset\n        end\n        else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0; // Wrap around to 0 after 9\n            end\n            else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with bubble (NOT) on in2\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        STATE_B = 2'b01,\n        STATE_A = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            default: next_state = STATE_B; // Default state for safety\n        endcase\n    end\n\n    // Sequential logic (state update)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= STATE_B; // Asynchronous reset to STATE_B\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic (depends only on state for Moore machine)\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1'b1; // Output in STATE_B\n            STATE_A: out = 1'b0; // Output in STATE_A\n            default: out = 1'b0; // Default output for safety\n        endcase\n    end\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    reg q_pos, q_neg;\n\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n    \n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    always @(*) begin\n        q = clk ? q_pos : q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A (\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B (\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n\nmodule top_module (\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out;\n    wire b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate first pair of A and B\n    A A1 (.x(x), .y(y), .z(a1_out));\n    B B1 (.x(x), .y(y), .z(b1_out));\n\n    // Instantiate second pair of A and B\n    A A2 (.x(x), .y(y), .z(a2_out));\n    B B2 (.x(x), .y(y), .z(b2_out));\n\n    // OR gate for first pair outputs\n    assign or_out = a1_out | b1_out;\n\n    // AND gate for second pair outputs\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate for OR and AND outputs\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Synchronous load\n        end\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 10'd0; // Synchronous reset\n        else if (q == 10'd999)\n            q <= 10'd0; // Reset counter after reaching 999\n        else\n            q <= q + 1'b1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n    );\n\n    // State transition logic\n    assign next_state[0] = state[0] & ~in | state[1] & ~in | state[2] & ~in | state[3] & ~in | state[4] & ~in | state[5] & ~in | state[6] & ~in | state[7] & ~in | state[8] & ~in | state[9] & ~in;\n    assign next_state[1] = state[0] & in | state[8] & in | state[9] & in;\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in | state[7] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;         // No change\n            2'b01: Q <= 1'b0;      // Reset\n            2'b10: Q <= 1'b1;      // Set\n            2'b11: Q <= ~Q;        // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a); // a == a\n    assign out[23] = ~(a ^ b); // a == b\n    assign out[22] = ~(a ^ c); // a == c\n    assign out[21] = ~(a ^ d); // a == d\n    assign out[20] = ~(a ^ e); // a == e\n    assign out[19] = ~(b ^ a); // b == a\n    assign out[18] = ~(b ^ b); // b == b\n    assign out[17] = ~(b ^ c); // b == c\n    assign out[16] = ~(b ^ d); // b == d\n    assign out[15] = ~(b ^ e); // b == e\n    assign out[14] = ~(c ^ a); // c == a\n    assign out[13] = ~(c ^ b); // c == b\n    assign out[12] = ~(c ^ c); // c == c\n    assign out[11] = ~(c ^ d); // c == d\n    assign out[10] = ~(c ^ e); // c == e\n    assign out[9]  = ~(d ^ a); // d == a\n    assign out[8]  = ~(d ^ b); // d == b\n    assign out[7]  = ~(d ^ c); // d == c\n    assign out[6]  = ~(d ^ d); // d == d\n    assign out[5]  = ~(d ^ e); // d == e\n    assign out[4]  = ~(e ^ a); // e == a\n    assign out[3]  = ~(e ^ b); // e == b\n    assign out[2]  = ~(e ^ c); // e == c\n    assign out[1]  = ~(e ^ d); // e == d\n    assign out[0]  = ~(e ^ e); // e == e\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n    // State encoding\n    typedef enum logic [0:0] {\n        LEFT  = 1'b0,\n        RIGHT = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (state)\n            LEFT: begin\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default fallback case\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT; // Asynchronous reset to walk_left\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine outputs depend only on current state)\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate signals for AND gate outputs\n    wire and1, and2, and3, and4;\n    \n    // 3-input AND gates\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    \n    // 2-input AND gates\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n    \n    // OR gate outputs\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\n    // On every positive edge of the clock\n    always @ (posedge clk) begin\n        // Compute the logic for Y[0] (Next state bit 0)\n        case (y)\n            3'b000: Y0 = x;\n            3'b001: Y0 = x & ~y[2]; // Y0 becomes 1 if x=1 and y=100\n            3'b010: Y0 = ~x;\n            //branches likewise starts .\n        //fin align\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the given data\n            counter <= data;\n        end else if (counter > 0) begin\n            // Decrement the counter if it is greater than 0\n            counter <= counter - 1;\n        end\n    end\n\n    // Assert terminal count (tc) when counter reaches 0\n    always @(*) begin\n        tc = (counter == 0);\n    end\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        S0, // Initial State\n        S1, // Detected '1'\n        S2, // Detected '11'\n        S3, // Detected '110'\n        S4  // Detected '1101' -> Final state\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for state transition\n    always @(*) begin\n        case (current_state)\n            S0: next_state = (data) ? S1 : S0;\n            S1: next_state = (data) ? S2 : S0;\n            S2: next_state = (data) ? S2 : S3;\n            S3: next_state = (data) ? S4 : S0;\n            S4: next_state = S4; // Once in final state, stay there\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (current_state == S4)\n            start_shifting <= 1'b1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 8'b0; // Reset outputs to zero\n        else \n            q <= d;    // Capture input 'd' on the positive edge of clk\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (prev_in ^ in) & ~prev_in & in; // Detect rising edges\n        prev_in <= in; // Register the input value for edge detection\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1; // Reset to 1\n        else if (q == 4'd10)\n            q <= 4'd1; // Wrap around to 1 after 10\n        else\n            q <= q + 4'd1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4; // Reset to 4 when a = 1\n        else\n            q <= q + 1; // Increment when a = 0\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Reset state to 1\n        end else begin\n            q <= {q[3:0], q[4] ^ q[2]}; // Shift and XOR taps (5 and 3)\n        end\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // Check if the result is zero\n        result_is_zero = (out == 8'b0) ? 1 : 0;\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "From the Karnaugh map, we derive the minimized function. Handle the don't-care conditions (`d`) optimally when assigning the function. Here is the complete Verilog module:\n\n```verilog\nmodule top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b1100, 4'b1101, 4'b1110, 4'b1011, 4'b1010: f = 1;\n            4'b0101                   : f = 1;\n            default                    : f = 0;\n        endcase\n    end //also optimizebb CLE */\n;\n /generatedceries"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1; end\n            8'h16: begin out = 4'd1; valid = 1; end\n            8'h1e: begin out = 4'd2; valid = 1; end\n            8'h26: begin out = 4'd3; valid = 1; end\n            8'h25: begin out = 4'd4; valid = 1; end\n            8'h2e: begin out = 4'd5; valid = 1; end\n            8'h36: begin out = 4'd6; valid = 1; end\n            8'h3d: begin out = 4'd7; valid = 1; end\n            8'h3e: begin out = 4'd8; valid = 1; end\n            8'h46: begin out = 4'd9; valid = 1; end\n            default: begin out = 4'd0; valid = 0; end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({c, d, a, b})\n            4'b0001: out = 0;\n            4'b0010: out = 1;\n            4'b0011: out = 1;\n            4'b0100: out = 0;\n            4'b0101: out = 0;\n            4'b1100: out = 0;\n            4'b1101: out = 1;\n            4'b1110: out = 1;\n            4'b1111: out = 1;\n            4'b1000: out = 0;\n            4'b1001: out = 1;\n            4'b1010: out = 1;\n            4'b1011: out = 1;\n            default: out = 0; // d (don't-care cases can be ignored or assigned any value)\n        endcase\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena)\n            q <= {q[2:0], data}; // Shift in MSB first\n        else if (count_ena)\n            q <= q - 1; // Decrement the current value\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'b000;\n            shift_ena <= 1'b1;\n        end else begin\n            if (count < 3'b100) begin\n                count <= count + 1'b1;\n                shift_ena <= 1'b1;\n            end else begin\n                shift_ena <= 1'b0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'b0000; // Synchronous reset: set counter to 0\n        else \n            q <= q + 1;   // Increment counter\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum reg [1:0] {A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11} state_t;\n    state_t current_state, next_state;\n\n    // State flip-flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next-state logic (state table)\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1]) next_state = B;              // r1 = 1 -> State B\n                else if (r[2]) next_state = C;         // r1 = 0, r2 = 1 -> State C\n                else if (r[3]) next_state = D;         // r1 = 0, r2 = 0, r3 = 1 -> State D\n                else next_state = A;                   // r1 = 0, r2 = 0, r3 = 0 -> Stay in State A\n            end\n            B: begin\n                if (r[1]) next_state = B;              // r1 = 1 -> Stay in State B\n                else next_state = A;                   // r1 = 0 -> Back to State A\n            end\n            C: begin\n                if (r[2]) next_state = C;              // r2 = 1 -> Stay in State C\n                else next_state = A;                   // r2 = 0 -> Back to State A\n            end\n            D: begin\n                next_state = A;                        // Always return to State A after D\n            end\n            default: next_state = A;                   // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default: no grants\n        case (current_state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000; // No grants in other states\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Synchronous reset to 0\n        else if (q == 4'd9) \n            q <= 4'd0; // Wrap around from 9 to 0\n        else \n            q <= q + 1; // Increment counter\n    end\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n    // Define state encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg done_reg;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            state <= IDLE;\n        else \n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;  // Default is to stay in the current state\n        done_reg = 1'b0;     // Default is to not signal done\n\n        case (state)\n            IDLE: begin\n                if (in[3]) \n                    next_state = BYTE1;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done_reg = 1'b1; // Signal the message is complete\n                if (in[3]) \n                    next_state = BYTE1;\n                else \n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // Perform a 4-input AND operation\n    assign out_or = |in;   // Perform a 4-input OR operation\n    assign out_xor = ^in;  // Perform a 4-input XOR operation\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    reg [2:0] state, next_state;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000; // Reset state\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        case (state)\n            3'b000: begin\n                next_state = (x == 1) ? 3'b001 : 3'b000;\n                z = 0;\n            end\n            3'b001: begin\n                next_state = (x == 1) ? 3'b100 : 3'b001;\n                z = 0;\n            end\n            3'b010: begin\n                next_state = (x == 1) ? 3'b001 : 3'b010;\n                z = 0;\n            end\n            3'b011: begin\n                next_state = (x == 1) ? 3'b010 : 3'b001;\n                z = 1;\n            end\n            3'b100: begin\n                next_state = (x == 1) ? 3'b100 : 3'b011;\n                z = 1;\n            end\n            default: begin\n                next_state = 3'b000; // Default to safe state\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        S_A,      // Initial state\n        S_B,      // Set f to 1 for one clock cycle\n        S_C,      // Waiting for x = 101\n        S_D,      // Set g to 1\n        S_E,      // Waiting for y within 2 cycles\n        S_F       // States for setting g permanently\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Registers for x pattern tracking\n    reg [2:0] x_history;\n    reg [1:0] y_wait_count;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            current_state <= S_A;\n            x_history <= 3'b000;\n            y_wait_count <= 2'b00;\n        end else begin\n            current_state <= next_state;\n            x_history <= {x_history[1:0], x}; // Shift-register to track x history\n            if (current_state == S_E) begin\n                y_wait_count <= y_wait_count + 1;\n            end else begin\n                y_wait_count <= 2'b00;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        // Default state transitions\n        next_state = current_state;\n\n        case (current_state)\n            S_A: begin\n                if (resetn) next_state = S_B;\n            end\n            S_B: begin\n                next_state = S_C;\n            end\n            S_C: begin\n                if (x_history == 3'b101) next_state = S_D;\n            end\n            S_D: begin\n                next_state = S_E;\n            end\n            S_E: begin\n                if (y) next_state = S_F;        // y=1 within 2 cycles\n                else if (y_wait_count == 2) next_state = S_A; // Timeout\n            end\n            S_F: begin\n                // Remain in S_F (g = 1 permanently)\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        f = 1'b0;\n        g = 1'b0;\n\n        case (current_state)\n            S_B:    f = 1'b1;    // Output f = 1 for one cycle\n            S_D,\n            S_E,\n            S_F:    g = 1'b1;    // Output g = 1 as specified\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // Reset to 0x34\n        else\n            q <= d;      // Load data\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all 8 bits to compute even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 0) ? 2'b00 : 2'b01; // State A\n            2'b01: next_state = (in == 0) ? 2'b10 : 2'b01; // State B\n            2'b10: next_state = (in == 0) ? 2'b00 : 2'b11; // State C\n            2'b11: next_state = (in == 0) ? 2'b10 : 2'b01; // State D\n            default: next_state = 2'b00; // Default case\n        endcase\n    end\n\n    assign out = (state == 2'b11) ? 1 : 0; // Output logic\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (~x & ~y) | (x & y);\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // State transition table (combinational logic)\n    always @(*) begin\n        case (state)\n            A: next_state = (w ? B : A);\n            B: next_state = (w ? C : D);\n            C: next_state = (w ? E : D);\n            D: next_state = (w ? F : A);\n            E: next_state = (w ? E : D);\n            F: next_state = (w ? C : D);\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (combinational logic)\n    assign z = (state == E || state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Synchronous active-low reset\n        end\n        else begin\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8]; // Update upper byte\n            end\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0]; // Update lower byte\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge);\n    \n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        pedge <= ~prev_in & in;  // Detect 0-to-1 transitions\n        prev_in <= in;          // Store the previous state of 'in'\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    always @(posedge clock) begin\n        p <= a; // Update p on the rising edge of the clock\n    end\n\n    always @(negedge clock) begin\n        q <= p; // Update q on the falling edge of the clock\n    end\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the input data into q\n        end else begin\n            q[0] <= q[1]; // Boundary case: q[-1] is assumed 0\n            q[511] <= q[510]; // Boundary case: q[512] is assumed 0\n            // Update the rest of the cells based on Rule 90\n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n    assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) out_both: Check if both the current bit and the bit to the left are '1'\n    assign out_both = in[99:1] & in[98:0];\n\n    // (2) out_any: Check if either the current bit or the bit to the right are '1'\n    assign out_any = in[99:1] | in[98:0];\n\n    // (3) out_different: Check if the current bit is different from the bit to the left (wrapping around)\n    assign out_different[99:1] = in[99:1] ^ in[98:0];\n    assign out_different[0] = in[0] ^ in[99];\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena) \n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[sel * 4 +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'hFFFF; // Set all bits to '1' for sel >= 9\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;       // Bitwise OR\n    assign out_or_logical = |(a | b);   // Logical OR\n    assign out_not = {~b, ~a};          // Inverse of b assigned to upper half, inverse of a to lower half\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic (combinational)\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output is 1 only in state D\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        min = a; // Start with 'a' as the initial minimum\n\n        if (b < min)\n            min = b;\n\n        if (c < min)\n            min = c;\n\n        if (d < min)\n            min = d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = (~c & ~d) | (~b & ~c) | (~a & ~c & d) | (a & b & c) | (a & ~b & d);\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "```verilog\nmodule top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\n\t// State encoding\n\tlocalparam A = 2'b00;\n\tlocalparam B = 2'b01;\n\tlocalparam C = 2'b10;\n\t\n\t// State registers\n\treg [1:0] state, next_state;\n\treg [1:0] count;\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (count == 3)\n\t\t\t\t\tnext_state = B;  // Continue staying in B\n\t\t\t\telse\n\t\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend `Correct"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        case (1'b1) // Priority encoding using \"case\"\n            in[3]: pos = 2'd3;\n            in[2]: pos = 2'd2;\n            in[1]: pos = 2'd1;\n            in[0]: pos = 2'd0;\n            default: pos = 2'd0; // Default to 0 if no bit is high\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF; // Default fallback\n        endcase\n    end\n\n    // State register (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= OFF; // Asynchronous reset to OFF state\n        else\n            state <= next_state; // Update to next state\n    end\n\n    // Output logic (based on current state)\n    always_comb begin\n        out = (state == ON) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Drive the output to logic low (0)\n    assign out = 0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one);\n\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always_ff @(posedge clk) begin\n        out <= in ^ out;  // XOR input 'in' with current 'out' value and assign to 'out'\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0; // Asynchronous reset\n        end else if (load) begin\n            q <= data; // Load has higher priority\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Right shift with q[3] set to 0\n        end\n    end\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    // Simplified equation derived from the truth table: \n    // f = (x3 & x1) | (x2 & ~x3)\n\n    assign f = (x3 & x1) | (x2 & ~x3);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;  // Reset output to 0\n        else\n            q <= d;     // Assign input d to output q\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // Perform bitwise AND reduction\n    assign out_or = |in;   // Perform bitwise OR reduction\n    assign out_xor = ^in;  // Perform bitwise XOR reduction\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b;   // Sum is the XOR of the inputs\n    assign cout = a & b;  // Carry-out is the AND of the inputs\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        shut_off_computer = cpu_overheated; // Assign based on condition\n    end\n\n    always @(*) begin\n        if (arrived)\n            keep_driving = 0; // Stop driving if arrived\n        else\n            keep_driving = ~gas_tank_empty; // Keep driving if there's gas\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] {OFF = 1'b0, ON = 1'b1} state_t;\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF; // Default case\n        endcase\n    end\n\n    // State register (sequential)\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine - only depends on state)\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate inputs with two 1 bits and split into outputs\n    wire [31:0] combined;\n    assign combined = {a, b, c, d, e, f, 2'b11};\n\n    assign w = combined[31:24];\n    assign x = combined[23:16];\n    assign y = combined[15:8];\n    assign z = combined[7:0];\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (a ^ b) ^ (c & d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // Define state encoding\n    typedef enum logic [0:0] {A = 1'b0, B = 1'b1} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            B: next_state = (in) ? B : A;\n            A: next_state = (in) ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flop with synchronous reset\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (state)\n            B: out = 1;\n            A: out = 0;\n            default: out = 1;\n        endcase\n    end\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    assign sum = a ^ b ^ cin;       // XOR for sum\n    assign cout = (a & b) | (b & cin) | (cin & a); // Carry-out logic\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    wire xnor_out;\n\n    assign xnor_out = ~(in1 ^ in2);  // XNOR operation\n    assign out = xnor_out ^ in3;     // XOR operation\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    // Determine the values for mux_in based on the K-map\n    assign mux_in[0] = (~c & d) | (c & d);    // Simplifies to d\n    assign mux_in[1] = 0;                     // Always 0\n    assign mux_in[2] = (c & ~d) | (c & d);    // Simplifies to c\n    assign mux_in[3] = (~c & ~d) | (c & d);   // Simplifies to ~d | c\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding (one-hot)\n    parameter A = 2'b01, B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (x == 1'b1) ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = x;   // z = 0 if x=0, z = 1 if x=1\n            B: z = ~x;  // z = 1 if x=0, z = 0 if x=1\n            default: z = 0;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output state\n);\n    // `state` is the same as `q`\n    assign state = q;\n\n    always @(posedge clk) begin\n        if (a == 0)\n            q <= 0; // Reset\n        else if (a == 1 && b == 1)\n            q <= ~q; // Toggle\n    end\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0011: f = 1;\n            4'b1000, 4'b1001, 4'b1010, 4'b1100, 4'b1101, 4'b1110: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err);\n\n    // State encoding\n    typedef enum logic[3:0] {\n        S0 = 4'b0000,  // Initial state (previous 0)\n        S1 = 4'b0001,  // 0 -> 1\n        S2 = 4'b0010,  // 01\n        S3 = 4'b0011,  // 011\n        S4 = 4'b0100,  // 0111\n        S5 = 4'b0101,  // 01111\n        S6 = 4'b0110,  // 011111\n        S7 = 4'b0111,  // 0111111\n        S8 = 4'b1000   // Error: 01111111...\n    } state_t;\n\n    state_t state, next_state;\n\n    // Sequential block: State transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Combinational block: Next state logic and outputs\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n        next_state = state;  // Default to hold state\n\n        case (state)\n            S0: begin\n                next_state = (in) ? S1 : S0;\n            end\n            S1: begin\n                next_state = (in) ? S2 : S0;\n            end\n            S2: begin\n                next_state = (in) ? S3 : S0;\n            end\n            S3: begin\n                next_state = (in) ? S4 : S0;\n            end\n            S4: begin\n                next_state = (in) ? S5 : S0;\n            end\n            S5: begin\n                next_state = (in) ? S6 : S0;\n            end\n            S6: begin\n                if (in) next_state = S7;    // 0111111\n                else begin\n                    next_state = S0;        // 0111110\n                    disc = 1;               // Discard detected\n                end\n            end\n            S7: begin\n                if (in) begin\n                    next_state = S8;        // 01111111...\n                    err = 1;                // Error condition\n                end else begin\n                    next_state = S0;        // 01111110\n                    flag = 1;               // Frame flag detected\n                end\n            end\n            S8: begin\n                // Remain in error state if 7+ 1s or until reset\n                next_state = (in) ? S8 : S0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        PATTERN_DETECTED = 3'b001,\n        LOAD_DELAY = 3'b010,\n        COUNTDOWN = 3'b011,\n        WAIT_ACK = 3'b100\n    } state_t;\n    \n    reg [2:0] state, next_state;\n    reg [3:0] delay, delay_reg;\n    reg [9:0] cycle_count; // Internal cycle counter\n    reg [3:0] bit_count;   // Tracks bits shifted in\n\n    // Assign output count to hold remaining delay time\n    assign count = (counting) ? delay : 4'bxxxx;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Sequential logic\n    always @(posedge clk) begin\n        if (reset) begin\n            counting <= 1'b0;\n            done <= 1'b0;\n            delay <= 4'b0;\n            delay_reg <= 4'b0;\n            cycle_count <= 10'b0;\n            bit_count <= 4'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counting <= 1'b0;\n                    done <= 1'b0;\n                    bit_count <= 4'b0;\n                end\n                PATTERN_DETECTED: begin\n                    if (bit_count < 4) begin\n                        delay[3-bit_count] <= data; // Shift in most-significant-bit first\n                        bit_count <= bit_count + 1;\n                    end else begin\n                        delay_reg <= delay + 1; // Calculate total delay cycles\n                        cycle_count <= 10'd1000; // Start with 1000 cycles\n                    end\n                end\n                LOAD_DELAY: begin\n                    counting <= 1'b1;\n                end\n                COUNTDOWN: begin\n                    if (cycle_count > 0) begin\n                        cycle_count <= cycle_count - 1;\n                    end else begin\n                        cycle_count <= 10'd1000; // Reset cycle count for next delay decrement\n                        if (delay > 0)\n                            delay <= delay - 1;\n                        else\n                            counting <= 1'b0; // End countdown\n                    end\n                end\n                WAIT_ACK: begin\n                    done <= 1'b1;\n                    if (ack) begin\n                        done <= 1'b0;\n                        delay <= 4'b0;\n                        delay_reg <= 4'b0;\n                        cycle_count <= 10'b0;\n                        bit_count <= 4'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (data == 1'b1) // Searching for 1101 start pattern\n                    next_state = PATTERN_DETECTED;\n            end\n            PATTERN_DETECTED: begin\n                if (bit_count == 4) // After detecting delay bits\n                    next_state = LOAD_DELAY;\n            end\n            LOAD_DELAY: begin\n                next_state = COUNTDOWN;\n            end\n            COUNTDOWN: begin\n                if (delay == 0 && cycle_count == 0)\n                    next_state = WAIT_ACK;\n            end\n            WAIT_ACK: begin\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    typedef enum logic [1:0] {\n        LOW = 2'b00,\n        MID = 2'b01,\n        HIGH = 2'b10,\n        ABOVE = 2'b11\n    } level_t;\n    \n    level_t level, prev_level;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset to \"low water for a long time\" state\n            level <= LOW;\n            prev_level <= LOW;\n            fr3 <= 1'b1;\n            fr2 <= 1'b1;\n            fr1 <= 1'b1;\n            dfr <= 1'b0;\n        end else begin\n            // Record previous level\n            prev_level <= level;\n\n            // Determine current water level based on sensors\n            casez (s)\n                3'b111: level <= ABOVE;   // All sensors asserted\n                3'b011: level <= HIGH;    // Sensors [2:1] asserted\n                3'b001: level <= MID;     // Sensor [1] asserted only\n                3'b000: level <= LOW;     // No sensors asserted\n                default: level <= LOW;    // Default case (if any)\n            endcase\n\n            // Determine outputs based on current and previous levels\n            case (level)\n                ABOVE: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\n                end\n                HIGH: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b1;\n                    dfr <= (prev_level == MID || prev_level == LOW) ? 1'b1 : 1'b0;\n                end\n                MID: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= (prev_level == LOW) ? 1'b1 : 1'b0;\n                end\n                LOW: begin\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b0;\n                end\n                default: begin\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    reg [3:0] state, next_state; // 4-bit state to hold FSM states\n    reg [3:0] bit_count; // Counter to track received data bits\n    reg done_reg;\n\n    // State Definitions\n    localparam IDLE       = 4'd0,\n               START      = 4'd1,\n               DATA       = 4'd2,\n               STOP       = 4'd3,\n               WAIT_STOP  = 4'd4;\n\n    // State Update\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Logic for 'done' signal\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            done_reg <= 1'b0;\n        else if (state == STOP && in == 1'b1)\n            done_reg <= 1'b1; // Set done when stop bit verified\n        else\n            done_reg <= 1'b0; // Clear done otherwise\n    end\n    assign done = done_reg;\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                bit_count = 4'd0;\n                if (in == 1'b0) // Start bit detected\n                    next_state = START;\n            end\n            START: begin\n                if (in == 1'b0) // Stay if still start bit\n                    next_state = DATA;\n            end\n            DATA: begin\n                if (bit_count == 4'd7) // All 8 data bits received\n                    next_state = STOP;\n                else\n                    bit_count = bit_count + 1; // Increment data bit counter\n            end\n            STOP: begin\n                if (in == 1'b1) // Valid stop bit detected\n                    next_state = IDLE;\n                else // Invalid stop bit, wait for next frame\n                    next_state = WAIT_STOP;\n            end\n            WAIT_STOP: begin\n                if (in == 1'b1) // Wait for idle state (stop bit)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // Define states\n    typedef enum logic [2:0] {\n        IDLE,        // Waiting for start bit\n        START,       // Detecting the start bit\n        DATA,        // Receiving 8 data bits\n        STOP,        // Verifying the stop bit\n        ERROR        // Error state (recover until next valid stop bit)\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [7:0] data_reg;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (in == 0)               // Detect start bit (0)\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                next_state = DATA;         // Move to data reception\n            end\n            DATA: begin\n                if (bit_count == 7)        // After 8 bits, go to stop\n                    next_state = STOP;\n                else\n                    next_state = DATA;\n            end\n            STOP: begin\n                if (in == 1)               // Stop bit must be 1\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;    // Invalid stop bit, go to error\n            end\n            ERROR: begin\n                if (in == 1)               // Wait until line is idle\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Output and data handling\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_byte <= 8'b0;\n            done <= 0;\n            data_reg <= 8'b0;\n            bit_count <= 0;\n        end else begin\n            done <= 0;                   // Default done to 0\n            case (current_state)\n                IDLE: begin\n                    bit_count <= 0;\n                end\n                START: begin\n                    // Transition to data state, no action needed here\n                end\n                DATA: begin\n                    data_reg[bit_count] <= in; // Shift in data bits (LSB first)\n                    bit_count <= bit_count + 1;\n                end\n                STOP: begin\n                    if (in == 1) begin       // Verify stop bit\n                        out_byte <= data_reg;\n                        done <= 1;           // Set done on valid byte completion\n                    end\n                end\n                ERROR: begin\n                    // Wait for line idle, no action needed\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Parameters\n    localparam PHT_SIZE = 128;\n\n    // Registers and memories\n    reg [1:0] PHT[PHT_SIZE-1:0];         // 2-bit saturating counters in Pattern History Table\n    reg [6:0] global_history;            // Global Branch History Register\n\n    // Helper wires\n    wire [6:0] predict_index = predict_pc ^ global_history; // XOR hashing for prediction index\n    wire [6:0] train_index = train_pc ^ train_history;      // XOR hashing for training index\n\n    // PHT Training State Update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset logic\n            integer i;\n            global_history <= 7'b0;\n            for (i = 0; i < PHT_SIZE; i = i + 1) begin\n                PHT[i] <= 2'b01; // Weakly not taken\n            end\n        end else begin\n            // Priority: Training logic\n            if (train_valid) begin\n                // Update the saturating counter for the trained branch\n                case (PHT[train_index])\n                    2'b00: PHT[train_index] <= train_taken ? 2'b01 : 2'b00; // Strongly not taken\n                    2'b01: PHT[train_index] <= train_taken ? 2'b10 : 2'b00; // Weakly not taken\n                    2'b10: PHT[train_index] <= train_taken ? 2'b11 : 2'b01; // Weakly taken\n                    2'b11: PHT[train_index] <= train_taken ? 2'b11 : 2'b10; // Strongly taken\n                endcase\n                \n                // Update global_history if mispredicted\n                if (train_mispredicted) begin\n                    global_history <= {train_history[5:0], train_taken};\n                end\n            end else if (predict_valid) begin\n                // Prediction logic\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\n    // Prediction Logic\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = PHT[predict_index][1]; // MSB indicates taken/not taken\n            predict_history = global_history;     // Provide current global history state\n        end else begin\n            predict_taken = 0;\n            predict_history = 0;\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    typedef enum logic [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALLING_LEFT,\n        FALLING_RIGHT,\n        DIGGING_LEFT,\n        DIGGING_RIGHT,\n        SPLATTERED\n    } state_t;\n\n    state_t state, next_state;\n    reg [4:0] fall_count; // Counter for falling\n\n    // State transition\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING_LEFT;\n                else if (dig) next_state = DIGGING_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING_RIGHT;\n                else if (dig) next_state = DIGGING_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING_LEFT: begin\n                if (ground && fall_count > 20) next_state = SPLATTERED;\n                else if (ground) next_state = WALK_LEFT;\n                else next_state = FALLING_LEFT;\n            end\n            FALLING_RIGHT: begin\n                if (ground && fall_count > 20) next_state = SPLATTERED;\n                else if (ground) next_state = WALK_RIGHT;\n                else next_state = FALLING_RIGHT;\n            end\n            DIGGING_LEFT: begin\n                if (!ground) next_state = FALLING_LEFT;\n                else next_state = DIGGING_LEFT;\n            end\n            DIGGING_RIGHT: begin\n                if (!ground) next_state = FALLING_RIGHT;\n                else next_state = DIGGING_RIGHT;\n            end\n            SPLATTERED: begin\n                next_state = SPLATTERED;\n            end\n            default: next_state = WALK_LEFT; // Default state\n        endcase\n    end\n\n    // State update and asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_count <= 0;\n        end else begin\n            state <= next_state;\n\n            if (state == FALLING_LEFT || state == FALLING_RIGHT)\n                fall_count <= fall_count + 1;\n            else\n                fall_count <= 0;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALLING_LEFT,\n            FALLING_RIGHT: aaah = 1;\n            DIGGING_LEFT: digging = 1;\n            DIGGING_RIGHT: digging = 1;\n            SPLATTERED: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "Here is the complete Verilog code for the described finite-state machine:\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE      = 3'b000,\n        DETECT_1  = 3'b001,\n        DETECT_11 = 3'b010,\n        DETECT_110= 3'b011,\n        DETECT_1101 = 3'b100,\n        SHIFTING  = 3'b101,\n        COUNTING  = 3'b110,\n        DONE_WAIT = 3'b111\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] shift_count;\n\n    // State transition logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: \n                if (data) next_state = DETECT_1;\n\n            DETECT_1: \n                if (!data) next_state = IDLE;\n                else       next_state.next;"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n    // Internal wires for neighbor count\n    wire [3:0] neighbors[15:0][15:0];  \n    integer i, j;\n\n    // Function to count neighbors for a given cell\n    function [3:0] count_neighbors;\n        input [255:0] grid;\n        input integer x, y;\n        integer dx, dy, nx, ny;\n        reg [3:0] count;\n        begin\n            count = 0;\n            for (dx = -1; dx <= 1; dx = dx + 1) begin\n                for (dy = -1; dy <= 1; dy = dy + 1) begin\n                    if (!(dx == 0 && dy == 0)) begin\n                        nx = (x + dx + 16) % 16; // Wrap around for toroid\n                        ny = (y + dy + 16) % 16; // Wrap around for toroid\n                        count = count + grid[nx * 16 + ny];\n                    end\n                end\n            end\n            count_neighbors = count;\n        end\n    endfunction\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    case (count_neighbors(q, i, j))\n                        4'd2: q[i * 16 + j] <= q[i * 16 + j]; // No change\n                        4'd3: q[i * 16 + j] <= 1'b1;          // Becomes alive\n                        default: q[i * 16 + j] <= 1'b0;       // Becomes dead\n                    endcase\n                end\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        LEFT = 3'b000,\n        RIGHT = 3'b001,\n        FALL_LEFT = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT = 3'b100,\n        DIG_RIGHT = 3'b101\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                if (!ground)            next_state = FALL_LEFT;\n                else if (dig)           next_state = DIG_LEFT;\n                else if (bump_left)     next_state = RIGHT;\n                else                    next_state = LEFT;\n            end\n            \n            RIGHT: begin\n                if (!ground)            next_state = FALL_RIGHT;\n                else if (dig)           next_state = DIG_RIGHT;\n                else if (bump_right)    next_state = LEFT;\n                else                    next_state = RIGHT;\n            end\n            \n            FALL_LEFT: begin\n                if (ground)             next_state = LEFT;\n                else                    next_state = FALL_LEFT;\n            end\n            \n            FALL_RIGHT: begin\n                if (ground)             next_state = RIGHT;\n                else                    next_state = FALL_RIGHT;\n            end\n            \n            DIG_LEFT: begin\n                if (!ground)            next_state = FALL_LEFT;\n                else                    next_state = DIG_LEFT;\n            end\n            \n            DIG_RIGHT: begin\n                if (!ground)            next_state = FALL_RIGHT;\n                else                    next_state = DIG_RIGHT;\n            end\n            \n            default: next_state = LEFT; // Default state\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= LEFT;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left  = (current_state == LEFT);\n    assign walk_right = (current_state == RIGHT);\n    assign aaah       = (current_state == FALL_LEFT) || (current_state == FALL_RIGHT);\n    assign digging    = (current_state == DIG_LEFT) || (current_state == DIG_RIGHT);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the clock to 12:00 AM\n            hh <= 8'h12; // \"12\" in BCD\n            mm <= 8'h00; // \"00\" in BCD\n            ss <= 8'h00; // \"00\" in BCD\n            pm <= 1'b0;  // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00; // Reset seconds to \"00\"\n                \n                // Increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00; // Reset minutes to \"00\"\n\n                    // Increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01; // Wrap around to \"01\"\n                        pm <= ~pm;   // Toggle AM/PM\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12; // Transition from \"11\" to \"12\"\n                    end else begin\n                        hh <= hh + 8'h01; // Increment hour\n                    end\n                end else begin\n                    mm <= mm + 8'h01; // Increment minutes\n                end\n            end else begin\n                ss <= ss + 8'h01; // Increment seconds\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    typedef enum reg [2:0] {LEFT, RIGHT, FALLING_LEFT, FALLING_RIGHT} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALLING_LEFT;\n                else if (bump_left || bump_right)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALLING_RIGHT;\n                else if (bump_left || bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALLING_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALLING_LEFT;\n            end\n            FALLING_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALLING_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (state)\n            LEFT: walk_left = 1;\n            RIGHT: walk_right = 1;\n            FALLING_LEFT, FALLING_RIGHT: aaah = 1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n    // Increment enable signals for the upper three digits\n    assign ena[1] = (q[3:0] == 4'd9);          // Enable tens digit\n    assign ena[2] = ena[1] && (q[7:4] == 4'd9); // Enable hundreds digit\n    assign ena[3] = ena[2] && (q[11:8] == 4'd9); // Enable thousands digit\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0; // Reset all digits to 0\n        end else begin\n            // Ones digit\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 1;\n\n            // Tens digit\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 1;\n            end\n\n            // Hundreds digit\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 1;\n            end\n\n            // Thousands digit\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0;                     // A -> Y2 = 0\n            3'b001: Y2 = w ? 1 : 0;             // B -> Y2 = w\n            3'b010: Y2 = 0;                     // C -> Y2 = 0\n            3'b011: Y2 = 1;                     // D -> Y2 = 1\n            3'b100: Y2 = 1;                     // E -> Y2 = 1\n            3'b101: Y2 = w ? 1 : 0;             // F -> Y2 = w\n            default: Y2 = 0;                    // Default case\n        endcase\n    end\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring,\n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode; // Turn on ringer if ring is 1 and not in vibrate mode\n    assign motor = ring & vibrate_mode;  // Turn on motor if ring is 1 and in vibrate mode\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n    // Implementation using assign statement\n    assign out_assign = a & b;\n\n    // Implementation using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    assign zero = 1'b0;\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 0; // Set q to 0 when a is 1\n        else\n            q <= ~q; // Toggle q when a is 0\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        FLIP = 2'b01,\n        PASS = 2'b10\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // State update (sequential logic)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic (combinational logic)\n    always @(*) begin\n        case (state)\n            IDLE: next_state = FLIP;      // On reset, transition to FLIP state\n            FLIP: next_state = x ? PASS : FLIP; // Flip bits, transition if x == 1\n            PASS: next_state = PASS;      // Stay in PASS state\n            default: next_state = IDLE;   // Default case\n        endcase\n    end\n\n    // Output logic (z based only on current state, Moore FSM)\n    always @(*) begin\n        case (state)\n            IDLE: z = 0;                  // No output in IDLE state\n            FLIP: z = ~x;                 // Complement x in FLIP state\n            PASS: z = x;                  // Pass x as is in PASS state\n            default: z = 0;               // Default case\n        endcase\n    end\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic (combinational)\n    always_comb begin\n        case (current_state)\n            A: next_state = (in ? B : A);\n            B: next_state = (in ? B : C);\n            C: next_state = (in ? D : A);\n            D: next_state = (in ? B : C);\n            default: next_state = A; // Default case for safety\n        endcase\n    end\n\n    // State register with asynchronous reset (sequential)\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= A;\n        else \n            current_state <= next_state;\n    end\n\n    // Output logic (combinational, Moore machine depends only on state)\n    always_comb begin\n        case (current_state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (r) \n            q <= 1'b0; // Reset output to 0\n        else \n            q <= d;    // Capture input d\n    end\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the shift register\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;                       // Shift left by 1 bit\n                2'b01: q <= q << 8;                       // Shift left by 8 bits\n                2'b10: q <= {{q[63]}, q[63:1]};           // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]};        // Arithmetic shift right by 8 bits\n                default: q <= q;                          // No operation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // \"1\" detected\n        S2 = 2'b10  // \"10\" detected\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0; // Reset to initial state\n        else\n            state <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        z = 1'b0;\n\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1; // \"101\" detected\n                end else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w == 1'b0) ? B : A;\n            B: next_state = (w == 1'b0) ? C : D;\n            C: next_state = (w == 1'b0) ? E : D;\n            D: next_state = (w == 1'b0) ? F : A;\n            E: next_state = (w == 1'b0) ? E : D;\n            F: next_state = (w == 1'b0) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // FSM state declaration\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [23:0] temp_bytes; // Temporary storage for bytes\n\n    // State update (sequential logic)\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state and output logic (combinational)\n    always @* begin\n        // Default values\n        next_state = state;\n        temp_bytes = out_bytes;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (in[3]) begin\n                    next_state = BYTE1;\n                    temp_bytes[23:16] = in; // Store first byte\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n                temp_bytes[15:8] = in; // Store second byte\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n                temp_bytes[7:0] = in; // Store third byte\n            end\n            BYTE3: begin\n                next_state = IDLE; // Back to IDLE after a message\n                done = 1'b1;       // Signal message done\n            end\n        endcase\n    end\n\n    // Update output register\n    always @(posedge clk) begin\n        if (reset)\n            out_bytes <= 24'b0;\n        else if (done)\n            out_bytes <= temp_bytes;\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    // Y1 is the input to state flip-flop y[1] (state B, binary 000010).\n    // From the state diagram:\n    // - A (y[0]) transitions to B (y[1]) on w = 1.\n    // - So Y1 = y[0] & w.\n\n    assign Y1 = y[0] & w;\n\n    // Y3 is the input to state flip-flop y[3] (state D, binary 001000).\n    // From the state diagram:\n    // - B (y[1]) goes to D on w = 0.\n    // - C (y[2]) goes to D on w = 0.\n    // - F (y[5]) goes to D on w = 0.\n    // - So Y3 = (y[1] | y[2] | y[5]) & ~w.\n\n    assign Y3 = (y[1] | y[2] | y[5]) & ~w;\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec; // Pass the input vector directly to outv\n    assign o2 = vec[2]; // Extract bit 2 of the input vector\n    assign o1 = vec[1]; // Extract bit 1 of the input vector\n    assign o0 = vec[0]; // Extract bit 0 of the input vector\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    out = (a ^ c); // XOR operation based on the analysis of the K-map\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n    assign out_lo = in[7:0];  // Lower 8 bits\n    assign out_hi = in[15:8]; // Upper 8 bits\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b); // NOR gate logic\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n    \n    // XOR using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // Y2 corresponds to state B\n    assign Y2 = y[1] & ~w;\n\n    // Y4 corresponds to state D\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & w) | (y[6] & w);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)        // Load R when L is asserted\n            Q <= R;\n        else if (E)   // Shift w into Q when E is enabled\n            Q <= w;\n        // Else maintain the current value of Q\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    // Declare the D flip-flop outputs\n    reg q1, q2, q3;\n\n    // Combinational logic for the D flip-flop inputs\n    wire d1 = x ^ q1;           // XOR gate\n    wire d2 = x & ~q2;          // AND gate\n    wire d3 = x | ~q3;          // OR gate\n\n    // Sequential logic: D flip-flops\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n\n    // Final output logic: 3-input XNOR\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = c | b;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load state when load is high\n        end else begin\n            // Compute the next state based on Rule 110\n            next_q[0] = (q[0] & ~q[1]) | (~q[0] & q[1] & q[511]);  // Boundary: q[-1] is 0\n            next_q[511] = (q[510] & ~q[511]) | (~q[511] & q[0] & q[510]);  // Boundary: q[512] is 0\n            for (integer i = 1; i < 511; i = i + 1) begin\n                next_q[i] = (q[i-1] & ~q[i] & ~q[i+1]) | (~q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i] & q[i+1]);\n            end\n            q <= next_q;  // Update state\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update (sequential logic)\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= A; // Reset to state A\n        else \n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A, B, C: out = 0;\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'b1111; // \"f\"\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = sel ? b : a;\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module flipflop(\n    input clk,\n    input D,\n    output reg Q\n);\n    always @(posedge clk) begin\n        Q <= D;\n    end\nendmodule\n\nmodule mux2to1(\n    input select,\n    input a,\n    input b,\n    output y\n);\n    assign y = select ? a : b;\nendmodule\n\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output Q\n);\n    wire mux_out;\n    \n    mux2to1 u1 (\n        .select(L),\n        .a(q_in),\n        .b(r_in),\n        .y(mux_out)\n    );\n    \n    flipflop u2 (\n        .clk(clk),\n        .D(mux_out),\n        .Q(Q)\n    );\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            out <= out | (prev_in & ~in); // Detect 1-to-0 transition and set the bit\n            prev_in <= in;               // Store current input for next cycle comparison\n        end\n    end\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "Here is the completed Verilog module implementing the combinational logic for the requested next-state and output equations:\n\n```verilog\nmodule top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    wire S     = state[0];\n    wire S1    = state[1];\n    wire S11   = state[2];\n    wire S110  = state[3];\n    wire B0    = state[4];\n    wire B1    = state[5];\n    wire B2    = state[6];\n    wire B3    = state[7];\n    wire Count = state[8];\n    wire Wait  = state[9];\n\n    // Next-state logic\n    assign S_next      = S & ~d | S1 & ~d | S11 & ~d | S110 & ~d & ~B0 & ack;\n    assign S1_next     = S & d | S1 & d;\n    assign B3_next     = B2;  // Always transitions from B2 to B prochaine"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= 2'b01; // Reset to weakly not-taken\n        else if (train_valid) begin\n            if (train_taken && state < 2'b11)\n                state <= state + 2'b01; // Increment\n            else if (!train_taken && state > 2'b00)\n                state <= state - 2'b01; // Decrement\n        end\n    end\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in)\n            8'b???????1: pos = 3'd0;\n            8'b??????10: pos = 3'd1;\n            8'b?????100: pos = 3'd2;\n            8'b????1000: pos = 3'd3;\n            8'b???10000: pos = 3'd4;\n            8'b??100000: pos = 3'd5;\n            8'b?1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0; // No bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n    always @* begin\n        // Default all outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Check scancode and assert the appropriate output\n        case (scancode)\n            16'he06b: left = 1;  // Left arrow\n            16'he072: down = 1;  // Down arrow\n            16'he074: right = 1; // Right arrow\n            16'he075: up = 1;    // Up arrow\n        endcase\n    end\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // Instantiate four full adders\n    full_adder fa0 (\n        .a(x[0]),\n        .b(y[0]),\n        .cin(1'b0),\n        .s(sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a(x[1]),\n        .b(y[1]),\n        .cin(c1),\n        .s(sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a(x[2]),\n        .b(y[2]),\n        .cin(c2),\n        .s(sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a(x[3]),\n        .b(y[3]),\n        .cin(c3),\n        .s(sum[3]),\n        .cout(c4)\n    );\n\n    // Overflow bit\n    assign sum[4] = c4;\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output s,\n    output cout\n);\n    assign s = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    // Intermediate wires for connecting gates\n    wire and1_out;\n    wire and2_out;\n\n    // First layer: Two AND gates\n    assign and1_out = a & b;\n    assign and2_out = c & d;\n\n    // Second layer: OR gate\n    assign out = and1_out | and2_out;\n\n    // Inverted output\n    assign out_n = ~out;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    // Internal shift register storage\n    reg [7:0] Q;\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable) \n            Q <= {Q[6:0], S}; // Shift left, MSB shifted in first\n    end\n\n    // Multiplexer logic for output selection\n    always @(*) begin\n        case ({A, B, C}) // 3-input logic selects the appropriate Q[n]\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater logic: only active in heating mode and if too cold\n    assign heater = mode & too_cold;\n\n    // Air conditioner logic: only active in cooling mode and if too hot\n    assign aircon = ~mode & too_hot;\n\n    // Fan logic: active if fan is manually requested or either heater or air conditioner is active\n    assign fan = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Minimum Sum-of-Products (SOP)\n    assign out_sop = (~a & b & c & d) | (a & b & c & ~d) | (a & b & c & d);\n\n    // Minimum Product-of-Sums (POS)\n    assign out_pos = (a | ~b | ~c | ~d) & (~a | ~b | ~c | d) & (~a | ~b | ~c | ~d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;  // Reset to 32'h1\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};  // Galois LFSR with taps at 32, 22, 2, and 1\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (b & d) | (a & (c | d));\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing 4-input NAND gate for the first output\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    \n    // Implementing 4-input NAND gate for the second output\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) out_both: Check if both the input bit and its left neighbour are '1'\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // (2) out_any: Check if either the input bit or its right neighbour are '1'\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // (3) out_different: Check if the input bit is different from its left neighbour (wrapping around for in[3])\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000; // Default case for safety\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Reset the counter to 0\n        end\n        else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0; // Wrap around to 0 when reaching 9\n            end\n            else begin\n                q <= q + 4'd1; // Increment the counter\n            end\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // in2 is inverted and ANDed with in1\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [1:0] { \n        STATE_A = 2'b00, \n        STATE_B = 2'b01 \n    } state_t;\n    state_t state, next_state;\n\n    // Asynchronous reset and state update\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_B; // Reset to state B\n        else\n            state <= next_state; // Update state\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = (in) ? STATE_A : STATE_B;\n            STATE_B: next_state = (in) ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Default fallback (should not happen)\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0; // Default fallback (should not happen)\n        endcase\n    end\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    reg q_pos, q_neg;\n\n    // Flip-flop triggered on the positive edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Flip-flop triggered on the negative edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Combine outputs from both edges\n    always @(*) begin\n        q = clk ? q_pos : q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*)\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 0;\n        endcase\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiating submodules\n    A u1(.x(x), .y(y), .z(a1_out));\n    A u2(.x(x), .y(y), .z(a2_out));\n    B u3(.x(x), .y(y), .z(b1_out));\n    B u4(.x(x), .y(y), .z(b2_out));\n\n    // Logic connections\n    assign or_out = a1_out | b1_out;\n    assign and_out = a2_out & b2_out;\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the register\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};       // Rotate right by 1 bit\n                2'b10: q <= {q[98:0], q[99]};       // Rotate left by 1 bit\n                default: q <= q;                    // No rotation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'b0;       // Reset counter to 0\n        else if (q == 10'd999)\n            q <= 10'b0;       // Wrap around to 0 after reaching 999\n        else\n            q <= q + 10'b1;   // Increment counter\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in; // NOT gate implementation\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // State transition logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | \n                           (state[3] & ~in) | (state[4] & ~in) | (state[5] & ~in) | \n                           (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in | state[7] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;        // No change\n            2'b01: Q <= 1'b0;     // Reset\n            2'b10: Q <= 1'b1;     // Set\n            2'b11: Q <= ~Q;       // Toggle\n        endcase\n    end\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    \n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    localparam LEFT = 1'b0, RIGHT = 1'b1;\n\n    // State register\n    reg current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                if (bump_left || bump_right)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_left || bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default safety case\n        endcase\n    end\n\n    // State update logic (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= LEFT; // Reset state\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic (Moore outputs depend on state only)\n    always @(*) begin\n        case (current_state)\n            LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Intermediate wires for AND gates\n    wire and1, and2, and3, and4;\n\n    // AND gate outputs\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    // OR gate outputs\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    reg [2:0] Y; // Internal register to hold the next state\n\n    // Combinational logic for the next state (Y) and output (z)\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                Y = x ? 3'b001 : 3'b000;\n                z = 0;\n            end\n            3'b001: begin\n                Y = x ? 3'b100 : 3'b001;\n                z = 0;\n            end\n            3'b010: begin\n                Y = x ? 3'b001 : 3'b010;\n                z = 0;\n            end\n            3'b011: begin\n                Y = x ? 3'b010 : 3'b001;\n                z = 1;\n            end\n            3'b100: begin\n                Y = x ? 3'b100 : 3'b011;\n                z = 1;\n            end\n            default: begin\n                Y = 3'b000; // Default safe state\n                z = 0;\n            end\n        endcase\n        Y0 = Y[0]; // Assign the LSB of the next state to Y0\n    end\n\n    // Sequential logic to update the state on the clock edge\n    always @(posedge clk) begin\n        Y <= y; // Update the current state\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n\n    // Wire connections\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) \n            counter <= data; // Load the counter with the input value\n        else if (counter != 0)\n            counter <= counter - 1; // Decrement counter if not zero\n    end\n\n    assign tc = (counter == 0); // Assert tc when counter reaches zero\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        S1   = 3'b001,\n        S11  = 3'b010,\n        S110 = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE:   next_state = (data) ? S1 : IDLE;\n            S1:     next_state = (data) ? S11 : IDLE;\n            S11:    next_state = (data) ? S11 : S110;\n            S110:   next_state = (data) ? S1101 : IDLE;\n            S1101:  next_state = S1101; // Remain in this state\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (current_state == S1101)\n            start_shifting <= 1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0; // Reset outputs to zero\n        else\n            q <= d;    // Capture input d on positive clock edge\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (~prev_in & in); // Detect rising edges\n        prev_in <= in;             // Store the previous value of 'in'\n    end\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd1; // Reset to 1\n        else if (q == 4'd10) \n            q <= 4'd1; // Wrap around to 1\n        else \n            q <= q + 1; // Increment the counter\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'b100; // Reset q to 4 when a is 1\n        end else begin\n            q <= q + 1; // Increment q when a is 0\n            if (q == 3'b110) \n                q <= 3'b000; // Reset q to 0 on overflow\n        end\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001;  // Reset to initial non-zero state\n        end else begin\n            q <= {q[3:0], q[4] ^ q[2]};  // Shift and tap XOR (bits 5 and 3)\n        end\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // Check if result is zero\n        result_is_zero = (out == 8'b0) ? 1 : 0;\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "Here is the Verilog code based on the provided Karnaugh map:\n\n```verilog\nmodule top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x)\n\t\t\t4'b0000, 4'b0002, 4'b0003: f = 0; // Entries with a 0 in the K-Map\n\t\t\t4'b0111, 4'b1010: f ---"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = (~c & d) | (c & b) | (c & a);\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in MSB first\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            // Decrement q\n            q <= q - 1;\n        end\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena);\n\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'b000;       // Reset the counter\n            shift_ena <= 1'b1;     // Enable shift for 4 cycles\n        end else if (shift_ena) begin\n            count <= count + 3'b001;\n            if (count == 3'b011)   // After 4 cycles\n                shift_ena <= 1'b0; // Disable shift\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Reset counter to 0\n        else\n            q <= q + 1;   // Increment counter\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    // Simplify the Karnaugh map to its minimal expression: out = b | (!a & c)\n    assign out = b | (~a & c);\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[.)\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Reset the counter to 0\n        else if (q == 4'd9) \n            q <= 4'd0; // Wrap around after counting to 9\n        else \n            q <= q + 4'd1; // Increment the counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n\n    reg [1:0] state, next_state;\n    reg done_reg;\n\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) \n            state <= IDLE;\n        else \n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3])\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            done_reg <= 0;\n        else if (state == BYTE3)\n            done_reg <= 1;\n        else\n            done_reg <= 0;\n    end\n\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;   // AND all 4 inputs\n    assign out_or = |in;    // OR all 4 inputs\n    assign out_xor = ^in;   // XOR all 4 inputs\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam S000 = 3'b000,\n               S001 = 3'b001,\n               S010 = 3'b010,\n               S011 = 3'b011,\n               S100 = 3'b100;\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= S000;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S000: next_state = (x == 1'b0) ? S000 : S001;\n            S001: next_state = (x == 1'b0) ? S001 : S100;\n            S010: next_state = (x == 1'b0) ? S010 : S001;\n            S011: next_state = (x == 1'b0) ? S001 : S010;\n            S100: next_state = (x == 1'b0) ? S011 : S100;\n            default: next_state = S000; // Should not occur\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S011, S100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "Here is the complete Verilog code for the described FSM:\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A,      // Reset state\n        B,      // Output f = 1 for one clock cycle\n        C,      // Monitor x for sequence 1, 0, 1\n        D,      // Output g = 1 and monitor y\n        E,      // Maintain g = 1 permanently\n        F       // Set g = 0 permanently\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] x_monitor_count;\n    reg [1:0] y_check_count;\n\n    // State transition logic\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        f = 0;\n        g = 0;\n\n        case (state)\n            A: begin\n                next_state = B;\n            end\n            B: begin\n                f = 1;  // Set f = 1 for one clock cycle\n                next_state = C;\n            end\n            C: begin\n                if (x_monitor_count == 3)  // Sequence detected\n                    next_state = D;\n            end\n            Result"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34; // Reset q to 0x34\n        else\n            q <= d;     // Update q with d\n    end\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n    assign parity = ^in; // XOR all bits of the input 'in' for even parity\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // State transition and output logic\n    always @(*) begin\n        case (state)\n            2'b00: begin // State A\n                next_state = (in == 0) ? 2'b00 : 2'b01; // A -> A or A -> B\n            end\n            2'b01: begin // State B\n                next_state = (in == 0) ? 2'b10 : 2'b01; // B -> C or B -> B\n            end\n            2'b10: begin // State C\n                next_state = (in == 0) ? 2'b00 : 2'b11; // C -> A or C -> D\n            end\n            2'b11: begin // State D\n                next_state = (in == 0) ? 2'b10 : 2'b01; // D -> C or D -> B\n            end\n            default: begin\n                next_state = 2'b00; // Default to state A\n            end\n        endcase\n    end\n\n    // Output logic based on current state\n    assign out = (state == 2'b11) ? 1'b1 : 1'b0; // Output 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\n    always @(*) begin\n        if (x && y)\n            z = 1;         // Both x and y are 1 -> z = 1\n        else if (x)\n            z = 0;         // x is 1, y is 0 -> z = 0\n        else if (y)\n            z = 0;         // y is 1, x is 0 -> z = 0\n        else\n            z = 1;         // Both x and y are 0 -> z = 1\n    end\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State Flip-Flop (Sequential logic)\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // State Table (Combinational logic)\n    always @* begin\n        case (current_state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @* begin\n        case (current_state)\n            E, F: z = 1'b1; // Output is 1 for states E and F\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Reset all flip-flops to 0\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0]; // Update lower byte\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8]; // Update upper byte\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge);\n\n    reg [7:0] in_d; // Register to store the delayed version of 'in'\n    \n    always @(posedge clk) begin\n        in_d <= in;               // Capture the delayed input\n        pedge <= ~in_d & in;      // Detect 0 to 1 transitions\n    end\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a,\n    output reg p,\n    output reg q\n);\n    always @(posedge clock) begin\n        if (a)\n            p <= 1;\n        else\n            p <= 0;\n    end\n\n    always @(negedge clock) begin\n        q <= p;\n    end\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load the input data into q\n        end else begin\n            q[0] <= q[1];  // Boundary condition: q[-1] = 0\n            q[511] <= q[510];  // Boundary condition: q[512] = 0\n            // Update internal cells based on Rule 90\n            for (int i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) out_both: Check if a bit and its left neighbour are both 1\n    assign out_both = in[99:1] & in[98:0];\n\n    // (2) out_any: Check if a bit or its right neighbour is 1\n    assign out_any = in[99:1] | in[98:0];\n\n    // (3) out_different: Check if a bit is different from its left neighbour\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena) \n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel*4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // For sel=9 to 15, all bits are '1'\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;          // Bitwise OR\n    assign out_or_logical = |(a | b);       // Logical OR (reduce OR over all bits)\n    assign out_not = {~b, ~a};              // Concatenate NOT b in [5:3] and NOT a in [2:0]\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\nalways @(*) begin\n    // State transition logic\n    case (state)\n        4'b0001: next_state = (in == 1'b0) ? 4'b0001 : 4'b0010; // A\n        4'b0010: next_state = (in == 1'b0) ? 4'b0100 : 4'b0010; // B\n        4'b0100: next_state = (in == 1'b0) ? 4'b0001 : 4'b1000; // C\n        4'b1000: next_state = (in == 1'b0) ? 4'b0100 : 4'b0010; // D\n        default: next_state = 4'b0001; // Default to state A\n    endcase\nend\n\n// Output logic\nassign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output is 1 only in state D\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        // Compare 'a' and 'b', store the smaller in 'min'\n        min = (a < b) ? a : b;\n        // Compare 'min' and 'c'\n        min = (min < c) ? min : c;\n        // Compare 'min' and 'd'\n        min = (min < d) ? min : d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n    assign out = (~c & ~d & (~a | b)) | (c & d & (a | ~b)) | (~c & d & ~b) | (c & ~d & b);\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_W1 = 2'b10\n    } state_t;\n\n    reg [1:0] state, next_state;\n    reg [1:0] w_count; // to track w=1 count over 3 cycles\n    reg [1:0] cycle_count; // to track number of cycles\n\n    // State transition logic\n    always @(*) begin\n        next_state = state; // Default to staying in the same state\n        z = 0; // Default output\n\n        case (state)\n            STATE_A: begin\n                if (s) next_state = STATE_B; // Transition to B when s = 1\n            end\n\n            STATE_B: begin\n                if (cycle_count == 2) begin\n                    if (w_count == 2) \n                        z = 1;\n                    next_state = STATE_B; // Remain in STATE_B after evaluation\n                end else begin\n                    next_state = STATE_B; // Continue counting\n                end\n            end\n        endcase\ne[end\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3; // Highest priority bit\n            4'b01??: pos = 2'd2;\n            4'b001?: pos = 2'd1;\n            4'b0001: pos = 2'd0; // Lowest priority bit\n            default: pos = 2'd0; // Default case when no bit is high\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON:  next_state = (k) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State update logic with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine: output determined by state only)\n    always_comb begin\n        out = (state == ON) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    // Drive the output to logic low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always @(posedge clk) begin\n        out <= in ^ out;\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0; // Asynchronous reset to zero\n        end else if (load) begin\n            q <= data; // Load data when load is high\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right with 0 padding on MSB\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (x2 & ~x3) | (x1 & x3);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            q <= 8'b0;  // Reset output to 0\n        else \n            q <= d;     // Latch data on positive edge of clk\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;       // AND reduction\n    assign out_or = |in;        // OR reduction\n    assign out_xor = ^in;       // XOR reduction\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b; // XOR for sum\n    assign cout = a & b; // AND for carry-out\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Default value when not overheated\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0; // Default when arrived\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    localparam OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate inputs and append two 1 bits at the LSB\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    // Assign concatenated bits to outputs\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d) | \n               (~a & b & ~c & d) | \n               (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | \n               (a & ~b & c & ~d) | \n               (a & b & ~c & ~d) | \n               (a & b & c & d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum reg [0:0] {STATE_B = 1'b0, STATE_A = 1'b1} state_t;\n    state_t current_state, next_state;\n\n    // State transition and output logic (Moore FSM)\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_B;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: next_state = (in) ? STATE_B : STATE_A;\n            STATE_A: next_state = (in) ? STATE_A : STATE_B;\n            default: next_state = STATE_B; // Should not occur\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1'b1;\n            STATE_A: out = 1'b0;\n            default: out = 1'b0; // Should not occur\n        endcase\n    end\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = ~(in1 ^ in2);\n\n    // XOR gate\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    // Assign each mux_in output based on its respective K-map logic\n    assign mux_in[0] = ~c & d;  // (cd = 01)\n    assign mux_in[1] = d;       // (cd = 10 or 11)\n    assign mux_in[2] = c;       // (cd = 11)\n    assign mux_in[3] = c | d;   // (cd = 10 or 11)\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n    // State encoding: one-hot\n    reg [1:0] state, next_state;\n    localparam A = 2'b01, B = 2'b10;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? B : B;\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == A) ? x : ~x;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state; // Move to next state\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a && b) \n            state <= ~state; // Toggle state\n        else if (a && ~b) \n            state <= 0;      // Reset state to 0\n        else if (~a && b) \n            state <= 1;      // Set state to 1\n        else \n            state <= state;  // Maintain state\n    end\n\n    assign q = state; // q mirrors the state\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000, 4'b0011, 4'b1000, 4'b1011, 4'b1100, 4'b1101, 4'b1110: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE    = 3'd0,\n        ONE     = 3'd1,\n        TWO     = 3'd2,\n        THREE   = 3'd3,\n        FOUR    = 3'd4,\n        FIVE    = 3'd5,\n        SIX     = 3'd6,\n        ERROR   = 3'd7\n    } state_t;\n\n    state_t state, next_state;\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic and Next state logic (Moore FSM)\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err  = 0;\n        next_state = state;\n\n        case (state)\n            IDLE: begin\n                if (in) next_state = ONE;\n                else next_state = IDLE;\n            end\n            ONE: begin\n                if (in) next_state = TWO;\n                else next_state = IDLE;\n            end\n            TWO: begin\n                if (in) next_state = THREE;\n                else next_state = IDLE;\n            end\n            THREE: begin\n                if (in) next_state = FOUR;\n                else next_state = IDLE;\n            end\n            FOUR: begin\n                if (in) next_state = FIVE;\n                else next_state = IDLE;\n            end\n            FIVE: begin\n                if (in) next_state = SIX;\n                else next_state = IDLE;\n            end\n            SIX: begin\n                if (in) next_state = ERROR;\n                else begin\n                    next_state = IDLE;\n                    flag = 1;  // 01111110 detected\n                end\n            end\n            ERROR: begin\n                if (in) next_state = ERROR;\n                else next_state = IDLE;\n                \n                err = 1;  // 7 or more 1s detected\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n\n        // Handle zero insertion (discard logic)\n        if (state == FIVE && !in) begin\n            disc = 1;  // 0111110 detected (discard bit)\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        MATCH = 3'b001,\n        LOAD_DELAY = 3'b010,\n        COUNTDOWN = 3'b011,\n        FINISHED = 3'b100\n    } state_t;\n\n    reg [2:0] state, next_state;\n    reg [3:0] pattern_shift, delay;\n    reg [13:0] counter; // Counter for delay cycles (0-16000 max for delay=15)\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state and datapath logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if (pattern_shift == 4'b1101)\n                    next_state = MATCH;\n            end\n            MATCH: begin\n                if (&delay) // When 4 bits are fully shifted in\n                    next_state = LOAD_DELAY;\n            end\n            LOAD_DELAY: begin\n                next_state = COUNTDOWN;\n            end\n            COUNTDOWN: begin\n                counting = 1;\n                if (counter == 14'd0)\n                    next_state = FINISHED;\n            end\n            FINISHED: begin\n                done = 1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Shift register and delay load logic\n    always @(posedge clk) begin\n        if (reset) begin\n            pattern_shift <= 4'b0;\n            delay <= 4'b0;\n        end else if (state == IDLE) begin\n            pattern_shift <= {pattern_shift[2:0], data}; // Shift in data\n        end else if (state == MATCH) begin\n            delay <= {delay[2:0], data}; // Shift in delay[3:0]\n        end\n    end\n\n    // Timer counter logic\n    always @(posedge clk) begin\n        if (reset || state == LOAD_DELAY) begin\n            counter <= (delay + 1) * 14'd1000; // Initialize counter\n            count <= delay;\n        end else if (state == COUNTDOWN && counter > 0) begin\n            counter <= counter - 1;\n            if (counter % 1000 == 0 && count > 0)\n                count <= count - 1; // Reduce remaining time every 1000 cycles\n        end\n    end\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State variable to keep track of previous water level change\n    reg previous_higher;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset state: All outputs asserted and state set for \"low water level\"\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n            previous_higher <= 0; // Assume water was low for a long time\n        end\n        else begin\n            // Control logic\n            casez (s)\n                3'b111: begin // Above s[3]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin // Between s[3] and s[2]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= previous_higher ? 1 : 0; // Add supplemental flow if previous level was lower\n                    previous_higher <= 1; // Current level is higher than before\n                end\n                3'b001: begin // Between s[2] and s[1]\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= previous_higher ? 1 : 0; // Add supplemental flow if previous level was lower\n                    previous_higher <= 1; // Current level is higher than before\n                end\n                3'b000: begin // Below s[1]\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1; // Supplemental flow always open\n                    previous_higher <= 0; // Current level is lower than before\n                end\n                default: begin\n                    // Default to safe state: no flow\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    // Define FSM states\n    typedef enum logic [2:0] {\n        IDLE,      // Waiting for start bit\n        START,     // Detect start bit\n        DATA,      // Receiving data bits\n        STOP,      // Verify stop bit\n        ERROR      // Wait for proper stop bit\n    } state_t;\n\n    state_t state, next_state;\n    logic [3:0] bit_count; // Counts data bits received\n    logic [7:0] data_byte; // Holds received data byte\n    logic done_reg;\n\n    // Sequential logic for state transitions and counters\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done_reg <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA)\n                bit_count <= bit_count + 1;\n            else\n                bit_count <= 0;\n\n            if (state == STOP && in == 1)\n                done_reg <= 1;\n            else\n                done_reg <= 0;\n        end\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in == 0)\n                    next_state = START; // Start bit detected\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                next_state = DATA; // Move to DATA state\n            end\n            DATA: begin\n                if (bit_count == 8)\n                    next_state = STOP; // All 8 data bits received\n                else\n                    next_state = DATA;\n            end\n            STOP: begin\n                if (in == 1)\n                    next_state = IDLE; // Stop bit is correct, go IDLE\n                else\n                    next_state = ERROR; // Stop bit incorrect, go ERROR\n            end\n            ERROR: begin\n                if (in == 1)\n                    next_state = IDLE; // Wait for stop bit, reset state machine\n                else\n                    next_state = ERROR;\n            end\n            default: next_state = IDLE; // Default state\n        endcase\n    end\n\n    // Output assignment\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_count; // For counting 8 data bits\n    reg [7:0] shift_reg; // Register to store the received data bits\n\n    // State transition logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'b0;\n            shift_reg <= 8'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state; // Update state\n            if (state == DATA && next_state == DATA) begin\n                shift_reg <= {in, shift_reg[7:1]}; // Shift data LSB first\n                bit_count <= bit_count + 1; // Increment bit counter\n            end else if (state != DATA) begin\n                bit_count <= 3'b0; // Reset bit counter in non-DATA states\n            end\n            if (state == STOP && next_state == IDLE) begin\n                done <= 1'b1; // Assert done signal\n                out_byte <= shift_reg; // Assign the received byte\n            end else begin\n                done <= 1'b0;\n            end\n        end\n    end\n\n    // Next-state logic\n    always_comb begin\n        next_state = state; // Default to stay in the same state by default\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) next_state = START; // Detect start bit\n            end\n            START: begin\n                // Assume one clock cycle for the first transition\n                next_state = DATA; // Go to DATA state\n            end\n            DATA: begin\n                if (bit_count == 3'd7) next_state = STOP; // After 8 bits, move to STOP\n            end\n            STOP: begin\n                if (in == 1'b1) next_state = IDLE; // Valid stop bit, move to IDLE\n                else next_state = ERROR; // Invalid stop bit, go to ERROR\n            end\n            ERROR: begin\n                if (in == 1'b1) next_state = IDLE; // Wait for idle line (1)\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    reg [6:0] global_history;               // Global branch history register\n    reg [1:0] PHT [127:0];                  // 128-entry Pattern History Table (PHT) with 2-bit counters\n\n    wire [6:0] predict_index = predict_pc ^ global_history;  // XOR PC and global history for index\n    wire [6:0] train_index = train_pc ^ train_history;       // XOR PC and train history for index\n\n    // Initialize outputs\n    assign predict_history = global_history;                  // Output current global history\n    assign predict_taken = (PHT[predict_index] >= 2'b10);     // Taken if 2-bit counter >= 2\n\n    integer i;\n    // Reset/initialize logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;                           // Reset global history to 0\n            for (i = 0; i < 128; i = i + 1)                  // Reset PHT to \"weakly not taken\" (2'b01)\n                PHT[i] <= 2'b01;\n        end else begin\n            if (train_valid) begin\n                // Training logic: Update PHT\n                if (train_taken && PHT[train_index] != 2'b11)\n                    PHT[train_index] <= PHT[train_index] + 1;  // Increment if taken\n                else if (!train_taken && PHT[train_index] != 2'b00)\n                    PHT[train_index] <= PHT[train_index] - 1;  // Decrement if not taken\n\n                // Recover global history if mispredicted\n                if (train_mispredicted)\n                    global_history <= {train_history[5:0], train_taken};\n                else\n                    global_history <= {global_history[5:0], train_taken};\n            end else if (predict_valid) begin\n                // Update global history on predictions\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALL_LEFT = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT = 3'b100,\n        DIG_RIGHT = 3'b101,\n        SPLAT = 3'b110\n    } state_t;\n\n    state_t state, next_state;\n\n    // Falling counter\n    reg [4:0] fall_counter;\n\n    // State transition logic\n    always_comb begin\n        next_state = state; // Default: stay in current state\n\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n            end\n            FALL_LEFT: begin\n                if (ground && fall_counter > 20)\n                    next_state = SPLAT;\n                else if (ground && fall_counter <= 20)\n                    next_state = WALK_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground && fall_counter > 20)\n                    next_state = SPLAT;\n                else if (ground && fall_counter <= 20)\n                    next_state = WALK_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                next_state = SPLAT; // Stay in SPLAT state forever\n            end\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            DIG_LEFT: digging = 1;\n            DIG_RIGHT: digging = 1;\n            SPLAT: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\n    // Falling counter logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            fall_counter <= 0;\n        else if ((state == FALL_LEFT || state == FALL_RIGHT) && !ground)\n            fall_counter <= fall_counter + 1;\n        else if (ground)\n            fall_counter <= 0;\n    end\n\n    // State update logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n// State encoding\ntypedef enum logic [2:0] {\n    WAIT_PATTERN = 3'd0,\n    SHIFT        = 3'd1,\n    COUNT        = 3'd2,\n    DONE_NOTIFY  = 3'd3\n} state_t;\n\nstate_t state, next_state;\nreg [3:0] pattern_reg, shift_count;\n\n// Sequential state logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= WAIT_PATTERN;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Pattern detection\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        pattern_reg <= 4'b0;\n    end else begin\n        pattern_reg <= {pattern_reg[2:0], data};\n    end\nend\n\n// State transition logic\nalways @(*) begin\n    // Default outputs\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n\n    case (state)\n        WAIT_PATTERN: begin\n            if (pattern_reg == 4'b1101) begin\n                next_state = SHIFT;\n            end else begin\n                next_state = WAIT_PATTERN;\n            end\n        end\n        SHIFT: begin\n            shift_ena = 1'b1;\n            if (shift_count == 4'd3) begin\n                next_state = COUNT;\n            end else begin\n                next_state = SHIFT;\n            end\n        end\n        COUNT: begin\n            counting = 1'b1;\n            if (done_counting) begin\n                next_state = DONE_NOTIFY;\n            end else begin\n                next_state = COUNT;\n            end\n        end\n        DONE_NOTIFY: begin\n            done = 1'b1;\n            if (ack) begin\n                next_state = WAIT_PATTERN;\n            end else begin\n                next_state = DONE_NOTIFY;\n            end\n        end\n        default: next_state = WAIT_PATTERN;\n    endcase\nend\n\n// Shift count logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        shift_count <= 4'd0;\n    end else if (state == SHIFT) begin\n        shift_count <= shift_count + 4'd1;\n    end else begin\n        shift_count <= 4'd0;\n    end\nend\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    reg [3:0] neighbors; // To count alive neighbors\n    integer i, j, x, y;\n\n    // Neighbor lookup considering toroidal wrapping\n    function [3:0] count_neighbors;\n        input [255:0] grid;\n        input integer row, col;\n        integer dx, dy, nx, ny;\n        begin\n            count_neighbors = 0;\n            for (dx = -1; dx <= 1; dx = dx + 1) begin\n                for (dy = -1; dy <= 1; dy = dy + 1) begin\n                    if (dx != 0 || dy != 0) begin\n                        nx = (row + dx + 16) % 16;\n                        ny = (col + dy + 16) % 16;\n                        count_neighbors = count_neighbors + grid[nx * 16 + ny];\n                    end\n                end\n            end\n        end\n    endfunction\n\n    // Always block for the game logic\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the initial grid state\n        end else begin\n            reg [255:0] next_q;\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    neighbors = count_neighbors(q, i, j);\n                    case (neighbors)\n                        4'd2: next_q[i * 16 + j] = q[i * 16 + j];    // State remains the same\n                        4'd3: next_q[i * 16 + j] = 1;               // Cell becomes alive\n                        default: next_q[i * 16 + j] = 0;            // Cell becomes dead\n                    endcase\n                end\n            end\n            q <= next_q; // Update the grid state\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // Define states\n    typedef enum logic [2:0] {\n        WALK_LEFT   = 3'b000,\n        WALK_RIGHT  = 3'b001,\n        FALL_LEFT   = 3'b010,\n        FALL_RIGHT  = 3'b011,\n        DIG_LEFT    = 3'b100,\n        DIG_RIGHT   = 3'b101\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;  // Reset to walking left on async reset\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic (combinational)\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)                next_state = FALL_LEFT;  // Fall if no ground\n                else if (dig)               next_state = DIG_LEFT;   // Start digging\n                else if (bump_left)         next_state = WALK_RIGHT; // Switch direction\n                else                        next_state = WALK_LEFT;  // Keep walking left\n            end\n            WALK_RIGHT: begin\n                if (!ground)                next_state = FALL_RIGHT; // Fall if no ground\n                else if (dig)               next_state = DIG_RIGHT;  // Start digging\n                else if (bump_right)        next_state = WALK_LEFT;  // Switch direction\n                else                        next_state = WALK_RIGHT; // Keep walking right\n            end\n            FALL_LEFT: begin\n                if (ground)                 next_state = WALK_LEFT;  // Resume walking left when ground reappears\n                else                        next_state = FALL_LEFT;  // Keep falling\n            end\n            FALL_RIGHT: begin\n                if (ground)                 next_state = WALK_RIGHT; // Resume walking right when ground reappears\n                else                        next_state = FALL_RIGHT; // Keep falling\n            end\n            DIG_LEFT: begin\n                if (!ground)                next_state = FALL_LEFT;  // Fall if ground disappears while digging\n                else                        next_state = DIG_LEFT;   // Keep digging on left\n            end\n            DIG_RIGHT: begin\n                if (!ground)                next_state = FALL_RIGHT; // Fall if ground disappears while digging\n                else                        next_state = DIG_RIGHT;  // Keep digging on right\n            end\n            default: next_state = WALK_LEFT;  // Default state\n        endcase\n    end\n\n    // Output logic (combinational)\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT:  walk_left  = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALL_LEFT,\n            FALL_RIGHT: aaah       = 1;\n            DIG_LEFT:   digging    = 1;\n            DIG_RIGHT:  digging    = 1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            ss <= 8'h00;\n            mm <= 8'h00;\n            hh <= 8'h12;\n            pm <= 1'b0;\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                // Increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    // Increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh <= hh + 8'h01;\n                    end\n                end else begin\n                    mm <= mm + 8'h01;\n                end\n            end else begin\n                ss <= ss + 8'h01;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        LEFT = 2'b00,\n        RIGHT = 2'b01,\n        FALLING_LEFT = 2'b10,\n        FALLING_RIGHT = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (Next state logic)\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALLING_LEFT;\n                else if (bump_left || (bump_left && bump_right))\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALLING_RIGHT;\n                else if (bump_right || (bump_left && bump_right))\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALLING_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALLING_LEFT;\n            end\n            FALLING_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALLING_RIGHT;\n            end\n            default: next_state = LEFT; // Should not happen\n        endcase\n    end\n\n    // State flip-flops (Sequential logic)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n                aaah = 1'b0;\n            end\n            FALLING_LEFT, FALLING_RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b1;\n            end\n            default: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n    // Enable signals for digits\n    assign ena[1] = (q[3:0] == 4'd9);                // Enable tens digit when ones digit rolls over\n    assign ena[2] = ena[1] && (q[7:4] == 4'd9);      // Enable hundreds digit when tens digit rolls over\n    assign ena[3] = ena[2] && (q[11:8] == 4'd9);     // Enable thousands digit when hundreds digit rolls over\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'd0;  // Reset all digits to zero\n        end else begin\n            // Ones digit\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 1;\n\n            // Tens digit\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 1;\n            end\n\n            // Hundreds digit\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 1;\n            end\n\n            // Thousands digit\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = 0;               // State A\n        3'b001: Y2 = w;               // State B\n        3'b010: Y2 = ~w;              // State C\n        3'b011: Y2 = 0;               // State D\n        3'b100: Y2 = 1;               // State E\n        3'b101: Y2 = 1;               // State F\n        default: Y2 = 0;              // Default fallback\n    endcase\nend\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n    assign ringer = ring & ~vibrate_mode; // Turn on ringer if ring is active and not in vibrate mode\n    assign motor = ring & vibrate_mode;  // Turn on motor if ring is active and in vibrate mode\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND gate using assign statement\n    assign out_assign = a & b;\n\n    // AND gate using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero);\n    assign zero = 1'b0; // Always output LOW\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (a)\n            q <= ~q;  // Toggle q when a is 1\n        else\n            q <= q;   // Hold q when a is 0\n    end\n    \nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        STATE_ZERO = 2'b00,  // Initial state (before any 1 is encountered)\n        STATE_ONE  = 2'b01   // After encountering the first '1'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (synchronous)\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_ZERO;\n        else\n            state <= next_state;\n    end\n\n    // Next state and output logic (combinational)\n    always_comb begin\n        case (state)\n            STATE_ZERO: begin\n                z = ~x; // Invert while in STATE_ZERO\n                if (x == 1'b1)\n                    next_state = STATE_ONE;\n                else\n                    next_state = STATE_ZERO;\n            end\n            STATE_ONE: begin\n                z = x; // Pass through while in STATE_ONE\n                next_state = STATE_ONE; // Remain in STATE_ONE\n            end\n            default: begin\n                z = 0;\n                next_state = STATE_ZERO; // Default fallback\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (combinational)\n    always @(*) begin\n        case (state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\n    // State register with asynchronous reset (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r) \n            q <= 1'b0;  // Reset output to 0 on active high reset\n        else \n            q <= d;     // Store the input on clock edge\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into shift register\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1 bit\n                2'b01: q <= q << 8; // Shift left by 8 bits\n                2'b10: q <= $signed(q) >>> 1; // Arithmetic shift right by 1 bit\n                2'b11: q <= $signed(q) >>> 8; // Arithmetic shift right by 8 bits\n                default: q <= q; // Default case (shouldn't be hit)\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // Detected '1'\n        S2 = 2'b10  // Detected '10'\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        z = 1'b0;\n\n        case (current_state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1; // Sequence \"101\" detected\n                end else\n                    next_state = S0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // Define state encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Sequential logic for state update\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic: z is high in states E and F\n    always @(*) begin\n        z = (state == E || state == F);\n    end\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [7:0] byte1, byte2, byte3;\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            IDLE:  next_state = (in[3]) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            byte1 <= 8'b0;\n            byte2 <= 8'b0;\n            byte3 <= 8'b0;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n        end else begin\n            done <= 1'b0; // Default is not done\n            \n            case (state)\n                BYTE1: byte1 <= in;\n                BYTE2: byte2 <= in;\n                BYTE3: begin\n                    byte3 <= in;\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1'b1; // Signal done after receiving the third byte\n                end\n                default: begin\n                    byte1 <= byte1;\n                    byte2 <= byte2;\n                    byte3 <= byte3;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y, // One-hot encoded states\n    input w,       // Input signal\n    output Y1,     // Next state for y[1]\n    output Y3      // Next state for y[3]\n);\n\n    // Deriving Y1\n    assign Y1 = y[0] & w; // Transition A -> B is when y[0] (A) and w = 1\n\n    // Deriving Y3\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[3] & w); \n    // y[1] & ~w (B -> D), y[2] & ~w (C -> D), y[3] & w (D -> F)\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;  // Output the same 3-bit vector\n    assign o2 = vec[2]; // Extract bit 2\n    assign o1 = vec[1]; // Extract bit 1\n    assign o0 = vec[0]; // Extract bit 0\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        out = c ^ d ^ a ^ b; // XOR of all inputs\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n    // XOR using an assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using a combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using a clocked always block (with flip-flop, output delayed)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y, // One-hot encoded state inputs\n    input w,       // Input signal\n    output Y2,     // Next-state logic for y[2] (state B)\n    output Y4      // Next-state logic for y[4] (state D)\n);\n\n    // Next-state logic for Y2 (state B)\n    assign Y2 = y[1] & ~w; // From state A to B on w=0\n\n    // Next-state logic for Y4 (state D)\n    assign Y4 = (y[2] & w) | // From state B to D on w=1\n                (y[3] & w) | // From state C to D on w=1\n                (y[4] & w) | // From state D to D on w=1\n                (y[6] & w);  // From state F to D on w=1\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;        // Load R into Q when L is asserted\n        else if (E)\n            Q <= w;        // Shift w into Q when E is asserted\n    end\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n    // Intermediate signals\n    wire xor_in, and_in, or_in;\n    wire q1, q2, q3;\n    wire nq1, nq2, nq3;\n\n    // XOR input with the flip-flop's output\n    assign xor_in = x ^ q1;\n    // AND input with the flip-flop's complemented output\n    assign and_in = x & nq2;\n    // OR input with the flip-flop's complemented output\n    assign or_in = x | nq3;\n\n    // D flip-flops\n    reg q1_reg, q2_reg, q3_reg;\n    always @(posedge clk) begin\n        q1_reg <= xor_in;\n        q2_reg <= and_in;\n        q3_reg <= or_in;\n    end\n\n    assign q1 = q1_reg;\n    assign nq1 = ~q1_reg;\n    assign q2 = q2_reg;\n    assign nq2 = ~q2_reg;\n    assign q3 = q3_reg;\n    assign nq3 = ~q3_reg;\n\n    // XNOR gate combining all flip-flop outputs\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = c | b;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end\n        else begin\n            reg [511:0] next_q; // Temporary register to store the next state\n            integer i;\n\n            for (i = 0; i < 512; i = i + 1) begin\n                // Handle boundaries (q[-1] and q[512] are both 0)\n                reg left  = (i == 0) ? 0 : q[i-1];\n                reg right = (i == 511) ? 0 : q[i+1];\n\n                // Rule 110 logic\n                next_q[i] = (left & q[i] & ~right) | \n                            (left & ~q[i] & right) |\n                            (~left & q[i] & right) |\n                            (~left & q[i] & ~right);\n            end\n\n            q <= next_q; // Update q to the next state\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State definitions\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (current_state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register and reset logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (current_state)\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'b1111; // Assigning `f` based on the context.\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out = sel ? b : a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module submodule(\n    input clk,\n    input L,\n    input D0,  // Data from mux input 0\n    input D1,  // Data from mux input 1\n    output reg Q\n);\n    wire mux_out;\n    \n    // 2-1 Multiplexer\n    assign mux_out = (L) ? D1 : D0;\n\n    // D Flip-Flop\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\nendmodule\n\n// Hierarchical module top_module\nmodule top_module(\n    input clk,\n    input L,\n    input [2:0] q_in,\n    input [2:0] r_in,\n    output [2:0] Q\n);\n    // Instantiate three submodules for each bit\n    submodule u0 (.clk(clk), .L(L), .D0(q_in[1] ^ q_in[2]), .D1(r_in[0]), .Q(Q[0]));\n    submodule u1 (.clk(clk), .L(L), .D0(q_in[0]), .D1(r_in[1]), .Q(Q[1]));\n    submodule u2 (.clk(clk), .L(L), .D0(q_in[2]), .D1(r_in[2]), .Q(Q[2]));\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    reg [31:0] in_d;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0; // Reset the output\n        end else begin\n            in_d <= in; // Capture the input in delayed register\n            out <= out | (in_d & ~in); // Set 'out' when transition from 1 to 0 occurs\n        end\n    end\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    // 8 D flip-flops triggered on the positive edge of clk\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    assign s = a + b;\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "Here is the complete Verilog module with the required logic implemented:\n\n```verilog\nmodule top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State encoding\n    wire S    = state[0];\n    wire S1   = state[1];\n    wire S11  = state[2];\n    wire S110 = state[3];\n    wire B0   = state[4];\n    wire B1   = state[5];\n    wire B2   = state[6];\n    wire B3   = state[7];\n    wire Count = state[8];\n    wire Wait = state[9];\n\n    // Next-state logic\n    assign S_next     = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next    = (S & d);\n    assign S1_next    = (S & d);\n    assign Count_next = B3;\u200d``"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;  // Increment counter\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;  // Decrement counter\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    always @(*) begin\n        casez (in) // Using casez for \"don't care\" matches\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default: pos = 3'd0; // Default case if no bits are high\n        endcase\n    end\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        // Default: all outputs are deasserted\n        left  = 0;\n        down  = 0;\n        right = 0;\n        up    = 0;\n\n        // Check scancode and set outputs accordingly\n        case (scancode)\n            16'he06b: left  = 1; // Left arrow\n            16'he072: down  = 1; // Down arrow\n            16'he074: right = 1; // Right arrow\n            16'he075: up    = 1; // Up arrow\n            default: ; // No arrow keys pressed\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4; // Carry wires\n\n    // Instantiate full adders for each bit\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n\n    assign sum[4] = c4; // Overflow bit\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Reset history to zero\n        end else if (train_mispredicted) begin\n            // Handle misprediction: concatenate train_history with train_taken\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            // Update history for branch prediction\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n    wire and1, and2; // Intermediate wires\n\n    assign and1 = a & b;  // First AND gate\n    assign and2 = c & d;  // Second AND gate\n    assign out = and1 | and2; // OR gate\n    assign out_n = ~out;  // NOT gate\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q; // 8-bit shift register\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift left and input S into Q[0]\n        end\n    end\n\n    // Multiplexer logic\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case (optional, should not occur)\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n    // Logic for heater and air conditioner\n    assign heater = mode && too_cold;        // Heater on if mode = heating and too cold\n    assign aircon = ~mode && too_hot;       // Aircon on if mode = cooling and too hot\n\n    // Fan logic: On if heater, aircon, or fan_on requested\n    assign fan = heater || aircon || fan_on;\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // SOP Form: out_sop = a'b'c'd + a'b'cd + abcd\n    assign out_sop = (~a & ~b & ~c & d) | (~a & ~b & c & d) | (a & b & c & d);\n\n    // POS Form: out_pos = (a + b + c' + d')(a + b' + c + d')(a' + b' + c + d)\n    assign out_pos = (a | b | ~c | ~d) & (a | ~b | c | ~d) & (~a | ~b | c | d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset to initial value\n        end else begin\n            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift with taps\n        end\n    end\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b | c) & d;\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    assign p1y = ~(p1a & p1b & p1c & p1d); // 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d); // 4-input NAND gate\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n    always @(*) begin\n        out = 0;\n        for (integer i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // (1) out_both: Check if both a bit and its left neighbour are '1'.\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // (2) out_any: Check if a bit or its right neighbour is '1'.\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    \n    // (3) out_different: Check if a bit is different from its left neighbour (with wrapping).\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'b0000; // Reset counter to 0\n        else if (slowena) begin\n            if (q == 4'b1001) \n                q <= 4'b0000; // Reset to 0 after reaching 9\n            else \n                q <= q + 1; // Increment counter\n        end\n        // If slowena is low, the counter holds its value\n    end\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = in1 & ~in2; // AND gate with in2 inverted\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            STATE_B: next_state = in ? STATE_B : STATE_A; // B --0--> A, B --1--> B\n            STATE_A: next_state = in ? STATE_A : STATE_B; // A --1--> A, A --0--> B\n            default: next_state = STATE_B; // Default case to handle unexpected states\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_B; // Asynchronous reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        case (state)\n            STATE_B: out = 1; // B output is 1\n            STATE_A: out = 0; // A output is 0\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    reg q_pos, q_neg;\n\n    // Capture data on the positive edge of the clock\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Capture data on the negative edge of the clock\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Combine the outputs from both clock edges\n    always @(*) begin\n        q = clk ? q_pos : q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n    // Submodule A definition\n    function A(input x, input y);\n        A = (x ^ y) & x;\n    endfunction\n\n    // Submodule B definition\n    function B(input x, input y);\n        begin\n            case ({x, y})\n                2'b00: B = 1;\n                2'b01: B = 0;\n                2'b10: B = 0;\n                2'b11: B = 1;\n                default: B = 0;\n            endcase\n        end\n    endfunction\n\n    // Intermediate wires\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate submodules A and B\n    assign a1_out = A(x, y);\n    assign b1_out = B(x, y);\n    assign a2_out = A(x, y);\n    assign b2_out = B(x, y);\n\n    // Logic for the top module\n    assign or_out = a1_out | b1_out;\n    assign and_out = a2_out & b2_out;\n    assign z = or_out ^ and_out;\n\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data; // Load data into the register\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};        // Rotate right\n                2'b10: q <= {q[98:0], q[99]};       // Rotate left\n                default: q <= q;                    // No rotation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\nalways @(posedge clk) begin\n    if (reset) \n        q <= 10'd0;\n    else if (q == 10'd999)\n        q <= 10'd0;\n    else\n        q <= q + 10'd1;\nend\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    // State transition logic\n    assign next_state[0] = state[0] & ~in | state[1] & ~in | state[2] & ~in | state[3] & ~in | state[4] & ~in |\n                           state[5] & ~in | state[7] & ~in | state[8] & ~in | state[9] & ~in;\n    assign next_state[1] = state[0] & in | state[8] & in | state[9] & in;\n    assign next_state[2] = state[1] & in;\n    assign next_state[3] = state[2] & in;\n    assign next_state[4] = state[3] & in;\n    assign next_state[5] = state[4] & in;\n    assign next_state[6] = state[5] & in;\n    assign next_state[7] = state[6] & in | state[7] & in;\n    assign next_state[8] = state[5] & ~in;\n    assign next_state[9] = state[6] & ~in;\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;        // No change\n            2'b01: Q <= 1'b0;     // Reset\n            2'b10: Q <= 1'b1;     // Set\n            2'b11: Q <= ~Q;       // Toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n\n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n\n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n    // Define state encoding\n    typedef enum logic [1:0] {\n        STATE_LEFT = 2'b01,\n        STATE_RIGHT = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_LEFT: begin\n                if (bump_left || bump_right) \n                    next_state = STATE_RIGHT;\n                else \n                    next_state = STATE_LEFT;\n            end\n            STATE_RIGHT: begin\n                if (bump_left || bump_right) \n                    next_state = STATE_LEFT;\n                else \n                    next_state = STATE_RIGHT;\n            end\n            default: next_state = STATE_LEFT; // Default state\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_LEFT; // Reset to walk left\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Moore output logic\n    always @(*) begin\n        case (state)\n            STATE_LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            STATE_RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n            default: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    // Intermediate wires for AND gate outputs\n    wire and1_out, and2_out, and3_out, and4_out;\n    \n    // AND gates\n    assign and1_out = p1a & p1b & p1c; // First 3-input AND gate for p1y\n    assign and2_out = p1d & p1e & p1f; // Second 3-input AND gate for p1y\n    assign and3_out = p2a & p2b;       // First 2-input AND gate for p2y\n    assign and4_out = p2c & p2d;       // Second 2-input AND gate for p2y\n    \n    // OR gates\n    assign p1y = and1_out | and2_out;  // OR result for p1y\n    assign p2y = and3_out | and4_out;  // OR result for p2y\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\n    reg [2:0] next_state;\n\n    always @(*) begin\n        // Next state logic\n        case (y)\n            3'b000: next_state = (x == 1'b0) ? 3'b000 : 3'b001;\n            3'b001: next_state = (x == 1'b0) ? 3'b001 : 3'b100;\n            3'b010: next_state = (x == 1'b0) ? 3'b010 : 3'b001;\n            3'b011: next_state = (x == 1'b0) ? 3'b001 : 3'b010;\n            3'b100: next_state = (x == 1'b0) ? 3'b011 : 3'b100;\n            default: next_state = 3'b000; // Default case for safety\n        endcase\n        \n        // Output logic\n        z = (y == 3'b011 || y == 3'b100) ? 1'b1 : 1'b0;\n        Y0 = next_state[0];\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] count;\n\n    always @(posedge clk) begin\n        if (load) \n            count <= data;          // Load the counter with the input data\n        else if (count > 0) \n            count <= count - 1;     // Decrement the counter if it's greater than 0\n    end\n\n    assign tc = (count == 0);        // Terminal count is asserted when count reaches 0\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE    = 3'b000,\n        S1      = 3'b001,\n        S11     = 3'b010,\n        S110    = 3'b011,\n        S1101   = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE:   next_state = data ? S1 : IDLE;\n            S1:     next_state = data ? S11 : IDLE;\n            S11:    next_state = data ? S11 : S110;\n            S110:   next_state = data ? S1101 : IDLE;\n            S1101:  next_state = S1101; // Remains in S1101 forever\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (current_state == S1101)\n            start_shifting <= 1'b1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 8'b0; // Reset sets the output to zero\n        else \n            q <= d; // Otherwise assign input d to q\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (in & ~prev_in); // Detect 0 to 1 transitions\n        prev_in <= in;             // Store the previous state\n    end\n    \nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1; // Reset counter to 1\n        else if (q == 4'd10)\n            q <= 4'd1; // Wrap around to 1 after reaching 10\n        else\n            q <= q + 1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a) \n            q <= 3'b100;\n        else \n            q <= q + 1;\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Initialize to 1 on reset\n        end else begin\n            // Tap positions at 5 and 3\n            q <= {q[3] ^ q[0], q[4:1]}; // XOR feedback and shift\n        end\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        out = do_sub ? (a - b) : (a + b);\n\n        // Set result_is_zero if the output is zero\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        f = (x[3] & x[4]) | (~x[3] & x[4]) | (x[3] & ~x[4] & x[2]);\n    end\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1E: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2E: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3D: begin out = 4'd7; valid = 1'b1; end\n            8'h3E: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "To implement the circuit based on the Karnaugh map, we first derive the simplified Boolean expressions:\n\nGiven the Karnaugh map:\n- For `ab = 01`, `cd` leads to output `d` or `do not care`.\n- For `cd = 00`, parts reaccurring association instructions"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in data MSB first\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement shift register\n            q <= q - 1;\n        end\n    end\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'b000;\n            shift_ena <= 1'b1;\n        end else if (count < 3'b100) begin\n            count <= count + 1;\n            shift_ena <= 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Reset the counter to 0\n        else\n            q <= q + 1;   // Increment the counter\n    end\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n    // Simplified logic from the Karnaugh map: out = b | a\n    assign out = b | a;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State flip-flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if      (r[1])                    next_state = B;\n                else if (r[2])                    next_state = C;\n                else if (r[3])                    next_state = D;\n                else                              next_state = A;\n            end\n            B: begin\n                if      (r[1])                    next_state = B;\n                else                              next_state = A;\n            end\n            C: begin\n                if      (r[2])                    next_state = C;\n                else                              next_state = A;\n            end\n            D: begin\n                if      (r[3])                    next_state = D;\n                else                              next_state = A;\n            end\n            default:                              next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default grant signals\n        case (state)\n            B: g[1] = 1'b1; // Grant for r1\n            C: g[2] = 1'b1; // Grant for r2\n            D: g[3] = 1'b1; // Grant for r3\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Synchronous reset\n        else if (q == 4'd9) \n            q <= 4'd0; // Reset counter to 0 on reaching 9\n        else \n            q <= q + 1'b1; // Increment counter\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n    // State declarations\n    typedef enum logic [1:0] {\n        IDLE, BYTE1, BYTE2, BYTE3\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            IDLE:   next_state = (in[3] == 1'b1) ? BYTE1 : IDLE;\n            BYTE1:  next_state = BYTE2;\n            BYTE2:  next_state = BYTE3;\n            BYTE3:  next_state = (in[3] == 1'b1) ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // 4-input AND\n    assign out_or  = |in;  // 4-input OR\n    assign out_xor = ^in;  // 4-input XOR\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] y, next_y;\n\n    // State transition based on table\n    always @(*) begin\n        case (y)\n            3'b000: next_y = x ? 3'b001 : 3'b000;\n            3'b001: next_y = x ? 3'b100 : 3'b001;\n            3'b010: next_y = x ? 3'b001 : 3'b010;\n            3'b011: next_y = x ? 3'b010 : 3'b001;\n            3'b100: next_y = x ? 3'b100 : 3'b011;\n            default: next_y = 3'b000; // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (y)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\n    // State register (with synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            y <= 3'b000;\n        else\n            y <= next_y;\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101,\n        G = 3'b110\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] count; // For monitoring y\n\n    // Sequential logic (state transitions)\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n            count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == E || state == F) begin\n                count <= count + 1;\n            end else begin\n                count <= 0;\n            end\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        f = 0;\n        g = 0;\n\n        case (state)\n            A: begin // Beginning state\n                if (resetn) next_state = B;\n            end\n\n            B: begin // Output f = 1 for one cycle\n                f = 1;\n                next_state = C;\n            end\n\n            C: begin // Wait for x = 1, 0, 1 sequence\n                if (x) next_state = D;\n            end\n\n            D: begin\n                if (!x) next_state = E;\n            end\n\n            E: begin\n                if (x) next_state = F;\n            end\n\n            F: begin // Set g = 1 and monitor y\n                g = 1;\n                if (y) next_state = G;\n                else if (count == 2) next_state = A; // Reset if y != 1 within 2 cycles\n            end\n\n            G: begin // g = 1 permanently\n                g = 1;\n            end\n\n            default: next_state = A; // Should never hit here\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // Reset to 0x34\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = ^in; // XOR all bits in 'in' to compute even parity\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n    // State transition logic\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // State A\n            2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State B\n            2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // State C\n            2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State D\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 2'b11) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output reg z);\n\n    always @(*) begin\n        if (x && y)\n            z = 1;  // When both x and y are 1, z is 1\n        else if (x && !y)\n            z = 0;  // When x is 1 and y is 0, z is 0\n        else if (!x && y)\n            z = 0;  // When x is 0 and y is 1, z is 0\n        else\n            z = 1;  // When both x and y are 0, z is 1\n    end\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic (state table)\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A; // Safety default\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\n    always @(posedge clk) begin\n        if (!resetn)\n            q <= 16'b0; // Synchronous reset, active-low\n        else begin\n            if (byteena[0]) \n                q[7:0] <= d[7:0]; // Update lower byte\n            if (byteena[1]) \n                q[15:8] <= d[15:8]; // Update upper byte\n        end\n    end\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge);\n\n    reg [7:0] in_d; // One-cycle delayed version of 'in'.\n\n    always @(posedge clk) begin\n        in_d <= in;                      // Save the previous state of 'in'.\n        pedge <= (~in_d & in);           // Detect 0 to 1 transitions.\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    always @(posedge clock) begin\n        if (a)\n            p <= 1'b1;\n        else\n            p <= 1'b0;\n    end\n\n    always @(negedge clock) begin\n        q <= p;\n    end\n    \nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load the input data into q\n        end else begin\n            q[0] <= q[1] ^ 0;  // Left boundary (q[-1] = 0)\n            q[511] <= q[510] ^ 0;  // Right boundary (q[512] = 0)\n            // Update internal cells using XOR of neighbors\n            for (integer i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i - 1] ^ q[i + 1];\n            end\n        end\n    end\n    \nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    // Compare A and B\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // Generate out_both\n    assign out_both = in[99:1] & in[98:0]; // Bitwise AND between in[99:1] and in[98:0]\n\n    // Generate out_any\n    assign out_any = in[99:1] | in[98:0]; // Bitwise OR between in[99:1] and in[98:0]\n\n    // Generate out_different\n    assign out_different = in ^ {in[0], in[99:1]}; // XOR in with a rotated version of itself\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n    always @(*) begin\n        if (ena) \n            q = d;\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel*4 +: 4];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Set all bits to '1' for sel = 9 to 15\n        endcase\n    end\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR\n    assign out_or_logical = |(a | b);\n    \n    // Inverse (NOT)\n    assign out_not[5:3] = ~b;  // Upper half: NOT of b\n    assign out_not[2:0] = ~a;  // Lower half: NOT of a\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        min = a; // Start with a as the minimum\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n    \nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    assign out = (~a & ~b & ~c) | (~a & b & ~d) | (~a & ~c & d) |\n                 (~b & c & d) | (~a & c & b) | (a & b & ~c) |\n                 (a & b & d) | (b & c & d);\n                 \nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State declaration\n    typedef enum logic [1:0] {\n        A, // Reset state\n        B, // Waiting for 3 clock cycles\n        C  // Checking w conditions\n    } state_t;\n    \n    state_t state, next_state;\n    reg [1:0] w_count; // Counter for w=1 occurrences\n    reg [1:0] cycle_count; // For counting 3 clock cycles\n\n    // State transition logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output assignment\n    always_comb begin\n        // Default assignments\n        next_state = state;\n        z = 0;\n\n        case (state)\n            A: begin\n                if (s)\n                    next_state = B;\n            end\n            B: begin\n                if (cycle_count == 2) begin\n                    if (w_count == 2)\n                        z = 1; // Set z to 1 if exactly 2 'w=1' occurrences\n                    next_state = B; // Continue checking after 3 cycles\n                end\n            end\n        endcase\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    assign out = {{24{in[7]}}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n    \n    always @(posedge clk) begin\n        if (!resetn)        // Active-low synchronous reset\n            shift_reg <= 4'b0;\n        else\n            shift_reg <= {shift_reg[2:0], in}; // Shift right with input\n    end\n    \n    assign out = shift_reg[3]; // Output MSB\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3; // Highest priority, bit 3\n            4'b01??: pos = 2'd2; // Next priority, bit 2\n            4'b001?: pos = 2'd1; // Next priority, bit 1\n            4'b0001: pos = 2'd0; // Lowest priority, bit 0\n            default: pos = 2'd0; // All inputs zero\n        endcase\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // Define states\n    typedef enum logic [0:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State Transition Logic (Combinational)\n    always_comb begin\n        case (current_state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON:  next_state = (k) ? OFF : ON;\n        endcase\n    end\n\n    // State Register (Synchronous with Asynchronous Reset)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= OFF;\n        else\n            current_state <= next_state;\n    end\n\n    // Output Logic (Moore Machine)\n    always_comb begin\n        out = (current_state == ON);\n    end\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    assign out = 1'b0; // Drive the output to logic low (0)\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    assign one = 1'b1; // Drive the output to logic high\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n    always @(posedge clk) begin\n        out <= in ^ out;\n    end\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0; // Asynchronous reset to zero\n        end else if (load) begin\n            q <= data; // Load data into the shift register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, q[3] becomes 0\n        end\n    end\n    \nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (~x3 & x2) | (x3 & x1);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0; // Reset output to 0\n        else\n            q <= d;    // Update output with input d\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;  // AND reduction operator\n    assign out_or = |in;   // OR reduction operator\n    assign out_xor = ^in;  // XOR reduction operator\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b;  // XOR for sum\n    assign cout = a & b; // AND for carry-out\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        // Shut off computer if the CPU is overheated\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        // Determine whether to keep driving\n        if (!arrived)\n            keep_driving = !gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic {OFF = 0, ON = 1} state_t;\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= OFF;  // Synchronous reset to OFF state\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for next state and output\n    always @(*) begin\n        case (current_state)\n            OFF: begin\n                out = 0;\n                if (j) \n                    next_state = ON;\n                else \n                    next_state = OFF;\n            end\n\n            ON: begin\n                out = 1;\n                if (k) \n                    next_state = OFF;\n                else \n                    next_state = ON;\n            end\n\n            default: begin  // Safety case\n                next_state = OFF;\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate input vectors and append two 1 bits (30 bits + 2 bits = 32 bits)\n    wire [31:0] concat_result = {a, b, c, d, e, f, 2'b11};\n\n    // Split 32-bit result into 4 output vectors\n    assign w = concat_result[31:24];\n    assign x = concat_result[23:16];\n    assign y = concat_result[15:8];\n    assign z = concat_result[7:0];\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (~a & ~b & ~c & ~d) | \n               (~a & ~b & c & d)  | \n               (~a & b & d)       | \n               (a & ~b & d)       | \n               (a & b & ~c & ~d)  | \n               (a & b & c & d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a,\n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum logic [0:0] {\n        STATE_A = 0,\n        STATE_B = 1\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B; // Synchronous reset to B\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: next_state = (in) ? STATE_B : STATE_A;\n            STATE_A: next_state = (in) ? STATE_A : STATE_B;\n        endcase\n    end\n\n    // Output logic (Moore: depends only on state)\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1;\n            STATE_A: out = 0;\n        endcase\n    end\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    logic xnor_out;\n\n    // Two-input XNOR\n    assign xnor_out = ~(in1 ^ in2);\n\n    // Two-input XOR\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n    // Assign values based on K-map\n    assign mux_in[0] = ~c & d; // When ab = 00\n    assign mux_in[1] = 0;      // When ab = 01\n    assign mux_in[2] = c | d;  // When ab = 11\n    assign mux_in[3] = 1;      // When ab = 10\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [1:0] state, next_state;\n    localparam A = 2'b01, B = 2'b10;\n\n    // State transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A; // Reset to state A\n        else \n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = A;\n                    z = 0;\n                end\n            end\n            B: begin\n                if (x) begin\n                    next_state = B;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            default: begin\n                next_state = A; // Default to state A for safety\n                z = 0;\n            end\n        endcase\n    end    \nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a & b) begin\n            state <= ~state; // Toggle state\n        end else begin\n            state <= state;  // Retain state\n        end\n    end\n\n    assign q = state; // Output is the current state\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    always_comb begin\n        case (x)\n            4'b0000: f = 1;\n            4'b0001: f = 0;\n            4'b0010: f = 0;\n            4'b0011: f = 1;\n            4'b0100: f = 0;\n            4'b0101: f = 0;\n            4'b0110: f = 0;\n            4'b0111: f = 0;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            4'b1010: f = 0;\n            4'b1011: f = 1;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            4'b1110: f = 1;\n            4'b1111: f = 0;\n            default: f = 0; // Default case for safety\n        endcase\n    end\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // States\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        ONE = 3'b001,\n        TWO = 3'b010,\n        THREE = 3'b011,\n        FOUR = 3'b100,\n        FIVE = 3'b101,\n        SIX = 3'b110,\n        ERROR = 3'b111\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always_comb begin\n        disc = 0;\n        flag = 0;\n        err = 0;\n        next_state = current_state;\n\n        case (current_state)\n            IDLE: begin\n                if (in)\n                    next_state = ONE;\n            end\n            ONE: begin\n                if (in)\n                    next_state = TWO;\n                else\n                    next_state = IDLE;\n            end\n            TWO: begin\n                if (in)\n                    next_state = THREE;\n                else\n                    next_state = IDLE;\n            end\n            THREE: begin\n                if (in)\n                    next_state = FOUR;\n                else\n                    next_state = IDLE;\n            end\n            FOUR: begin\n                if (in)\n                    next_state = FIVE;\n                else\n                    next_state = IDLE;\n            end\n            FIVE: begin\n                if (in)\n                    next_state = SIX;\n                else\n                    next_state = IDLE;\n            end\n            SIX: begin\n                if (in) begin\n                    next_state = ERROR; // More than 6 ones means error\n                end else begin\n                    flag = 1; // Six consecutive ones followed by zero is a flag\n                    next_state = IDLE;\n                end\n            end\n            ERROR: begin\n                err = 1; // Seven or more consecutive ones indicates error\n                if (!in)\n                    next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State update logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Discard logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            disc <= 0;\n        else if ((current_state == FIVE) && (in == 0))\n            disc <= 1; // Discard bit after 5 consecutive 1s\n        else\n            disc <= 0;\n    end\n\n    // Outputs flag and err are handled directly in combinational logic above\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "```verilog\nmodule top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n    reg [3:0] shift_reg, delay;\n    reg [15:0] delay_counter;\n    reg [3:0] remaining_time;\n    reg [2:0] state;\n\n    // State encoding\n    localparam IDLE       = 3'd0,\n               PATTERN    = 3'd1,\n               READ_DELAY = 3'd2,\n               COUNTING   = 3'd3,\n               DONE       = 3'd4;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 4'd0;\n            delay <= 4'd0;\n            delay_counter <= 16'd0;\n            count <= 4'd0;\n            remaining_time <= 4'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    done <= 1'b0;\n                    counting <= 1'b0;\n                    if (shift_reg == 4'b1101) begin\n                        state <= READ_DELAY;\n                    end\n                end\n\n                READ_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg[2:0] == 3'b111) begin // 4 bits done\n                        remaining_time <= {delay[2:0], data};\n                        state <= COUNTING;\n                        counting <= 1b"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        LOW = 2'b00,\n        MID_LOW = 2'b01,\n        MID_HIGH = 2'b10,\n        HIGH = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n    reg previous_level_lower;\n\n    // State transition logic\n    always @(*) begin\n        next_state = current_state;\n        fr3 = 0; fr2 = 0; fr1 = 0; dfr = 0; // Default outputs\n        case (current_state)\n            LOW: begin\n                fr3 = 1; fr2 = 1; fr1 = 1; // Max flow rate\n                if (s[1]) next_state = MID_LOW; // Water level rising into MID_LOW\n            end\n            MID_LOW: begin\n                fr2 = 1; fr1 = 1; // Nominal flow for MID_LOW\n                if (s[2]) begin\n                    next_state = MID_HIGH; // Rising into MID_HIGH\n                    dfr = previous_level_lower; // Add supplemental flow if rising\n                end else if (!s[1]) begin\n                    next_state = LOW; // Dropping to LOW\n                end\n            end\n            MID_HIGH: begin\n                fr1 = 1; // Nominal flow for MID_HIGH\n                if (s[3]) begin\n                    next_state = HIGH; // Rising into HIGH\n                end else if (!s[2]) begin\n                    next_state = MID_LOW; // Dropping to MID_LOW\n                    dfr = previous_level_lower; // Add supplemental flow if dropping\n                end\n            end\n            HIGH: begin\n                // No flow in HIGH\n                if (!s[3]) next_state = MID_HIGH; // Dropping to MID_HIGH\n            end\n        endcase\n    end\n\n    // State register and previous level tracking\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= LOW; // Reset to LOW state\n            previous_level_lower <= 1; // Assume prior state was lower\n        end else begin\n            previous_level_lower <= (next_state > current_state); // Track if rising\n            current_state <= next_state;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // Define state encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_counter; // Counter for 8 data bits\n    reg [7:0] data_reg;    // Register to store received data\n\n    // State transition block\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default: remain in the current state\n        case (state)\n            IDLE: begin\n                done = 0; // Byte not received yet\n                if (in == 1'b0) // Start bit detected\n                    next_state = START;\n            end\n            START: begin\n                if (in == 1'b0) // Remain in START (confirm start bit is still low)\n                    next_state = DATA;\n                else // Error, go back to IDLE\n                    next_state = IDLE;\n            end\n            DATA: begin\n                if (bit_counter == 3'd7) // Last data bit received\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1'b1) // Correct stop bit\n                    next_state = IDLE;\n                else // Stop bit incorrect, go to ERROR state\n                    next_state = ERROR;\n            end\n            ERROR: begin\n                if (in == 1'b1) // Wait until an idle line (logic 1)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Counter and data logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_counter <= 0;\n            data_reg <= 0;\n            done <= 0;\n        end\n        else begin\n            done <= 0; // Default: done is low\n            case (state)\n                START: begin\n                    bit_counter <= 0; // Clear counter at start bit\n                end\n                DATA: begin\n                    data_reg[bit_counter] <= in; // Shift in data bit\n                    bit_counter <= bit_counter + 1;\n                end\n                STOP: begin\n                    if (in == 1'b1) // If stop bit is correct\n                        done <= 1; // Signal byte received successfully\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE   = 3'b000,\n        START  = 3'b001,\n        DATA   = 3'b010,\n        STOP   = 3'b011,\n        ERROR  = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_count;\n    reg [7:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        next_state = state;\n        done = 1'b0; // Default: no valid byte received\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) // Detect start bit\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA; // Move to DATA state on next clock\n            end\n            DATA: begin\n                if (bit_count == 3'd7)\n                    next_state = STOP; // All 8 data bits received\n            end\n            STOP: begin\n                if (in == 1'b1) begin // Correct stop bit\n                    done = 1'b1;\n                    next_state = IDLE;\n                end else // Incorrect stop bit\n                    next_state = ERROR;\n            end\n            ERROR: begin\n                if (in == 1'b1) // Wait for stop bit before retrying\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // State update and data shifting\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'b0;\n            shift_reg <= 8'b0;\n            out_byte <= 8'b0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                DATA: begin\n                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit (LSB first)\n                    bit_count <= bit_count + 1'b1;\n                end\n                STOP: begin\n                    if (in == 1'b1) // Correct stop bit\n                        out_byte <= shift_reg;\n                    bit_count <= 3'b0; // Reset bit counter\n                end\n                ERROR: begin\n                    bit_count <= 3'b0; // Reset bit counter in error state\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n    \n    // Prediction interface\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    // Training interface\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n    // Parameters\n    localparam PHT_SIZE = 128;\n    localparam COUNTER_BITS = 2;\n\n    // Pattern History Table (PHT)\n    reg [COUNTER_BITS-1:0] PHT [PHT_SIZE-1:0];\n\n    // Global History Register (GHR)\n    reg [6:0] GHR;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            GHR <= 7'b0;\n        end else begin\n            // Training has higher precedence than prediction for updating GHR\n            if (train_valid) begin\n                if (train_mispredicted) begin\n                    GHR <= {train_history[5:0], train_taken};\n                end else begin\n                    GHR <= {GHR[5:0], train_taken};\n                end\n            end else if (predict_valid) begin\n                // GHR gets updated based on prediction\n                GHR <= {GHR[5:0], predict_taken};\n            end\n        end\n    end\n\n    // Prediction logic\n    always @(*) begin\n        predict_history = GHR;\n\n        if (predict_valid) begin\n            // XOR pc with GHR to generate index\n            wire [6:0] index = predict_pc ^ GHR;\n\n            // Access PHT, predict branch direction\n            predict_taken = PHT[index][COUNTER_BITS-1];\n        end else begin\n            predict_taken = 1'b0; // Default, no prediction made\n        end\n    end\n\n    // Training logic\n    always @(posedge clk) begin\n        if (train_valid) begin\n            // XOR pc with history for training\n            wire [6:0] index = train_pc ^ train_history;\n\n            // Saturating counter update\n            if (train_taken) begin\n                if (PHT[index] != 2'b11) begin\n                    PHT[index] <= PHT[index] + 1;\n                end\n            end else begin\n                if (PHT[index] != 2'b00) begin\n                    PHT[index] <= PHT[index] - 1;\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State declaration\n    typedef enum logic [2:0] {\n        WALK_LEFT  = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALL_LEFT  = 3'b010,\n        FALL_RIGHT = 3'b011,\n        DIG_LEFT   = 3'b100,\n        DIG_RIGHT  = 3'b101,\n        SPLATTER   = 3'b110\n    } state_t;\n\n    state_t state, next_state;\n    logic [4:0] fall_counter; // 5-bit counter to track fall duration\n\n    // State transition logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 5'd0;\n        end else begin\n            state <= next_state;\n\n            // Update fall counter\n            if (state == FALL_LEFT || state == FALL_RIGHT)\n                fall_counter <= fall_counter + 5'd1;\n            else\n                fall_counter <= 5'd0;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)                         next_state = FALL_LEFT;\n                else if (dig)                        next_state = DIG_LEFT;\n                else if (bump_left || bump_right)    next_state = WALK_RIGHT;\n                else                                 next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)                         next_state = FALL_RIGHT;\n                else if (dig)                        next_state = DIG_RIGHT;\n                else if (bump_left || bump_right)    next_state = WALK_LEFT;\n                else                                 next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (fall_counter > 5'd20 && ground)  next_state = SPLATTER;\n                else if (ground)                    next_state = WALK_LEFT;\n                else                                 next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (fall_counter > 5'd20 && ground)  next_state = SPLATTER;\n                else if (ground)                    next_state = WALK_RIGHT;\n                else                                 next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)                         next_state = FALL_LEFT;\n                else                                 next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)                         next_state = FALL_RIGHT;\n                else                                 next_state = DIG_RIGHT;\n            end\n            SPLATTER:                               next_state = SPLATTER;\n            default:                                next_state = WALK_LEFT; // Default safety case\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign walk_left  = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah       = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging    = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "Below is the concise and complete Verilog code for the finite-state machine (FSM) implementation as described:\n\n```verilog\nmodule top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE,        // Waiting for 1101 pattern\n        SHIFT,       // Shift 4 bits\n        COUNT,       // Counting delay\n        DONE,        // Notify user\n        WAIT_ACK     // Wait for ack\n    } state_t;\n\n    state_t state, next_state;\n    logic [3:0] pattern_reg;\n\n    // Detect 1101 pattern\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            pattern_reg <= 4'b0;\n        else\n            pattern_reg <= {pattern_reg[2:0], data};\n    end\n\n    wire detect_1101 = (pattern_reg == 4'b1101);\n\n    // State transition logic\n    always @(*) begin\n        // Default outputs\n        next_state = state;\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (detect_1101)\n                    next_state = SHIFT; // Transition to SHIFT state\n            end\n            \n            SHIFT: begin\n                shift_ena = 1'b1; // Assert shift_ena for 4 cycles\n                if (pattern_reg[3] == 1'b1) // 4 shifts are complete\n                    next_state = COUNT;\n            end\n            \n            COUNT: begin\n                counting = 1'b"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    // Count neighbors for a given cell\n    function [3:0] count_neighbors;\n        input integer x, y;\n        integer dx, dy, nx, ny;\n        begin\n            count_neighbors = 0;\n            for (dx = -1; dx <= 1; dx = dx + 1) begin\n                for (dy = -1; dy <= 1; dy = dy + 1) begin\n                    if (dx != 0 || dy != 0) begin // Exclude self\n                        nx = (x + dx + 16) % 16; // Wrap around horizontally\n                        ny = (y + dy + 16) % 16; // Wrap around vertically\n                        count_neighbors = count_neighbors + q[ny*16 + nx]; // Access cell state\n                    end\n                end\n            end\n        end\n    endfunction\n\n    integer x, y;\n    reg [255:0] next_q;\n\n    always @(*) begin\n        if (load)\n            next_q = data; // Load new data\n        else begin\n            next_q = 0;\n            for (y = 0; y < 16; y = y + 1) begin\n                for (x = 0; x < 16; x = x + 1) begin\n                    case (count_neighbors(x, y))\n                        2: next_q[y*16 + x] = q[y*16 + x]; // No change\n                        3: next_q[y*16 + x] = 1;           // Cell becomes alive\n                        default: next_q[y*16 + x] = 0;     // Cell dies\n                    endcase\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data; // Load initial state\n        else\n            q <= next_q; // Update state\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    typedef enum logic [2:0] {\n        WALK_LEFT, WALK_RIGHT, FALL_LEFT, FALL_RIGHT, DIG_LEFT, DIG_RIGHT\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (dig)\n                    next_state = DIG_LEFT;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (dig)\n                    next_state = DIG_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else\n                    next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else\n                    next_state = DIG_RIGHT;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State Update Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n            DIG_LEFT: begin\n                digging = 1;\n                walk_left = 1;\n            end\n            DIG_RIGHT: begin\n                digging = 1;\n                walk_right = 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= 8'h12; // 12 in BCD\n            mm <= 8'h00;\n            ss <= 8'h00;\n            pm <= 1'b0; // AM\n        end\n        else if (ena) begin\n            // Seconds counter\n            if (ss == 8'h59) begin\n                ss <= 8'h00; // Reset seconds\n                // Minutes counter\n                if (mm == 8'h59) begin\n                    mm <= 8'h00; // Reset minutes\n                    // Hours counter\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01; // Roll over to 1\n                        pm <= ~pm; // Toggle AM/PM\n                    end\n                    else if (hh == 8'h11) begin\n                        hh <= 8'h12; // Go to 12\n                    end\n                    else begin\n                        hh <= hh + 8'h01; // Increment hours\n                    end\n                end\n                else begin\n                    mm <= mm + 8'h01; // Increment minutes\n                end\n            end\n            else begin\n                ss <= ss + 8'h01; // Increment seconds\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    typedef enum logic [1:0] {\n        LEFT = 2'b00,\n        RIGHT = 2'b01,\n        FALL_LEFT = 2'b10,\n        FALL_RIGHT = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_LEFT;\n                else if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_RIGHT;\n                else if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;  // Default state\n        endcase\n    end\n\n    // State flip-flops\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        case (state)\n            LEFT: walk_left = 1;\n            RIGHT: walk_right = 1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nKeep your reasoning process short and concise. Please complete the Verilog code below and return the complete module code:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    // Enable signals logic\n    assign ena[1] = (q[3:0] == 4'd9);\n    assign ena[2] = ena[1] && (q[7:4] == 4'd9);\n    assign ena[3] = ena[2] && (q[11:8] == 4'd9);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n        end else begin\n            // Ones digit\n            if (q[3:0] == 4'd9) \n                q[3:0] <= 4'd0;\n            else \n                q[3:0] <= q[3:0] + 4'd1;\n\n            // Tens digit\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // Hundreds digit\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // Thousands digit\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\nendmodule"}
