{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,  // current state (A=3'b000, B=3'b001, \u2026, F=3'b101)\n    input        w,\n    output reg   Y2  // next\u2010state bit 2\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0;          // A -> next y[2]=0\n            3'b001: Y2 = 1'b1;          // B -> next y[2]=1\n            3'b010: Y2 = w ? 1'b1 : 1'b0; // C -> if w=1\u2192D(011):1 else\u2192E(100):0\n            3'b011: Y2 = 1'b0;          // D -> next y[2]=0\n            3'b100: Y2 = w ? 1'b1 : 1'b0; // E -> if w=1\u2192D(011):1 else\u2192E(100):0\n            3'b101: Y2 = 1'b1;          // F -> next y[2]=1\n            default: Y2 = 1'b0;         // unused states\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring==1 and vibrate_mode==1 \u2192 motor=1, ringer=0\n    // If ring==1 and vibrate_mode==0 \u2192 ringer=1, motor=0\n    // If ring==0 \u2192 both outputs = 0\n    assign motor  = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Continuous assignment for AND gate\n    assign out_assign = a & b;\n\n    // Combinational always block for AND gate\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Continuously drive the output low\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg   q\n);\n\n    // counts consecutive 1\u2019s seen on a (only 0 or 1)\n    reg cnt1;\n\n    always @(posedge clk) begin\n        if (a == 1'b0) begin\n            // any 0 on a: set q=1, reset the 1\u2032s counter\n            q    <= 1'b1;\n            cnt1 <= 1'b0;\n        end else begin\n            // a==1: increment the one\u2019s counter (max=1)\n            if (cnt1) begin\n                // second consecutive 1 \u2192 clear q\n                q    <= 1'b0;\n                cnt1 <= 1'b0;\n            end else begin\n                // first 1 seen\n                cnt1 <= 1'b1;\n                // leave q unchanged\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // active\u2010high asynchronous reset\n    input  x,       // serial input, LSB first\n    output z        // serial 2's\u2011complement output\n);\n\n    // State encoding\n    localparam ZERO = 1'b0,  // Haven't seen first '1' yet\n               ONES = 1'b1;  // Have seen first '1', now invert\n\n    reg state, next_state;\n\n    // State register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= ZERO;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @* begin\n        case (state)\n            ZERO: next_state = x ? ONES : ZERO;\n            ONES: next_state = ONES;\n            default: next_state = ZERO;\n        endcase\n    end\n\n    // Output logic (Mealy style)\n    //   before first '1': z = x\n    //   after first '1':  z = ~x\n    assign z = (state == ZERO) ? x : ~x;\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output reg out\n);\n\n    // state encoding\n    localparam A = 2'd0;\n    localparam B = 2'd1;\n    localparam C = 2'd2;\n    localparam D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // output logic (Moore)\n    always @(*) begin\n        case (state)\n            D: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse byte order: {B0,B1,B2,B3} \u2192 {B3,B2,B1,B0}\n    assign out = { in[7:0],   // byte0 \u2192 byte3\n                   in[15:8],  // byte1 \u2192 byte2\n                   in[23:16], // byte2 \u2192 byte1\n                   in[31:24]  // byte3 \u2192 byte0\n                 };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // D flip\u2011flop with active\u2011high synchronous reset\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             load,\n    input             ena,\n    input      [1:0]  amount,\n    input      [63:0] data,\n    output reg [63:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: // shift left by 1\n                    q <= q << 1;\n                2'b01: // shift left by 8\n                    q <= q << 8;\n                2'b10: // arithmetic shift right by 1\n                    q <= {q[63], q[63:1]};\n                2'b11: // arithmetic shift right by 8\n                    q <= {{8{q[63]}}, q[63:8]};\n                default:\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  aresetn,\n    input  x,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        S0 = 2'b00,  // no bits matched\n        S1 = 2'b01,  // seen \"1\"\n        S2 = 2'b10   // seen \"10\"\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register with async active\u2011low reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state and output logic (Mealy)\n    always @(*) begin\n        // Defaults\n        next_state = state;\n        z = 1'b0;\n\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n\n            S1: begin\n                if (x)\n                    next_state = S1; // still just \"1\"\n                else\n                    next_state = S2; // \"10\"\n            end\n\n            S2: begin\n                if (x) begin\n                    next_state = S1; // overlap, last '1'\n                    z = 1'b1;         // \"101\" detected\n                end else begin\n                    next_state = S0; // \"100\" no match\n                end\n            end\n\n            default: begin\n                next_state = S0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output reg   z\n);\n\n    // state encoding\n    localparam [2:0]\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // next\u2010state and output (Moore machine)\n    always @(*) begin\n        // default\n        next_state = A;\n        z = 1'b0;\n\n        case (state)\n            A: begin\n                z = 1'b0;\n                next_state = w ? A : B;     // 1\u2192A, 0\u2192B\n            end\n            B: begin\n                z = 1'b0;\n                next_state = w ? D : C;     // 1\u2192D, 0\u2192C\n            end\n            C: begin\n                z = 1'b0;\n                next_state = w ? D : E;     // 1\u2192D, 0\u2192E\n            end\n            D: begin\n                z = 1'b0;\n                next_state = w ? A : F;     // 1\u2192A, 0\u2192F\n            end\n            E: begin\n                z = 1'b1;\n                next_state = w ? D : E;     // 1\u2192D, 0\u2192E\n            end\n            F: begin\n                z = 1'b1;\n                next_state = w ? D : C;     // 1\u2192D, 0\u2192C\n            end\n            default: begin\n                z = 1'b0;\n                next_state = A;\n            end\n        endcase\n    end\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": ""}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,   // one\u2010hot state vector: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1,  // next\u2010state input for flip\u2010flop y[1] (B)\n    output       Y3   // next\u2010state input for flip\u2010flop y[3] (D)\n);\n\n    // Next\u2010B only when in A and w=1\n    assign Y1 = y[0] & w;\n    \n    // Next\u2010D when in B,C,E or F and w=0\n    // B->D on 0; C->D on 0; E->D on 0; F->D on 0\n    assign Y3 = ~w & ( y[1] | y[2] | y[4] | y[5] );\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the vector\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // The K\u2010map corresponds to the 4\u2010input parity function\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n    // Combinational split of 16-bit input into upper and lower bytes\n    assign out_lo = in[7:0];\n    assign out_hi = in[15:8];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // NOR gate implementation\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input  clk,\n    input  a,\n    input  b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    // 1) XOR via continuous assignment\n    assign out_assign = a ^ b;\n\n    // 2) XOR via combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) XOR via clocked always block (adds one-cycle delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y, \n    input        w,\n    output       Y2,  // next-hot bit for state B\n    output       Y4   // next-hot bit for state D\n);\n\n    // next-state for B = from A when w=0\n    assign Y2 = y[1] & ~w;\n    \n    // next-state for D = from B,C,E,F when w=1\n    assign Y4 = w & ( y[2] | y[3] | y[5] | y[6] );\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input   [7:0] sel,\n    output        out\n);\n    // variable bit\u2010select does the 256:1 mux\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // On every rising clock edge, decide between load, shift, or hold\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;      // Load mode\n        else if (E)\n            Q <= w;      // Shift mode\n        else\n            Q <= Q;      // Hold mode (no change)\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state bits, initialize to 0\n    reg q0 = 1'b0, q1 = 1'b0, q2 = 1'b0;\n\n    // next\u2010state logic\n    wire d0 = x ^  q0;   // XOR with its own output\n    wire d1 = x & ~q1;   // AND with complement of its own output\n    wire d2 = x | ~q2;   // OR  with complement of its own output\n\n    // state flip\u2010flops\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\n    // output is 3-input XNOR of the state bits\n    assign z = ~(q0 ^ q1 ^ q2);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n    // From the truth\u2010table/Q\u2013waveform analysis:\n    // q = 1 whenever b==1 or c==1, otherwise q=0.\n    assign q = b | c;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input       [511:0] data,\n    output reg  [511:0] q\n);\n\n    // Rule\u2010110 truth\u2010table vector: bit7=111\u21920, bit6=110\u21921, bit5=101\u21921, bit4=100\u21920, bit3=011\u21921, bit2=010\u21921, bit1=001\u21921, bit0=000\u21920\n    localparam [7:0] RULE = 8'b0110_1110;\n\n    // Pad q with zeros at both ends to simplify neighbor indexing\n    wire [513:0] pp = {1'b0, q, 1'b0};\n\n    // Compute next state for each cell\n    wire [511:0] nxt;\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : RULE110\n            // index = {left, center, right}\n            assign nxt[i] = RULE[{ pp[i], pp[i+1], pp[i+2] }];\n        end\n    endgenerate\n\n    // State update\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= nxt;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    // combinational selection based on c\n    always @* begin\n        case (c)\n            4'h0: q = b;       // c == 0 \u2192 b\n            4'h1: q = e;       // c == 1 \u2192 e\n            4'h2: q = a;       // c == 2 \u2192 a\n            4'h3: q = d;       // c == 3 \u2192 d\n            default: q = 4'hF; // c >= 4 \u2192 all ones\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    if (sel)\n        out = b;\n    else\n        out = a;\nend\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "// ----------------------------------------------------------------\n// submodule: one D\u2010FF plus 2:1 mux\n// ----------------------------------------------------------------\nmodule top_module(\n    input        clk,\n    input        L,       // load enable\n    input        q_in,    // shift feedback or previous Q\n    input        r_in,    // parallel load data\n    output reg   Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\n// ----------------------------------------------------------------\n// top\u2010level: three bit\u2010slice instances of top_module\n// ----------------------------------------------------------------\nmodule full_module (\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    wire [2:0] feedback;\n\n    // compute the 3\u2010bit shift/feedback pattern {q[1]^q[2], q[0], q[2]}\n    assign feedback[2] = q[1] ^ q[2];\n    assign feedback[1] = q[0];\n    assign feedback[0] = q[2];\n\n    // instantiate three bit\u2010slice FF+Mux\n    top_module u2 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (feedback[2]),\n        .r_in  (r[2]),\n        .Q     (q[2])\n    );\n\n    top_module u1 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (feedback[1]),\n        .r_in  (r[1]),\n        .Q     (q[1])\n    );\n\n    top_module u0 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (feedback[0]),\n        .r_in  (r[0]),\n        .Q     (q[0])\n    );\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,  // active\u2010high synchronous reset\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // register to hold previous cycle's input\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            prev_in <= 32'b0;\n            out     <= 32'b0;\n        end else begin\n            // detect 1->0 transition per bit and latch it\n            out     <= out | (prev_in & ~in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // Eight D\u2010flip\u2010flops, all clocked on the rising edge of clk\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // sign\u2010extend inputs to 9 bits, add, then detect signed overflow\n    wire [8:0] sum_ext;\n    assign sum_ext  = {a[7], a} + {b[7], b};\n    assign s        = sum_ext[7:0];\n    // overflow if sign of result differs from the carry\u2010in to sign bit\n    assign overflow = sum_ext[8] ^ sum_ext[7];\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,      // one-hot: {Wait,Count,B3,B2,B1,B0,S110,S11,S1,S}\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n  // state[0]=S, [1]=S1, [2]=S11, [3]=S110,\n  // [4]=B0, [5]=B1, [6]=B2, [7]=B3,\n  // [8]=Count, [9]=Wait\n\n  // next\u2010state logic\n  assign S_next      = ((state[0] | state[1] | state[3]) & ~d)\n                      | (state[9] & ack);\n\n  assign S1_next     = state[0] & d;\n\n  // B3 <= B2\n  assign B3_next     = state[6];\n\n  // Count <= from B3 or stay in Count while counting\n  assign Count_next  = state[7]\n                      | (state[8] & ~done_counting);\n\n  // Wait <= from Count when done_counting or stay in Wait until ack\n  assign Wait_next   = (state[8] & done_counting)\n                      | (state[9] & ~ack);\n\n  // outputs\n  assign shift_ena   = state[4] | state[5] | state[6] | state[7];\n  assign counting    = state[8];\n  assign done        = state[9];\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic       clk,\n    input  logic       areset,\n    input  logic       train_valid,\n    input  logic       train_taken,\n    output logic [1:0] state\n);\n\n    // Two-bit saturating counter:\n    //   - Reset to \"weakly not-taken\" (2'b01)\n    //   - When train_valid=1:\n    //       * train_taken=1: increment up to 2'b11\n    //       * train_taken=0: decrement down to 2'b00\n    //   - When train_valid=0: hold state\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken) begin\n                // increment, saturate at 3\n                state <= (state == 2'b11) ? 2'b11 : state + 1;\n            end else begin\n                // decrement, saturate at 0\n                state <= (state == 2'b00) ? 2'b00 : state - 1;\n            end\n        end\n        // else: train_valid=0 -> hold current state\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @* begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // default: no arrow\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        case (scancode)\n            16'he06b: left  = 1'b1;  // left arrow\n            16'he072: down  = 1'b1;  // down arrow\n            16'he074: right = 1'b1;  // right arrow\n            16'he075: up    = 1'b1;  // up arrow\n            default: ;               // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3;\n\n    // ripple\u2010carry chain of four full adders\n    full_adder fa0(.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(x[1]), .b(y[1]), .cin(c1),  .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(x[2]), .b(y[2]), .cin(c2),  .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(x[3]), .b(y[3]), .cin(c3),  .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input            clk,\n    input            areset,            // async, active\u2010high\n    input            predict_valid,\n    input            predict_taken,\n    output logic [31:0] predict_history,\n    \n    input            train_mispredicted,\n    input            train_taken,\n    input      [31:0] train_history\n);\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end\n    else if (train_mispredicted) begin\n        // roll back to history before mispredicted branch + actual outcome\n        // new[31:1] = train_history[30:0], new[0] = train_taken\n        predict_history <= {train_history[30:0], train_taken};\n    end\n    else if (predict_valid) begin\n        // shift in speculative prediction\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n    // intermediate wires for the AND gate outputs\n    wire w1, w2;\n\n    // first layer: two AND gates\n    and and1(w1, a, b);\n    and and2(w2, c, d);\n\n    // second layer: OR gate driving 'out'\n    or  or1 (out, w1, w2);\n\n    // inverted output\n    not not1(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // Positive\u2010edge\u2010triggered D flip\u2010flop\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n\n    // 8-bit shift register\n    reg [7:0] Q;\n    always @(posedge clk) begin\n        if (enable)\n            // shift right: MSB is Q[7], LSB is Q[0]; new bit S goes into Q[0]\n            Q <= {Q[6:0], S};\n    end\n\n    // 8-to-1 multiplexer for random\u2010access read based on ABC\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater on in heating mode when too cold\n    assign heater = mode & too_cold;\n    // Air conditioner on in cooling mode when too hot\n    assign aircon = ~mode & too_hot;\n    // Fan on if requested or whenever heater/AC is running\n    assign fan = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,    // active\u2010high synchronous\n    output reg [31:0] q\n);\n\n    // polynomial x^32 + x^22 + x^2 + x^1 + 1\n    // taps at bit\u2010positions 32,22,2,1 \u2192 mask bits [31,21,1,0]\n    localparam [31:0] TAP_MASK = 32'h8020_0003;\n\n    wire feedback = q[0];\n    wire [31:0] shifted  = {1'b0, q[31:1]};           // shift right by 1\n    wire [31:0] next_q   = shifted ^ ({32{feedback}} & TAP_MASK);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h0000_0001;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table one finds\n    //    q = (a OR b) AND (c OR d)\n\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d, \n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n    // Two independent 4\u2011input NAND gates\n\n    // First NAND gate: Y = !(A & B & C & D)\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Second NAND gate: Y = !(A & B & C & D)\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @* begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) out_both[i] = in[i] & in[i+1], for i=0..2\n    assign out_both = in[2:0] & in[3:1];\n\n    // (2) out_any[i] = in[i] | in[i-1], for i=1..3\n    assign out_any  = in[3:1] | in[2:0];\n\n    // (3) out_different[i] = in[i] ^ in[(i+1)%4], wrap\u2010around at i=3\n    assign out_different[0] = in[0] ^ in[1];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[3] = in[3] ^ in[0];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0] a,\n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // On every rising edge of clk: synchronous reset, then conditional increment\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // AND gate with bubble (inversion) on in2\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinationally tie output to input\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            B: next_state = (in ? B : A);\n            A: next_state = (in ? A : B);\n            default: next_state = B;\n        endcase\n    end\n\n    // Moore output = state==B\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // two edge\u2010triggered storage elements\n    reg q_pos, q_neg;\n\n    // capture D on the rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // capture D on the falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // mux between the two based on the current clock level\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // XNOR operation: out is high when a and b are equal\n    assign out = a ~^ b;\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1, b1, a2, b2;\n    wire or_out, and_out;\n\n    // first A and B instances driving OR\n    A a_inst1 (\n        .x(x),\n        .y(y),\n        .z(a1)\n    );\n    B b_inst1 (\n        .x(x),\n        .y(y),\n        .z(b1)\n    );\n    assign or_out = a1 | b1;\n\n    // second A and B instances driving AND\n    A a_inst2 (\n        .x(x),\n        .y(y),\n        .z(a2)\n    );\n    B b_inst2 (\n        .x(x),\n        .y(y),\n        .z(b2)\n    );\n    assign and_out = a2 & b2;\n\n    // final XOR\n    assign z = or_out ^ and_out;\nendmodule\n\n// Module A: z = (x ^ y) & x\nmodule A(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Module B implements the truth table:\n// x y | z\n// 0 0 | 1\n// 0 1 | 0\n// 1 0 | 0\n// 1 1 | 1\n// i.e. B = x XNOR y\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = ~(x ^ y);\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             load,\n    input      [1:0]  ena,\n    input      [99:0] data,\n    output reg [99:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01:  // rotate right by 1\n                    q <= { q[0], q[99:1] };\n                2'b10:  // rotate left by 1\n                    q <= { q[98:0], q[99] };\n                default: // 2'b00 or 2'b11: hold\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,   // active\u2011high synchronous reset\n    output reg [9:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Simple NOT gate: out is the inversion of in\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    // Next\u2010state logic (one\u2010hot encoding)\n    assign next_state[0] = ~in & ( state[0] | state[1] | state[2] | state[3]\n                                | state[4] | state[7] | state[8] | state[9] );\n    assign next_state[1] =  in & ( state[0] | state[8] | state[9] );\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & ( state[6] | state[7] );\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // Output logic (Moore outputs)\n    assign out1 = state[8] | state[9];  // asserted in S8 or S9\n    assign out2 = state[7] | state[9];  // asserted in S7 or S9\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    // On each rising clock edge, update Q per the JK truth table\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;     // hold\n            2'b01: Q <= 1'b0;  // reset\n            2'b10: Q <= 1'b1;  // set\n            2'b11: Q <= ~Q;    // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Count the number of '1's in the 3\u2010bit vector\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // out[5*i + j] = 1 iff {a,b,c,d,e}[i] == {a,b,c,d,e}[j]\n    // mapping: a\u2192i=4, b\u21923, c\u21922, d\u21921, e\u21920\n    assign out = {\n        // i = 4 (a)\n        (~a ^ a), (~a ^ b), (~a ^ c), (~a ^ d), (~a ^ e),\n        // i = 3 (b)\n        (~b ^ a), (~b ^ b), (~b ^ c), (~b ^ d), (~b ^ e),\n        // i = 2 (c)\n        (~c ^ a), (~c ^ b), (~c ^ c), (~c ^ d), (~c ^ e),\n        // i = 1 (d)\n        (~d ^ a), (~d ^ b), (~d ^ c), (~d ^ d), (~d ^ e),\n        // i = 0 (e)\n        (~e ^ a), (~e ^ b), (~e ^ c), (~e ^ d), (~e ^ e)\n    };\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // state encoding\n    localparam LEFT  = 1'b0,\n               RIGHT = 1'b1;\n\n    reg state, next_state;\n    wire bump = bump_left | bump_right;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic (Moore)\n    always @(*) begin\n        case (state)\n            LEFT:  next_state = bump ? RIGHT : LEFT;\n            RIGHT: next_state = bump ? LEFT  : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // output logic (Moore)\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n    // combinational AND of a and b\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Intermediate AND gates for p1y\n    wire p1_and1 = p1a & p1b & p1c;\n    wire p1_and2 = p1d & p1e & p1f;\n    assign p1y    = p1_and1 | p1_and2;\n\n    // Intermediate AND gates for p2y\n    wire p2_and1 = p2a & p2b;\n    wire p2_and2 = p2c & p2d;\n    assign p2y    = p2_and1 | p2_and2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    // Combinational logic for Y0 and z\n    always @(*) begin\n        // Next\u2010state bit 0\n        //   when y2=0 : Y0 = x ^ y0\n        //   when y2=1 : only state 100 with x=0 gives Y0=1\n        Y0 = (~y[2] & (x ^ y[0])) \n           | ( y[2] & ~y[1] & ~y[0] & ~x);\n\n        // Output z = 1 in states 011 or 100\n        z  = (~y[2] &  y[1] &  y[0])\n           | ( y[2] & ~y[1] & ~y[0]);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2\u2010input NOR\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  d,\n    input  ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous active\u2010high reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk,\n    input        load,\n    input  [9:0] data,\n    output       tc\n);\n\n    reg [9:0] count;\n\n    // On each rising clock edge, either load or decrement\n    always @(posedge clk) begin\n        if (load)\n            count <= data;\n        else if (count != 0)\n            count <= count - 1;\n    end\n\n    // Terminal\u2010count flag when count reaches zero\n    assign tc = (count == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,         // synchronous active\u2010high\n    input        data,\n    output reg   start_shifting\n);\n\n    // State encoding\n    localparam S0 = 3'd0,  // no match\n               S1 = 3'd1,  // saw \"1\"\n               S2 = 3'd2,  // saw \"11\"\n               S3 = 3'd3,  // saw \"110\"\n               S4 = 3'd4;  // found \"1101\" (terminal)\n\n    reg [2:0] state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore)\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else\n            start_shifting <= (state == S4);\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // delayed version of 'in'\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        // sample input\n        in_d    <= in;\n        // detect 0->1 transitions on previous cycle\n        anyedge <= (~in_d) & in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 4'd1;\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a, \n    output reg [2:0] q\n);\n\n    // On each rising edge of clk:\n    //   if a==1, load q with 4 (3'b100)\n    //   else increment q modulo 7 (i.e. wrap from 6 back to 0)\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4;\n        else begin\n            if (q == 3'd6)\n                q <= 3'd0;\n            else\n                q <= q + 3'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": ""}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // Perform add or subtract\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // Set zero flag\n        if (out == 8'b0)\n            result_is_zero = 1'b1;\n        else\n            result_is_zero = 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // f is 1 exactly when x[1] != x[3]\n    assign f = x[1] ^ x[3];\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input      [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @(*) begin\n        // default outputs\n        out   = 4'd0;\n        valid = 1'b0;\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1E: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2E: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3D: begin out = 4'd7; valid = 1'b1; end\n            8'h3E: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin /* out=0, valid=0 */ end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Bit\u2011reverse the 8\u2011bit input\n    assign out = {in[0], in[1], in[2], in[3],\n                  in[4], in[5], in[6], in[7]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2010map simplification:  out = c + a\u00b7!d\n    always @* begin\n        out = c | (a & ~d);\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift left: MSB first\n            q <= { q[2:0], data };\n        end else if (count_ena) begin\n            // down\u2010count\n            q <= q - 1;\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // Pass-through wire behavior\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,     // active\u2010high synchronous\n    output shift_ena\n);\n\n    // 3\u2010bit down\u2010counter to generate a 4\u2010cycle pulse\n    reg [2:0] cnt;\n\n    // shift_ena is high as long as cnt > 0\n    assign shift_ena = (cnt != 3'd0);\n\n    // Synchronous reset and count\u2010down logic\n    always @(posedge clk) begin\n        if (reset) begin\n            // on reset assert shift_ena for 4 cycles\n            cnt <= 3'd4;\n        end else if (cnt != 3'd0) begin\n            // after reset, count down to zero\n            cnt <= cnt - 3'd1;\n        end\n        // once cnt == 0, it stays 0 and shift_ena stays low\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous, active high\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;  // wraps naturally at 16\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Continuous\u2010assignment MUX\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Procedural MUX\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    // From the K\u2011map, the function is 1 for all minterms except a=0, b=0, c=0\n    // which simplifies to out = a OR b OR c\n    assign out = a | b | c;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input  [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    localparam [1:0]\n        A = 2'd0,\n        B = 2'd1,\n        C = 2'd2,\n        D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state flip\u2010flops with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: next_state = r[1] ? B : A;\n            C: next_state = r[2] ? C : A;\n            D: next_state = r[3] ? D : A;\n            default: next_state = A;\n        endcase\n    end\n\n    // outputs: g[i] = 1 when in the corresponding grant state\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output       done\n);\n\n    // state encoding\n    localparam SEARCH = 2'd0,  GOT1 = 2'd1,  GOT2 = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // detect potential message start\n    wire is_header = in[3];\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @* begin\n        case (state)\n            SEARCH: next_state = is_header ? GOT1 : SEARCH;\n            GOT1:   next_state = GOT2;\n            GOT2:   next_state = is_header ? GOT1 : SEARCH;\n            default: next_state = SEARCH;\n        endcase\n    end\n\n    // done goes high when we are sampling the 3rd byte (state == GOT2)\n    assign done = (state == GOT2);\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n// 4\u2010input reductions\nassign out_and = &in;  // reduction AND\nassign out_or  = |in;  // reduction OR\nassign out_xor = ^in;  // reduction XOR\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous active\u2011high\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    localparam S0 = 3'b000,\n               S1 = 3'b001,\n               S2 = 3'b010,\n               S3 = 3'b011,\n               S4 = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // next\u2011state and output logic (Moore machine)\n    always @(*) begin\n        // default\n        next_state = S0;\n        z = 1'b0;\n\n        case (state)\n            S0: begin\n                z = 1'b0;\n                if (x) next_state = S1;\n                else   next_state = S0;\n            end\n            S1: begin\n                z = 1'b0;\n                if (x) next_state = S4;\n                else   next_state = S1;\n            end\n            S2: begin\n                z = 1'b0;\n                if (x) next_state = S1;\n                else   next_state = S2;\n            end\n            S3: begin\n                z = 1'b1;\n                if (x) next_state = S2;\n                else   next_state = S1;\n            end\n            S4: begin\n                z = 1'b1;\n                if (x) next_state = S4;\n                else   next_state = S3;\n            end\n            default: begin\n                next_state = S0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  x,\n    input  y,\n    output reg f,\n    output reg g\n);\n\n    // state encoding\n    localparam S_A   = 4'd0,\n               S_B0  = 4'd1,\n               S_B1  = 4'd2,\n               S_B2  = 4'd3,\n               S_C   = 4'd4,\n               S_D0  = 4'd5,\n               S_D1  = 4'd6,\n               S_G1  = 4'd7,\n               S_G0  = 4'd8;\n\n    reg [3:0] state, next_state;\n\n    // state register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= S_A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            S_A:    next_state = S_B0;\n            S_B0:   next_state = (x ? S_B1 : S_B0);\n            S_B1:   next_state = (x ? S_B1 : S_B2);\n            S_B2:   next_state = (x ? S_C  : S_B0);\n            S_C:    next_state = S_D0;\n            S_D0:   next_state = (y ? S_G1 : S_D1);\n            S_D1:   next_state = (y ? S_G1 : S_G0);\n            S_G1,\n            S_G0:   next_state = state;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // output logic (Moore)\n    always @(*) begin\n        // defaults\n        f = 1'b0;\n        g = 1'b0;\n        case (state)\n            S_A:   f = 1'b1;\n            S_C,\n            S_D0,\n            S_D1,\n            S_G1:  g = 1'b1;\n            default:;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // On negative edge of clk: synchronous, active\u2010high reset to 0x34\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // even parity: XOR\u2010reduce all 8 bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // next_state logic (combinational)\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A \u2192 B on 1, A on 0\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B \u2192 B on 1, C on 0\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C \u2192 D on 1, A on 0\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D \u2192 B on 1, C on 0\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // output logic (Moore: depends only on current state)\n    assign out = (state == 2'b11);  // out = 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // From the timing table:\n    // x y | z\n    // 0 0 | 1\n    // 0 1 | 0\n    // 1 0 | 0\n    // 1 1 | 1\n    // which is XNOR\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous active\u2010high\n    input        w,\n    output       z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register (flip\u2011flops)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input          clk,\n    input          resetn,\n    input  [1:0]   byteena,\n    input  [15:0]  d,\n    output reg [15:0] q\n);\n\n    // 16 D\u2011FFs with byte-enable write and synchronous active\u2011low reset\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // lower byte\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            // upper byte\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // register to hold the previous cycle's input\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // detect rising\u2010edge: in was 0 last cycle and is 1 this cycle\n        pedge   <=  in & ~prev_in;\n        // update previous-input register\n        prev_in <=  in;\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clock,\n    input  a,\n    output reg p,\n    output reg q\n);\n\n// p is a level\u2010sensitive latch, transparent when clock==1\nalways @(*) begin\n    if (clock)\n        p = a;\n    // else p holds its old value (inferred latch)\nend\n\n// q is a level\u2010sensitive latch, transparent when clock==0\nalways @(*) begin\n    if (!clock)\n        q = p;\n    // else q holds its old value\nend\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // On each clock: load new data or advance Rule\u00a090 (xor of left/right neighbors,\n    // with boundaries held at 0).\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            // left shift in 0 at MSB, right shift in 0 at LSB, then XOR\n            q <= {1'b0,       q[511:1]} \n               ^ {q[510:0],   1'b0      };\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n    // z is 1 when A equals B\n    assign z = (A == B);\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left neighbour are 1\n    // out_both[i] = in[i] & in[i+1], for i=0..98\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) any of this bit or its right neighbour is 1\n    // out_any[i] = in[i] | in[i-1], for i=1..99\n    assign out_any[99:1] = in[99:1] | in[98:0];\n\n    // (3) this bit differs from its left neighbour, wrap around\n    // out_different[i] = in[i] ^ in[(i+1)%100]\n    // build a 100\u2010bit vector of left\u2010neighbours: {in[0], in[99:1]}\n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  d,\n    input  ena,\n    output logic q\n);\n\n    // level\u2010sensitive D\u2010latch: when ena==1, q follows d; when ena==0, q holds its value\n    always_latch begin\n        if (ena)\n            q = d;\n        // else: latch retains previous q\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input   [7:0]   sel,\n    output  [3:0]   out\n);\n\n    // form a 10\u2010bit byte\u2010address by appending two zeros to sel\n    wire [9:0] idx = {sel, 2'b00};\n\n    // variable part\u2010select: take 4 bits starting at idx\n    assign out = in[idx +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\nalways_comb begin\n    case(sel)\n        4'd0:  out = a;\n        4'd1:  out = b;\n        4'd2:  out = c;\n        4'd3:  out = d;\n        4'd4:  out = e;\n        4'd5:  out = f;\n        4'd6:  out = g;\n        4'd7:  out = h;\n        4'd8:  out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of corresponding bits\n    assign out_or_bitwise = a | b;\n\n    // logical OR: 1 if any bit in a or b is 1\n    assign out_or_logical = |a | |b;\n\n    // upper half = inverted b, lower half = inverted a\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input       in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output      out\n);\n\n    // one\u2010hot encoding: state[0]=A, state[1]=B, state[2]=C, state[3]=D\n    always @(*) begin\n        // Next\u2010A: from A or C when in=0\n        next_state[0] = (~in) & (state[0] | state[2]);\n\n        // Next\u2010B: from A, B, or D when in=1\n        next_state[1] = in & (state[0] | state[1] | state[3]);\n\n        // Next\u2010C: from B or D when in=0\n        next_state[2] = (~in) & (state[1] | state[3]);\n\n        // Next\u2010D: from C when in=1\n        next_state[3] = in & state[2];\n    end\n\n    // Output is 1 only in state D\n    assign out = state[3];\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // first level of comparison\n    wire [7:0] min_ab = (a < b) ? a : b;\n    wire [7:0] min_cd = (c < d) ? c : d;\n\n    // second level of comparison\n    wire [7:0] min_abcd = (min_ab < min_cd) ? min_ab : min_cd;\n\n    always @(*) begin\n        min = min_abcd;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and    = a & b;\n    assign out_or     = a | b;\n    assign out_xor    = a ^ b;\n    assign out_nand   = ~(a & b);\n    assign out_nor    = ~(a | b);\n    assign out_xnor   = ~(a ^ b);\n    assign out_anotb  = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous, active high\n    input  s,\n    input  w,\n    output reg z\n);\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg       state;\n    reg [1:0] cycle_cnt;   // counts 0,1,2\n    reg [2:0] ones_cnt;    // count of w==1 seen so far\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= A;\n            cycle_cnt  <= 2'b00;\n            ones_cnt   <= 3'd0;\n            z          <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    // in A we only watch 's'\n                    z         <= 1'b0;\n                    cycle_cnt <= 2'b00;\n                    ones_cnt  <= 3'd0;\n                    if (s)\n                        state <= B;\n                    else\n                        state <= A;\n                end\n\n                B: begin\n                    // accumulate w into ones_cnt for 3 cycles\n                    if (cycle_cnt < 2) begin\n                        // first or second sample\n                        ones_cnt  <= ones_cnt + w;\n                        cycle_cnt <= cycle_cnt + 1;\n                        z         <= 1'b0;\n                    end else begin\n                        // third sample: compute total = ones_cnt + w\n                        // and drive z next cycle\n                        z         <= ((ones_cnt + w) == 3'd2);\n                        // reset for next 3\u2010cycle window\n                        ones_cnt  <= 3'd0;\n                        cycle_cnt <= 2'b00;\n                    end\n                    state <= B;  // stay in B forever\n                end\n\n                default: begin\n                    // should not happen\n                    state      <= A;\n                    cycle_cnt  <= 2'b00;\n                    ones_cnt   <= 3'd0;\n                    z          <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concatenate with the 8\u2011bit input\n    assign out = { {24{in[7]}}, in };\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    // Synchronous, active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        if      (in[3]) pos = 2'd3;\n        else if (in[2]) pos = 2'd2;\n        else if (in[1]) pos = 2'd1;\n        else if (in[0]) pos = 2'd0;\n        else             pos = 2'd0;\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output out\n);\n\n    // state encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state_reg, state_next;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state_reg <= OFF;\n        else\n            state_reg <= state_next;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state_reg)\n            OFF: state_next = j ? ON  : OFF;\n            ON:  state_next = k ? OFF : ON;\n            default: state_next = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state_reg == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Tie the output to constant 0\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Continuous assignment drives the output to logic\u20101\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @* begin\n        for (i = 0; i < 100; i = i + 1)\n            out[i] = in[99 - i];\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // On every rising edge of clk, out is updated to in XOR out\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,  // asynchronous, active\u2010high reset\n    input        load,    // synchronous, active\u2010high load\n    input        ena,     // synchronous, active\u2010high shift enable\n    input  [3:0] data,    // parallel load data\n    output reg [3:0] q     // shift register contents\n);\n\n    // on posedge clk or posedge areset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;                     // highest priority\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};           // right shift, fill MSB with 0\n        end\n        // else retain current q\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = \u03a3 m(2,3,5,7) = (~x3 & x2) | (x3 & x1)\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // 8 D flip\u2011flops with active\u2011high asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // 100\u2010input reductions\n    assign out_and = &in;   // AND of all 100 bits\n    assign out_or  = |in;   // OR  of all 100 bits\n    assign out_xor = ^in;   // XOR of all 100 bits\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // sum is XOR of inputs\n    assign sum  = a ^ b;\n    // carry-out is AND of inputs\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input  cpu_overheated,\n    output reg shut_off_computer,\n    input  arrived,\n    input  gas_tank_empty,\n    output reg keep_driving\n);\n\n    // combinational logic for shut_off_computer\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // combinational logic for keep_driving\n    always @(*) begin\n        if (!arrived)\n            keep_driving = !gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        reset,\n    output reg   out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic (Moore)\n    always @(*) begin\n        out = (state == ON);\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate the six 5\u2011bit inputs (30 bits) and two LSB \u201c1\u201ds,\n    // then split into four 8\u2011bit outputs: w=MSB\u2026 z=LSB\n    assign {w, x, y, z} = { a, b, c, d, e, f, 1'b1, 1'b1 };\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n    // q = 1 for even parity of inputs\n    assign q = ~(a ^ b ^ c ^ d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // Simple AND gate implementation\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,  // active\u2011high synchronous\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous, active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum is the XOR of all three inputs\n    assign sum  = a ^ b ^ cin;\n\n    // cout is 1 if any two of the inputs are 1\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input        in1,\n    input        in2,\n    input        in3,\n    output logic out\n);\n\n    // intermediate XNOR of in1 and in2\n    logic xnor_out;\n    assign xnor_out = ~(in1 ^ in2);\n\n    // final XOR with in3\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n    // f0 = c OR d       implemented as c?1:d\n    wire f0 = c ? 1'b1 : d;\n\n    // f1 = 0\n    wire f1 = 1'b0;\n\n    // f2 = c AND d     implemented as c?d:0\n    wire f2 = c ? d : 1'b0;\n\n    // notd = ~d        implemented as d?0:1\n    wire notd = d ? 1'b0 : 1'b1;\n\n    // f3 = c OR ~d     implemented as c?1:notd\n    wire f3 = c ? 1'b1 : notd;\n\n    // assign into mux_in[3:0] in binary\u2010select order {ab}\n    //   ab=00\u2192[0]=f0, 01\u2192[1]=f1, 10\u2192[2]=f2, 11\u2192[3]=f3\n    assign mux_in = { f3,   // ab=11\n                      f2,   // ab=10\n                      f1,   // ab=01\n                      f0 }; // ab=00\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  x,\n    output z\n);\n\n    // one\u2010hot state encoding\n    reg state_A, state_B;\n    wire next_A, next_B;\n\n    // next\u2010state logic\n    assign next_A = state_A & ~x;\n    assign next_B = (state_A & x) | state_B;\n\n    // Mealy output logic\n    assign z = (state_A &  x)    // in A, x=1 \u2192 z=1\n            | (state_B & ~x);   // in B, x=0 \u2192 z=1\n\n    // state register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;  // reset to A\n            state_B <= 1'b0;\n        end else begin\n            state_A <= next_A;\n            state_B <= next_B;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n    // f = (\u00acx1 & x3)  +  (\u00acx2 & \u00acx4)  +  (x2 & x3 & x4)\n    assign f = (~x[1] &  x[3])\n             | (~x[2] & ~x[4])\n             | ( x[2] &  x[3] &  x[4]);\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,    // active\u2010high synchronous\n    input  in,\n    output disc,     // pulse when a stuffed zero should be discarded\n    output flag,     // pulse on flag sequence 01111110\n    output err       // high on 7 or more consecutive 1's\n);\n    // State encoding\n    localparam S0  = 4'd0;  // saw a 0 (or reset)\n    localparam S1  = 4'd1;  // saw 1\n    localparam S2  = 4'd2;  // saw 11\n    localparam S3  = 4'd3;\n    localparam S4  = 4'd4;\n    localparam S5  = 4'd5;  // saw 11111\n    localparam S6  = 4'd6;  // saw 111111\n    localparam SD  = 4'd7;  // one\u2010cycle \u201cdiscard\u201d pulse state\n    localparam SF  = 4'd8;  // one\u2010cycle \u201cflag\u201d   pulse state\n    localparam SE  = 4'd9;  // error state (7+ ones)\n    \n    reg [3:0] state, next_state;\n    reg       disc_r, flag_r, err_r;\n    \n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n    \n    // Next\u2010state logic & Moore outputs\n    always @(*) begin\n        // default\n        next_state = S0;\n        disc_r      = 1'b0;\n        flag_r      = 1'b0;\n        err_r       = 1'b0;\n        \n        case (state)\n            // ----------------------------------------------------------------\n            // Output pulses for one cycle in SD, SF, SE\n            SD: begin\n                disc_r = 1;\n                // after disc, behave like S0 on fresh input\n                next_state = in ? S1 : S0;\n            end\n            SF: begin\n                flag_r = 1;\n                // after flag, behave like S0 on fresh input\n                next_state = in ? S1 : S0;\n            end\n            SE: begin\n                err_r = 1;\n                // stay in error as long as 1's; exit to S0 on 0\n                next_state = in ? SE : S0;\n            end\n            \n            // ----------------------------------------------------------------\n            // Counting ones\n            S0, S1, S2, S3, S4: begin\n                // from 0\u20134 ones: on 1, increment; on 0, stay in S0\n                if (in)\n                    next_state = state + 1;\n                else\n                    next_state = S0;\n            end\n            \n            S5: begin\n                // saw 5 ones\n                if (in)\n                    next_state = S6;   // go to six\u2010ones\n                else\n                    next_state = SD;   // stuffed\u2010zero: discard\n            end\n            \n            S6: begin\n                // saw 6 ones\n                if (in)\n                    next_state = SE;   // seventh one \u2192 error\n                else\n                    next_state = SF;   // flag\n            end\n            \n            default: begin\n                next_state = S0;\n            end\n        endcase\n    end\n    \n    // output assignments\n    assign disc = disc_r;\n    assign flag = flag_r;\n    assign err  = err_r;\n    \nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": ""}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": ""}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE       = 2'd0,\n               DATA       = 2'd1,\n               STOP_CHECK = 2'd2,\n               WAIT_STOP  = 2'd3;\n\n    reg [1:0]  state;\n    reg [3:0]  bit_cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= IDLE;\n            bit_cnt <= 4'd0;\n            done    <= 1'b0;\n        end else begin\n            // Default\n            done <= 1'b0;\n            case (state)\n                IDLE: begin\n                    // Wait for start bit (0)\n                    if (in == 1'b0) begin\n                        state   <= DATA;\n                        bit_cnt <= 4'd0;\n                    end\n                end\n\n                DATA: begin\n                    // Count 8 data bits (LSB first, but we don't store them here)\n                    if (bit_cnt == 4'd7) begin\n                        state <= STOP_CHECK;\n                    end\n                    bit_cnt <= bit_cnt + 1;\n                end\n\n                STOP_CHECK: begin\n                    // Expect stop bit = 1\n                    if (in == 1'b1) begin\n                        done  <= 1'b1;  // valid byte received\n                        state <= IDLE;\n                    end else begin\n                        // Bad stop bit: skip until we see a 1\n                        state <= WAIT_STOP;\n                    end\n                end\n\n                WAIT_STOP: begin\n                    // Stay here until line returns to idle (stop bit seen)\n                    if (in == 1'b1) begin\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": ""}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input         clk,\n    input         areset, \n\n    // prediction interface\n    input         predict_valid,\n    input   [6:0] predict_pc,\n    output        predict_taken, \n    output  [6:0] predict_history,\n\n    // training interface\n    input         train_valid,\n    input         train_taken,\n    input         train_mispredicted,\n    input   [6:0] train_history, \n    input   [6:0] train_pc\n);\n\n    // global history register\n    reg [6:0] history;\n\n    // 2-bit saturating PHT, 128 entries\n    reg [1:0] PHT [0:127];\n\n    // combinational indices\n    wire [6:0] pred_index  = predict_pc  ^ history;\n    wire [6:0] train_index = train_pc    ^ train_history;\n\n    // prediction outputs (read PHT before any update in this cycle)\n    wire [1:0] pred_counter = PHT[pred_index];\n    assign predict_taken  = pred_counter[1];\n    assign predict_history = history;\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // async reset\n            history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1)\n                PHT[i] <= 2'b10;  // initialize to weakly-taken\n        end else begin\n            // TRAIN: update the PHT entry for (train_pc, train_history)\n            if (train_valid) begin\n                case (PHT[train_index])\n                    2'b00: if (train_taken)        PHT[train_index] <= 2'b01;\n                    2'b01: PHT[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: PHT[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: if (!train_taken)       PHT[train_index] <= 2'b10;\n                endcase\n            end\n\n            // HISTORY UPDATE\n            // priority: mispredict training > prediction > no update\n            if (train_valid && train_mispredicted) begin\n                // recover history to state after actual outcome\n                history <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // speculative update with predicted outcome\n                history <= { history[5:0], predict_taken };\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encodings\n    localparam WL = 3'd0,\n               WR = 3'd1,\n               FL = 3'd2,\n               FR = 3'd3,\n               DL = 3'd4,\n               DR = 3'd5,\n               SP = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case(state)\n            // Walking left\n            WL: begin\n                if (!ground)              next_state = FL;        // fall\n                else if (dig)             next_state = DL;        // dig\n                else if (bump_left)       next_state = WR;        // turn\n                else                      next_state = WL;\n            end\n            // Walking right\n            WR: begin\n                if (!ground)              next_state = FR;        // fall\n                else if (dig)             next_state = DR;        // dig\n                else if (bump_right)      next_state = WL;        // turn\n                else                      next_state = WR;\n            end\n            // Digging left\n            DL: begin\n                if (!ground)              next_state = FL;        // fall off dig pit\n                else                      next_state = DL;\n            end\n            // Digging right\n            DR: begin\n                if (!ground)              next_state = FR;        // fall off dig pit\n                else                      next_state = DR;\n            end\n            // Falling left\n            FL: begin\n                if (ground) begin\n                    // if fallen >20 cycles => splat\n                    if (fall_count > 20)  next_state = SP;\n                    else                  next_state = WL;\n                end else\n                    next_state = FL;\n            end\n            // Falling right\n            FR: begin\n                if (ground) begin\n                    if (fall_count > 20)  next_state = SP;\n                    else                  next_state = WR;\n                end else\n                    next_state = FR;\n            end\n            // Splattered: terminal\n            SP:  next_state = SP;\n            default: next_state = WL;\n        endcase\n    end\n\n    // State and fall_count registers\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state      <= WL;\n            fall_count <= 0;\n        end else begin\n            state <= next_state;\n            // count only in falling states\n            if (state==FL || state==FR)\n                fall_count <= fall_count + 1;\n            else\n                fall_count <= 0;\n        end\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n    assign digging    = (state == DL) || (state == DR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input  clk,\n    input  reset,          // active\u2010high synchronous\n    input  data,\n    output reg shift_ena,\n    output reg counting,\n    input  done_counting,\n    output reg done,\n    input  ack\n);\n\n    // state encoding\n    localparam WAIT_SEQ   = 2'd0,\n               SHIFT      = 2'd1,\n               WAIT_COUNT = 2'd2,\n               DONE_ST    = 2'd3;\n\n    reg [1:0] state, seq_state, shift_cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // initialize everything\n            state      <= WAIT_SEQ;\n            seq_state  <= 2'd0;\n            shift_cnt  <= 2'd0;\n            shift_ena  <= 1'b0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            // default outputs off\n            shift_ena <= 1'b0;\n            counting  <= 1'b0;\n            done      <= 1'b0;\n\n            case (state)\n            // ------------------------------------------------------------------\n            WAIT_SEQ: begin\n                // sequence\u2010detector for 1101\n                case (seq_state)\n                2'd0: seq_state <= data      ? 2'd1 : 2'd0;\n                2'd1: seq_state <= data      ? 2'd2 : 2'd0;\n                2'd2: seq_state <= (data==0) ? 2'd3 : 2'd2;\n                2'd3: begin\n                          if (data) begin\n                              // Detected 1101 \u2192 go to SHIFT\n                              state     <= SHIFT;\n                              seq_state <= 2'd0;\n                              shift_cnt <= 2'd0;\n                          end else begin\n                              seq_state <= 2'd0;\n                          end\n                       end\n                default: seq_state <= 2'd0;\n                endcase\n            end\n\n            // ------------------------------------------------------------------\n            SHIFT: begin\n                shift_ena <= 1'b1;\n                if (shift_cnt == 2'd3) begin\n                    // completed 4 cycles (0,1,2,3)\n                    state     <= WAIT_COUNT;\n                    shift_cnt <= 2'd0;\n                end else begin\n                    shift_cnt <= shift_cnt + 1;\n                end\n            end\n\n            // ------------------------------------------------------------------\n            WAIT_COUNT: begin\n                counting <= 1'b1;\n                if (done_counting)\n                    state <= DONE_ST;\n            end\n\n            // ------------------------------------------------------------------\n            DONE_ST: begin\n                done <= 1'b1;\n                if (ack)\n                    state <= WAIT_SEQ;\n            end\n\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input       [255:0] data,\n    output reg  [255:0] q\n);\n\n    reg     [255:0] next_q;\n    integer         r, c;\n    integer         up, down, left, right;\n    reg     [3:0]   cnt;\n\n    // compute next generation combinationally\n    always @(*) begin\n        for (r = 0; r < 16; r = r + 1) begin\n            for (c = 0; c < 16; c = c + 1) begin\n                // wrap\u2010around indices\n                up    = (r == 0 ) ? 15 : r - 1;\n                down  = (r == 15) ?  0 : r + 1;\n                left  = (c == 0 ) ? 15 : c - 1;\n                right = (c == 15) ?  0 : c + 1;\n\n                // count 8 neighbours\n                cnt = q[ up*16 + left ] +\n                      q[ up*16 +  c   ] +\n                      q[ up*16 + right] +\n                      q[  r*16 + left ] +\n                      q[  r*16 + right] +\n                      q[down*16 + left ] +\n                      q[down*16 +  c   ] +\n                      q[down*16 + right];\n\n                // apply rules\n                if (cnt == 3)\n                    next_q[r*16 + c] = 1'b1;\n                else if (cnt == 2)\n                    next_q[r*16 + c] = q[r*16 + c];\n                else\n                    next_q[r*16 + c] = 1'b0;\n            end\n        end\n    end\n\n    // synchronous update / load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam [2:0]\n        WALK_L = 3'd0,\n        WALK_R = 3'd1,\n        FALL_L = 3'd2,\n        FALL_R = 3'd3,\n        DIG_L  = 3'd4,\n        DIG_R  = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_L;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            // Walking left\n            WALK_L: begin\n                if (!ground)\n                    next_state = FALL_L;\n                else if (dig)\n                    next_state = DIG_L;\n                else if (bump_left | bump_right)\n                    next_state = WALK_R;\n                else\n                    next_state = WALK_L;\n            end\n\n            // Walking right\n            WALK_R: begin\n                if (!ground)\n                    next_state = FALL_R;\n                else if (dig)\n                    next_state = DIG_R;\n                else if (bump_left | bump_right)\n                    next_state = WALK_L;\n                else\n                    next_state = WALK_R;\n            end\n\n            // Falling left\n            FALL_L: begin\n                if (ground)\n                    next_state = WALK_L;\n                else\n                    next_state = FALL_L;\n            end\n\n            // Falling right\n            FALL_R: begin\n                if (ground)\n                    next_state = WALK_R;\n                else\n                    next_state = FALL_R;\n            end\n\n            // Digging left\n            DIG_L: begin\n                if (!ground)\n                    next_state = FALL_L;\n                else\n                    next_state = DIG_L;\n            end\n\n            // Digging right\n            DIG_R: begin\n                if (!ground)\n                    next_state = FALL_R;\n                else\n                    next_state = DIG_R;\n            end\n\n            default: next_state = WALK_L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WALK_L);\n    assign walk_right = (state == WALK_R);\n    assign aaah       = (state == FALL_L) || (state == FALL_R);\n    assign digging    = (state == DIG_L)  || (state == DIG_R);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            ss <= 8'h00;\n            mm <= 8'h00;\n            hh <= 8'h12;\n            pm <= 1'b0;\n        end else if (ena) begin\n            // Seconds\n            if (ss[3:0] == 4'd9) begin\n                if (ss[7:4] == 4'd5) begin\n                    ss <= 8'h00;\n                    // Minutes\n                    if (mm[3:0] == 4'd9) begin\n                        if (mm[7:4] == 4'd5) begin\n                            mm <= 8'h00;\n                            // Hours\n                            if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end else if (hh[3:0] == 4'd9) begin\n                                hh <= 8'h10;\n                            end else begin\n                                hh <= hh + 8'h01;\n                            end\n                            // Toggle AM/PM at 11\u219212\n                            if (hh == 8'h11)\n                                pm <= ~pm;\n                        end else begin\n                            mm <= mm + 8'h10;\n                        end\n                    end else begin\n                        mm <= mm + 8'h01;\n                    end\n                end else begin\n                    ss <= ss + 8'h10;\n                end\n            end else begin\n                ss <= ss + 8'h01;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam WL = 2'b00,  // walking left\n               WR = 2'b01,  // walking right\n               FL = 2'b10,  // falling (was walking left)\n               FR = 2'b11;  // falling (was walking right)\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WL;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            WL: begin\n                if (!ground)\n                    next_state = FL;\n                else if (bump_left)       // bump on left \u2192 turn right\n                    next_state = WR;\n                else\n                    next_state = WL;\n            end\n\n            WR: begin\n                if (!ground)\n                    next_state = FR;\n                else if (bump_right)      // bump on right \u2192 turn left\n                    next_state = WL;\n                else\n                    next_state = WR;\n            end\n\n            FL: begin\n                if (ground)               // landed \u2192 resume walking left\n                    next_state = WL;\n                else\n                    next_state = FL;\n            end\n\n            FR: begin\n                if (ground)               // landed \u2192 resume walking right\n                    next_state = WR;\n                else\n                    next_state = FR;\n            end\n\n            default: next_state = WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,\n    output     [3:1] ena,\n    output reg [15:0] q\n);\n\n    // Combinational carry\u2010lookahead for BCD digits\n    wire ena1 = (q[3:0]   == 4'd9);        // ones\u2192tens\n    wire ena2 = (q[7:4]   == 4'd9) & ena1; // tens\u2192hundreds\n    wire ena3 = (q[11:8]  == 4'd9) & ena2; // hundreds\u2192thousands\n\n    assign ena = { ena3, ena2, ena1 };\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit\n            if (ena1)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // tens digit\n            if (ena1) begin\n                if (ena2)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // hundreds digit\n            if (ena2) begin\n                if (ena3)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // thousands digit\n            if (ena3) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,\n    input        w,\n    output reg   Y2\n);\n\n    // next\u2010state logic for y[2]\n    always @(*) begin\n        // y[3]=MSB, y[2]=middle bit, y[1]=LSB\n        // Y2 = (~y2 & y1) | (w & ~y1 & (y3 ^ y2))\n        Y2 = (~y[2] & y[1])\n           | (w & ~y[1] & (y[3] ^ y[2]));\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring, \n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring is asserted, choose exactly one output:\n    //   vibrate_mode=1 \u2192 motor\n    //   vibrate_mode=0 \u2192 ringer\n    // Otherwise both outputs are 0.\n    assign ringer = ring & ~vibrate_mode;\n    assign motor  = ring &  vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Continuous assignment implementation of AND\n    assign out_assign = a & b;\n\n    // Combinational always block implementation of AND\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Constant\u2010low output\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg   q\n);\n\n    // store previous 'a' to detect two\u2010in\u2010a\u2010row patterns\n    reg prev_a;\n\n    always @(posedge clk) begin\n        // if we saw \"00\" on two consecutive clocks \u21d2 set q\n        if (prev_a==1'b0 && a==1'b0)\n            q <= 1'b1;\n        // if we saw \"11\" on two consecutive clocks \u21d2 clear q\n        else if (prev_a==1'b1 && a==1'b1)\n            q <= 1'b0;\n        // otherwise hold q\n\n        // update history\n        prev_a <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  x,\n    output z\n);\n\n    // State encoding\n    localparam SEARCH = 1'b0,  // still looking for the LSB\u2011\u20181\u2019\n               INVERT = 1'b1;  // after (and including) that 1, invert\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore)\n    always @(*) begin\n        case (state)\n            SEARCH:  next_state = x ? INVERT : SEARCH;\n            INVERT:  next_state = INVERT;\n            default: next_state = SEARCH;\n        endcase\n    end\n\n    // Output logic (Moore): depends only on state and current x\n    // Before first '1', pass x straight through; thereafter invert.\n    assign z = (state == SEARCH) ? x : ~x;\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output reg   out\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    always @(*) begin\n        case (state)\n            D: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse the order of the four 8\u2011bit bytes\n    assign out = { in[ 7: 0],\n                   in[15: 8],\n                   in[23:16],\n                   in[31:24] };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // D flip\u2011flop with active\u2011high synchronous reset\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input              ena,\n    input       [1:0]  amount,\n    input      [63:0]  data,\n    output reg [63:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: // shift left by 1\n                    q <= q << 1;\n                2'b01: // shift left by 8\n                    q <= q << 8;\n                2'b10: // arithmetic shift right by 1\n                    q <= { {1{q[63]}}, q[63:1] };\n                2'b11: // arithmetic shift right by 8\n                    q <= { {8{q[63]}}, q[63:8] };\n                default:\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,\n    input        x,\n    output reg   z\n);\n    // State encoding\n    localparam S0 = 2'd0,  // no bits seen or just reset\n               S1 = 2'd1,  // saw a leading '1'\n               S2 = 2'd2;  // saw \"10\"\n    \n    reg [1:0] state, next_state;\n\n    // Combinational: compute next state and Mealy output\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                // else stay S0\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    next_state = S1;  // still saw a '1'\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;  // overlap: treat this '1' as start\n                    z = 1'b1;         // \"101\" detected\n                end else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Sequential: state register with neg\u2010edge async reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output reg   z\n);\n\n    // state encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic & output logic (Moore)\n    always @(*) begin\n        // default assignments\n        next_state = A;\n        z = 1'b0;\n\n        case (state)\n            A: begin\n                z = 1'b0;\n                if (w == 1'b0) next_state = B;\n                else            next_state = A;\n            end\n            B: begin\n                z = 1'b0;\n                if (w == 1'b0) next_state = C;\n                else            next_state = D;\n            end\n            C: begin\n                z = 1'b0;\n                if (w == 1'b0) next_state = E;\n                else            next_state = D;\n            end\n            D: begin\n                z = 1'b0;\n                if (w == 1'b0) next_state = F;\n                else            next_state = A;\n            end\n            E: begin\n                z = 1'b1;\n                if (w == 1'b0) next_state = E;\n                else            next_state = D;\n            end\n            F: begin\n                z = 1'b1;\n                if (w == 1'b0) next_state = C;\n                else            next_state = D;\n            end\n            default: begin\n                z = 1'b0;\n                next_state = A;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input             clk,\n    input      [7:0]  in,\n    input             reset,\n    output reg [23:0] out_bytes,\n    output reg        done\n);\n\n    // state encoding\n    localparam WAIT  = 2'd0,\n               GOT1  = 2'd1,\n               GOT2  = 2'd2;\n\n    reg [1:0]   state;\n    reg [7:0]   b1, b2, b3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= WAIT;\n            done      <= 1'b0;\n            // b1,b2,b3 and out_bytes can be left as don't\u2010care\n        end else begin\n            done <= 1'b0;  // default\n\n            case (state)\n                // look for first byte (in[3]==1)\n                WAIT: begin\n                    if (in[3]) begin\n                        b1    <= in;\n                        state <= GOT1;\n                    end\n                end\n\n                // second byte\n                GOT1: begin\n                    b2    <= in;\n                    state <= GOT2;\n                end\n\n                // third byte, assert done and output\n                GOT2: begin\n                    b3    <= in;\n                    done  <= 1'b1;\n                    out_bytes <= { b1, b2, in };\n\n                    // immediately begin next search;\n                    // if this byte also has in[3]==1, treat it as new b1\n                    if (in[3]) begin\n                        b1    <= in;\n                        state <= GOT1;\n                    end else begin\n                        state <= WAIT;\n                    end\n                end\n\n                default: state <= WAIT;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,  // one\u2010hot state: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1, // next\u2010state input for B (y[1])\n    output       Y3  // next\u2010state input for D (y[3])\n);\n\n    // B is entered only from A on w=1\n    assign Y1 = y[0] & w;\n\n    // D is entered from B,C,E,F on w=0\n    assign Y3 = ~w & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // replicate the input vector\n    assign outv = vec;\n\n    // split into individual bits\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // The K\u2010map implements a 4\u2010input parity (XOR) function:\n    // f = a ^ b ^ c ^ d\n\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Combinational split of 16\u2011bit half\u2011word into upper and lower bytes\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // out is the NOR of a and b\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a, \n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) continuous assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) clocked always block XOR (registered, one-cycle delayed)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,\n    input        w,\n    output       Y2,\n    output       Y4\n);\n\n    // One\u2010hot encoding: y[1]=A, y[2]=B, y[3]=C, y[4]=D, y[5]=E, y[6]=F\n    // Next\u2010state B (y2') occurs only from A on w=0\n    assign Y2 = y[1] & ~w;\n\n    // Next\u2010state D (y4') occurs from B,C,E,F on w=1\n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input  [7:0]   sel,\n    output         out\n);\n\n    // 1\u2011bit output selects the bit from 'in' indexed by 'sel'\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // Compute next state with a small 2\u2010to\u20101 tree:\n    //   if L==1     : load R\n    //   else if E==1: shift in w\n    //   else        : hold Q\n    wire d_next = L ? R\n                   : E ? w\n                   : Q;\n\n    always @(posedge clk) begin\n        Q <= d_next;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state flip\u2011flops\n    reg q0, q1, q2;\n\n    // combinational next\u2011state logic\n    wire d0 = x ^  q0;   // XOR with its own Q\n    wire d1 = x & ~q1;   // AND with its own Q\u0305\n    wire d2 = x | ~q2;   // OR  with its own Q\u0305\n\n    // output is 3\u2011input XNOR of the flip\u2011flop outputs\n    assign z = ~(q0 ^ q1 ^ q2);\n\n    // initialize to zero before start\n    initial begin\n        q0 = 0;\n        q1 = 0;\n        q2 = 0;\n    end\n\n    // on each clock, capture next state\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table, q is high whenever b=1 or c=1 (a and d are irrelevant)\n    assign q = b | c;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // next state computed per Rule 110: f(l,c,r) = (~l & c) | (c ^ r)\n    wire [511:0] next_q;\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : rule110\n            // boundary cells see zeros outside [0..511]\n            wire l = (i == 511) ? 1'b0 : q[i+1];\n            wire c = q[i];\n            wire r = (i ==   0) ? 1'b0 : q[i-1];\n            assign next_q[i] = (~l & c) | (c ^ r);\n        end\n    endgenerate\n\n    // synchronous load or advance\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output       out\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n               \n    reg [1:0] state, next_state;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a,\n    input  [3:0] b,\n    input  [3:0] c,\n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    always @* begin\n        out = sel ? b : a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "// ------------------------------------------------------------------\n// sub\u2010module: D\u2010FF with 2:1 mux\n// ------------------------------------------------------------------\nmodule top_module(\n    input        clk,\n    input        L,       // load enable\n    input        q_in,    // shift\u2010in path\n    input        r_in,    // reload path\n    output reg   Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\n\n// ------------------------------------------------------------------\n// top\u2010level: 3\u2010bit LFSR with reload r[2:0], load L, clock clk\n// new q = L ? r : {q[1]^q[2], q[0], q[2]}\n// ------------------------------------------------------------------\nmodule full_module (\n    input      [2:0] r,\n    input            L,\n    input            clk,\n    output     [2:0] q\n);\n\n    // internal nets for the three bits\n    wire q0, q1, q2;\n    // feedback bit = old q1 ^ old q2\n    wire fb0 = q1 ^ q2;\n\n    // instantiate bit\u20100 cell\n    top_module u0 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (fb0),    // shift\u2010in for bit0\n        .r_in (r[0]),   // reload bit0\n        .Q    (q0)\n    );\n\n    // instantiate bit\u20101 cell\n    top_module u1 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q0),     // shift\u2010in for bit1\n        .r_in (r[1]),\n        .Q    (q1)\n    );\n\n    // instantiate bit\u20102 cell\n    top_module u2 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q2),     // shift\u2010in for bit2 = old q2\n        .r_in (r[2]),\n        .Q    (q2)\n    );\n\n    assign q = {q2, q1, q0};\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input              clk,\n    input              reset,  // synchronous active\u2010high\n    input      [31:0]  in,\n    output reg [31:0]  out\n);\n\n    // register to hold previous input state\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // clear captures and sync prev_in to avoid spurious detections\n            out     <= 32'b0;\n            prev_in <= in;\n        end else begin\n            // detect 1\u21920 transitions: prev_in==1 and in==0\n            // once set, out bit remains 1 until next reset\n            out     <= out | (prev_in & ~in);\n            // update previous input\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, capture d into q (8 D\u2011FFs)\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // 8\u2010bit two's\u2010complement add\n    assign s = a + b;\n\n    // signed overflow: operands same sign, result different sign\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ s[7]);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,    // one-hot: state[0]=S, state[1]=S1, ..., state[9]=Wait\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n    // one\u2010hot state signals\n    wire S    = state[0];\n    wire S1   = state[1];\n    wire S11  = state[2];\n    wire S110 = state[3];\n    wire B0   = state[4];\n    wire B1   = state[5];\n    wire B2   = state[6];\n    wire B3   = state[7];\n    wire Count= state[8];\n    wire Wait = state[9];\n\n    // next\u2010state logic\n    assign B3_next    = B2;\n    assign S_next     = (S     & ~d)\n                      | (S1    & ~d)\n                      | (S110  & ~d)\n                      | (Wait  &  ack);\n    assign S1_next    =  S & d;\n    assign Count_next =  B3\n                      | (Count & ~done_counting);\n    assign Wait_next  = (Count &  done_counting)\n                      | (Wait  & ~ack);\n\n    // output logic (Moore)\n    assign shift_ena = B0 | B1 | B2 | B3;\n    assign counting  = Count;\n    assign done      = Wait;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic        clk,\n    input  logic        areset,       // async active\u2010high reset\n    input  logic        train_valid,\n    input  logic        train_taken,\n    output logic [1:0]  state\n);\n\n  // Asynchronous reset, synchronous saturating update\n  always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= 2'b01;            // weakly not-taken on reset\n    end else if (train_valid) begin\n      if (train_taken) begin\n        // increment but saturate at 3\n        state <= (state == 2'b11) ? 2'b11 : state + 2'd1;\n      end else begin\n        // decrement but saturate at 0\n        state <= (state == 2'b00) ? 2'b00 : state - 2'd1;\n      end\n    end\n    // else keep current state\n  end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @* begin\n        casex (in)\n            8'bxxxxxxx1: pos = 3'd0;\n            8'bxxxxxx10: pos = 3'd1;\n            8'bxxxxx100: pos = 3'd2;\n            8'bxxxx1000: pos = 3'd3;\n            8'bxxx10000: pos = 3'd4;\n            8'bxx100000: pos = 3'd5;\n            8'bx1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default:     pos = 3'd0;  // also covers in==0\n        endcase\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // default outputs\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        case (scancode)\n            16'hE06B: left  = 1'b1; // left arrow\n            16'hE072: down  = 1'b1; // down arrow\n            16'hE074: right = 1'b1; // right arrow\n            16'hE075: up    = 1'b1; // up arrow\n            default: ;              // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n    // Instantiate four full adders\n    full_adder fa0(.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(x[1]), .b(y[1]), .cin(c1),  .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(x[2]), .b(y[2]), .cin(c2),  .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(x[3]), .b(y[3]), .cin(c3),  .sum(sum[3]), .cout(c4));\n    // Overflow bit\n    assign sum[4] = c4;\nendmodule\n\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n\n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // On areset clear history\n    // On mispredict roll back and shift in the actual outcome\n    // Else on a new prediction shift in the predicted outcome\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // history before the branch is train_history,\n            // now shift in the actual result train_taken\n            predict_history <= { train_history[30:0], train_taken };\n        end\n        else if (predict_valid) begin\n            // shift in the predicted direction\n            predict_history <= { predict_history[30:0], predict_taken };\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // Intermediate wires for the two AND gates\n    wire ab_and;\n    wire cd_and;\n\n    // First layer: two AND gates\n    and and1(ab_and, a, b);\n    and and2(cd_and, c, d);\n\n    // Second layer: OR gate feeding 'out'\n    or  or1(out, ab_and, cd_and);\n\n    // Inverted output\n    not not1(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // On every rising edge of clk, sample d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n\n    reg [7:0] Q;\n\n    // 8-bit shift register: S \u2192 Q[0], Q[i] \u2192 Q[i+1] on enable\n    always @(posedge clk) begin\n        if (enable)\n            Q <= { Q[6:0], S };\n    end\n\n    // 8\u2011to\u20111 multiplexer selecting Q[{A,B,C}]\n    always @(*) begin\n        Z = Q[{A, B, C}];\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater on in heating mode when too cold\n    assign heater = mode & too_cold;\n\n    // Air conditioner on in cooling mode when too hot\n    assign aircon = ~mode & too_hot;\n\n    // Fan on if heater or aircon is on, or user requests fan\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [31:0] q\n);\n\n    // Galois LFSR taps for polynomial x^32 + x^22 + x^2 + x + 1\n    // mask bits: [31]=x^32, [21]=x^22, [1]=x^2, [0]=x^1\n    localparam [31:0] TAP_MASK = 32'h8020_0003;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // synchronous, active\u2010high reset\n            q <= 32'h0000_0001;\n        end else begin\n            // shift right by one\n            if (q[0])\n                // if LSB=1, apply feedback mask\n                q <= (q >> 1) ^ TAP_MASK;\n            else\n                // else just shift\n                q <= q >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n    // From the truth\u2010table: q is 1 exactly when\n    // at least one of {a,b} is 1 AND at least one of {c,d} is 1\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Two independent 4\u2011input NAND gates, replicating the 7420\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) both this bit and its left neighbour (higher index)\n    //    out_both[i] = in[i] & in[i+1], for i = 0..2\n    assign out_both = in[2:0] & in[3:1];\n\n    // (2) any of this bit and its right neighbour (lower index)\n    //    out_any[i] = in[i] | in[i-1], for i = 1..3\n    assign out_any  = in[3:1] | in[2:0];\n\n    // (3) this bit different from left neighbour, with wrap\n    //    out_different[i] = in[i] ^ in[(i+1)%4]\n    assign out_different[0] = in[0] ^ in[1];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[3] = in[3] ^ in[0];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0] a,\n    output reg [15:0] q\n);\n\n    // Combinational ROM lookup inferred from the waveform\n    always @* begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // out = in1 AND (NOT in2)\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinationally drive out with the value of in\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding: A = 1'b0, B = 1'b1\n    reg state, next_state;\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    // Next\u2010state logic (Moore)\n    // B: out=1, transitions: 0\u2192A, 1\u2192B\n    // A: out=0, transitions: 0\u2192B, 1\u2192A\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // State register with asynchronous reset to B\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Output = 1 in state B, 0 in state A\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // Two single\u2010edge D\u2010FFs, one on posedge, one on negedge\n    reg q_pos, q_neg;\n\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // MUX selects the latest capture based on clk level\n    always @(*) begin\n        q = clk ? q_pos : q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // XNOR operation: out is 1 when a equals b\n    assign out = a ~^ b;\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1, b1, a2, b2, or_out, and_out;\n\n    // first A and B, OR their outputs\n    A uA1(.x(x), .y(y), .z(a1));\n    B uB1(.x(x), .y(y), .z(b1));\n    assign or_out = a1 | b1;\n\n    // second A and B, AND their outputs\n    A uA2(.x(x), .y(y), .z(a2));\n    B uB2(.x(x), .y(y), .z(b2));\n    assign and_out = a2 & b2;\n\n    // final XOR\n    assign z = or_out ^ and_out;\nendmodule\n\n// Module A: z = (x ^ y) & x\nmodule A(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Module B: truth\u2010table from waveform => XNOR\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = ~(x ^ y);\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input       [1:0]  ena,\n    input       [99:0] data,\n    output reg  [99:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // synchronous load\n            q <= data;\n        end else begin\n            // synchronous rotate\n            case (ena)\n                2'b01: // rotate right by 1\n                    q <= { q[0], q[99:1] };\n                2'b10: // rotate left by 1\n                    q <= { q[98:0], q[99] };\n                default: // 2'b00 or 2'b11: hold\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous, active high\n    output reg [9:0] q    // will count 0\u2013999\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 10'd0;\n    else if (q == 10'd999)\n        q <= 10'd0;\n    else\n        q <= q + 10'd1;\nend\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // Invert the input\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    // next\u2010state logic (one\u2010hot encoding)\n    assign next_state[0] = ~in & ( state[0] | state[1] | state[2]\n                                 | state[3] | state[4] | state[7]\n                                 | state[8] | state[9] );\n    assign next_state[1] =  in & ( state[0] | state[8] | state[9] );\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & ( state[6] | state[7] );\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // output logic\n    // out1 = 1 in S8 or S9\n    // out2 = 1 in S7 or S9\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    // Positive\u2010edge\u2013triggered JK flip\u2010flop\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;    // hold\n            2'b01: Q <= 1'b0; // reset\n            2'b10: Q <= 1'b1; // set\n            2'b11: Q <= ~Q;   // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Sum the three bits; result 0..3 fits in 2 bits\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // out[24:20] = comparisons of a with {a,b,c,d,e}\n    // out[19:15] = comparisons of b with {a,b,c,d,e}\n    // out[14:10] = comparisons of c with {a,b,c,d,e}\n    // out[ 9: 5] = comparisons of d with {a,b,c,d,e}\n    // out[ 4: 0] = comparisons of e with {a,b,c,d,e}\n    assign out = {\n        /* a vs {a,b,c,d,e} */ ~a^a, ~a^b, ~a^c, ~a^d, ~a^e,\n        /* b vs {a,b,c,d,e} */ ~b^a, ~b^b, ~b^c, ~b^d, ~b^e,\n        /* c vs {a,b,c,d,e} */ ~c^a, ~c^b, ~c^c, ~c^d, ~c^e,\n        /* d vs {a,b,c,d,e} */ ~d^a, ~d^b, ~d^c, ~d^d, ~d^e,\n        /* e vs {a,b,c,d,e} */ ~e^a, ~e^b, ~e^c, ~e^d, ~e^e\n    };\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        bump_left,\n    input        bump_right,\n    output       walk_left,\n    output       walk_right\n);\n\n    // State encoding\n    localparam LEFT  = 1'b0,\n               RIGHT = 1'b1;\n\n    // State registers\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore machine)\n    always @(*) begin\n        case (state)\n            LEFT:  // walking left\n                if (bump_left || bump_right)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            RIGHT: // walking right\n                if (bump_left || bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            default:\n                next_state = LEFT;\n        endcase\n    end\n\n    // Output logic (Moore: only depends on current state)\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n\n    // From the waveform, q is high only when both a and b are 1\n    assign q = a & b;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Intermediate wires for the four AND gates\n    wire p1_and1, p1_and2;\n    wire p2_and1, p2_and2;\n\n    // Two 3\u2010input AND gates for p1y\n    assign p1_and1 = p1a & p1b & p1c;\n    assign p1_and2 = p1d & p1e & p1f;\n    // OR their outputs\n    assign p1y      = p1_and1 | p1_and2;\n\n    // Two 2\u2010input AND gates for p2y\n    assign p2_and1 = p2a & p2b;\n    assign p2_and2 = p2c & p2d;\n    // OR their outputs\n    assign p2y      = p2_and1 | p2_and2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n// Combinational logic for next\u2010state bit Y0 and output z\nalways @(*) begin\n    // Y0 = for y2=0, Y0 = x \u2295 y0; for y=100,x=0 \u2192 1; else 0\n    Y0 = (~y[2] & (x ^ y[0])) \n         | ( y[2] & ~y[1] & ~y[0] & ~x );\n\n    // z = 1 when present state y == 3 (011) or y == 4 (100)\n    z  = (~y[2] &  y[1] &  y[0])\n         | ( y[2] & ~y[1] & ~y[0] );\nend\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2-input NOR gate\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    // wire connections\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D flip\u2010flop with asynchronous reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk, \n    input        load, \n    input  [9:0] data, \n    output       tc\n);\n\n    reg [9:0] count;\n\n    // Synchronous load / down\u2010counter\n    always @(posedge clk) begin\n        if (load)\n            count <= data;\n        else if (count != 0)\n            count <= count - 1;\n        // else count stays at 0\n    end\n\n    // Terminal\u2010count flag is high when the counter is zero\n    assign tc = (count == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,         // synchronous, active\u2010high\n    input  data,\n    output start_shifting\n);\n    // State encoding\n    localparam IDLE = 3'd0,\n               S1   = 3'd1,   // saw \"1\"\n               S2   = 3'd2,   // saw \"11\"\n               S3   = 3'd3,   // saw \"110\"\n               DONE = 3'd4;   // saw \"1101\" \u2013 terminal\n\n    reg [2:0] state, next_state;\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = data      ? S1   : IDLE;\n            S1:   next_state = data      ? S2   : IDLE;\n            S2:   next_state = data      ? S2   : S3;\n            S3:   next_state = data      ? DONE : IDLE;\n            DONE: next_state = DONE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output goes high in DONE and stays high until reset\n    assign start_shifting = (state == DONE);\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // Eight D\u2010FFs with active\u2010high synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0000_0000;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold last\u2010cycle value of in\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        // detect 0->1 transitions: high this cycle if in_prev=0 and in=1\n        anyedge <=  (~in_prev) & in;\n        // update previous sample\n        in_prev <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous reset\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1;\n        end else begin\n            if (q == 4'd10)\n                q <= 4'd1;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            // when a is high, load 4\n            q <= 3'd4;\n        end else begin\n            // when a is low, count 4\u21925\u21926\u21920\u21921\u2192\u2026\n            if (q == 3'd6)\n                q <= 3'd0;\n            else\n                q <= q + 3'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [4:0] q\n);\n\n    // Galois LFSR, taps at bit\u2011positions 5 (q[4]) and 3 (q[2])\n    // synchronous active\u2011high reset to 00001\n    always @(posedge clk) begin\n        if (reset)\n            q <= 5'b00001;\n        else\n            // new_q = { q[0], q[4]^q[0], q[3], q[2]^q[0], q[1] }\n            q <= { q[0],\n                   q[4] ^ q[0],\n                   q[3],\n                   q[2] ^ q[0],\n                   q[1] };\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input            do_sub,\n    input      [7:0] a,\n    input      [7:0] b,\n    output reg [7:0] out,\n    output reg       result_is_zero\n);\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n        // set zero flag\n        result_is_zero = (out == 8'd0);\n    end\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // x[3]x[4] are the row\u2010select bits (A,B), x[1]x[2] are the column\u2010select bits (C,D)\n    // minimized from the K\u2010map: \n    //   f = A\u00b7C' + A'\u00b7C\u00b7D\n    // where A=x[3], C=x[1], D=x[2]\n\n    assign f = ( x[3] & ~x[1] )      // A\u00b7C'\n             | ( ~x[3] & x[1] & x[2] ); // A'\u00b7C\u00b7D\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @(*) begin\n        // default values for no\u2010match\n        valid = 1'b0;\n        out   = 4'd0;\n        case (code)\n            8'h45: begin valid = 1'b1; out = 4'd0; end\n            8'h16: begin valid = 1'b1; out = 4'd1; end\n            8'h1E: begin valid = 1'b1; out = 4'd2; end\n            8'h26: begin valid = 1'b1; out = 4'd3; end\n            8'h25: begin valid = 1'b1; out = 4'd4; end\n            8'h2E: begin valid = 1'b1; out = 4'd5; end\n            8'h36: begin valid = 1'b1; out = 4'd6; end\n            8'h3D: begin valid = 1'b1; out = 4'd7; end\n            8'h3E: begin valid = 1'b1; out = 4'd8; end\n            8'h46: begin valid = 1'b1; out = 4'd9; end\n            default: /* keep valid=0, out=0 */;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // reverse bit order: out[7]=in[0], out[6]=in[1], \u2026, out[0]=in[7]\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // combinational logic\n    always @(*) begin\n        out = a | c;\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift toward LSB, bring in 'data' at MSB\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // treat q as a 4-bit unsigned down\u2010counter\n            q <= q - 1;\n        end\n        // otherwise hold q\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // Wire\u2010like behavior: direct connection from in to out\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,    // active\u2010high synchronous\n    output reg shift_ena\n);\n\n    // 3 bits are enough to count down from 4 to 0\n    reg [2:0] cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // On reset load counter to 4 and assert enable\n            cnt        <= 3'd4;\n            shift_ena  <= 1'b1;\n        end else begin\n            if (cnt != 0) begin\n                // still in the 4\u2011cycle window\n                cnt       <= cnt - 3'd1;\n                shift_ena <= 1'b1;\n            end else begin\n                // past the 4 cycles, disable\n                shift_ena <= 1'b0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // On each rising clock edge, either reset or increment\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;    // synchronous active-high reset\n        else\n            q <= q + 1'b1;   // counts 0..15 then rolls over\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Continuous\u2010assignment mux\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Procedural mux\n    always @* begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    input  c,\n    output out\n);\n    // K\u2010map collapse yields f = a + b + c\n    assign out = a | b | c;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input  [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: begin\n                if      (r[1])       next_state = B;  // highest priority\n                else if (r[2])       next_state = C;\n                else if (r[3])       next_state = D;\n                else                 next_state = A;\n            end\n            B: next_state = (r[1] ? B : A);\n            C: next_state = (r[2] ? C : A);\n            D: next_state = (r[3] ? D : A);\n            default: next_state = A;\n        endcase\n    end\n\n    // State register (synchronous, active\u2010low reset)\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,  // synchronous, active\u2011high\n    output       done\n);\n\n    // state encoding\n    localparam WAIT = 2'd0,\n               B1   = 2'd1,\n               B2   = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= WAIT;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            WAIT:  next_state = in[3] ? B1 : WAIT;  // look for first\u2010byte marker\n            B1:    next_state = B2;                 // got byte1, now byte2\n            B2:    next_state = WAIT;               // got byte2, now byte3 \u21d2 go back to WAIT\n            default: next_state = WAIT;\n        endcase\n    end\n\n    // done is asserted for one cycle when state==B2,\n    // which corresponds to the cycle immediately after the 3rd byte\n    assign done = (state == B2);\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // 4\u2011input reduction gates\n    assign out_and = &in;   // 4\u2011input AND\n    assign out_or  = |in;   // 4\u2011input OR\n    assign out_xor = ^in;   // 4\u2011input XOR\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active high\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam [2:0]\n        S0 = 3'b000,\n        S1 = 3'b001,\n        S2 = 3'b010,\n        S3 = 3'b011,\n        S4 = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state and output logic (Moore)\n    always @(*) begin\n        // default assignments\n        next_state = S0;\n        z          = 1'b0;\n        case (state)\n            S0: begin\n                if (x) next_state = S1;\n                else   next_state = S0;\n                z = 1'b0;\n            end\n            S1: begin\n                if (x) next_state = S4;\n                else   next_state = S1;\n                z = 1'b0;\n            end\n            S2: begin\n                if (x) next_state = S1;\n                else   next_state = S2;\n                z = 1'b0;\n            end\n            S3: begin\n                if (x) next_state = S2;\n                else   next_state = S1;\n                z = 1'b1;\n            end\n            S4: begin\n                if (x) next_state = S4;\n                else   next_state = S3;\n                z = 1'b1;\n            end\n            default: begin\n                next_state = S0;\n                z          = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input        x,\n    input        y,\n    output       f,\n    output       g\n);\n\n    // State encoding\n    localparam A     = 4'd0,\n               B     = 4'd1,\n               C0    = 4'd2,  // waiting for first '1'\n               C1    = 4'd3,  // got '1', next expect '0'\n               C2    = 4'd4,  // got '1','0', next expect '1'\n               WAIT1 = 4'd5,  // g=1, 1st cycle to see y\n               WAIT2 = 4'd6,  // g=1, 2nd cycle to see y\n               G1    = 4'd7,  // g=1 permanently\n               G0    = 4'd8;  // g=0 permanently\n\n    reg [3:0] state, next_state;\n\n    // State register with synchronous, active\u2011low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        next_state = state;  // default: hold\n        case(state)\n            A:     next_state = B;\n            B:     next_state = C0;\n            C0:    next_state = x ? C1 : C0;\n            C1:    next_state = (x==1'b0) ? C2 : C1;\n            C2:    next_state = (x==1'b1) ? WAIT1 : C0;\n            WAIT1: next_state = y ? G1 : WAIT2;\n            WAIT2: next_state = y ? G1 : G0;\n            G1:    next_state = G1;\n            G0:    next_state = G0;\n            default: next_state = A;\n        endcase\n    end\n\n    // Outputs\n    assign f = (state == B);\n    assign g = (state == WAIT1) || (state == WAIT2) || (state == G1);\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // On the falling edge of clk, synchronously reset or load d\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // synchronous active\u2011high reset to 0x34\n        else\n            q <= d;      // normal D\u2011flip\u2011flop operation\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // Even parity = XOR reduction of all 8 input bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input       in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output      out\n);\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A: in=0\u2192A, in=1\u2192B\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B: in=0\u2192C, in=1\u2192B\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C: in=0\u2192A, in=1\u2192D\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D: in=0\u2192C, in=1\u2192B\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic (Moore): only depends on current state\n    assign out = (state == 2'b11);  // D\u21921, others\u21920\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z is 1 when x and y are equal (XNOR)\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active\u2011high\n    input        w,\n    output       z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // output logic (Moore)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             resetn,   // synchronous, active\u2011low\n    input      [1:0]  byteena,  // byteena[1] = upper byte, byteena[0] = lower byte\n    input      [15:0] d,\n    output reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // write lower byte\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            // write upper byte\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input            clk,\n    input  [7:0]     in,\n    output reg [7:0] pedge\n);\n\n    // two\u2010stage shift register to detect a 0\u21921 transition one cycle later\n    reg [7:0] d1, d2;\n\n    always @(posedge clk) begin\n        d1    <= in;         // stage 1: sample input\n        d2    <= d1;         // stage 2: delayed input\n        pedge <= d1 & ~d2;   // pedge will be high one cycle after 0\u21921\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clock,\n    input        a, \n    output reg   p,\n    output reg   q\n);\n\n    // level\u2013high transparent latch for p\n    // when clock==1, p follows a; when clock==0, p holds its last value\n    always @(*) begin\n        if (clock)\n            p = a;\n        // else p retains its old value (inferred latch)\n    end\n\n    // falling\u2010edge\u2010triggered D\u2010FF for q\n    // on each negedge of clock, q <= p\n    always @(negedge clock) begin\n        q <= p;\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input       [511:0] data,\n    output reg  [511:0] q\n);\n\n    reg [511:0] q_next;\n    integer     i;\n\n    // compute next state (Rule 90) with zero boundary\n    always @* begin\n        // left boundary: q[-1]=0, so q_next[0] = 0 ^ q[1] = q[1]\n        q_next[0] = q[1];\n        // interior cells\n        for (i = 1; i < 511; i = i + 1)\n            q_next[i] = q[i-1] ^ q[i+1];\n        // right boundary: q[512]=0, so q_next[511] = q[510] ^ 0 = q[510]\n        q_next[511] = q[510];\n    end\n\n    // sequential update / load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= q_next;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n\n    // z is 1 if and only if A equals B\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // (1) both this bit and its left neighbour are 1:\n    //    out_both[i] = in[i] & in[i+1],  i=0..98\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) this bit or its right neighbour are 1:\n    //    out_any[i] = in[i] | in[i-1],  i=1..99\n    assign out_any  = in[99:1] & 1'b1 // preserve range\n                     | in[98:0];     // align bit\u20110..98 with 1..99\n\n    // (3) bit differs from its left neighbour, with wrap at MSB:\n    //    out_different[i] = in[i] ^ in[(i+1)%100]\n    //    we build a 1\u2011bit left\u2011rotated version of 'in':\n    //      rotated = { in[0], in[99:1] }\n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic d,\n    input  logic ena,\n    output logic q\n);\n\n    // Level\u2010sensitive D\u2010latch: when ena==1, q follows d; when ena==0, q holds its value\n    always @(*) begin\n        if (ena)\n            q = d;\n        // else q retains its previous value (latch inferred)\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input   [7:0]  sel,\n    output  [3:0]  out\n);\n\n  // Break the 1024\u2011bit bus into 256 entries of 4 bits each.\n  wire [3:0] in_w [0:255];\n  genvar i;\n  generate\n    for (i = 0; i < 256; i = i + 1) begin : pack\n      // in_w[i] gets bits in[4*i+3 : 4*i]\n      assign in_w[i] = in[4*i +: 4];\n    end\n  endgenerate\n\n  // Select the desired 4\u2011bit slice\n  assign out = in_w[sel];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\nalways_comb begin\n    case (sel)\n        4'd0:  out = a;\n        4'd1:  out = b;\n        4'd2:  out = c;\n        4'd3:  out = d;\n        4'd4:  out = e;\n        4'd5:  out = f;\n        4'd6:  out = g;\n        4'd7:  out = h;\n        4'd8:  out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of each bit\n    assign out_or_bitwise = a | b;\n\n    // logical OR of the entire vectors\n    // reduction OR on a and b, then logical OR\n    assign out_or_logical = (|a) || (|b);\n\n    // upper half = ~b, lower half = ~a\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input       in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output      out\n);\n\n    // one\u2011hot encoding:\n    // state[0] = A, state[1] = B, state[2] = C, state[3] = D\n\n    // combinational next\u2011state logic\n    always @(*) begin\n        // default\n        next_state = 4'b0000;\n\n        // A <= A when in=0, C when in=0\n        next_state[0] = (state[0] & ~in)\n                      | (state[2] & ~in);\n\n        // B <= A when in=1, B when in=1, D when in=1\n        next_state[1] = in & (state[0]\n                            | state[1]\n                            | state[3]);\n\n        // C <= B when in=0, D when in=0\n        next_state[2] = ~in & (state[1]\n                              | state[3]);\n\n        // D <= C when in=1\n        next_state[3] = state[2] & in;\n    end\n\n    // Moore output: out=1 in state D only\n    assign out = state[3];\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // intermediate pairwise minima\n    reg [7:0] ab_min, cd_min;\n\n    always @(*) begin\n        // find min of a and b\n        ab_min = (a < b) ? a : b;\n        // find min of c and d\n        cd_min = (c < d) ? c : d;\n        // find overall min\n        min    = (ab_min < cd_min) ? ab_min : cd_min;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and   = a & b;\n    assign out_or    = a | b;\n    assign out_xor   = a ^ b;\n    assign out_nand  = ~(a & b);\n    assign out_nor   = ~(a | b);\n    assign out_xnor  = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": ""}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concatenate with the 8\u2011bit input\n    assign out = { {24{in[7]}}, in };\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // active\u2010low synchronous reset\n    input  in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    // 4\u2010stage shift register with sync. active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        if      (in[0]) pos = 2'd0;\n        else if (in[1]) pos = 2'd1;\n        else if (in[2]) pos = 2'd2;\n        else if (in[3]) pos = 2'd3;\n        else             pos = 2'd0;\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  areset,\n    output out\n);\n    // state encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Tie the output to logic 0\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n\n    // Drive the output constantly high\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @* begin\n        for (i = 0; i < 100; i = i + 1)\n            out[i] = in[99 - i];\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    output logic out\n);\n\n    // On each rising edge of clk, sample D = in ^ out\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,\n    input        load,\n    input        ena,\n    input  [3:0] data,\n    output reg [3:0] q\n);\n\n    // Asynchronous reset, synchronous load/shift\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            // right shift: MSB \u2190 0, LSB is shifted out\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = \u03a3m(2,3,5,7) = (~x3 & x2) | (x2 & x1) | (x3 & x1)\n    //       = (x2 & ~x3) | (x1 & (x2 | x3))\n    assign f = (x2 & ~x3) | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2010flip\u2010flops with active\u2010high async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // 100\u2011input reduction gates\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // half\u2010adder: sum is XOR of inputs, carry\u2010out is AND of inputs\n    assign sum  = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input           cpu_overheated,\n    output reg      shut_off_computer,\n    input           arrived,\n    input           gas_tank_empty,\n    output reg      keep_driving\n);\n\n    // combinational logic, no latches\n    always @(*) begin\n        // shut off computer when CPU overheats\n        shut_off_computer = cpu_overheated;\n\n        // keep driving if not arrived AND tank not empty\n        keep_driving = (~arrived) && (~gas_tank_empty);\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        reset,  // active\u2010high synchronous reset\n    output       out\n);\n    // state encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default:      next_state = OFF;\n        endcase\n    end\n\n    // state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate all inputs (30 bits) + two LSB '1' bits \u2192 32 bits total,\n    // then split into four 8\u2010bit chunks for w,x,y,z.\n    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n    // q is high when the total number of 1\u2019s on {a,b,c,d} is even\n    assign q = ~(a ^ b ^ c ^ d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // Continuous assignment for AND gate\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam B = 1'b0,\n               A = 1'b1;\n\n    reg state, next_state;\n\n    // State register (synchronous active\u2010high reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum is the XOR of all three inputs\n    assign sum  = a ^ b ^ cin;\n    // carry-out is high if any two or more inputs are high\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\nalways_comb\n    out = (in1 ~^ in2) ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n// we must implement these four functions of (c,d) using only 2:1 muxes:\n//  mux_in[0] = f00(c,d) = c|d       = d ? 1 : c\n//  mux_in[1] = f01(c,d) = 0         = 1'b0\n//  mux_in[2] = f10(c,d) = c|~d      = d ? c : 1\n//  mux_in[3] = f11(c,d) = c&d       = d ? c : 0\n\n// the Verilog ?: operator synthesizes to a 2-to-1 MUX\n\nassign mux_in[0] = d ? 1'b1 : c;    // c OR d\nassign mux_in[1] = 1'b0;            // constant 0\nassign mux_in[2] = d ? c      : 1'b1; // c OR ~d\nassign mux_in[3] = d ? c      : 1'b0; // c AND d\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  x,\n    output z\n);\n\n    // one\u2010hot state encoding\n    reg sA, sB;\n    wire next_sA, next_sB;\n\n    // next\u2010state logic\n    assign next_sA = sA & ~x;            // stay in A only if in A and x==0\n    assign next_sB = (sA & x) | sB;      // go to B on A,x==1 or stay in B\n\n    // output logic (Mealy)\n    assign z = (sA & x) | (sB & ~x);\n\n    // state register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            sA <= 1'b1;\n            sB <= 1'b0;\n        end else begin\n            sA <= next_sA;\n            sB <= next_sB;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // f = \u03a3m(0,2,8,9,10,11,12,13)\n    // K\u2010map grouping yields\n    //    f = ~x[2]&~x[4]\n    //      + x[3]&x[4]&(~x[1] | x[2])\n\n    always_comb begin\n        f = (~x[2] & ~x[4])\n          | ( x[3] & x[4] & (~x[1] | x[2]) );\n    end\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous active\u2010high\n    input  in,\n    output disc,\n    output flag,\n    output err\n);\n\n    // State encoding\n    localparam S0    = 4'd0,\n               S1    = 4'd1,\n               S2    = 4'd2,\n               S3    = 4'd3,\n               S4    = 4'd4,\n               S5    = 4'd5,\n               S6    = 4'd6,\n               SDISC = 4'd7,\n               SFLAG = 4'd8,\n               SERR  = 4'd9;\n\n    reg [3:0] state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            S0:    next_state = in ? S1    : S0;\n            S1:    next_state = in ? S2    : S0;\n            S2:    next_state = in ? S3    : S0;\n            S3:    next_state = in ? S4    : S0;\n            S4:    next_state = in ? S5    : S0;\n            S5:    next_state = in ? S6    : SDISC;  // five 1s + 0 \u2192 discard\n            S6:    next_state = in ? SERR  : SFLAG;  // six 1s + 0 \u2192 flag,  +1 \u2192 error\n            SDISC: next_state = in ? S1    : S0;     // eat stuffed 0, then treat as fresh 0\n            SFLAG: next_state = in ? S1    : S0;\n            SERR:  next_state = in ? SERR  : S0;     // stay in error on 1s, clear on 0\n            default: next_state = S0;\n        endcase\n    end\n\n    // Moore outputs\n    assign disc = (state == SDISC);\n    assign flag = (state == SFLAG);\n    assign err  = (state == SERR);\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire       clk,\n    input  wire       reset,   // synchronous, active\u2011high\n    input  wire       data,\n    output wire [3:0] count,\n    output reg        counting,\n    output reg        done,\n    input  wire       ack\n);\n\n    // states\n    localparam SEARCH = 2'd0,\n               SHIFT  = 2'd1,\n               COUNT  = 2'd2,\n               DONE   = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // for pattern detect\n    reg [3:0] shift_reg;\n\n    // for shifting in delay[3:0]\n    reg [2:0] bitcnt;\n    reg [3:0] delay_load;\n\n    // remaining blocks\n    reg [3:0] delay_rem;\n\n    // cycle counter for 1000 clocks\n    reg [9:0] cycle_cnt;\n    localparam CYCLES = 10'd999;  // count 0..999 = 1000 clocks\n\n    // output assignment\n    assign count = delay_rem;  \n\n    // FSM sequential\n    always @(posedge clk) begin\n        if (reset) begin\n            state       <= SEARCH;\n            shift_reg   <= 4'd0;\n            bitcnt      <= 3'd0;\n            delay_load  <= 4'd0;\n            delay_rem   <= 4'd0;\n            cycle_cnt   <= 10'd0;\n            counting    <= 1'b0;\n            done        <= 1'b0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n            SEARCH: begin\n                // shift in for pattern\n                shift_reg <= {shift_reg[2:0], data};\n            end\n\n            SHIFT: begin\n                // shift next 4 data bits into delay_load\n                shift_reg  <= {shift_reg[2:0], data}; // optional, not used further\n                delay_load <= {delay_load[2:0], data};\n                bitcnt     <= bitcnt + 1'b1;\n            end\n\n            COUNT: begin\n                counting <= 1'b1;\n                // count 1000 cycles\n                if (cycle_cnt == CYCLES) begin\n                    cycle_cnt <= 10'd0;\n                    // block complete: decrement remaining\n                    if (delay_rem != 4'd0)\n                        delay_rem <= delay_rem - 1'b1;\n                end else begin\n                    cycle_cnt <= cycle_cnt + 1'b1;\n                end\n            end\n\n            DONE: begin\n                done <= 1'b1;\n                counting <= 1'b0;\n            end\n            endcase\n\n            // clear one\u2011cycle signals on state entry/exit\n            if (state != COUNT)\n                cycle_cnt <= 10'd0;\n            if (state != DONE)\n                done <= 1'b0;\n            if (state != COUNT)\n                counting <= 1'b0;\n        end\n    end\n\n    // FSM next\u2011state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n        SEARCH: begin\n            if (shift_reg == 4'b1101)\n                next_state = SHIFT;\n        end\n\n        SHIFT: begin\n            if (bitcnt == 3'd3)\n                next_state = COUNT;\n        end\n\n        COUNT: begin\n            // when last block finished, i.e. delay_rem==0 && just completed 1000 cycles\n            if (cycle_cnt == CYCLES && delay_rem == 4'd0)\n                next_state = DONE;\n        end\n\n        DONE: begin\n            if (ack)\n                next_state = SEARCH;\n        end\n        endcase\n    end\n\n    // load delay_rem when entering COUNT\n    always @(posedge clk) begin\n        if (!reset && state == SHIFT && next_state == COUNT) begin\n            delay_rem <= delay_load + 1'b0; // initial remaining = loaded value\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input              clk,\n    input              reset,  // active\u2010high, synchronous\n    input       [3:1]  s,      // s[1]=lowest, s[3]=highest\n    output reg         fr3,\n    output reg         fr2,\n    output reg         fr1,\n    output reg         dfr     // supplemental valve\n);\n\n    // remember last sensor state\n    reg [3:1] prev_s;\n\n    // count how many sensors are asserted\n    wire [1:0] sum_curr = s[1] + s[2] + s[3];\n    wire [1:0] sum_prev = prev_s[1] + prev_s[2] + prev_s[3];\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // reset to \"water low for a long time\"\n            prev_s <= 3'b000;\n            fr1    <= 1'b1;\n            fr2    <= 1'b1;\n            fr3    <= 1'b1;\n            dfr    <= 1'b1;\n        end else begin\n            // detect rising level\n            dfr <= (sum_curr > sum_prev) ? 1'b1 : 1'b0;\n\n            // update nominal flow outputs based on current sensor pattern\n            case (s)\n                3'b111: {fr3, fr2, fr1} <= 3'b000; // above s3: no flow\n                3'b110: {fr3, fr2, fr1} <= 3'b001; // between s3 & s2: fr1\n                3'b100: {fr3, fr2, fr1} <= 3'b011; // between s2 & s1: fr1,fr2\n                3'b000: {fr3, fr2, fr1} <= 3'b111; // below s1: fr1,fr2,fr3\n                default: {fr3, fr2, fr1} <= 3'b111; // safe default\n            endcase\n\n            // remember this cycle's sensor reading\n            prev_s <= s;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE     = 2'd0,\n               DATA     = 2'd1,\n               STOP     = 2'd2,\n               ERR_STOP = 2'd3;\n\n    reg [1:0] state;\n    reg [3:0] bitcnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state  <= IDLE;\n            bitcnt <= 4'd0;\n            done   <= 1'b0;\n        end else begin\n            // default\n            done <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    // Wait for start bit (0)\n                    if (in == 1'b0) begin\n                        state  <= DATA;\n                        bitcnt <= 4'd0;\n                    end\n                end\n\n                DATA: begin\n                    // shift through 8 data bits LSB first\n                    if (bitcnt == 4'd7) begin\n                        state <= STOP;\n                    end\n                    bitcnt <= bitcnt + 4'd1;\n                end\n\n                STOP: begin\n                    // check stop bit (must be 1)\n                    if (in == 1'b1) begin\n                        done  <= 1'b1;\n                        state <= IDLE;\n                    end else begin\n                        // bad stop bit, wait until line returns to 1\n                        state <= ERR_STOP;\n                    end\n                end\n\n                ERR_STOP: begin\n                    // keep waiting for a valid stop bit\n                    if (in == 1'b1) begin\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output reg [7:0] out_byte,\n    output reg       done\n);\n    // State encoding\n    localparam IDLE      = 3'd0;\n    localparam START     = 3'd1;\n    localparam DATA      = 3'd2;\n    localparam STOP      = 3'd3;\n    localparam WAIT_STOP = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [2:0] bit_cnt;\n    reg [7:0] shift_reg;\n\n    // Sequential: state transitions, bit\u2011shifting, output generation\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bit_cnt   <= 3'd0;\n            shift_reg <= 8'd0;\n            out_byte  <= 8'd0;\n            done      <= 1'b0;\n        end else begin\n            state <= next_state;\n            done  <= 1'b0;           // default: deassert done every cycle\n            case (state)\n                IDLE: begin\n                    // waiting for start bit\n                end\n                START: begin\n                    // consume start bit, initialize for data\n                    bit_cnt   <= 3'd0;\n                    shift_reg <= 8'd0;\n                end\n                DATA: begin\n                    // shift in LSB\u2011first\n                    shift_reg <= {in, shift_reg[7:1]};\n                    bit_cnt   <= bit_cnt + 1'b1;\n                end\n                STOP: begin\n                    // check stop bit\n                    if (in) begin\n                        out_byte <= shift_reg;\n                        done     <= 1'b1;\n                    end\n                    // else bad stop \u2192 handled in next_state logic\n                end\n                WAIT_STOP: begin\n                    // just wait for line to return to idle (1)\n                end\n            endcase\n        end\n    end\n\n    // Combinational: next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: \n                if (in == 1'b0)\n                    next_state = START;      // start bit detected\n            START:\n                next_state = DATA;          // move on to data bits\n            DATA:\n                if (bit_cnt == 3'd7)\n                    next_state = STOP;       // all 8 data bits done\n            STOP:\n                if (in)\n                    next_state = IDLE;       // good stop bit\n                else\n                    next_state = WAIT_STOP;  // bad stop, wait for idle\n            WAIT_STOP:\n                if (in)\n                    next_state = IDLE;       // back to idle\n            default:\n                next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    // prediction interface\n    input        predict_valid,\n    input  [6:0] predict_pc,\n    output       predict_taken, \n    output [6:0] predict_history,\n\n    // training interface\n    input        train_valid,\n    input        train_taken,\n    input        train_mispredicted,\n    input  [6:0] train_history, \n    input  [6:0] train_pc\n);\n\n    // 128-entry PHT of 2-bit saturating counters\n    reg [1:0] pht [0:127];\n    // global history register\n    reg [6:0] history_reg;\n\n    // combinational prediction\n    wire [6:0] predict_idx     = predict_pc ^ history_reg;\n    wire [1:0] predict_counter = pht[predict_idx];\n\n    assign predict_taken   = predict_counter[1];\n    assign predict_history = history_reg;\n\n    // combinational train index\n    wire [6:0] train_idx = train_pc ^ train_history;\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // reset GHISTORY\n            history_reg <= 7'b0;\n            // init PHT to weakly not taken (01)\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b01;\n        end else begin\n            // 1) update PHT if training\n            if (train_valid) begin\n                if (train_taken) begin\n                    // increment toward '11'\n                    if (pht[train_idx] != 2'b11)\n                        pht[train_idx] <= pht[train_idx] + 1;\n                end else begin\n                    // decrement toward '00'\n                    if (pht[train_idx] != 2'b00)\n                        pht[train_idx] <= pht[train_idx] - 1;\n                end\n            end\n\n            // 2) update global history\n            //    - on mispredict recovery has priority\n            if (train_valid && train_mispredicted) begin\n                history_reg <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                history_reg <= { history_reg[5:0], predict_taken };\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": ""}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input  clk,\n    input  reset,        // synchronous, active\u2010high\n    input  data,\n    output reg shift_ena,\n    output reg counting,\n    input  done_counting,\n    output reg done,\n    input  ack\n);\n\n    // State encoding\n    reg [3:0] state, next_state;\n    localparam \n        S0        = 4'd0,   // no bits matched\n        S1        = 4'd1,   // saw \"1\"\n        S11       = 4'd2,   // saw \"11\"\n        S110      = 4'd3,   // saw \"110\"\n        SHIFT1    = 4'd4,   // 1st shift pulse\n        SHIFT2    = 4'd5,   // 2nd\n        SHIFT3    = 4'd6,   // 3rd\n        SHIFT4    = 4'd7,   // 4th\n        COUNTING  = 4'd8,   // counting in datapath\n        DONE_ST   = 4'd9;   // timeout, waiting for ack\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic + output logic (Moore)\n    always @(*) begin\n        // defaults\n        next_state = state;\n        shift_ena   = 1'b0;\n        counting    = 1'b0;\n        done        = 1'b0;\n\n        case(state)\n            // --------------------------------------------------\n            // SEARCH FOR 1101\n            S0: begin\n                if (data)        next_state = S1;\n                else             next_state = S0;\n            end\n            S1: begin\n                if (data)        next_state = S11;\n                else             next_state = S0;\n            end\n            S11: begin\n                if (data)        next_state = S11;   // \"111\" \u2192 keep last two '11'\n                else             next_state = S110;  // \"110\"\n            end\n            S110: begin\n                if (data)        next_state = SHIFT1; // \"1101\" detected!\n                else             next_state = S0;     // mismatch, go back\n            end\n\n            // --------------------------------------------------\n            // ISSUE EXACTLY 4 SHIFT PULSES\n            SHIFT1: begin\n                shift_ena   = 1'b1;\n                next_state  = SHIFT2;\n            end\n            SHIFT2: begin\n                shift_ena   = 1'b1;\n                next_state  = SHIFT3;\n            end\n            SHIFT3: begin\n                shift_ena   = 1'b1;\n                next_state  = SHIFT4;\n            end\n            SHIFT4: begin\n                shift_ena   = 1'b1;\n                next_state  = COUNTING;\n            end\n\n            // --------------------------------------------------\n            // ASSERT counting UNTIL done_counting\n            COUNTING: begin\n                counting    = 1'b1;\n                if (done_counting)\n                    next_state = DONE_ST;\n                else\n                    next_state = COUNTING;\n            end\n\n            // --------------------------------------------------\n            // ASSERT done UNTIL ack\n            DONE_ST: begin\n                done        = 1'b1;\n                if (ack)\n                    next_state = S0;\n                else\n                    next_state = DONE_ST;\n            end\n\n            default: begin\n                next_state = S0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer r, c;\n    integer r_up, r_dn, c_l, c_r, idx;\n    reg [3:0] sum;\n\n    // Compute next state combinationally\n    always @* begin\n        for (r = 0; r < 16; r = r + 1) begin\n            for (c = 0; c < 16; c = c + 1) begin\n                // wrap\u2010around neighbors\n                r_up = (r == 0)  ? 15 : r - 1;\n                r_dn = (r == 15) ?  0 : r + 1;\n                c_l  = (c == 0)  ? 15 : c - 1;\n                c_r  = (c == 15) ?  0 : c + 1;\n                // sum the eight neighbors\n                sum = q[r_up*16 + c_l] + q[r_up*16 + c] + q[r_up*16 + c_r]\n                    + q[r  *16 + c_l]                 + q[r  *16 + c_r]\n                    + q[r_dn*16 + c_l] + q[r_dn*16 + c] + q[r_dn*16 + c_r];\n                idx = r*16 + c;\n                // apply rules: 3 \u2192 live; 2 \u2192 hold; else \u2192 dead\n                next_q[idx] = (sum == 3) || (q[idx] && sum == 2);\n            end\n        end\n    end\n\n    // Sequential update / load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n    // state encoding\n    localparam WALK_L = 3'd0,\n               WALK_R = 3'd1,\n               FALL_L = 3'd2,\n               FALL_R = 3'd3,\n               DIG_L  = 3'd4,\n               DIG_R  = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state register with async posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_L;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        next_state = state;  // default hold\n        case (state)\n            // walking left\n            WALK_L: begin\n                if (!ground)\n                    next_state = FALL_L;\n                else if (dig)\n                    next_state = DIG_L;\n                else if (bump_left && bump_right)\n                    next_state = WALK_R;  // invert on both\n                else if (bump_left)\n                    next_state = WALK_R;\n                else if (bump_right)\n                    next_state = WALK_L;  // bump on right while walking left \u2192 stays left\n            end\n            // walking right\n            WALK_R: begin\n                if (!ground)\n                    next_state = FALL_R;\n                else if (dig)\n                    next_state = DIG_R;\n                else if (bump_left && bump_right)\n                    next_state = WALK_L;\n                else if (bump_left)\n                    next_state = WALK_R;  // bump on left while walking right \u2192 stays right\n                else if (bump_right)\n                    next_state = WALK_L;\n            end\n            // falling: ignore bump/dig until ground returns\n            FALL_L: begin\n                if (ground)\n                    next_state = WALK_L;\n            end\n            FALL_R: begin\n                if (ground)\n                    next_state = WALK_R;\n            end\n            // digging: ignore bump/dig until ground=0\n            DIG_L: begin\n                if (!ground)\n                    next_state = FALL_L;\n            end\n            DIG_R: begin\n                if (!ground)\n                    next_state = FALL_R;\n            end\n            default: next_state = WALK_L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WALK_L);\n    assign walk_right = (state == WALK_R);\n    assign aaah       = (state == FALL_L) || (state == FALL_R);\n    assign digging    = (state == DIG_L ) || (state == DIG_R );\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,\n    input            ena,\n    output reg       pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n    // Synchronous 12\u2011hour BCD clock with AM/PM\n    always @(posedge clk) begin\n        if (reset) begin\n            // 12:00:00 AM\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n            pm <= 1'b0;\n        end else if (ena) begin\n            // --- seconds increment ---\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                // --- minutes increment ---\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    // --- hours increment ---\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;              // toggle AM/PM at 12 -> 1\n                    end else if (hh[3:0] == 4'h9) begin\n                        // BCD tens++\n                        hh <= { hh[7:4] + 1, 4'h0 };\n                    end else begin\n                        // BCD ones++\n                        hh <= hh + 8'h01;\n                    end\n                end else if (mm[3:0] == 4'h9) begin\n                    // BCD tens++\n                    mm <= { mm[7:4] + 1, 4'h0 };\n                end else begin\n                    // BCD ones++\n                    mm <= mm + 8'h01;\n                end\n            end else if (ss[3:0] == 4'h9) begin\n                // seconds tens++\n                ss <= { ss[7:4] + 1, 4'h0 };\n            end else begin\n                // seconds ones++\n                ss <= ss + 8'h01;\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input            clk,\n    input            areset,\n    input            bump_left,\n    input            bump_right,\n    input            ground,\n    output           walk_left,\n    output           walk_right,\n    output           aaah\n);\n\n    // State encoding\n    localparam WL = 2'b00,  // walking left\n               WR = 2'b01,  // walking right\n               FL = 2'b10,  // falling (remember left)\n               FR = 2'b11;  // falling (remember right)\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WL;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WL: begin\n                if (!ground)          next_state = FL;\n                else if (bump_left)   next_state = WR;\n                else                   next_state = WL;\n            end\n            WR: begin\n                if (!ground)          next_state = FR;\n                else if (bump_right)  next_state = WL;\n                else                   next_state = WR;\n            end\n            FL: begin\n                if (ground)           next_state = WL;\n                else                   next_state = FL;\n            end\n            FR: begin\n                if (ground)           next_state = WR;\n                else                   next_state = FR;\n            end\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,   // synchronous, active\u2010high\n    output      [3:1] ena,     // carry\u2010out enables for digits 1..3\n    output reg [15:0] q        // BCD digits: q[3:0]=ones, q[7:4]=tens, q[11:8]=hundreds, q[15:12]=thousands\n);\n\n    // detect when a digit rolls over from 9->0\n    wire one_roll  = (q[3:0]   == 4'd9);\n    wire ten_roll  = one_roll && (q[7:4]   == 4'd9);\n    wire hun_roll  = ten_roll && (q[11:8] == 4'd9);\n\n    // upper\u2010digit enables\n    assign ena[1] = one_roll;   // enable tens\n    assign ena[2] = ten_roll;   // enable hundreds\n    assign ena[3] = hun_roll;   // enable thousands\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit\n            if (one_roll)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // tens digit\n            if (one_roll) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // hundreds digit\n            if (ten_roll) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // thousands digit\n            if (hun_roll) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose 'a', when sel=1 choose 'b'\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,\n    input        w,\n    output reg   Y2\n);\n\n    // Next\u2010state bit y[2] logic\n    // States A=000, B=001, C=010, D=011, E=100, F=101\n    // Y2 = 1 for B(001), C(010,w=1), E(100,w=1), F(101)\n    always @(*) begin\n        // (~y2 & y1) covers B and F\n        // w & ~y1 & ((~y3 & y2) | (y3 & ~y2)) covers C(w=1) and E(w=1)\n        Y2 = (~y[2] & y[1]) \n           | (w & ~y[1] & ((~y[3] & y[2]) | (y[3] & ~y[2])));\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring is asserted and we're not in vibrate mode, turn on ringer.\n    // If ring is asserted and we are in vibrate mode, turn on motor.\n    assign ringer = ring & ~vibrate_mode;\n    assign motor  = ring &  vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Continuous\u2010assignment AND\n    assign out_assign = a & b;\n\n    // Combinational always block AND\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    // Constant 0 output\n    assign zero = 1'b0;\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  a,\n    output reg q\n);\n\n    // remember previous a\n    reg prev_a;\n\n    always @(posedge clk) begin\n        // if two equal a\u2019s in a row, update q\n        if (a == prev_a) begin\n            if (a == 1'b0)\n                q <= 1'b1;\n            else\n                q <= 1'b0;\n        end\n        // else hold q\n\n        // update history\n        prev_a <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // active\u2010high asynchronous reset\n    input  x,       // serial input, LSB first\n    output z        // serial two's\u2010complement output\n);\n\n    // state = 1 means we still have the +1 carry to add\n    reg state, next_state;\n\n    // state register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 1'b1;       // upon reset, re\u2010start adding the +1\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic: carry_out = carry_in & ~x\n    // once x==1 we consume the carry (carry\u21920) forever\n    assign next_state = state & ~x;\n\n    // output logic: while carry=1, z=x; once carry=0, z=~x\n    assign z = state ? x : ~x;\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output       out\n);\n\n    // state encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n    // Reverse byte order: [31:24]\u2194[7:0], [23:16]\u2194[15:8]\n    assign out = { in[7:0],\n                   in[15:8],\n                   in[23:16],\n                   in[31:24] };\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // Synchronous active\u2011high reset D\u2011flip\u2011flop\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        load,\n    input        ena,\n    input  [1:0] amount,\n    input  [63:0] data,\n    output reg [63:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: // shift left by 1\n                    q <= {q[62:0], 1'b0};\n                2'b01: // shift left by 8\n                    q <= {q[55:0], 8'b0};\n                2'b10: // arithmetic shift right by 1\n                    q <= {q[63], q[63:1]};\n                2'b11: // arithmetic shift right by 8\n                    q <= {{8{q[63]}}, q[63:8]};\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    localparam S0 = 2'd0,  // no bits seen\n               S1 = 2'd1,  // saw '1'\n               S2 = 2'd2;  // saw \"10\"\n\n    reg [1:0] state, next_state;\n\n    // state register with negative-edge asynchronous reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic and Mealy output\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;  // still saw a '1'\n                else\n                    next_state = S2;  // got \"10\"\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;  // overlap: last '1'\n                    z = 1'b1;         // detected \"101\"\n                end else begin\n                    next_state = S0;  // reset on '0'\n                end\n            end\n            default: begin\n                next_state = S0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,\n    input  w,\n    output z\n);\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;  // A(0)--1-->A, --0-->B\n            B: next_state = w ? D : C;  // B(0)--1-->D, --0-->C\n            C: next_state = w ? D : E;  // C(0)--1-->D, --0-->E\n            D: next_state = w ? A : F;  // D(0)--1-->A, --0-->F\n            E: next_state = w ? D : E;  // E(1)--1-->D, --0-->E\n            F: next_state = w ? D : C;  // F(1)--1-->D, --0-->C\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": ""}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,   // one\u2010hot state: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1,  // next\u2010state bit for B (y[1])\n    output       Y3   // next\u2010state bit for D (y[3])\n);\n\n    // From A (y[0]), w=1 \u2192 B\n    assign Y1 = y[0] & w;\n\n    // From B, C, E, F on w=0 \u2192 D\n    // i.e. y[1] or y[2] or y[4] or y[5], when w=0\n    assign Y3 = ~w & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the full vector\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o2   = vec[2];\n    assign o1   = vec[1];\n    assign o0   = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2010map we get\n    // out = a^b ^ c^d = parity of all four inputs\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Split the 16-bit input into high and low bytes\n    assign out_lo = in[7:0];    // Lower byte\n    assign out_hi = in[15:8];   // Upper byte\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // NOR gate implementation\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a,\n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) Continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) Combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) Clocked always block XOR (registered, one\u2010clock delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one\u2010hot: y[1]=A, y[2]=B, y[3]=C, y[4]=D, y[5]=E, y[6]=F\n    input        w,\n    output       Y2, // next\u2010state bit for B\n    output       Y4  // next\u2010state bit for D\n);\n\n    // Y2 = go to B only from A on w=0\n    assign Y2 = y[1] & ~w;\n\n    // Y4 = go to D on w=1 from B, C, E, or F\n    assign Y4 = w & ( y[2] | y[3] | y[5] | y[6] );\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input   [7:0] sel,\n    output        out\n);\n\n    // 256-to-1 mux: select one bit of 'in' based on 'sel'\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // Internal data\u2010select net\n    wire D;\n    \n    // Multiplexer tree:\n    //   if L=1   \u2192 load R\n    //   else if E=1 \u2192 shift in w\n    //   else      \u2192 hold Q\n    assign D = L ? R\n             : E ? w\n             : Q;\n\n    // D\u2010flip\u2010flop clocked on rising edge\n    always @(posedge clk) begin\n        Q <= D;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state bits\n    reg q0, q1, q2;\n\n    // next\u2010state logic\n    wire d0 = x ^  q0;    // XOR with its own output\n    wire d1 = x & ~q1;    // AND with its own complemented output\n    wire d2 = x | ~q2;    // OR  with its own complemented output\n\n    // state registers (initialized to zero)\n    initial {q2, q1, q0} = 3'b000;\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\n    // output: 3\u2010input XNOR\n    assign z = ~(q0 ^ q1 ^ q2);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n    // From the truth\u2010table, q = 1 whenever b=1 or c=1, regardless of a or d.\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // combinational next\u2010state\n    reg [511:0] next_q;\n    integer     i;\n    always @(*) begin\n        for (i = 0; i < 512; i = i+1) begin\n            // pick left/center/right, padding boundaries with 0\n            case ({ (i==0    ? 1'b0 : q[i-1]),\n                    (            q[i]         ),\n                    (i==511  ? 1'b0 : q[i+1]) })\n                // patterns that produce 1 in Rule 110\n                3'b110,\n                3'b101,\n                3'b011,\n                3'b010,\n                3'b001: next_q[i] = 1'b1;\n                default: next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    // synchronous load / step\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n    // state encoding\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // state register with synchronous, active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    out = sel ? b : a;\nend\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "// 1-bit D\u2011FF + 2:1 mux\nmodule top_module(\n    input        clk,\n    input        L,\n    input        q_in,\n    input        r_in,\n    output reg   Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\n// 3-bit register with load or feedback {q[1]^q[2], q[0], q[2]}\nmodule full_module(\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n\n    wire q0, q1, q2;\n    wire f0, f1, f2;\n\n    // feedback taps\n    assign f2 = q1 ^ q2;  // new MSB\n    assign f1 = q0;       // new mid\n    assign f0 = q2;       // new LSB\n\n    // instantiate three 1\u2011bit regs\n    top_module u2 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (f2),\n        .r_in  (r[2]),\n        .Q     (q2)\n    );\n\n    top_module u1 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (f1),\n        .r_in  (r[1]),\n        .Q     (q1)\n    );\n\n    top_module u0 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (f0),\n        .r_in  (r[0]),\n        .Q     (q0)\n    );\n\n    // pack outputs\n    assign q = {q2, q1, q0};\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,  // active\u2010high synchronous\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // Register to hold previous cycle's input\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out     <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            // detect 1->0 transitions: prev_in & ~in\n            // once set, out bit stays high until reset\n            out     <= out | (prev_in & ~in);\n            // update previous-input\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On every rising edge of clk, capture the 8\u2010bit input d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // 8\u2011bit two\u2019s\u2011complement addition\n    assign s = a + b;\n\n    // Signed overflow occurs if a and b have the same sign\n    // but the sum has the opposite sign:\n    //   a[7]==b[7] && s[7]!=a[7]\n    assign overflow = (~a[7] & ~b[7] &  s[7])\n                    | ( a[7] &  b[7] & ~s[7]);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,    // one-hot: [0]=S, [1]=S1, [2]=S11, [3]=S110, [4]=B0, [5]=B1, [6]=B2, [7]=B3, [8]=Count, [9]=Wait\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n    // Next\u2010state logic\n    // S_next: stay in S on d=0 from S, S1, S11, S110; or return to S from Wait when ack=1\n    assign S_next     = (~d & (state[0] | state[1] | state[2] | state[3])) \n                        | (state[9] & ack);\n\n    // S1_next: from S on d=1\n    assign S1_next    = state[0] & d;\n\n    // B3_next: from B2 unconditionally\n    assign B3_next    = state[6];\n\n    // Count_next: from B3 unconditionally, or stay in Count until done_counting\n    assign Count_next = state[7] \n                        | (state[8] & ~done_counting);\n\n    // Wait_next: from Count when done_counting, or stay in Wait until ack\n    assign Wait_next  = (state[8] & done_counting) \n                        | (state[9] & ~ack);\n\n    // Output logic (Moore outputs)\n    assign done       = state[9];                     // Wait state\n    assign counting   = state[8];                     // Count state\n    assign shift_ena  = state[4] | state[5] \n                      | state[6] | state[7];         // B0\u2013B3 states\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        train_valid,\n    input  logic        train_taken,\n    output logic [1:0]  state\n);\n\n  logic [1:0] next_state;\n\n  // Combinational next-state logic for a 2-bit saturating counter\n  always_comb begin\n    next_state = state;\n    if (train_valid) begin\n      if (train_taken) begin\n        if (state != 2'b11)\n          next_state = state + 1;\n      end else begin\n        if (state != 2'b00)\n          next_state = state - 1;\n      end\n    end\n  end\n\n  // Synchronous state update with asynchronous reset\n  always_ff @(posedge clk or posedge areset) begin\n    if (areset)\n      state <= 2'b01;        // weakly not\u2010taken on reset\n    else\n      state <= next_state;\n  end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;  // no bits set\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    // Combinational logic: decode the 16\u2011bit scancode into one of four arrow outputs\n    always @(*) begin\n        // Default all outputs to 0\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        case (scancode)\n            16'hE06B: left  = 1'b1;  // Left arrow  \n            16'hE072: down  = 1'b1;  // Down arrow  \n            16'hE074: right = 1'b1;  // Right arrow \n            16'hE075: up    = 1'b1;  // Up arrow    \n            default:   ;              // No arrow key\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    // internal carry wires\n    wire c1, c2, c3;\n\n    // instantiate 4 full\u2010adders\n    full_adder fa0 (\n        .a  (x[0]),\n        .b  (y[0]),\n        .ci (1'b0),\n        .s  (sum[0]),\n        .co (c1)\n    );\n\n    full_adder fa1 (\n        .a  (x[1]),\n        .b  (y[1]),\n        .ci (c1),\n        .s  (sum[1]),\n        .co (c2)\n    );\n\n    full_adder fa2 (\n        .a  (x[2]),\n        .b  (y[2]),\n        .ci (c2),\n        .s  (sum[2]),\n        .co (c3)\n    );\n\n    full_adder fa3 (\n        .a  (x[3]),\n        .b  (y[3]),\n        .ci (c3),\n        .s  (sum[3]),\n        .co (sum[4])   // MSB is the final carry (overflow)\n    );\nendmodule\n\n// simple full\u2010adder module\nmodule full_adder (\n    input  a,\n    input  b,\n    input  ci,\n    output s,\n    output co\n);\n    assign s  = a ^ b ^ ci;\n    assign co = (a & b) | (b & ci) | (a & ci);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,           // async, posedge active\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n    \n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // internal 32\u2010bit history register\n    logic [31:0] history;\n\n    // expose current history\n    assign predict_history = history;\n\n    // on reset, clear; on mispredict, rollback+insert actual;\n    // else on valid prediction, shift in predicted bit\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // rollback to train_history (pre\u2010branch) then shift in actual\n            history <= { train_history[30:0], train_taken };\n        end\n        else if (predict_valid) begin\n            // shift in new prediction\n            history <= { history[30:0], predict_taken };\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // intermediate wires for the two AND gates\n    wire ab_and;\n    wire cd_and;\n\n    // first layer: two AND gates\n    and u_and1(ab_and, a, b);\n    and u_and2(cd_and, c, d);\n\n    // second layer: OR gate driving out\n    or  u_or1(out,    ab_and, cd_and);\n\n    // inverted output\n    not u_not1(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // On each rising edge of clk, sample d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n\n    // 8\u2011bit shift register\n    // Q[0] is the first stage (MSB shifted in first), Q[7] is the last stage\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            // shift right: new Q[0] <= S; Q[i] <= old Q[i\u20131]\n            Q <= { Q[6:0], S };\n        end\n    end\n\n    // 8\u2011to\u20111 multiplexer: select one of Q[0]..Q[7] by {A,B,C}\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater is on in heating mode when it's too cold\n    assign heater = mode & too_cold;\n\n    // Aircon is on in cooling mode when it's too hot\n    assign aircon = (~mode) & too_hot;\n\n    // Fan runs if user requests it or whenever heater/aircon is on\n    assign fan    = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,   // synchronous active\u2010high\n    output reg [31:0] q       // 32\u2010bit Galois LFSR state\n);\n\n    // tap mask for positions 32,22,2,1 \u2192 bits [31,21,1,0]\n    localparam [31:0] TAPS = 32'h8020_0003;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h0000_0001;\n        end else begin\n            // Galois LFSR: shift right, conditionally XOR with TAPS when LSB=1\n            if (q[0])\n                q <= (q >> 1) ^ TAPS;\n            else\n                q <=  q >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the waveform, q is high iff (a or b) is high AND (c or d) is high.\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d, \n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // Two independent 4-input NAND gates, replicating the 7420\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @* begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,       // bits\u00a00\u20132: check in[i] & in[i+1]\n    output [3:1] out_any,        // bits\u00a01\u20133: check in[i] | in[i-1]\n    output [3:0] out_different   // wrapping XOR with left neighbor\n);\n\n    // (1) both this bit and its left neighbour are 1\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // (2) any of this bit or its right neighbour is 1\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // (3) bit differs from its left neighbour (with wrap\u2011around)\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0]     a,\n    output reg [15:0] q\n);\n    // Combinational lookup extracted from the waveform\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // Synchronous active\u2010high reset, count on slowena\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n        // else: hold current q\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // AND gate with bubble on in2 (i.e. in2 is inverted)\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinationally tie out to in\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic (Moore machine)\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore: output depends only on current state)\n    assign out = (state == B) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // Two single\u2010edge FFs: one on posedge, one on negedge\n    reg q_pos, q_neg;\n\n    // Capture D on rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Capture D on falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Mux between the two based on clock level\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // XNOR gate: out is 1 if a and b are equal\n    assign out = ~(a ^ b);\n    // alternatively: assign out = a ~^ b;\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // internal nets\n    wire a1, a2;\n    wire b1, b2;\n    wire or_out, and_out;\n\n    // instantiate first A and B, OR their outputs\n    A uA1 (\n        .x(x),\n        .y(y),\n        .z(a1)\n    );\n    B uB1 (\n        .x(x),\n        .y(y),\n        .z(b1)\n    );\n    assign or_out = a1 | b1;\n\n    // instantiate second A and B, AND their outputs\n    A uA2 (\n        .x(x),\n        .y(y),\n        .z(a2)\n    );\n    B uB2 (\n        .x(x),\n        .y(y),\n        .z(b2)\n    );\n    assign and_out = a2 & b2;\n\n    // final XOR\n    assign z = or_out ^ and_out;\n\nendmodule\n\n\n// Module A: z = (x ^ y) & x\nmodule A(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n\n// Module B: implements XNOR, as per waveform\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = ~(x ^ y);  // or: assign z = x ~^ y;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input       [1:0]  ena,\n    input       [99:0] data,\n    output reg  [99:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01:  // rotate right by 1\n                    q <= { q[0], q[99:1] };\n                2'b10:  // rotate left by 1\n                    q <= { q[98:0], q[99] };\n                default: // 2'b00 or 2'b11: hold\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 10'd1;\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Invert input\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input         in,\n    input  [9:0]  state,\n    output [9:0]  next_state,\n    output        out1,\n    output        out2\n);\n\n    // Next\u2010state logic for one\u2010hot encoding\n    // on in=0\n    assign next_state[0] = ~in & (state[0] | state[1] | state[2] | state[3] |\n                                  state[4] | state[7] | state[8] | state[9]);\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // on in=1\n    assign next_state[1] =  in & (state[0] | state[8] | state[9]);\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & (state[6] | state[7]);\n\n    // All other next_state bits are 0 (since unassigned bits default to 1\u2019b0)\n\n    // Output logic (one\u2010hot current state \u2192 outputs)\n    assign out1 = state[8] | state[9];  // high in S8 or S9\n    assign out2 = state[7] | state[9];  // high in S7 or S9\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;    // no change\n            2'b01: Q <= 1'b0; // reset\n            2'b10: Q <= 1'b1; // set\n            2'b11: Q <= ~Q;   // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n    // Sum the three bits; result ranges from 0 to 3, fits in 2 bits\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // We want out[24] = ~(a^a), out[23] = ~(a^b), \u2026 out[20] = ~(a^e)\n    //              out[19] = ~(b^a), \u2026                 out[15] = ~(b^e)\n    // and so on down to out[4] = ~(d^a)\u2026 out[0] = ~(e^e).\n    //\n    // Equivalence of x and y is ~(x^y), which can be written ~x ^ y.\n\n    assign out = {\n        ~a^a, ~a^b, ~a^c, ~a^d, ~a^e,   // bits 24..20\n        ~b^a, ~b^b, ~b^c, ~b^d, ~b^e,   // bits 19..15\n        ~c^a, ~c^b, ~c^c, ~c^d, ~c^e,   // bits 14..10\n        ~d^a, ~d^b, ~d^c, ~d^d, ~d^e,   // bits 9 ..5\n        ~e^a, ~e^b, ~e^c, ~e^d, ~e^e    // bits 4 ..0\n    };\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,       // async, posedge-active reset\n    input        bump_left,\n    input        bump_right,\n    output       walk_left,\n    output       walk_right\n);\n\n    // State encoding\n    localparam LEFT  = 1'b0,\n               RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore FSM)\n    // If bumped on either side, flip direction; otherwise stay\n    always @(*) begin\n        if (bump_left | bump_right)\n            next_state = ~state;\n        else\n            next_state = state;\n    end\n\n    // Output logic (Moore: outputs depend only on state)\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n    // From the waveform, q is high only when both a and b are 1\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // intermediate AND gates\n    wire p1_and1, p1_and2;\n    wire p2_and1, p2_and2;\n\n    assign p1_and1 = p1a & p1b & p1c;\n    assign p1_and2 = p1d & p1e & p1f;\n    assign p1y     = p1_and1 | p1_and2;\n\n    assign p2_and1 = p2a & p2b;\n    assign p2_and2 = p2c & p2d;\n    assign p2y     = p2_and1 | p2_and2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    // Combinational logic for next\u2010state bit Y0 and output z\n    always @(*) begin\n        // next state bit 0\n        case (y)\n            3'b000: Y0 = x;      // 000 \u2192 Y0 = 0 when x=0, 1 when x=1\n            3'b001: Y0 = ~x;     // 001 \u2192 Y0 = 1 when x=0, 0 when x=1\n            3'b010: Y0 = x;      // 010 \u2192 Y0 = 0 when x=0, 1 when x=1\n            3'b011: Y0 = ~x;     // 011 \u2192 Y0 = 1 when x=0, 0 when x=1\n            3'b100: Y0 = ~x;     // 100 \u2192 Y0 = 1 when x=0, 0 when x=1\n            default: Y0 = 1'b0;  // unused states\n        endcase\n\n        // output z = 1 only in states 011 or 100\n        z = (y == 3'b011) || (y == 3'b100);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2-input NOR: out = ~(in1 | in2)\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    // Simple wire connections\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  d,\n    input  ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous active\u2010high reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] cnt;\n\n    // Synchronous load / countdown\n    always @(posedge clk) begin\n        if (load) begin\n            cnt <= data;\n        end else if (cnt != 0) begin\n            cnt <= cnt - 1;\n        end\n        // else cnt stays at 0\n    end\n\n    // Terminal count flag\n    assign tc = (cnt == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,        // active\u2010high synchronous reset\n    input  data,\n    output reg start_shifting\n);\n\n    // State encoding\n    localparam S0      = 3'd0,\n               S1      = 3'd1,\n               S11     = 3'd2,\n               S110    = 3'd3,\n               S_SHIFT = 3'd4;\n\n    reg [2:0] state, next_state;\n\n    // State register and start_shifting register\n    always @(posedge clk) begin\n        if (reset) begin\n            state           <= S0;\n            start_shifting  <= 1'b0;\n        end else begin\n            state <= next_state;\n            // latch the detection flag when we see 1101\n            if (state == S110 && data == 1'b1)\n                start_shifting <= 1'b1;\n            else\n                start_shifting <= start_shifting;\n        end\n    end\n\n    // Next\u2010state logic\n    always @* begin\n        next_state = state;\n        case (state)\n            S0:    next_state = (data) ? S1   : S0;\n            S1:    next_state = (data) ? S11  : S0;\n            S11:   next_state = (data) ? S11  : S110;\n            S110:  next_state = (data) ? S_SHIFT : S0;\n            S_SHIFT: next_state = S_SHIFT;  // stay in shifting state\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2011FFs with active\u2011high synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold last\u2010cycle input\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        // detect 0\u21921 on each bit: set anyedge one cycle later\n        anyedge <= (~in_d) & in;\n        // update delayed version\n        in_d    <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // Synchronous active\u2010high reset, count 1..10\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    // On each rising clock:\n    //   \u2013 if a==1, load q with 4\n    //   \u2013 else count up modulo\u20107 (0\u20266)\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4;\n        else if (q == 3'd6)\n            q <= 3'd0;\n        else\n            q <= q + 3'd1;\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [4:0] q\n);\n\n    // Galois\u2011LFSR for polynomial x^5 + x^3 + 1 (taps at bit positions 5 and 3)\n    // mask has 1\u2019s at bit-positions 4 and 2 (0-based) corresponding to degrees 5 and 3\n    localparam [4:0] TAP_MASK = 5'b10100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // synchronous, active\u2011high reset to non\u2011zero seed\n            q <= 5'b00001;\n        end else begin\n            // shift right; if LSB was 1, XOR in TAP_MASK\n            if (q[0])\n                q <= (q >> 1) ^ TAP_MASK;\n            else\n                q <= q >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // perform add or subtract\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        // set zero\u2010flag\n        if (out == 8'd0)\n            result_is_zero = 1'b1;\n        else\n            result_is_zero = 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // f = x3\u00b7!x1  +  x4\u00b7x2\n    // from K\u2010map simplification:\n    //   group of four at x3=1,x1=0  \u2192 x3 & ~x1\n    //   group of two at x4=1,x2=1  \u2192 x4 & x2\n\n    assign f = (x[3] & ~x[1]) | (x[4] & x[2]);\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @(*) begin\n        valid = 1'b0;\n        out   = 4'd0;\n        case (code)\n            8'h45: begin valid = 1'b1; out = 4'd0; end\n            8'h16: begin valid = 1'b1; out = 4'd1; end\n            8'h1E: begin valid = 1'b1; out = 4'd2; end\n            8'h26: begin valid = 1'b1; out = 4'd3; end\n            8'h25: begin valid = 1'b1; out = 4'd4; end\n            8'h2E: begin valid = 1'b1; out = 4'd5; end\n            8'h36: begin valid = 1'b1; out = 4'd6; end\n            8'h3D: begin valid = 1'b1; out = 4'd7; end\n            8'h3E: begin valid = 1'b1; out = 4'd8; end\n            8'h46: begin valid = 1'b1; out = 4'd9; end\n            default: begin valid = 1'b0; out = 4'd0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse bit ordering: b7 b6 b5 b4 b3 b2 b1 b0 -> b0 b1 b2 b3 b4 b5 b6 b7\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2010map simplification you get:\n    //    f = a + c\n    // All don't\u2010cares can be absorbed into this expression.\n\n    always @(*) begin\n        out = a | c;\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift right, new bit into MSB\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // down\u2010count\n            q <= q - 1;\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Pass-through wire behavior\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,      // synchronous, active\u2010high\n    output shift_ena\n);\n\n    // counter to generate a 4-cycle pulse after reset\n    reg [2:0] cnt;\n\n    // synchronous reset, count down when nonzero\n    always @(posedge clk) begin\n        if (reset)\n            cnt <= 3'd4;            // load 4 on reset\n        else if (cnt != 3'd0)\n            cnt <= cnt - 3'd1;      // count down\n        // else remain at 0\n    end\n\n    // shift enable is high while cnt>0 (exactly 4 cycles after reset)\n    assign shift_ena = (cnt != 3'd0);\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    // On each rising clock edge, if reset is asserted, clear q to 0.\n    // Otherwise, increment the 4\u2011bit counter (wraps naturally mod 16).\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // 2-to-1 mux using continuous assignment\n    // if sel_b1 and sel_b2 are both true, choose b; otherwise choose a\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // 2-to-1 mux using procedural if\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    input  c,\n    output out\n);\n    // The only 0 in the K\u2010map is at a=0, b=0, c=0\n    // so out is 1 whenever at least one of a, b, or c is 1.\n    assign out = a | b | c;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,  // active\u2010low synchronous reset\n    input  [3:1] r,       // r[1],r[2],r[3] requests\n    output [3:1] g        // g[1],g[2],g[3] grants\n);\n\n    // State encoding\n    localparam [1:0]\n        A = 2'b00,\n        B = 2'b01,  // grant to device 1\n        C = 2'b10,  // grant to device 2\n        D = 2'b11;  // grant to device 3\n\n    reg [1:0] state, next_state;\n\n    //================================================================\n    // 1) Combinational next\u2010state logic\n    //================================================================\n    always @(*) begin\n        case(state)\n            A: begin\n                if (r[1])       next_state = B;\n                else if (r[2])  next_state = C;\n                else if (r[3])  next_state = D;\n                else            next_state = A;\n            end\n            B: begin\n                if (r[1])       next_state = B;\n                else            next_state = A;\n            end\n            C: begin\n                if (r[2])       next_state = C;\n                else            next_state = A;\n            end\n            D: begin\n                if (r[3])       next_state = D;\n                else            next_state = A;\n            end\n            default:          next_state = A;\n        endcase\n    end\n\n    //================================================================\n    // 2) State flip\u2010flops (synchronous, active\u2010low reset)\n    //================================================================\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    //================================================================\n    // 3) Output logic (one\u2010hot grant)\n    //================================================================\n    // g[i] is high iff we are in state B/C/D corresponding to i=1/2/3\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0;\n        else if (q == 4'd9) \n            q <= 4'd0;\n        else \n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output reg   done\n);\n\n    // count = how many bytes of the current 3\u2010byte packet have been seen:\n    // 0 = waiting for a byte with in[3]=1 (packet start)\n    // 1 = got 1st byte, now expecting 2nd\n    // 2 = got 2nd byte, now expecting 3rd\n    reg [1:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n            done  <= 0;\n        end else begin\n            // default: no done unless we just saw the 3rd byte\n            done <= 0;\n            case (count)\n                2'd0: begin\n                    // looking for first byte (in[3]==1)\n                    if (in[3])\n                        count <= 2'd1;\n                    else\n                        count <= 2'd0;\n                end\n                2'd1: begin\n                    // we have first, now consume second\n                    count <= 2'd2;\n                end\n                2'd2: begin\n                    // this in is the 3rd byte\n                    done  <= 1;\n                    // after a full packet, go back to search\n                    count <= 2'd0;\n                end\n                default: count <= 2'd0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n    // 2-to-1 multiplexer: when sel=0 select a, when sel=1 select b\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // reduction operators implement 4\u2010input gates\n    assign out_and = &in;   // 4-input AND\n    assign out_or  = |in;   // 4-input OR\n    assign out_xor = ^in;   // 4-input XOR (parity)\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active\u2010high\n    input        x,\n    output reg   z\n);\n    // state encoding\n    localparam S0 = 3'b000,\n               S1 = 3'b001,\n               S2 = 3'b010,\n               S3 = 3'b011,\n               S4 = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // next\u2010state & output logic (Moore)\n    always @(*) begin\n        // default\n        next_state = S0;\n        z          = 1'b0;\n        case(state)\n            S0: begin\n                next_state = x ? S1 : S0;\n                z          = 1'b0;\n            end\n            S1: begin\n                next_state = x ? S4 : S1;\n                z          = 1'b0;\n            end\n            S2: begin\n                next_state = x ? S1 : S2;\n                z          = 1'b0;\n            end\n            S3: begin\n                next_state = x ? S2 : S1;\n                z          = 1'b1;\n            end\n            S4: begin\n                next_state = x ? S4 : S3;\n                z          = 1'b1;\n            end\n            default: begin\n                next_state = S0;\n                z          = 1'b0;\n            end\n        endcase\n    end\n\n    // state register with synchronous, active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  x,\n    input  y,\n    output f,\n    output g\n);\n\n    // state encoding\n    localparam A       = 4'd0,\n               S0      = 4'd1,\n               S1      = 4'd2,\n               S2      = 4'd3,\n               DET     = 4'd4,\n               WAIT_Y0 = 4'd5,\n               WAIT_Y1 = 4'd6,\n               G1      = 4'd7,\n               G0      = 4'd8;\n\n    reg [3:0] state, next_state;\n\n    // state register with synchronous, active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            A:       next_state = S0;                   // after reset, one cycle of f=1\n            S0:      next_state = x ? S1 : S0;          // look for first '1'\n            S1:      next_state = x ? S1 : S2;          // saw '1', now look for '0'\n            S2:      next_state = x ? DET : S0;         // saw '10', look for final '1'\n            DET:     next_state = WAIT_Y0;              // 101 detected, next cycle g=1\n            WAIT_Y0: next_state = y ? G1 : WAIT_Y1;     // first y window\n            WAIT_Y1: next_state = y ? G1 : G0;          // second y window\n            G1:      next_state = G1;                   // permanent g=1\n            G0:      next_state = G0;                   // permanent g=0\n            default: next_state = A;\n        endcase\n    end\n\n    // outputs\n    assign f = (state == A);\n    assign g = (state == WAIT_Y0 || state == WAIT_Y1 || state == G1);\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // even parity bit: XOR\u2010reduce all 8 data bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            2'b00:  // A\n                if (in) next_state = 2'b01; // B\n                else    next_state = 2'b00; // A\n            2'b01:  // B\n                if (in) next_state = 2'b01; // B\n                else    next_state = 2'b10; // C\n            2'b10:  // C\n                if (in) next_state = 2'b11; // D\n                else    next_state = 2'b00; // A\n            2'b11:  // D\n                if (in) next_state = 2'b01; // B\n                else    next_state = 2'b10; // C\n            default:\n                next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic (Moore): only depends on current state\n    assign out = (state == 2'b11);  // 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // From the waveform, z = 1 only when (x,y) = 00 or 11\n    // i.e. z = XNOR(x,y)\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,\n    input  w,\n    output z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register (synchronous reset, active-high)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\n    // 16 D\u2011FFs with byte enables and sync, active\u2011low reset\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // lower byte (bits 7:0)\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            // upper byte (bits 15:8)\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // internal registers to hold previous input and the detected edges\n    reg [7:0] prev;\n    reg [7:0] detect;\n\n    always @(posedge clk) begin\n        // detect 0\u21921 transitions this cycle\n        detect <= in & ~prev;\n        // output the detected transitions from the previous cycle\n        pedge  <= detect;\n        // save current input for next\u2010cycle comparison\n        prev   <= in;\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clock,\n    input        a,\n    output reg   p,\n    output reg   q\n);\n\n    // p is a positive\u2010level latch: transparent when clock=1\n    always @ (clock or a) begin\n        if (clock)\n            p = a;\n        // else keep old p (incomplete if => latch)\n    end\n\n    // q is a negative\u2010level latch: transparent when clock=0\n    always @ (clock or p) begin\n        if (!clock)\n            q = p;\n        // else keep old q\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // next state is XOR of left and right neighbors, with zero\u2010boundaries\n    wire [511:0] next_q = ({q[510:0], 1'b0} ^ {1'b0, q[511:1]});\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n    // z is 1 when A equals B\n    assign z = (A == B);\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left neighbour (higher\u2010indexed bit) are 1\n    //    out_both[i] = in[i] & in[i+1], for i = 0..98\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) any of this bit or its right neighbour (lower\u2010indexed bit) is 1\n    //    out_any[i] = in[i] | in[i-1], for i = 1..99\n    assign out_any  = in[99:1] | in[98:0];\n\n    // (3) this bit differs from its left neighbour, wrapping around\n    //    neighbor(i) = in[(i+1)%100]\n    //    out_different = in ^ {in[0], in[99:1]}\n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic d,\n    input  logic ena,\n    output logic q\n);\n\n    // level\u2010sensitive D\u2010latch: when ena==1, q follows d; when ena==0, q holds its value\n    always_latch begin\n        if (ena)\n            q = d;\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n    // Shift the 1024\u2011bit vector right by sel*4,\n    // then take the low 4 bits as the selected nibble.\n    assign out = (in >> (sel * 4))[3:0];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0:  out = a;\n            4'd1:  out = b;\n            4'd2:  out = c;\n            4'd3:  out = d;\n            4'd4:  out = e;\n            4'd5:  out = f;\n            4'd6:  out = g;\n            4'd7:  out = h;\n            4'd8:  out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output       out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of corresponding bits\n    assign out_or_bitwise = a | b;\n\n    // logical OR: high if any bit of a or b is 1\n    assign out_or_logical = |(a | b);\n\n    // upper half = ~b[2:0], lower half = ~a[2:0]\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,       // one-hot: A=0001, B=0010, C=0100, D=1000\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // Moore output: high only in state D\n    assign out = state[3];\n\n    // Next\u2010state logic\n    always @(*) begin\n        // default all zero\n        next_state = 4'b0000;\n\n        // A = state[0]; B = state[1]; C = state[2]; D = state[3]\n        // A->A on in=0, C->A on in=0\n        next_state[0] = (state[0] & ~in) |\n                        (state[2] & ~in);\n\n        // A->B on in=1, B->B on in=1, D->B on in=1\n        next_state[1] = (state[0] &  in) |\n                        (state[1] &  in) |\n                        (state[3] &  in);\n\n        // B->C on in=0, D->C on in=0\n        next_state[2] = (state[1] & ~in) |\n                        (state[3] & ~in);\n\n        // C->D on in=1\n        next_state[3] =  state[2] & in;\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // combinational logic to find the minimum of four unsigned 8\u2011bit numbers\n    always @(*) begin\n        min = a;\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Combinational logic assignments\n    assign out_and   = a &  b;\n    assign out_or    = a |  b;\n    assign out_xor   = a ^  b;\n    assign out_nand  = ~(a &  b);\n    assign out_nor   = ~(a |  b);\n    assign out_xnor  = ~(a ^  b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input            clk,\n    input            reset,  // active\u2010high synchronous\n    input            s,\n    input            w,\n    output reg       z\n);\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n    reg        state;\n    reg [1:0]  cycle_count;  // counts 0,1,2,3\n    reg [1:0]  ones_count;   // counts number of 1\u2019s seen in the 3 samples\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state       <= A;\n            cycle_count <= 2'd0;\n            ones_count  <= 2'd0;\n            z           <= 1'b0;\n        end else begin\n            // default: deassert z unless we override below\n            z <= 1'b0;\n\n            case (state)\n                A: begin\n                    // stay in A until s=1\n                    cycle_count <= 2'd0;\n                    ones_count  <= 2'd0;\n                    if (s)\n                        state <= B;\n                end\n\n                B: begin\n                    if (cycle_count < 2'd3) begin\n                        // collect one more w\u2010sample\n                        ones_count  <= ones_count + (w ? 1'b1 : 1'b0);\n                        cycle_count <= cycle_count + 2'd1;\n                    end else begin\n                        // we've just finished 3 samples: now assert z if exactly two 1's\n                        z           <= (ones_count == 2);\n                        // reset counters to start next 3\u2010sample window\n                        cycle_count <= 2'd0;\n                        ones_count  <= 2'd0;\n                    end\n                end\n\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate sign\u2010bit (in[7]) 24 times, then concatenate the original 8 bits\n    assign out = {{24{in[7]}}, in};\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    // 4\u2010bit shift register\n    reg [3:0] shift_reg;\n    \n    // The MSB of the shift register is the module output\n    assign out = shift_reg[3];\n    \n    // Synchronous, active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= { shift_reg[2:0], in };\n    end\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n\n    // Combinational priority encoder: MSB has highest priority.\n    always @(*) begin\n        if      (in[3]) pos = 2'd3;\n        else if (in[2]) pos = 2'd2;\n        else if (in[1]) pos = 2'd1;\n        else if (in[0]) pos = 2'd0;\n        else             pos = 2'd0;  // default when in == 4'b0000\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        areset,\n    output       out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            OFF:    next_state = j ? ON  : OFF;\n            ON:     next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic (Moore: depends only on state)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n\n    // Continuously drive the output low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n\n    // Continuously drive the output high\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @* begin\n        for (i = 0; i < 100; i = i + 1)\n            out[i] = in[99 - i];\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // On each rising clock edge, capture D = in XOR out\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,\n    input        load,\n    input        ena,\n    input  [3:0] data,\n    output reg [3:0] q\n);\n\n    // Asynchronous reset, synchronous load / shift\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            // right shift, MSB becomes 0\n            q <= {1'b0, q[3:1]};\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = \u03a3 m(2,3,5,7) = (~x3 & x2) | (x3 & x1)\n    assign f = (x3 & x1) | (~x3 & x2);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // 8 D-flops with active\u2010high async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // reduction operators apply across all bits of the vector\n    assign out_and = &in;   // 100\u2010input AND\n    assign out_or  = |in;   // 100\u2010input OR\n    assign out_xor = ^in;   // 100\u2010input XOR\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // Sum is XOR of a and b\n    assign sum  = a ^ b;\n    // Carry-out is AND of a and b\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input  cpu_overheated,\n    output reg shut_off_computer,\n    input  arrived,\n    input  gas_tank_empty,\n    output reg keep_driving\n);\n\n    // Combinational logic: no latches\n    always @(*) begin\n        // shut_off_computer is 1 if CPU overheats, else 0\n        shut_off_computer = cpu_overheated;\n\n        // keep_driving is true only if we have not arrived and the tank is not empty\n        keep_driving = (~arrived) && (~gas_tank_empty);\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        reset,\n    output       out\n);\n\n    // state encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // state register with synchronous active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate a\u2013f (30 bits) and two LSBs of 1, then split into four 8\u2011bit outputs\n    assign {w, x, y, z} = { a, b, c, d, e, f, 1'b1, 1'b1 };\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n// q is high when the number of 1\u2019s on {a,b,c,d} is even\nassign q = ~(a ^ b ^ c ^ d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // Simple AND gate implementation\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state_reg, state_next;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state_reg <= B;\n        else\n            state_reg <= state_next;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state_reg)\n            B: state_next = (in ? B : A);\n            A: state_next = (in ? A : B);\n            default: state_next = B;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state_reg == B);\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum = a \u2295 b \u2295 cin\n    assign sum  = a ^ b ^ cin;\n\n    // cout = majority(a, b, cin)\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // intermediate net to hold XNOR result of in1 and in2\n    logic xnor_out;\n\n    // two\u2011input XNOR\n    assign xnor_out = in1 ~^ in2;\n\n    // two\u2011input XOR with in3\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n// ab = 00 : f = c + d  = c?1:d\nassign mux_in[0] = c ? 1'b1 : d;\n\n// ab = 01 : f = 0\nassign mux_in[1] = 1'b0;\n\n// ab = 11 : f = c\u00b7d  = c?d:0\nassign mux_in[2] = c ? d : 1'b0;\n\n// ab = 10 : f = c | ~d  = d?c:1\nassign mux_in[3] = d ? c : 1'b1;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // asynchronous active\u2010high reset\n    input  x,\n    output reg z\n);\n\n    // one\u2010hot encoding: state[0]=A, state[1]=B\n    localparam [1:0] A = 2'b01,\n                     B = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    // combinational next\u2010state and output logic\n    always @(*) begin\n        // default assignments to avoid inferred latches\n        next_state = A;\n        z          = 1'b0;\n        case (state)\n            A: begin\n                if (x == 1'b0) begin\n                    next_state = A;\n                    z          = 1'b0;\n                end else begin\n                    next_state = B;\n                    z          = 1'b1;\n                end\n            end\n            B: begin\n                next_state = B;\n                if (x == 1'b0)\n                    z = 1'b1;\n                else\n                    z = 1'b0;\n            end\n            default: begin\n                // on invalid encoding, go to A\n                next_state = A;\n                z          = 1'b0;\n            end\n        endcase\n    end\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output disc,\n    output flag,\n    output err\n);\n\n    // State encoding\n    localparam S0 = 4'd0,  // no recent 1s (or just saw 0)\n               S1 = 4'd1,\n               S2 = 4'd2,\n               S3 = 4'd3,\n               S4 = 4'd4,\n               S5 = 4'd5,\n               S6 = 4'd6,\n               D  = 4'd7,  // discard state (0111110)\n               F  = 4'd8,  // flag state    (01111110)\n               E  = 4'd9;  // error state   (7+ ones)\n\n    reg [3:0] state, next_state;\n\n    // State register (synchronous reset, active high)\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1  : S0;\n            S1: next_state = in ? S2  : S0;\n            S2: next_state = in ? S3  : S0;\n            S3: next_state = in ? S4  : S0;\n            S4: next_state = in ? S5  : S0;\n            S5: next_state = in ? S6  : S0;\n            S6: next_state = in ? E   : F;\n            D:  next_state = in ? S1  : S0;\n            F:  next_state = in ? S1  : S0;\n            E:  next_state = in ? E   : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore outputs)\n    assign disc = (state == D);\n    assign flag = (state == F);\n    assign err  = (state == E);\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire       clk,\n    input  wire       reset,    // synchronous active\u2010high\n    input  wire       data,\n    output wire [3:0] count,\n    output reg        counting,\n    output reg        done,\n    input  wire       ack\n);\n\n    // State encoding\n    typedef enum reg [1:0] {S_SEARCH=2'd0, S_SHIFT=2'd1, S_COUNT=2'd2, S_DONE=2'd3} state_t;\n    state_t state, next_state;\n\n    reg [3:0] pattern_sr;    // for 1101 detection\n    reg [1:0] shift_cnt;     // 0..3\n    reg [3:0] delay_reg;     // loaded delay[3:0]\n    reg [3:0] remain;        // remaining segments\n    reg [9:0] cycle_cnt;     // 0..999\n\n    // Output count is current remain\n    assign count = remain;\n\n    // Next\u2010state / datapath\n    always @(posedge clk) begin\n        if (reset) begin\n            state       <= S_SEARCH;\n            pattern_sr  <= 4'b0000;\n            shift_cnt   <= 2'd0;\n            delay_reg   <= 4'd0;\n            remain      <= 4'd0;\n            cycle_cnt   <= 10'd0;\n            counting    <= 1'b0;\n            done        <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                //----------------------------------------------------------------\n                S_SEARCH: begin\n                    counting <= 1'b0;\n                    done     <= 1'b0;\n                    // shift in bit for pattern detection\n                    pattern_sr <= {pattern_sr[2:0], data};\n                end\n\n                //----------------------------------------------------------------\n                S_SHIFT: begin\n                    // load delay MSB first: first data bit --> delay_reg[3], then [2], [1], [0]\n                    delay_reg[3-shift_cnt] <= data;\n                    shift_cnt <= shift_cnt + 1'b1;\n                end\n\n                //----------------------------------------------------------------\n                S_COUNT: begin\n                    counting <= 1'b1;\n                    done     <= 1'b0;\n                    // count 0..999 cycles per segment\n                    if (cycle_cnt == 10'd999) begin\n                        cycle_cnt <= 10'd0;\n                        if (remain == 4'd0) begin\n                            // last segment done\n                            remain <= 4'd0;\n                        end else begin\n                            remain <= remain - 1'b1;\n                        end\n                    end else begin\n                        cycle_cnt <= cycle_cnt + 1'b1;\n                    end\n                end\n\n                //----------------------------------------------------------------\n                S_DONE: begin\n                    counting <= 1'b0;\n                    done     <= 1'b1;\n                    // nothing else until ack\n                end\n\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            //------------------------------------------------------------\n            S_SEARCH: begin\n                if (pattern_sr == 4'b1101) begin\n                    next_state = S_SHIFT;\n                end\n            end\n\n            //------------------------------------------------------------\n            S_SHIFT: begin\n                if (shift_cnt == 2'd3) begin\n                    next_state = S_COUNT;\n                end\n            end\n\n            //------------------------------------------------------------\n            S_COUNT: begin\n                // when last cycle of last segment finishes\n                if (cycle_cnt == 10'd999 && remain == 4'd0) begin\n                    next_state = S_DONE;\n                end\n            end\n\n            //------------------------------------------------------------\n            S_DONE: begin\n                if (ack) begin\n                    next_state = S_SEARCH;\n                end\n            end\n        endcase\n    end\n\n    // Initialize counters on transitions\n    always @(posedge clk) if (!reset) begin\n        if (state == S_SEARCH && next_state == S_SHIFT) begin\n            // got start pattern, init shift_cnt\n            shift_cnt  <= 2'd0;\n        end\n        if (state == S_SHIFT && next_state == S_COUNT) begin\n            // loaded delay_reg, initialize counters\n            remain    <= delay_reg;\n            cycle_cnt <= 10'd0;\n        end\n        if (state == S_DONE && next_state == S_SEARCH) begin\n            // clear pattern shift register for next search\n            pattern_sr <= 4'd0;\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // level encoding: 0=below s1, 1=between s1&s2, 2=between s2&s3, 3=above s3\n    reg [1:0] level, prev_level;\n    wire [1:0] curr_level;\n\n    // decode the current water\u2010level from sensors\n    assign curr_level = s[3] ? 2'd3 :\n                        s[2] ? 2'd2 :\n                        s[1] ? 2'd1 :\n                                2'd0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // reset to \"low water for a long time\" state\n            level      <= 2'd0;\n            prev_level <= 2'd0;\n            fr1        <= 1'b1;\n            fr2        <= 1'b1;\n            fr3        <= 1'b1;\n            dfr        <= 1'b1;\n        end else begin\n            // remember previous level\n            prev_level <= level;\n            level      <= curr_level;\n\n            // nominal flow valves\n            // fr1: on for levels 0,1,2\n            // fr2: on for levels 0,1\n            // fr3: on for level 0\n            fr1 <= (curr_level < 3);\n            fr2 <= (curr_level < 2);\n            fr3 <= (curr_level < 1);\n\n            // supplemental valve on if level is rising\n            dfr <= (curr_level > prev_level);\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output reg   done\n);\n\n    // State encoding\n    localparam IDLE  = 2'd0,\n               RECV  = 2'd1,\n               STOP  = 2'd2,\n               WAIT  = 2'd3;\n\n    reg [1:0] state, next_state;\n    reg [2:0] bit_cnt;  // counts 0..7 for 8 data bits\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Bit counter\n    always @(posedge clk) begin\n        if (reset)\n            bit_cnt <= 3'd0;\n        else begin\n            case (state)\n                IDLE: if (in == 1'b0)\n                          bit_cnt <= 3'd0;  // start counting on start bit detect\n                RECV: bit_cnt <= bit_cnt + 3'd1;\n                default: /* keep */ bit_cnt <= bit_cnt;\n            endcase\n        end\n    end\n\n    // done pulse: high for one cycle when valid stop bit seen\n    always @(posedge clk) begin\n        if (reset)\n            done <= 1'b0;\n        else\n            done <= (state == STOP && in == 1'b1);\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                // wait for start bit (0)\n                if (in == 1'b0)\n                    next_state = RECV;\n            end\n            RECV: begin\n                // received 8 data bits?\n                if (bit_cnt == 3'd7)\n                    next_state = STOP;\n            end\n            STOP: begin\n                // check stop bit\n                if (in == 1'b1)\n                    next_state = IDLE;  // good frame\n                else\n                    next_state = WAIT;  // bad stop bit, wait for line to return high\n            end\n            WAIT: begin\n                // wait for idle high before next start\n                if (in == 1'b1)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output [7:0] out_byte,\n    output       done\n);\n\n    // State encoding\n    localparam IDLE       = 2'd0,\n               RX_DATA    = 2'd1,\n               CHECK_STOP = 2'd2,\n               WAIT_STOP  = 2'd3;\n\n    reg [1:0]      state, next_state;\n    reg [2:0]      bit_cnt;\n    reg [7:0]      data_reg;\n    reg            done_reg;\n\n    // Output assignments\n    assign out_byte = data_reg;\n    assign done     = done_reg;\n\n    // State and data sequential block\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bit_cnt   <= 3'd0;\n            data_reg  <= 8'd0;\n            done_reg  <= 1'b0;\n        end else begin\n            state    <= next_state;\n            done_reg <= 1'b0;  // default deassert\n\n            case (state)\n                IDLE: begin\n                    // wait for start bit (0)\n                    if (in == 1'b0) begin\n                        bit_cnt <= 3'd0;\n                    end\n                end\n\n                RX_DATA: begin\n                    // sample one data bit LSB first\n                    data_reg[bit_cnt] <= in;\n                    bit_cnt <= bit_cnt + 3'd1;\n                end\n\n                CHECK_STOP: begin\n                    // nothing here; decision in next_state logic\n                end\n\n                WAIT_STOP: begin\n                    // just waiting for line to go high\n                end\n            endcase\n        end\n    end\n\n    // Next\u2010state + done logic\n    always @* begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (in == 1'b0)\n                    next_state = RX_DATA;  // got start bit\n                else\n                    next_state = IDLE;\n            end\n\n            RX_DATA: begin\n                if (bit_cnt == 3'd7)\n                    next_state = CHECK_STOP;  // done with 8 data bits\n                else\n                    next_state = RX_DATA;\n            end\n\n            CHECK_STOP: begin\n                if (in == 1'b1) begin\n                    // valid stop bit\n                    next_state = IDLE;\n                    done_reg   = 1'b1;\n                end else begin\n                    // bad stop bit: wait for line high\n                    next_state = WAIT_STOP;\n                end\n            end\n\n            WAIT_STOP: begin\n                if (in == 1'b1)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_STOP;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input              clk,\n    input              areset,\n\n    // Prediction interface (Fetch stage)\n    input              predict_valid,\n    input      [6:0]   predict_pc,\n    output             predict_taken,\n    output reg [6:0]   predict_history,\n\n    // Training interface (execute stage)\n    input              train_valid,\n    input              train_taken,\n    input              train_mispredicted,\n    input      [6:0]   train_history,\n    input      [6:0]   train_pc\n);\n\n    //==========================================================================\n    // 2\u2010bit saturating counter PHT (128 entries)\n    //==========================================================================\n    reg [1:0] pht [0:127];\n\n    //==========================================================================\n    // Global history register (7\u2010bit)\n    //==========================================================================\n    reg [6:0] ghist;\n\n    //==========================================================================\n    // Combinational index and state computations\n    //==========================================================================\n    // Prediction index & state\n    wire [6:0] predict_idx   = predict_pc ^ ghist;\n    wire [1:0] predict_state = pht[predict_idx];\n    // Next history if we take the prediction path\n    wire [6:0] next_ghist_pred = { ghist[5:0], predict_state[1] };\n\n    // Training index & new PHT state\n    wire [6:0] train_idx        = train_pc ^ train_history;\n    wire [1:0] train_old_state  = pht[train_idx];\n    wire [1:0] train_new_state  = train_taken\n                                  ? (train_old_state == 2'b11 ? 2'b11 : train_old_state + 1)\n                                  : (train_old_state == 2'b00 ? 2'b00 : train_old_state - 1);\n    // Next history if we recover on a misprediction\n    wire [6:0] next_ghist_train = { train_history[5:0], train_taken };\n\n    //==========================================================================\n    // Outputs\n    //==========================================================================\n    assign predict_taken   = predict_state[1];\n    // predict_history is just the ghist used internally\n    // (registered at the last clock edge)\n    // We'll update this in the sequential block below.\n\n    //==========================================================================\n    // Sequential block: asynchronous reset, PHT update, GHIST update\n    //==========================================================================\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // reset global history\n            ghist <= 7'b0;\n            predict_history <= 7'b0;\n            // initialize PHT entries to weakly\u2010not\u2010taken (01)\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            // 1) PHT update on training\n            if (train_valid) begin\n                pht[train_idx] <= train_new_state;\n            end\n\n            // 2) GHIST update: misprediction recovery has priority\n            if (train_valid && train_mispredicted) begin\n                ghist <= next_ghist_train;\n            end else if (predict_valid) begin\n                ghist <= next_ghist_pred;\n            end\n\n            // 3) Drive predict_history for downstream stages\n            //    (This is the GHIST used for the last prediction cycle.)\n            if (predict_valid) begin\n                predict_history <= ghist;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam WL = 3'd0,\n               WR = 3'd1,\n               DL = 3'd2,\n               DR = 3'd3,\n               FL = 3'd4,\n               FR = 3'd5,\n               SP = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_count;\n\n    // Asynchronous reset, synchronous state register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state      <= WL;\n            fall_count <= 6'd0;\n        end else begin\n            state <= next_state;\n            // fall_count logic\n            if (state==FL || state==FR) begin\n                if (!ground)\n                    fall_count <= fall_count + 1'b1;\n                else\n                    fall_count <= 6'd0;\n            end else begin\n                fall_count <= 6'd0;\n            end\n        end\n    end\n\n    // Next\u2010state logic (Moore)\n    always @(*) begin\n        next_state = state;  // default\n        case(state)\n            WL, WR: begin\n                // 1) fall if no ground\n                if (!ground) begin\n                    next_state = (state==WL ? FL : FR);\n                end\n                // 2) dig if requested and on ground\n                else if (dig) begin\n                    next_state = (state==WL ? DL : DR);\n                end\n                // 3) bump \u21d2 flip direction\n                else if (bump_left || bump_right) begin\n                    next_state = (state==WL ? WR : WL);\n                end\n            end\n\n            DL, DR: begin\n                // keep digging until hole opens under you\n                if (!ground) begin\n                    next_state = (state==DL ? FL : FR);\n                end\n                // else remain digging\n            end\n\n            FL, FR: begin\n                if (ground) begin\n                    // splatter if fell >20 cycles\n                    if (fall_count > 6'd20)\n                        next_state = SP;\n                    else\n                        next_state = (state==FL ? WL : WR);\n                end\n                // else remain falling\n            end\n\n            SP: begin\n                // stay splattered forever\n                next_state = SP;\n            end\n\n            default: next_state = WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign digging    = (state == DL) || (state == DR);\n    assign aaah       = (state == FL) || (state == FR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    input        data,\n    output reg   shift_ena,\n    output reg   counting,\n    input        done_counting,\n    output reg   done,\n    input        ack\n);\n\n    // state encoding\n    localparam IDLE  = 2'd0,\n               SHIFT = 2'd1,\n               COUNT = 2'd2,\n               DONE  = 2'd3;\n\n    reg [1:0] state;\n    reg [2:0] shift_cnt;\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= IDLE;\n            shift_cnt  <= 3'd0;\n            shift_reg  <= 4'd0;\n            shift_ena  <= 1'b0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            // always shift in serial data\n            shift_reg <= {shift_reg[2:0], data};\n\n            // default outputs\n            shift_ena <= 1'b0;\n            counting  <= 1'b0;\n            done      <= 1'b0;\n\n            case (state)\n                // look for pattern 1101\n                IDLE: begin\n                    if (shift_reg == 4'b1101) begin\n                        state     <= SHIFT;\n                        shift_cnt <= 3'd0;\n                    end\n                end\n\n                // enable shifting next 4 bits\n                SHIFT: begin\n                    shift_ena <= 1'b1;\n                    if (shift_cnt == 3'd3) begin\n                        state <= COUNT;\n                    end\n                    shift_cnt <= shift_cnt + 1'b1;\n                end\n\n                // wait for counter to finish\n                COUNT: begin\n                    counting <= 1'b1;\n                    if (done_counting) begin\n                        state <= DONE;\n                    end\n                end\n\n                // notify done, wait for ack\n                DONE: begin\n                    done <= 1'b1;\n                    if (ack) begin\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input      [255:0]  data,\n    output reg [255:0]  q\n);\n    // next state\n    wire [255:0] next_q;\n\n    genvar r, c;\n    generate\n        for (r = 0; r < 16; r = r + 1) begin : ROWS\n            for (c = 0; c < 16; c = c + 1) begin : COLS\n                // wrap\u2010around neighbours\n                localparam integer UP    = (r == 0  ? 15 : r - 1);\n                localparam integer DOWN  = (r == 15 ? 0  : r + 1);\n                localparam integer LEFT  = (c == 0  ? 15 : c - 1);\n                localparam integer RIGHT = (c == 15 ? 0  : c + 1);\n\n                // count neighbours\n                wire [3:0] sum;\n                assign sum =\n                      q[UP    *16 + LEFT ] + q[UP    *16 + c     ] + q[UP    *16 + RIGHT]\n                    + q[r     *16 + LEFT ]                         + q[r     *16 + RIGHT]\n                    + q[DOWN  *16 + LEFT ] + q[DOWN  *16 + c     ] + q[DOWN  *16 + RIGHT];\n\n                // current cell\n                wire cell = q[r*16 + c];\n\n                // Game of Life rule\n                assign next_q[r*16 + c] =\n                    (sum == 3) ? 1'b1 :\n                    (sum == 2) ? cell : 1'b0;\n            end\n        end\n    endgenerate\n\n    // state register\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input            clk,\n    input            areset,\n    input            bump_left,\n    input            bump_right,\n    input            ground,\n    input            dig,\n    output           walk_left,\n    output           walk_right,\n    output           aaah,\n    output           digging\n);\n\n    // State encoding\n    localparam [2:0]\n        S_L   = 3'd0,  // walking left\n        S_R   = 3'd1,  // walking right\n        S_LF  = 3'd2,  // falling left\n        S_RF  = 3'd3,  // falling right\n        S_DL  = 3'd4,  // digging left\n        S_DR  = 3'd5;  // digging right\n\n    reg [2:0] state, next_state;\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S_L: begin\n                if (!ground)\n                    next_state = S_LF;             // fall\n                else if (dig)\n                    next_state = S_DL;             // start digging\n                else if (bump_left | bump_right)\n                    next_state = S_R;              // turn around\n            end\n            S_R: begin\n                if (!ground)\n                    next_state = S_RF;\n                else if (dig)\n                    next_state = S_DR;\n                else if (bump_left | bump_right)\n                    next_state = S_L;\n            end\n            S_DL: begin\n                if (!ground)\n                    next_state = S_LF;             // reach end of dig \u2192 fall\n            end\n            S_DR: begin\n                if (!ground)\n                    next_state = S_RF;\n            end\n            S_LF: begin\n                if (ground)\n                    next_state = S_L;              // land \u2192 resume left\n            end\n            S_RF: begin\n                if (ground)\n                    next_state = S_R;              // land \u2192 resume right\n            end\n            default: next_state = S_L;\n        endcase\n    end\n\n    // State register with asynchronous posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_L;\n        else\n            state <= next_state;\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_L);\n    assign walk_right = (state == S_R);\n    assign aaah       = (state == S_LF) || (state == S_RF);\n    assign digging    = (state == S_DL) || (state == S_DR);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": ""}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam L  = 2'b00,  // walking left\n               R  = 2'b01,  // walking right\n               FL = 2'b10,  // falling, was going left\n               FR = 2'b11;  // falling, was going right\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= L;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore FSM)\n    always @* begin\n        case (state)\n            L: begin\n                if (!ground)\n                    next_state = FL;             // start falling, keep left direction\n                else if (bump_left)\n                    next_state = R;              // bump on left \u2192 go right\n                else\n                    next_state = L;              // keep walking left\n            end\n\n            R: begin\n                if (!ground)\n                    next_state = FR;             // start falling, keep right direction\n                else if (bump_right)\n                    next_state = L;              // bump on right \u2192 go left\n                else\n                    next_state = R;              // keep walking right\n            end\n\n            FL: begin\n                if (ground)\n                    next_state = L;              // landed \u2192 resume walking left\n                else\n                    next_state = FL;             // keep falling\n            end\n\n            FR: begin\n                if (ground)\n                    next_state = R;              // landed \u2192 resume walking right\n                else\n                    next_state = FR;             // keep falling\n            end\n\n            default: next_state = L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == L);\n    assign walk_right = (state == R);\n    assign aaah       = (state == FL) || (state == FR);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n    // detect when each digit is about to roll over from 9 -> 0\n    wire ones_max     = (q[3:0]   == 4'd9);\n    wire tens_max     = (q[7:4]   == 4'd9);\n    wire hundreds_max= (q[11:8] == 4'd9);\n\n    // enable pulses for cascading\n    assign ena[1] = ones_max;\n    assign ena[2] = tens_max     & ena[1];\n    assign ena[3] = hundreds_max & ena[2];\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit always increments\n            if (ones_max)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // tens digit increments when ones wraps\n            if (ena[1]) begin\n                if (tens_max)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // hundreds digit increments when tens wraps\n            if (ena[2]) begin\n                if (hundreds_max)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // thousands digit increments when hundreds wraps\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,  // y = {y3,y2,y1}\n    input        w,\n    output reg   Y2   // next\u2010state bit y2\n);\n\n    // combinational logic for next y2\n    // y2+ = (~y2 & y1)\n    //      | (~y1 & w & (y3 ^ y2))\n    always @(*) begin\n        Y2 = (~y[2] & y[1])\n           | (~y[1] & w & (y[3] ^ y[2]));\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // Combinational logic: when there's a ring, choose ringer or motor but not both\n    assign ringer = ring & ~vibrate_mode;\n    assign motor  = ring &  vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// continuous\u2010assignment AND\nassign out_assign = a & b;\n\n// combinational always block AND\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n    // Constant zero output\n    assign zero = 1'b0;\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  a,\n    output reg q\n);\n\n    // one\u2010cycle delayed version of 'a'\n    reg a_prev;\n\n    always @(posedge clk) begin\n        // if 'a' has been stable for two consecutive clk edges,\n        // drive q = ~a  (so two 0\u2019s \u2192 q=1, two 1\u2019s \u2192 q=0)\n        if (a_prev == a)\n            q <= ~a;\n\n        // then update the delay flip\u2010flop\n        a_prev <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,  // asynchronous, active\u2010high reset\n    input        x,       // serial data in, LSB first\n    output reg   z        // serial data out\n);\n\n    // State encoding\n    localparam CARRY    = 1'b1,\n               NO_CARRY = 1'b0;\n    reg state, next_state;\n\n    // state register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= CARRY;      // on reset, prepare to add +1\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state and output logic (Moore except z uses x)\n    always @(*) begin\n        case (state)\n            CARRY: begin\n                z = ~x;              // sum = x ^ 1\n                next_state = x ? CARRY : NO_CARRY;  \n            end\n            NO_CARRY: begin\n                z = x;               // passing remaining bits\n                next_state = NO_CARRY;\n            end\n            default: begin\n                z = 1'bx;\n                next_state = CARRY;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output       out\n);\n\n    // State encoding\n    localparam [1:0]\n        A = 2'd0,\n        B = 2'd1,\n        C = 2'd2,\n        D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;  // 0\u2192A, 1\u2192B\n            B: next_state = in ? B : C;  // 0\u2192C, 1\u2192B\n            C: next_state = in ? D : A;  // 0\u2192A, 1\u2192D\n            D: next_state = in ? B : C;  // 0\u2192C, 1\u2192B\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse the byte order: byte 0 \u2194 byte 3, byte 1 \u2194 byte 2\n    assign out = { in[7:0],    // original byte 0 \u2192 new byte 3 (MSB)\n                   in[15:8],   // original byte 1 \u2192 new byte 2\n                   in[23:16],  // original byte 2 \u2192 new byte 1\n                   in[31:24]   // original byte 3 \u2192 new byte 0 (LSB)\n                 };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // Synchronous active\u2010high reset D\u2010flip\u2010flop\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x XOR y) AND x\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input              ena,\n    input      [1:0]   amount,\n    input      [63:0]  data,\n    output reg [63:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0],      1'b0};            // shift left by 1\n                2'b01: q <= {q[55:0],      8'b0};            // shift left by 8\n                2'b10: q <= {q[63],        q[63:1]};         // arithmetic right by 1\n                2'b11: q <= {{8{q[63]}},   q[63:8]};         // arithmetic right by 8\n                default: q <= q;\n            endcase\n        end\n        // else retain old q\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,  // active\u2011low async reset\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    localparam S0 = 2'd0,  // no bits recognized\n               S1 = 2'd1,  // saw \u201c1\u201d\n               S2 = 2'd2;  // saw \u201c10\u201d\n\n    reg [1:0] state, next_state;\n\n    // state register with negative\u2011edge asynchronous reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // next state and output logic (Mealy)\n    always @(*) begin\n        next_state = state;\n        z          = 1'b0;\n        case (state)\n            S0: begin\n                if (x)      next_state = S1;\n                else        next_state = S0;\n            end\n            S1: begin\n                if (x)      next_state = S1;\n                else        next_state = S2;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1; // overlap: last '1' starts new seq\n                    z          = 1'b1;\n                end else begin\n                    next_state = S0;\n                end\n            end\n            default: begin\n                next_state = S0;\n                z          = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output reg   z\n);\n\n    // state encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic and output logic (Moore)\n    always @(*) begin\n        // default\n        next_state = A;\n        z = 1'b0;\n\n        case (state)\n            A: begin\n                z = 1'b0;\n                next_state = w ? A : B;\n            end\n            B: begin\n                z = 1'b0;\n                next_state = w ? D : C;\n            end\n            C: begin\n                z = 1'b0;\n                next_state = w ? D : E;\n            end\n            D: begin\n                z = 1'b0;\n                next_state = w ? A : F;\n            end\n            E: begin\n                z = 1'b1;\n                next_state = w ? D : E;\n            end\n            F: begin\n                z = 1'b1;\n                next_state = w ? D : C;\n            end\n            default: begin\n                z = 1'b0;\n                next_state = A;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": ""}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,  // one\u2010hot state vector: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1, // next\u2010state input for FF y[1] (state B)\n    output       Y3  // next\u2010state input for FF y[3] (state D)\n);\n\n    // Y1 = A\u2192B on w=1\n    assign Y1 = y[0] & w;\n\n    // Y3 = B\u2192D, C\u2192D, E\u2192D, F\u2192D on w=0\n    assign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the vector\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // The K\u2010map implements even\u2010odd parity over all four inputs.\n    // out is 1 whenever an odd number of inputs is 1.\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Combinational split of 16-bit half\u2011word into two bytes\n    assign out_lo = in[7:0];   // lower byte\n    assign out_hi = in[15:8];  // upper byte\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out\n);\n\n    // NOR gate implementation\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a,\n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) clocked always block XOR (registered, one\u2010clock delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one\u2010hot current state: y[1]=A, y[2]=B, \u2026, y[6]=F\n    input        w,\n    output       Y2, // next\u2010state bit for B\n    output       Y4  // next\u2010state bit for D\n);\n\n    // B is reached only from A when w=0\n    assign Y2 = y[1] & ~w;\n\n    // D is reached from B,C,E,F when w=1\n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input  [7:0]   sel,\n    output         out\n);\n\n    // Variable bit\u2010select directly implements a 256-to-1 mux\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\n    // Next\u2010state mux: if load then R, else if enable then w, else hold Q\n    wire d = L ? R\n           : E ? w\n           : Q;\n\n    // D flip\u2010flop\n    always @(posedge clk) begin\n        Q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state bits (D\u2011FF outputs), initialized to 0\n    reg [2:0] q = 3'b000;\n    wire [2:0] d;\n\n    // next\u2011state logic\n    assign d[0] = x ^  q[0];   // XOR with its own output\n    assign d[1] = x & ~q[1];   // AND with complement of its own output\n    assign d[2] = x | ~q[2];   // OR  with complement of its own output\n\n    // state registers\n    always @(posedge clk) begin\n        q <= d;\n    end\n\n    // output is 3\u2011input XNOR of the flip\u2011flop outputs\n    // reduction-XNOR: ~(q[0]^q[1]^q[2])\n    assign z = ~^q;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n    // From the truth\u2010table, q is \u20181\u2019 exactly when b or c is \u20181\u2019 (a and d are don't\u2010cares).\n    assign q = b | c;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // compute left\u2010 and right\u2010neighbour vectors, with boundary cells=0\n    wire [511:0] q_l = { q[510:0], 1'b0    };  // q_l[i] = q[i-1] or 0 if i==0\n    wire [511:0] q_r = { 1'b0,     q[511:1] };  // q_r[i] = q[i+1] or 0 if i==511\n\n    // Rule 110: next = (~L & R) | (C & ~R) | (L & ~C & R)\n    wire [511:0] next_q = (~q_l & q_r)\n                       | ( q    & ~q_r)\n                       | ( q_l  & ~q & q_r);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // state encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    // 2-to-1 mux: if sel==0 choose a, else choose b\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module full_module (\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    // feedback for bit2: q2_next = q1_old ^ q2_old\n    wire fb2 = q[1] ^ q[2];\n\n    // bit 0: q0_next = (L ? r[0] : q_old2)\n    top_module u0 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q[2]),\n        .r_in (r[0]),\n        .Q    (q[0])\n    );\n\n    // bit 1: q1_next = (L ? r[1] : q_old0)\n    top_module u1 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q[0]),\n        .r_in (r[1]),\n        .Q    (q[1])\n    );\n\n    // bit 2: q2_next = (L ? r[2] : q1_old ^ q2_old)\n    top_module u2 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (fb2),\n        .r_in (r[2]),\n        .Q    (q[2])\n    );\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous reset\n    input  [31:0] in,\n    output reg [31:0] out\n);\n\n    // register to hold previous cycle's inputs\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            prev_in <= 32'b0;\n            out     <= 32'b0;\n        end else begin\n            // detect 1\u21920 transitions and latch them in 'out'\n            out     <= out | (prev_in & ~in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, capture the 8\u2010bit vector d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // 8\u2010bit sum\n    assign s = a + b;\n\n    // signed overflow: occurs if a and b have same sign, but s has opposite sign\n    assign overflow =\n           (~a[7] & ~b[7] &  s[7])  // both positive, result negative\n        | ( a[7] &  b[7] & ~s[7]); // both negative, result positive\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,    // one\u2013hot: {Wait,Count,B3,B2,B1,B0,S110,S11,S1,S}\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n  // decode current states\n  wire S     = state[0];\n  wire S1    = state[1];\n  wire S11   = state[2];\n  wire S110  = state[3];\n  wire B0    = state[4];\n  wire B1    = state[5];\n  wire B2    = state[6];\n  wire B3    = state[7];\n  wire Count = state[8];\n  wire WaitS = state[9];\n\n  // next\u2011state logic\n  // S_next: S,S1,S110 on d=0, or from Wait on ack=1\n  assign S_next     = (~d & (S | S1 | S110)) \n                    | (ack & WaitS);\n\n  // S1_next: from S on d=1\n  assign S1_next    =  d  & S;\n\n  // B3_next: from B2 always\n  assign B3_next    =  B2;\n\n  // Count_next: from B3, or stay in Count while !done_counting\n  assign Count_next =  B3\n                    | (Count & ~done_counting);\n\n  // Wait_next: from Count when done_counting, or stay in Wait while ack=0\n  assign Wait_next  =  (Count & done_counting)\n                    | (WaitS & ~ack);\n\n  // outputs (Moore)\n  assign shift_ena  = B0 | B1 | B2 | B3;\n  assign counting   = Count;\n  assign done       = WaitS;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        train_valid,\n    input  logic        train_taken,\n    output logic [1:0]  state\n);\n\n  // Asynchronous reset to weakly not-taken (2'b01), synchronous saturating counter\n  always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= 2'b01;\n    end else begin\n      if (train_valid) begin\n        if (train_taken) begin\n          // increment but saturate at 3\n          if (state != 2'b11)\n            state <= state + 1;\n        end else begin\n          // decrement but saturate at 0\n          if (state != 2'b00)\n            state <= state - 1;\n        end\n      end\n      // else: hold current state\n    end\n  end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @* begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;  // no bits set\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // default outputs\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        // decode arrow-key scancodes\n        case (scancode)\n            16'hE06B: left  = 1'b1;  // left arrow\n            16'hE072: down  = 1'b1;  // down arrow\n            16'hE074: right = 1'b1;  // right arrow\n            16'hE075: up    = 1'b1;  // up arrow\n            default:  ;             // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    // Internal carry wires\n    wire c1, c2, c3, c4;\n\n    // Instantiate 4 full adders\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (1'b0),\n        .sum (sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c1),\n        .sum (sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c2),\n        .sum (sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c3),\n        .sum (sum[3]),\n        .cout(c4)\n    );\n\n    // The MSB of sum is the final carry\u2011out (overflow)\n    assign sum[4] = c4;\n\nendmodule\n\n// Simple full\u2010adder\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  clk,\n    input  areset,\n    input  predict_valid,\n    input  predict_taken,\n    output logic [31:0] predict_history,\n\n    input  train_mispredicted,\n    input  train_taken,\n    input  [31:0] train_history\n);\n\n    // internal history register\n    logic [31:0] history;\n\n    // asynchronous reset, update on clock edge\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 32'b0;\n        end else if (train_mispredicted) begin\n            // rollback to history before mispredicted branch plus actual outcome\n            history <= { train_history[30:0], train_taken };\n        end else if (predict_valid) begin\n            // shift in predicted outcome at LSB (bit 0 is newest)\n            history <= { history[30:0], predict_taken };\n        end\n    end\n\n    // drive output\n    assign predict_history = history;\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n    // intermediate wires\n    wire w1, w2;\n\n    // first layer: two AND gates\n    and and1 (w1, a, b);\n    and and2 (w2, c, d);\n\n    // second layer: OR gate driving out\n    or  or1   (out, w1, w2);\n\n    // inverted output\n    not not1 (out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    // On each rising edge of clk, sample d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input           clk,\n    input           enable,\n    input           S,\n    input           A,\n    input           B,\n    input           C,\n    output reg      Z\n);\n\n    // 8\u2010bit shift register\n    // Q[0] gets S, Q[1] <= old Q[0], \u2026, Q[7] <= old Q[6]\n    reg [7:0] Q;\n    always @(posedge clk) begin\n        if (enable)\n            Q <= { Q[6:0], S };\n        // else Q retains its value\n    end\n\n    // 8:1 MUX controlled by ABC\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater on only in heating mode when too cold\n    assign heater = mode & too_cold;\n    // Air conditioner on only in cooling mode when too hot\n    assign aircon = (~mode) & too_hot;\n    // Fan on if heater or aircon is running or if user requests fan\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,      // synchronous active\u2011high\n    output reg [31:0] q\n);\n\n    // feedback bit is LSB of current state\n    wire fb = q[0];\n\n    // tap mask for bits 22, 2, and 1 (zero\u2011based indices 21,1,0)\n    // bit 31 (tap at position 32) is handled by feeding fb into MSB\n    localparam [30:0] TAP = 31'h00200003;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // reset to 1\n            q <= 32'h00000001;\n        end else begin\n            // Galois LFSR shift\u2011right:\n            //   new MSB = fb\n            //   new [30:0] = old [31:1] ^ (fb ? TAP : 0)\n            q <= { fb,\n                   q[31:1] ^ ({31{fb}} & TAP)\n                 };\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n// q is 1 whenever two or more inputs are 1\nassign q = (a & b)\n         | (a & c)\n         | (a & d)\n         | (b & c)\n         | (b & d)\n         | (c & d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d, \n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // Two independent 4\u2010input NAND gates (7420 equivalent)\n    nand u1 (p1y, p1a, p1b, p1c, p1d);\n    nand u2 (p2y, p2a, p2b, p2c, p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @* begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // (1) both this bit and its left\u2010neighbour are 1\n    assign out_both[0] = in[0] & in[1];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[2] = in[2] & in[3];\n\n    // (2) any of this bit or its right\u2010neighbour are 1\n    assign out_any[1] = in[1] | in[0];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[3] = in[3] | in[2];\n\n    // (3) this bit different from its left\u2010neighbour, wrap at the top\n    assign out_different[0] = in[0] ^ in[1];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[3] = in[3] ^ in[0];\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0]  a,\n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // in2 has a bubble going into the AND gate, so it is inverted\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinational pass\u2010through\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous reset (active\u2010high)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            B: begin\n                if (in == 1'b0) next_state = A;\n                else             next_state = B;\n            end\n            A: begin\n                if (in == 1'b0) next_state = B;\n                else             next_state = A;\n            end\n            default: next_state = B;\n        endcase\n    end\n\n    // Moore output (depends only on current state)\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // two internal single\u2010edge FFs\n    reg q_pos, q_neg;\n\n    // sample D on the rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // sample D on the falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // multiplexer picks the most recent sample\n    // when clk=1 use q_pos, when clk=0 use q_neg\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // XNOR: output is '1' when a and b are equal\n    assign out = a ~^ b;\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    // truth\u2010table from waveform: z = 1 for (0,0) & (1,1), else 0 \u21d2 XNOR\n    assign z = x ~^ y;\nendmodule\n\nmodule top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1, a2, b1, b2;\n    wire or_out, and_out;\n\n    // first pair \u2192 OR\n    A A1(.x(x), .y(y), .z(a1));\n    B B1(.x(x), .y(y), .z(b1));\n    or  Uor (or_out,  a1, b1);\n\n    // second pair \u2192 AND\n    A A2(.x(x), .y(y), .z(a2));\n    B B2(.x(x), .y(y), .z(b2));\n    and Uand(and_out, a2, b2);\n\n    // final XOR\n    xor Uxor(z, or_out, and_out);\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [1:0]   ena,\n    input      [99:0]  data,\n    output reg [99:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01:  q <= { q[0],    q[99:1]   }; // rotate right\n                2'b10:  q <= { q[98:0], q[99]     }; // rotate left\n                default:q <= q;                      // no operation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [9:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 10'd1;\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Continuous assignment implementing a NOT gate\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    // Next\u2010state logic (one\u2010hot encoding)\n    assign next_state[0] = ~in & (state[0] | state[1] | state[2] | state[3] | state[4]\n                                 | state[7] | state[8] | state[9]);\n    assign next_state[1] =  in & (state[0] | state[8] | state[9]);\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & (state[6] | state[7]);\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // Output logic\n    // Only S8, S9 assert out1; only S7, S9 assert out2\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;     // hold\n            2'b01: Q <= 1'b0;  // reset\n            2'b10: Q <= 1'b1;  // set\n            2'b11: Q <= ~Q;    // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Sum the three bits; the result ranges 0\u20133, fitting in 2 bits\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input        a,\n    input        b,\n    input        c,\n    input        d,\n    input        e,\n    output [24:0] out\n);\n\n    // out[24] .. out[0] = comparisons of {a,b,c,d,e} with {a,b,c,d,e}, \n    // 1 when equal (= ~(x^y) == ~x ^ y)\n    assign out = {\n        // compare a with {a,b,c,d,e}\n        (~a ^ a), (~a ^ b), (~a ^ c), (~a ^ d), (~a ^ e),\n        // compare b with {a,b,c,d,e}\n        (~b ^ a), (~b ^ b), (~b ^ c), (~b ^ d), (~b ^ e),\n        // compare c with {a,b,c,d,e}\n        (~c ^ a), (~c ^ b), (~c ^ c), (~c ^ d), (~c ^ e),\n        // compare d with {a,b,c,d,e}\n        (~d ^ a), (~d ^ b), (~d ^ c), (~d ^ d), (~d ^ e),\n        // compare e with {a,b,c,d,e}\n        (~e ^ a), (~e ^ b), (~e ^ c), (~e ^ d), (~e ^ e)\n    };\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // state encoding\n    localparam S_LEFT  = 1'b0,\n               S_RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            S_LEFT:  next_state = (bump_left | bump_right) ? S_RIGHT : S_LEFT;\n            S_RIGHT: next_state = (bump_left | bump_right) ? S_LEFT  : S_RIGHT;\n            default: next_state = S_LEFT;\n        endcase\n    end\n\n    // State register with asynchronous posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Outputs depend only on current state (Moore)\n    assign walk_left  = (state == S_LEFT);\n    assign walk_right = (state == S_RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n    // From the waveform: q=1 only when a=1 and b=1\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // Intermediate AND gates for the p1 network (3\u2011input ANDs)\n    wire p1_and1 = p1a & p1b & p1c;\n    wire p1_and2 = p1d & p1e & p1f;\n\n    // Intermediate AND gates for the p2 network (2\u2011input ANDs)\n    wire p2_and1 = p2a & p2b;\n    wire p2_and2 = p2c & p2d;\n\n    // OR the outputs of each pair of AND gates\n    assign p1y = p1_and1 | p1_and2;\n    assign p2y = p2_and1 | p2_and2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,   // not used \u2013 outputs are pure functions of y,x\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    always @(*) begin\n        // Y0 = 1 for (y,x) = 000,1; 001,0; 010,1; 011,0; 100,0\n        // minimized: ~y2&(y0 ^ x)  +  y2&~y1&~y0&~x\n        Y0 = (~y[2] & (y[0] ^ x))\n           | ( y[2] & ~y[1] & ~y[0] & ~x );\n\n        // z = 1 in states 011 or 100\n        z  = (~y[2] &  y[1] &  y[0])\n           | ( y[2] & ~y[1] & ~y[0]);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2-input NOR: out = !(in1 | in2)\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    // wire up the signals\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous active\u2010high reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk, \n    input        load, \n    input  [9:0] data, \n    output       tc\n);\n    reg [9:0] count;\n\n    // terminal count is high when count is zero\n    assign tc = (count == 10'd0);\n\n    always @(posedge clk) begin\n        if (load) begin\n            count <= data;\n        end else if (count != 10'd0) begin\n            count <= count - 10'd1;\n        end\n        // else count stays at 0\n    end\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,        // synchronous, active\u2010high\n    input  data,\n    output reg start_shifting\n);\n\n    // state encoding\n    localparam S0 = 2'b00; // no bits matched\n    localparam S1 = 2'b01; // saw \"1\"\n    localparam S2 = 2'b10; // saw \"11\"\n    localparam S3 = 2'b11; // saw \"110\"\n\n    reg [1:0] state, nstate;\n\n    // STATE REGISTER\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= nstate;\n    end\n\n    // NEXT\u2010STATE LOGIC\n    always @(*) begin\n        case (state)\n            S0: nstate = data ? S1 : S0;\n            S1: nstate = data ? S2 : S0;\n            S2: nstate = data ? S2 : S3;\n            S3: nstate = data ? S1 : S0;\n            default: nstate = S0;\n        endcase\n    end\n\n    // OUTPUT LATCH: once 1101 seen, stick start_shifting=1\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (state == S3 && data)\n            start_shifting <= 1'b1;\n        // else keep previous\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // 8 D flip\u2010flops with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold last\u2010cycle value of 'in'\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // detect rising edges: low->high\n        anyedge <= (~prev_in) & in;\n\n        // update history\n        prev_in <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1;\n        end else begin\n            if (q == 4'd10)\n                q <= 4'd1;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    // track previous a to detect its falling edge\n    reg a_prev;\n\n    always @(posedge clk) begin\n        if (a) begin\n            // while a==1, keep q loaded to 4\n            q <= 3'd4;\n        end else if (a_prev) begin\n            // on the first cycle after a falls, hold q\n            q <= q;\n        end else if (q == 3'd6) begin\n            // normal counting with 6\u21920 wrap\n            q <= 3'd0;\n        end else begin\n            q <= q + 3'd1;\n        end\n\n        // update a_prev\n        a_prev <= a;\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n    // Galois LFSR with polynomial x^5 + x^3 + 1\n    // taps at bit positions 5 (q[4]) and 3 (q[2])\n    localparam [4:0] TAPS = 5'b10010;  // bit4 and bit2\n\n    wire feedback = q[0];        // LFSR output bit\n    wire [4:0] shifted = q >> 1;\n    wire [4:0] next_state = feedback ? (shifted ^ TAPS) : shifted;\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 5'b00001;        // synchronous active\u2010high reset to 1\n        else\n            q <= next_state;\n    end\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // set zero\u2010flag unconditionally\n        result_is_zero = (out == 8'd0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @* begin\n        valid = 1'b0;\n        out   = 4'b0000;\n        case (code)\n            8'h45: begin valid = 1'b1; out = 4'd0; end\n            8'h16: begin valid = 1'b1; out = 4'd1; end\n            8'h1E: begin valid = 1'b1; out = 4'd2; end\n            8'h26: begin valid = 1'b1; out = 4'd3; end\n            8'h25: begin valid = 1'b1; out = 4'd4; end\n            8'h2E: begin valid = 1'b1; out = 4'd5; end\n            8'h36: begin valid = 1'b1; out = 4'd6; end\n            8'h3D: begin valid = 1'b1; out = 4'd7; end\n            8'h3E: begin valid = 1'b1; out = 4'd8; end\n            8'h46: begin valid = 1'b1; out = 4'd9; end\n            default: begin valid = 1'b0; out = 4'd0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse bit order: out[7] = in[0], \u2026, out[0] = in[7]\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n    // Simplified from the K\u2011map: out = a + (!a & !b & c)\n    always @(*) begin\n        out = a | (c & ~a & ~b);\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift in MSB first\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            // down\u2010count\n            q <= q - 1;\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // continuous assignment: out follows in\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,      // active\u2011high synchronous\n    output reg   shift_ena\n);\n\n    // 3\u2011bit down\u2011counter to generate 4 cycles of enable (3,2,1,0)\n    reg [2:0] cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // upon (synchronous) reset assert shift_ena\n            // for exactly 4 cycles: 3,2,1,0\n            cnt       <= 3'd3;\n            shift_ena <= 1'b1;\n        end else if (cnt != 0) begin\n            // still in the 4\u2011cycle window\n            cnt       <= cnt - 1;\n            shift_ena <= 1'b1;\n        end else begin\n            // beyond 4 cycles, keep disabled\n            shift_ena <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous active\u2011high\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else\n        q <= q + 1;\nend\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // continuous\u2010assignment mux\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // procedural mux using if\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n// From the K\u2011map the function is 0 only when a=b=c=0, otherwise 1.\n// Hence F = a + b + c\n\nassign out = a | b | c;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input          clk,\n    input          resetn,  // active\u2010low synchronous reset\n    input   [3:1]  r,       // r[1], r[2], r[3]\n    output  [3:1]  g        // g[1], g[2], g[3]\n);\n\n    // state encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])      next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else            next_state = A;\n            end\n            B: next_state = r[1] ? B : A;\n            C: next_state = r[2] ? C : A;\n            D: next_state = r[3] ? D : A;\n            default: next_state = A;\n        endcase\n    end\n\n    // outputs: grant exactly one device in B, C or D\n    // g[1] = 1 in state B, g[2] = 1 in state C, g[3] = 1 in state D\n    assign g = { (state == D),\n                 (state == C),\n                 (state == B) };\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)       // synchronous, active-high reset\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;  // wrap around after 9\n        else\n            q <= q + 4'd1;\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input         clk,\n    input  [7:0]  in,\n    input         reset,\n    output reg    done\n);\n    // state encoding\n    localparam WAIT1 = 2'd0,\n               GOT1  = 2'd1,\n               GOT2  = 2'd2;\n\n    reg [1:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT1;\n            done  <= 1'b0;\n        end else begin\n            case (state)\n                WAIT1: begin\n                    if (in[3]) begin    // first byte detected\n                        state <= GOT1;\n                    end else begin\n                        state <= WAIT1;\n                    end\n                    done <= 1'b0;\n                end\n                GOT1: begin           // second byte\n                    state <= GOT2;\n                    done  <= 1'b0;\n                end\n                GOT2: begin           // third byte \u2192 done\n                    state <= WAIT1;\n                    done  <= 1'b1;\n                end\n                default: begin\n                    state <= WAIT1;\n                    done  <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 mux: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // 4\u2011input reduction gates\n    assign out_and = &in;   // reduction AND\n    assign out_or  = |in;   // reduction OR\n    assign out_xor = ^in;   // reduction XOR\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    localparam S0 = 3'd0,\n               S1 = 3'd1,\n               S2 = 3'd2,\n               S3 = 3'd3,\n               S4 = 3'd4;\n\n    reg [2:0] state, next_state;\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S4 : S1;\n            S2: next_state = x ? S1 : S2;\n            S3: next_state = x ? S2 : S1;\n            S4: next_state = x ? S4 : S3;\n            default: next_state = S0;\n        endcase\n    end\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // output logic (Moore)\n    always @(*) begin\n        case (state)\n            S3, S4: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  x,\n    input  y,\n    output f,\n    output g\n);\n\n    // State encoding\n    localparam A         = 4'd0,\n               B         = 4'd1,  // assert f\n               S1        = 4'd2,  // waiting for first '1'\n               S2        = 4'd3,  // got '1', waiting for '0'\n               S3        = 4'd4,  // got '1','0', waiting for '1'\n               G1        = 4'd5,  // assert g (cycle 1), check y\n               G_WAIT1   = 4'd6,  // keep g=1 (cycle 2), check y\n               STAY_G    = 4'd7,  // lock g=1 forever\n               G0        = 4'd8;  // lock g=0 forever\n\n    reg [3:0] state, next_state;\n\n    // state register with synchronous, active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            A:       next_state = B;\n            B:       next_state = S1;\n            S1:      next_state = x ? S2      : S1;\n            S2:      next_state = (x==1'b0) ? S3 : S2;\n            S3:      next_state = x ? G1      : S1;\n            G1:      next_state = y ? STAY_G : G_WAIT1;\n            G_WAIT1: next_state = y ? STAY_G : G0;\n            STAY_G:  next_state = STAY_G;\n            G0:      next_state = G0;\n            default: next_state = A;\n        endcase\n    end\n\n    // outputs\n    assign f = (state == B);\n    assign g = (state == G1 || state == G_WAIT1 || state == STAY_G);\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input         clk,\n    input  [7:0]  d,\n    input         reset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2011FFs with synchronous active\u2011high reset to 0x34 on negedge clk\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // Even parity: XOR\u2010reduce all bits of 'in'\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A -> B/A\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B -> B/C\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C -> D/A\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D -> B/C\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == 2'b11);  // 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // From the waveform the output is high exactly when x==y.\n    // That is the Boolean XNOR function:\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active-high\n    input        w,\n    output       z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State flip\u2011flops (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore: output depends only on state)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        resetn,\n    input  [1:0] byteena,\n    input  [15:0] d,\n    output reg [15:0] q\n);\n\n    // Synchronous, active\u2010low reset; byte\u2010wide write enable\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n            if (byteena[0])\n                q[7:0]  <= d[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input            clk,\n    input      [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // register to hold last cycle's input\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // detect rising edge: in was 0, now 1\n        pedge   <=  in & ~prev_in;\n        // update history\n        prev_in <=  in;\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clock,\n    input        a,\n    output reg   p,\n    output reg   q\n);\n\n// master latch: transparent when clock==1\nalways @(*) begin\n    if (clock)\n        p = a;\nend\n\n// slave latch : transparent when clock==0\nalways @(*) begin\n    if (!clock)\n        q = p;\nend\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // compute neighbors with zero\u2010padded boundaries\n    wire [511:0] left  = { q[510:0], 1'b0      }; // left neighbor of q[i] is q[i-1], q[0] gets 0\n    wire [511:0] right = { 1'b0,      q[511:1] }; // right neighbor of q[i] is q[i+1], q[511] gets 0\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= left ^ right; // Rule 90: next state = left XOR right\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n\n    // z is 1 exactly when A equals B\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // out_both[i] = in[i] & in[i+1], for i = 0..98\n    assign out_both   = in[98:0] & in[99:1];\n\n    // out_any[i]  = in[i] | in[i-1], for i = 1..99\n    assign out_any    = in[99:1] | in[98:0];\n\n    // out_different[i] = in[i] ^ in[i+1] with wrap\u2010around (in[99]'s left neighbour is in[0])\n    // build a 100\u2010bit \u201cleft\u2010shifted\u201d version of in with wrap:\n    //    shifted[99] = in[0], shifted[98:0] = in[99:1]\n    wire [99:0] shifted = { in[0], in[99:1] };\n    assign out_different = in ^ shifted;\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic d,\n    input  logic ena,\n    output logic q\n);\n\n    // inference of a transparent D\u2010latch\n    always_latch begin\n        if (ena)\n            q = d;\n        // else: q holds its previous value\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n\n    // shift the 1024\u2010bit bus right by sel*4 and take the bottom 4 bits\n    // (Variable shifts and bitwise & are synthesizable in most tools.)\n    assign out = (in >> (sel << 2)) & 4'hF;\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        unique case (sel)\n            4'd0:  out = a;\n            4'd1:  out = b;\n            4'd2:  out = c;\n            4'd3:  out = d;\n            4'd4:  out = e;\n            4'd5:  out = f;\n            4'd6:  out = g;\n            4'd7:  out = h;\n            4'd8:  out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a,\n    input  [2:0] b,\n    output [2:0] out_or_bitwise,\n    output       out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of each bit\n    assign out_or_bitwise = a | b;\n\n    // logical OR of the two vectors (true if any bit of a or b is 1)\n    assign out_or_logical = |(a | b);\n\n    // upper half = NOT b, lower half = NOT a\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,       // one\u2010hot: state[0]=A, state[1]=B, state[2]=C, state[3]=D\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // next_state logic (combinational)\n    always @* begin\n        // default\n        next_state = 4'b0000;\n        // A \u2190 {A,C} when in=0\n        next_state[0] = ~in & (state[0] | state[2]);\n        // B \u2190 {A,B,D} when in=1\n        next_state[1] =  in & (state[0] | state[1] | state[3]);\n        // C \u2190 {B,D} when in=0\n        next_state[2] = ~in & (state[1] | state[3]);\n        // D \u2190 C when in=1\n        next_state[3] =  in &  state[2];\n    end\n\n    // Moore output: only state D outputs 1\n    assign out = state[3];\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // Combinational logic to find the minimum of four unsigned 8\u2011bit values\n    always @(*) begin\n        min = a;\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Combinational gate outputs\n    assign out_and   = a &  b;     // AND\n    assign out_or    = a |  b;     // OR\n    assign out_xor   = a ^  b;     // XOR\n    assign out_nand  = ~(a & b);   // NAND\n    assign out_nor   = ~(a | b);   // NOR\n    assign out_xnor  = a ~^ b;     // XNOR (equivalent to ~(a^b))\n    assign out_anotb = a & ~b;     // A AND (NOT B)\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output out\n);\n\n    // Simplified from the K\u2010map:\n    //   F = \u03a3m(0,1,2,4,6,7,8,9,11,15)\n    //   F = ~a\u00b7~d  +  ~b\u00b7~c  +  ~a\u00b7b\u00b7c  +  a\u00b7c\u00b7d\n\n    assign out = (~a & ~d)\n               | (~b & ~c)\n               | (~a &  b &  c)\n               | ( a &  c &  d);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // active HIGH synchronous\n    input        s,\n    input        w,\n    output reg   z\n);\n\n    // cycle count: 0 = idle, 1..3 = sample #1..#3 of current window\n    reg [1:0] cycle;\n    // count of w==1 in the current 3-cycle window\n    reg [2:0] ones;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cycle <= 2'd0;\n            ones  <= 3'd0;\n            z     <= 1'b0;\n        end else begin\n            if (cycle == 2'd0) begin\n                // idle: wait for s\n                z <= 1'b0;\n                if (s) begin\n                    cycle <= 2'd1;\n                    ones  <= w;\n                end\n            end\n            else if (cycle < 2'd3) begin\n                // still sampling window\n                cycle <= cycle + 2'd1;\n                ones  <= ones + w;\n                z     <= 1'b0;\n            end\n            else begin\n                // cycle==3: this is the 4th clock (output & restart)\n                z     <= (ones + w == 3'd2);\n                // start next window: treat this w as sample #1\n                cycle <= 2'd1;\n                ones  <= w;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concatenate with the 8\u2011bit input\n    assign out = { {24{in[7]}}, in };\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // active\u2010low synchronous reset\n    input  in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    // On each rising edge of clk, either synchronously reset or shift\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= { shift_reg[2:0], in };\n    end\n\n    // The output is the MSB of the shift register\n    assign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        if      (in[3]) pos = 2'd3;\n        else if (in[2]) pos = 2'd2;\n        else if (in[1]) pos = 2'd1;\n        else if (in[0]) pos = 2'd0;\n        else             pos = 2'd0;\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        areset,\n    output       out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state combinational logic\n    always @* begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON : next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Moore output: only depends on current state\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Tie the output permanently low\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Continuously drive the output to logic 1\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // On each rising edge of clk, new out <= old out XOR in\n    always_ff @(posedge clk) begin\n        out <= out ^ in;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,\n    input        load,\n    input        ena,\n    input  [3:0] data,\n    output reg [3:0] q\n);\n\n    // Asynchronous reset, synchronous load and shift\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else begin\n            if (load) begin\n                q <= data;\n            end else if (ena) begin\n                // Shift right, bring in 0 at MSB\n                q <= {1'b0, q[3:1]};\n            end\n            // else retain q\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = \u03a3m(2,3,5,7) = x2&~x3  +  x1&(x2|x3)\n    assign f = (x2 & ~x3) \n             | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input      [7:0]   d,\n    input              areset,\n    output reg [7:0]   q\n);\n\n    // 8 D\u2010FFs with active\u2010high asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // 100\u2010input reduction gates\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // sum = a XOR b\n    assign sum  = a ^ b;\n    // cout = a AND b\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input  cpu_overheated,\n    output reg shut_off_computer,\n    input  arrived,\n    input  gas_tank_empty,\n    output reg keep_driving\n);\n\n    // Combinational logic \u2013 no inferred latches\n    always @(*) begin\n        // shut down iff the CPU is overheated\n        shut_off_computer = cpu_overheated;\n    end\n\n    always @(*) begin\n        // keep driving only if not arrived and tank is not empty\n        keep_driving = (~arrived) && (~gas_tank_empty);\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate a\u2013f (30 bits) then two \u20181\u2019 bits (LSBs) into a 32\u2011bit vector,\n    // then split into four 8\u2011bit outputs [31:24]=w, [23:16]=x, [15:8]=y, [7:0]=z\n    assign {w, x, y, z} = { a, b, c, d, e, f, 2'b11 };\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n    // q is high when a,b,c,d have an even number of 1\u2019s (even\u2010parity checker)\n    // reduction XNOR (~^) returns 1 if the number of 1\u2019s in {a,b,c,d} is even\n    assign q = ~^({a, b, c, d});\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // Implement AND functionality\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,  // active\u2011high synchronous reset\n    output out\n);\n\n    // State encoding\n    localparam B = 1'b0,\n               A = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default:  next_state = B;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == B) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n    // sum is XOR of the three inputs\n    assign sum  = a ^ b ^ cin;\n    // carry-out when any two of the inputs are 1\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // XNOR of in1 and in2, then XOR with in3\n    logic xnor_out;\n    assign xnor_out = in1 ~^ in2;\n    assign out      = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n// We must not use any gates \u2013 only 2:1 muxes (written as \u201c?:\u201d) and constants.\n// f0(c,d) = c|d    = c?1:d\n// f1        = 0    = constant\n// f2(c,d) = c&d    = c?d:0\n// f3(c,d) = c|~d   = c?1:(~d)\n// we build ~d with a mux: ~d = d?0:1\n\nwire notd;\nassign notd      = d ? 1'b0 : 1'b1;   // ~d\n\nassign mux_in[0] = c ? 1'b1 : d;      // f0 = c?1:d\nassign mux_in[1] = 1'b0;              // f1 = 0\nassign mux_in[2] = c ? d     : 1'b0;  // f2 = c?d:0\nassign mux_in[3] = c ? 1'b1 : notd;   // f3 = c?1:(~d)\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  x,\n    output z\n);\n\n    // one\u2010hot state encoding: state[0]=A, state[1]=B\n    reg  [1:0] state, next_state;\n\n    // Mealy output\n    assign z = (state[0] &  x) \n             | (state[1] & ~x);\n\n    // next\u2010state logic (combinational)\n    always @(*) begin\n        next_state[0] = state[0] & ~x;            // A->A on x=0\n        next_state[1] = (state[0] &  x)            // A->B on x=1\n                        |  state[1];               // B->B always\n    end\n\n    // state register with asynchronous, active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b01;    // reset into A\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        in,\n    output       disc,\n    output       flag,\n    output       err\n);\n\n    // State encoding\n    localparam S0    = 4'd0,  // saw a 0 (or reset)\n               S1    = 4'd1,  // saw 1 consecutive '1'\n               S2    = 4'd2,\n               S3    = 4'd3,\n               S4    = 4'd4,\n               S5    = 4'd5,\n               S6    = 4'd6,  // saw 6 consecutive '1'\n               DISC  = 4'd7,  // output disc\n               FLAG  = 4'd8,  // output flag\n               ERR   = 4'd9;  // output err (7+ ones)\n\n    reg [3:0] state, next_state;\n\n    // Synchronous state register with active\u2010high synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            S0:    next_state = in ? S1   : S0;\n            S1:    next_state = in ? S2   : S0;\n            S2:    next_state = in ? S3   : S0;\n            S3:    next_state = in ? S4   : S0;\n            S4:    next_state = in ? S5   : S0;\n            S5:    next_state = in ? S6   : DISC;   // 0111110 \u2192 DISC\n            S6:    next_state = in ? ERR  : FLAG;   // 01111110 \u2192 FLAG, 7th '1' \u2192 ERR\n            DISC:  next_state = S0;                  // consume inserted zero\n            FLAG:  next_state = S0;                  // consume flag zero\n            ERR:   next_state = in ? ERR  : S0;      // stay on 1s, else reset\n            default: next_state = S0;\n        endcase\n    end\n\n    // Moore outputs\n    assign disc = (state == DISC);\n    assign flag = (state == FLAG);\n    assign err  = (state == ERR);\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire        clk,\n    input  wire        reset,    // synchronous active\u2010high\n    input  wire        data,\n    output wire [3:0]  count,\n    output reg         counting,\n    output reg         done,\n    input  wire        ack\n);\n\n    // state encoding\n    localparam S_SEARCH = 2'd0,\n               S_SHIFT  = 2'd1,\n               S_COUNT  = 2'd2,\n               S_DONE   = 2'd3;\n\n    reg [1:0]  state, next_state;\n    reg [3:0]  seq_reg;        // shift register for detecting 1101\n    reg [2:0]  shift_cnt;      // counts 0..4\n    reg [3:0]  delay_reg;      // loaded MSB\u2010first\n    reg [3:0]  rem_delay;      // remaining delay nibble\n    reg [9:0]  cycle_cnt;      // 0..999\n\n    // state register\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= S_SEARCH;\n            seq_reg    <= 4'd0;\n            shift_cnt  <= 3'd0;\n            delay_reg  <= 4'd0;\n            rem_delay  <= 4'd0;\n            cycle_cnt  <= 10'd0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                S_SEARCH: begin\n                    // shift in incoming data for pattern detect\n                    seq_reg <= {seq_reg[2:0], data};\n                end\n                S_SHIFT: begin\n                    // shift next 4 bits MSB\u2010first into delay_reg\n                    delay_reg <= {delay_reg[2:0], data};\n                    shift_cnt <= shift_cnt + 1'b1;\n                end\n                S_COUNT: begin\n                    counting <= 1'b1;\n                    // count clock cycles\n                    if (cycle_cnt == 10'd999) begin\n                        cycle_cnt <= 10'd0;\n                        // after 1000 cycles, decrement remaining\n                        if (rem_delay != 0)\n                            rem_delay <= rem_delay - 1'b1;\n                    end else begin\n                        cycle_cnt <= cycle_cnt + 1'b1;\n                    end\n                end\n                S_DONE: begin\n                    counting <= 1'b0;\n                    done     <= 1'b1;\n                end\n            endcase\n            // default clears / inits\n            if (state != S_COUNT) cycle_cnt <= 10'd0;\n            if (state != S_COUNT) rem_delay <= rem_delay;\n            if (state != S_DONE) done <= 1'b0;\n        end\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S_SEARCH: begin\n                if (seq_reg == 4'b1101) begin\n                    next_state = S_SHIFT;\n                end\n            end\n            S_SHIFT: begin\n                if (shift_cnt == 3'd4) begin\n                    next_state = S_COUNT;\n                end\n            end\n            S_COUNT: begin\n                // initialize rem_delay on entry\n                if (cycle_cnt == 10'd0 && rem_delay == delay_reg) begin\n                    // first cycle block, just started\n                    rem_delay = delay_reg;\n                end\n                // when last block of 1000 ends and rem_delay==0 -> done\n                if ((cycle_cnt == 10'd999) && (rem_delay == 0))\n                    next_state = S_DONE;\n            end\n            S_DONE: begin\n                if (ack)\n                    next_state = S_SEARCH;\n            end\n        endcase\n    end\n\n    // handshake: load rem_delay when entering COUNT\n    always @(posedge clk) begin\n        if (!reset && state == S_SHIFT && shift_cnt == 3'd4) begin\n            rem_delay <= delay_reg;\n        end\n        if (state == S_SEARCH && next_state == S_SEARCH) begin\n            // on reset of search, clear seq register\n            seq_reg <= 4'd0;\n            shift_cnt <= 3'd0;\n        end\n    end\n\n    assign count = rem_delay;\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input            clk,\n    input            reset,   // active\u2010high synchronous\n    input      [3:1] s,       // s[1] = bottom, s[3] = top\n    output reg       fr3,\n    output reg       fr2,\n    output reg       fr1,\n    output reg       dfr      // supplemental valve\n);\n\n    // count how many sensors are asserted (0..3)\n    wire [1:0] curr_cnt = s[1] + s[2] + s[3];\n    reg  [1:0] prev_cnt;\n    wire       rising = (curr_cnt > prev_cnt);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // treat as if level has been low for a long time\n            prev_cnt <= 2'd0;\n            fr1      <= 1'b1;\n            fr2      <= 1'b1;\n            fr3      <= 1'b1;\n            dfr      <= 1'b1;\n        end else begin\n            // remember old level\n            prev_cnt <= curr_cnt;\n\n            // default: supplemental on rising\n            dfr <= rising;\n\n            // nominal flow based on current level\n            case (curr_cnt)\n                2'd3: begin // above s3\n                    fr1 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr3 <= 1'b0;\n                    dfr <= 1'b0;        // no supplemental when full\n                end\n                2'd2: begin // between s3 & s2\n                    fr1 <= 1'b1;\n                    fr2 <= 1'b0;\n                    fr3 <= 1'b0;\n                    // dfr already = rising\n                end\n                2'd1: begin // between s2 & s1\n                    fr1 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr3 <= 1'b0;\n                    // dfr already = rising\n                end\n                2'd0: begin // below s1\n                    fr1 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr3 <= 1'b1;\n                    // dfr already = rising\n                end\n                default: begin\n                    fr1 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr3 <= 1'b0;\n                    dfr <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output done\n);\n\n    // State encoding\n    localparam IDLE      = 2'd0,\n               DATA      = 2'd1,\n               STOP      = 2'd2,\n               WAIT_STOP = 2'd3;\n\n    reg [1:0]  state, next_state;\n    reg [2:0]  bit_cnt, next_bit_cnt;\n    reg        done_reg, next_done;\n\n    // Output\n    assign done = done_reg;\n\n    // Sequential: state, bit counter and done register\n    always @(posedge clk) begin\n        if (reset) begin\n            state    <= IDLE;\n            bit_cnt  <= 3'd0;\n            done_reg <= 1'b0;\n        end else begin\n            state    <= next_state;\n            bit_cnt  <= next_bit_cnt;\n            done_reg <= next_done;\n        end\n    end\n\n    // Combinational: next\u2010state logic, counter, and done pulse\n    always @(*) begin\n        // defaults\n        next_state   = state;\n        next_bit_cnt = bit_cnt;\n        next_done    = 1'b0;\n\n        case (state)\n            IDLE: begin\n                // Wait for start bit = 0\n                if (in == 1'b0) begin\n                    next_state   = DATA;\n                    next_bit_cnt = 3'd0;\n                end\n            end\n\n            DATA: begin\n                // Count 8 data bits (LSB first, but we don't store them here)\n                if (bit_cnt == 3'd7) begin\n                    next_state = STOP;\n                end else begin\n                    next_bit_cnt = bit_cnt + 1'b1;\n                end\n            end\n\n            STOP: begin\n                // Check stop bit\n                if (in == 1'b1) begin\n                    next_done  = 1'b1;   // one\u2010cycle pulse\n                    next_state = IDLE;\n                end else begin\n                    // Bad stop, wait until line goes idle\n                    next_state = WAIT_STOP;\n                end\n            end\n\n            WAIT_STOP: begin\n                // Wait for line to return to idle (1) before next start\n                if (in == 1'b1) begin\n                    next_state = IDLE;\n                end\n            end\n\n            default: begin\n                next_state   = IDLE;\n                next_bit_cnt = 3'd0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output reg [7:0] out_byte,\n    output reg       done\n);\n\n    // FSM states\n    localparam IDLE      = 2'd0;\n    localparam RECEIVE   = 2'd1;\n    localparam STOP_BIT  = 2'd2;\n    localparam WAIT_IDLE = 2'd3;\n\n    reg [1:0] state;\n    reg [2:0] bit_cnt;\n    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bit_cnt   <= 3'd0;\n            shift_reg <= 8'd0;\n            out_byte  <= 8'd0;\n            done      <= 1'b0;\n        end else begin\n            done <= 1'b0;  // default: de\u2011assert done\n            case (state)\n                // wait for start bit (in==0)\n                IDLE: begin\n                    if (in == 1'b0) begin\n                        state   <= RECEIVE;\n                        bit_cnt <= 3'd0;\n                    end\n                end\n\n                // shift in 8 data bits, LSB first\n                RECEIVE: begin\n                    shift_reg[bit_cnt] <= in;\n                    if (bit_cnt == 3'd7) begin\n                        state <= STOP_BIT;\n                    end else begin\n                        bit_cnt <= bit_cnt + 3'd1;\n                    end\n                end\n\n                // check stop bit\n                STOP_BIT: begin\n                    if (in == 1'b1) begin\n                        out_byte <= shift_reg;\n                        done     <= 1'b1;\n                        state    <= IDLE;\n                    end else begin\n                        // bad stop \u2014 sync by waiting for idle level\n                        state <= WAIT_IDLE;\n                    end\n                end\n\n                // drop bits until line returns to idle (in==1)\n                WAIT_IDLE: begin\n                    if (in == 1'b1)\n                        state <= IDLE;\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input               clk,\n    input               areset, \n\n    // Prediction interface (Fetch stage)\n    input               predict_valid,\n    input   [6:0]       predict_pc,\n    output              predict_taken, \n    output  [6:0]       predict_history,\n\n    // Training interface (commit/resolve stage)\n    input               train_valid,\n    input               train_taken,\n    input               train_mispredicted,\n    input   [6:0]       train_history, \n    input   [6:0]       train_pc\n);\n\n    // 2-bit saturating PHT, 128 entries\n    reg [1:0] PHT [0:127];\n    // Global history register (7 bits)\n    reg [6:0] GHR;\n\n    // Combinational indices\n    wire [6:0] pred_index  = predict_pc ^ GHR;\n    wire [6:0] train_index = train_pc   ^ train_history;\n\n    // Combinational outputs\n    assign predict_taken   = PHT[pred_index][1];\n    assign predict_history = GHR;\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // reset GHR\n            GHR <= 7'b0;\n            // initialize PHT to weakly not-taken (01)\n            for (i=0; i<128; i=i+1)\n                PHT[i] <= 2'b01;\n        end else begin\n            // 1) update the PHT on training\n            if (train_valid) begin\n                if (train_taken) begin\n                    // increment up to '11'\n                    PHT[train_index] <= (PHT[train_index] == 2'b11) \n                                        ? 2'b11 \n                                        : PHT[train_index] + 2'b01;\n                end else begin\n                    // decrement down to '00'\n                    PHT[train_index] <= (PHT[train_index] == 2'b00) \n                                        ? 2'b00 \n                                        : PHT[train_index] - 2'b01;\n                end\n            end\n\n            // 2) update/restore the GHR\n            if (train_valid && train_mispredicted) begin\n                // restore GHR to the state after the mispredicted branch\n                GHR <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // speculative update on prediction\n                GHR <= { GHR[5:0], PHT[pred_index][1] };\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam W_L   = 3'd0,\n               W_R   = 3'd1,\n               DIG_L = 3'd2,\n               DIG_R = 3'd3,\n               FALL_L= 3'd4,\n               FALL_R= 3'd5,\n               SPLAT = 3'd6;\n\n    reg [2:0] state;\n    reg [5:0] fall_count;\n\n    // State and fall counter update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state      <= W_L;\n            fall_count <= 6'd0;\n        end else begin\n            case (state)\n                // Walking Left\n                W_L: begin\n                    if (!ground) begin\n                        state      <= FALL_L;\n                        fall_count <= 6'd1;\n                    end else if (dig) begin\n                        state      <= DIG_L;\n                        fall_count <= 6'd0;\n                    end else if (bump_left | bump_right) begin\n                        state      <= W_R;\n                        fall_count <= 6'd0;\n                    end else begin\n                        state      <= W_L;\n                        fall_count <= 6'd0;\n                    end\n                end\n\n                // Walking Right\n                W_R: begin\n                    if (!ground) begin\n                        state      <= FALL_R;\n                        fall_count <= 6'd1;\n                    end else if (dig) begin\n                        state      <= DIG_R;\n                        fall_count <= 6'd0;\n                    end else if (bump_left | bump_right) begin\n                        state      <= W_L;\n                        fall_count <= 6'd0;\n                    end else begin\n                        state      <= W_R;\n                        fall_count <= 6'd0;\n                    end\n                end\n\n                // Digging Left\n                DIG_L: begin\n                    if (!ground) begin\n                        state      <= FALL_L;\n                        fall_count <= 6'd1;\n                    end else begin\n                        state      <= DIG_L;\n                        fall_count <= 6'd0;\n                    end\n                end\n\n                // Digging Right\n                DIG_R: begin\n                    if (!ground) begin\n                        state      <= FALL_R;\n                        fall_count <= 6'd1;\n                    end else begin\n                        state      <= DIG_R;\n                        fall_count <= 6'd0;\n                    end\n                end\n\n                // Falling Left\n                FALL_L: begin\n                    if (!ground) begin\n                        state      <= FALL_L;\n                        fall_count <= fall_count + 6'd1;\n                    end else if (fall_count > 6'd20) begin\n                        state      <= SPLAT;\n                        // fall_count can stay or freeze\n                    end else begin\n                        state      <= W_L;\n                        fall_count <= 6'd0;\n                    end\n                end\n\n                // Falling Right\n                FALL_R: begin\n                    if (!ground) begin\n                        state      <= FALL_R;\n                        fall_count <= fall_count + 6'd1;\n                    end else if (fall_count > 6'd20) begin\n                        state      <= SPLAT;\n                    end else begin\n                        state      <= W_R;\n                        fall_count <= 6'd0;\n                    end\n                end\n\n                // Splattered (terminal)\n                SPLAT: begin\n                    state      <= SPLAT;\n                    // fall_count can remain\n                end\n\n                default: begin\n                    state      <= W_L;\n                    fall_count <= 6'd0;\n                end\n            endcase\n        end\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == W_L);\n    assign walk_right = (state == W_R);\n    assign digging    = (state == DIG_L) | (state == DIG_R);\n    assign aaah       = (state == FALL_L) | (state == FALL_R);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input        clk,\n    input        reset,          // synchronous, active\u2010high\n    input        data,\n    output reg   shift_ena,\n    output reg   counting,\n    input        done_counting,\n    output reg   done,\n    input        ack\n);\n\n    // State encoding\n    localparam S_IDLE   = 3'd0,  // no match yet\n               S_1      = 3'd1,  // saw '1'\n               S_11     = 3'd2,  // saw \"11\"\n               S_110    = 3'd3,  // saw \"110\"\n               S_SHIFT  = 3'd4,  // shifting in 4 bits\n               S_COUNT  = 3'd5,  // waiting for counters\n               S_NOTIFY = 3'd6;  // done, waiting for ack\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_cnt;         // counts 0,1,2,3,4\n\n    // State & shift_cnt update\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= S_IDLE;\n            shift_cnt <= 3'd0;\n        end else begin\n            state <= next_state;\n            // shift counter only in S_SHIFT\n            if (state == S_SHIFT)\n                shift_cnt <= shift_cnt + 3'd1;\n            else\n                shift_cnt <= 3'd0;\n        end\n    end\n\n    // Next\u2010state logic & outputs\n    always @(*) begin\n        // defaults\n        next_state = state;\n        shift_ena   = 1'b0;\n        counting    = 1'b0;\n        done        = 1'b0;\n\n        case(state)\n        //---------------------------------------------------\n        // look for 1101 (overlap capable)\n        S_IDLE: begin\n            if (data)\n                next_state = S_1;\n        end\n        S_1: begin\n            if (data)\n                next_state = S_11;\n            else\n                next_state = S_IDLE;\n        end\n        S_11: begin\n            if (data)\n                next_state = S_11;    // \"111\" -> keep last two '11'\n            else\n                next_state = S_110;\n        end\n        S_110: begin\n            if (data)\n                next_state = S_SHIFT; // 110 -> +1 = 1101\n            else\n                next_state = S_IDLE;\n        end\n\n        //---------------------------------------------------\n        // shift exactly 4 cycles\n        S_SHIFT: begin\n            if (shift_cnt < 3'd4)\n                shift_ena = 1'b1;\n            if (shift_cnt == 3'd3)\n                next_state = S_COUNT;\n        end\n\n        //---------------------------------------------------\n        // wait for done_counting\n        S_COUNT: begin\n            counting = 1'b1;\n            if (done_counting)\n                next_state = S_NOTIFY;\n        end\n\n        //---------------------------------------------------\n        // notify done, wait for ack\n        S_NOTIFY: begin\n            done = 1'b1;\n            if (ack)\n                next_state = S_IDLE;\n        end\n\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             load,\n    input      [255:0] data,\n    output reg [255:0] q\n);\n\n    // next state\n    wire [255:0] next_q;\n\n    genvar r, c;\n    generate\n        for (r = 0; r < 16; r = r + 1) begin: ROW\n            for (c = 0; c < 16; c = c + 1) begin: COL\n                // wrap\u2010around indices\n                localparam integer rp  = (r == 15) ? 0    : r + 1;\n                localparam integer rm  = (r == 0)  ? 15   : r - 1;\n                localparam integer cp  = (c == 15) ? 0    : c + 1;\n                localparam integer cm  = (c == 0)  ? 15   : c - 1;\n                localparam integer idx = r*16 + c;\n\n                // sum of 8 neighbours\n                wire [3:0] cnt = \n                      q[rm*16 + cm] + q[rm*16 +   c] + q[rm*16 + cp]\n                    + q[  r*16 + cm]                  + q[  r*16 + cp]\n                    + q[rp*16 + cm] + q[rp*16 +   c] + q[rp*16 + cp];\n\n                // apply rules:\n                //    cnt==3 => alive\n                //    cnt==2 => stays the same\n                assign next_q[idx] = (cnt == 3) | ((cnt == 2) & q[idx]);\n            end\n        end\n    endgenerate\n\n    // sequential update or load initial state\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam [2:0]\n        S_WL = 3'd0,\n        S_WR = 3'd1,\n        S_FL = 3'd2,\n        S_FR = 3'd3,\n        S_DL = 3'd4,\n        S_DR = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_WL;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            // walking left\n            S_WL: begin\n                if (!ground)\n                    next_state = S_FL;                // fall left\n                else if (dig)\n                    next_state = S_DL;                // start digging left\n                else if (bump_left | bump_right)\n                    next_state = S_WR;                // bump -> flip to right\n                else\n                    next_state = S_WL;\n            end\n\n            // walking right\n            S_WR: begin\n                if (!ground)\n                    next_state = S_FR;                // fall right\n                else if (dig)\n                    next_state = S_DR;                // start digging right\n                else if (bump_left | bump_right)\n                    next_state = S_WL;                // bump -> flip to left\n                else\n                    next_state = S_WR;\n            end\n\n            // falling left\n            S_FL: begin\n                if (ground)\n                    next_state = S_WL;                // landed, resume left\n                else\n                    next_state = S_FL;\n            end\n\n            // falling right\n            S_FR: begin\n                if (ground)\n                    next_state = S_WR;                // landed, resume right\n                else\n                    next_state = S_FR;\n            end\n\n            // digging left\n            S_DL: begin\n                if (!ground)\n                    next_state = S_FL;                // dig hole to air -> fall left\n                else\n                    next_state = S_DL;\n            end\n\n            // digging right\n            S_DR: begin\n                if (!ground)\n                    next_state = S_FR;                // dig hole to air -> fall right\n                else\n                    next_state = S_DR;\n            end\n\n            default: next_state = S_WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_WL);\n    assign walk_right = (state == S_WR);\n    assign aaah       = (state == S_FL) | (state == S_FR);\n    assign digging    = (state == S_DL) | (state == S_DR);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous active\u2010high\n    input        ena,    // one\u2010pulse per second\n    output reg   pm,\n    output reg [7:0] hh, // BCD hours 01\u201312\n    output reg [7:0] mm, // BCD minutes 00\u201359\n    output reg [7:0] ss  // BCD seconds 00\u201359\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // initialize to 12:00:00 AM\n        hh <= 8'h12;\n        mm <= 8'h00;\n        ss <= 8'h00;\n        pm <= 1'b0;\n    end else if (ena) begin\n        // ---- seconds ----\n        if (ss == 8'h59) begin\n            ss <= 8'h00;\n            // ---- minutes ----\n            if (mm == 8'h59) begin\n                mm <= 8'h00;\n                // ---- hours ----\n                if (hh == 8'h12) begin\n                    hh <= 8'h01;\n                    pm <= ~pm;\n                end else begin\n                    // increment BCD hour (01\u219202\u202609\u219210, 10\u219211, 11\u219212)\n                    if (hh[3:0] == 4'h9) begin\n                        hh <= {hh[7:4] + 1, 4'h0};\n                    end else begin\n                        hh <= hh + 1;\n                    end\n                end\n            end else begin\n                // increment BCD minute (00\u201359)\n                if (mm[3:0] == 4'h9) begin\n                    mm <= {mm[7:4] + 1, 4'h0};\n                end else begin\n                    mm <= mm + 1;\n                end\n            end\n        end else begin\n            // increment BCD second (00\u201359)\n            if (ss[3:0] == 4'h9) begin\n                ss <= {ss[7:4] + 1, 4'h0};\n            end else begin\n                ss <= ss + 1;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam [1:0]\n        WALK_L = 2'd0,\n        WALK_R = 2'd1,\n        FALL_L = 2'd2,\n        FALL_R = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_L;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore)\n    always @(*) begin\n        case (state)\n            WALK_L: begin\n                if (!ground)\n                    next_state = FALL_L;\n                else if (bump_left || bump_right)\n                    next_state = WALK_R;\n                else\n                    next_state = WALK_L;\n            end\n\n            WALK_R: begin\n                if (!ground)\n                    next_state = FALL_R;\n                else if (bump_left || bump_right)\n                    next_state = WALK_L;\n                else\n                    next_state = WALK_R;\n            end\n\n            FALL_L: begin\n                if (ground)\n                    next_state = WALK_L;\n                else\n                    next_state = FALL_L;\n            end\n\n            FALL_R: begin\n                if (ground)\n                    next_state = WALK_R;\n                else\n                    next_state = FALL_R;\n            end\n\n            default: next_state = WALK_L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WALK_L);\n    assign walk_right = (state == WALK_R);\n    assign aaah       = (state == FALL_L) || (state == FALL_R);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:1] ena,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q   <= 16'b0;\n        ena <= 3'b0;\n    end else begin\n        // ones digit\n        if (q[3:0] == 4'd9) begin\n            q[3:0]  <= 4'd0;\n            ena[1]  <= 1'b1;\n        end else begin\n            q[3:0]  <= q[3:0] + 1;\n            ena[1]  <= 1'b0;\n        end\n\n        // tens digit\n        if (ena[1]) begin\n            if (q[7:4] == 4'd9) begin\n                q[7:4]  <= 4'd0;\n                ena[2]  <= 1'b1;\n            end else begin\n                q[7:4]  <= q[7:4] + 1;\n                ena[2]  <= 1'b0;\n            end\n        end else begin\n            ena[2] <= 1'b0;\n        end\n\n        // hundreds digit\n        if (ena[2]) begin\n            if (q[11:8] == 4'd9) begin\n                q[11:8] <= 4'd0;\n                ena[3]  <= 1'b1;\n            end else begin\n                q[11:8] <= q[11:8] + 1;\n                ena[3]  <= 1'b0;\n            end\n        end else begin\n            ena[3] <= 1'b0;\n        end\n\n        // thousands digit\n        if (ena[3]) begin\n            if (q[15:12] == 4'd9)\n                q[15:12] <= 4'd0;\n            else\n                q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,\n    input        w,\n    output reg   Y2\n);\n\n    // next\u2010state logic for y[2]\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0;    // A\u2192{B,A} \u2192 y2\u2032=0\n            3'b001: Y2 = 1'b1;    // B\u2192{C,D} \u2192 y2\u2032=1\n            3'b010: Y2 = w;       // C\u2192{E,D} \u2192 y2\u2032= w\n            3'b011: Y2 = 1'b0;    // D\u2192{F,A} \u2192 y2\u2032=0\n            3'b100: Y2 = w;       // E\u2192{E,D} \u2192 y2\u2032= w\n            3'b101: Y2 = 1'b1;    // F\u2192{C,D} \u2192 y2\u2032=1\n            default: Y2 = 1'b0;   // safe for unused states\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring is asserted, choose ringer or motor based on vibrate_mode\n    assign ringer = ring & ~vibrate_mode;\n    assign motor  = ring &  vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // 1) continuous\u2010assignment (assign)\n    assign out_assign = a & b;\n\n    // 2) combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Constant zero output\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg   q\n);\n\n    // intermediate register to hold 'a' one cycle\n    reg d;\n\n    always @(posedge clk) begin\n        d <= a;      // capture input\n        q <= ~d;     // output is inverted version of previous 'a'\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // active\u2013high, asynchronous\n    input  x,       // serial input, LSB first\n    output reg z    // serial 2\u2019s\u2011complement output\n);\n\n    // Two states:  \n    //   S0 = \u201chaven\u2019t seen first \u20181\u2019 yet\u201d (copy input)\n    //   S1 = \u201cseen first \u20181\u2019\u201d            (invert input)\n    typedef enum logic { S0, S1 } state_t;\n    state_t state, next_state;\n\n    // Next\u2011state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0: if (x) next_state = S1;\n            S1:             next_state = S1;\n        endcase\n    end\n\n    // State register + output register\n    // z is updated in the same clock that state is, so it's a Moore\u2010type\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n            z     <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                S0: z <= x;     // before first 1, just copy\n                S1: z <= ~x;    // after first 1, invert\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output       out\n);\n\n    // state encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output logic\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse byte order: {B3, B2, B1, B0} -> {B0, B1, B2, B3}\n    assign out = { in[7:0],    // byte 0\n                   in[15:8],   // byte 1\n                   in[23:16],  // byte 2\n                   in[31:24]   // byte 3\n                 };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  d,\n    input  r,\n    output logic q\n);\n\n    // D flip\u2010flop with active\u2010high synchronous reset\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input              ena,\n    input       [1:0]  amount,\n    input      [63:0]  data,\n    output reg [63:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00:  q <= q << 1;                        // logical left by 1\n                2'b01:  q <= q << 8;                        // logical left by 8\n                2'b10:  q <= {q[63], q[63:1]};              // arithmetic right by 1\n                2'b11:  q <= {{8{q[63]}}, q[63:8]};         // arithmetic right by 8\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,  // active\u2010low async reset\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam [1:0]\n        S0 = 2'b00,  // no valid prefix\n        S1 = 2'b01,  // saw \"1\"\n        S2 = 2'b10;  // saw \"10\"\n\n    reg [1:0] state, next_state;\n\n    // State register with negative\u2010edge async reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state and output (Mealy)\n    always @(*) begin\n        next_state = S0;\n        z          = 1'b0;\n        case (state)\n            S0: begin\n                if (x) \n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x) \n                    next_state = S1;  // still could be start of \"1\"\n                else\n                    next_state = S2;  // saw \"10\"\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;  // overlap: \"101\" ends in \"1\"\n                    z          = 1'b1; // detected \"101\"\n                end else\n                    next_state = S0;  // saw \"100\" \u2192 restart\n            end\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  wire clk,\n    input  wire reset,\n    input  wire w,\n    output wire z\n);\n\n    // State encoding\n    localparam [2:0]\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w == 1'b0) ? B : A;\n            B: next_state = (w == 1'b0) ? C : D;\n            C: next_state = (w == 1'b0) ? E : D;\n            D: next_state = (w == 1'b0) ? F : A;\n            E: next_state = (w == 1'b0) ? E : D;\n            F: next_state = (w == 1'b0) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore\u2010output logic\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,     // synchronous, active\u2010high\n    output reg [23:0] out_bytes,\n    output reg       done\n);\n\n    // State encoding\n    localparam WAIT = 2'd0,\n               S1   = 2'd1,\n               S2   = 2'd2;\n\n    reg [1:0] state;\n    reg [7:0] byte1, byte2;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= WAIT;\n            byte1      <= 8'd0;\n            byte2      <= 8'd0;\n            out_bytes  <= 24'd0;\n            done       <= 1'b0;\n        end else begin\n            // default\n            done <= 1'b0;\n            case (state)\n                WAIT: begin\n                    if (in[3]) begin\n                        byte1 <= in;\n                        state <= S1;\n                    end else\n                        state <= WAIT;\n                end\n\n                S1: begin\n                    byte2 <= in;\n                    state <= S2;\n                end\n\n                S2: begin\n                    // we've now got the third byte\n                    out_bytes <= { byte1, byte2, in };\n                    done       <= 1'b1;\n                    state      <= WAIT;\n                end\n\n                default: state <= WAIT;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,  // one\u2010hot state vector: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1, // next\u2010state input for y[1] (B)\n    output       Y3  // next\u2010state input for y[3] (D)\n);\n\n    // Y1 = 1 whenever we are in A (y[0]) and w=1 \u2192 next state = B\n    assign Y1 = y[0] & w;\n\n    // Y3 = 1 whenever we are in B,C,D,E or F (y[1]\u2013y[5]) and w=0 \u2192 next state = D\n    assign Y3 = (~w) & ( y[1] | y[2] | y[3] | y[4] | y[5] );\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the 3\u2011bit vector\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2011map one finds the function is 1 exactly\n    // when an odd number of inputs are 1, i.e. out = a\u2295b\u2295c\u2295d\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Upper byte\n    assign out_hi = in[15:8];\n\n    // Lower byte\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // NOR gate: output is high only when both inputs are low\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a,\n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) clocked always block XOR (registered, one\u2010cycle delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one-hot: y[1]=A, y[2]=B, y[3]=C, y[4]=D, y[5]=E, y[6]=F\n    input        w,\n    output       Y2, // next\u2010state bit for B\n    output       Y4  // next\u2010state bit for D\n);\n\n    // next\u2010state equations by inspection\n    assign Y2 = y[1] & ~w;  \n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input   [7:0] sel,\n    output        out\n);\n\n    // 256\u2010to\u20101 mux: use variable bit\u2010select\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // First MUX: choose between parallel\u2010load (R) and shift\u2010in (w)\n    wire data_in = L ? R : w;\n\n    // Second MUX: choose between shifting/loading or hold\n    wire next_Q  = E ? data_in : Q;\n\n    // Edge\u2010triggered D\u2010FF\n    always @(posedge clk) begin\n        Q <= next_Q;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    output       z\n);\n\n    // State bits\n    reg q0, q1, q2;\n    // Next\u2010state signals\n    wire d0, d1, d2;\n\n    // Compute next states\n    assign d0 = x ^  q0;   // XOR with current q0\n    assign d1 = x & ~q1;   // AND with complement of q1\n    assign d2 = x | ~q2;   // OR  with complement of q2\n\n    // Output is 3\u2011input XNOR of the state bits\n    // A 3\u2011input XNOR is the negation of their three\u2011way XOR\n    assign z  = ~ (q0 ^ q1 ^ q2);\n\n    // D\u2011flip\u2011flops: on each rising edge of clk, update state\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\n    // Initial condition: all flip\u2011flops start at 0\n    initial { q0, q1, q2 } = 3'b000;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n    // From the waveform, q is 1 whenever b==1 or c==1, otherwise 0.\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // next state\n    reg [511:0] next_q;\n    integer     i;\n\n    // compute next_q combinationally\n    always @* begin\n        for (i = 0; i < 512; i = i + 1) begin\n            // boundary cells see 0 off\u2010grid\n            // {left, center, right}\n            case ({ (i ? q[i-1] : 1'b0),\n                    q[i],\n                    (i < 511 ? q[i+1] : 1'b0) })\n                // Rule 110: 111->0, 100->0, 000->0\n                3'b111, 3'b100, 3'b000: next_q[i] = 1'b0;\n                // all others -> 1\n                default:               next_q[i] = 1'b1;\n            endcase\n        end\n    end\n\n    // sequential update or load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,  // synchronous, active\u2010high\n    output reg out\n);\n\n    // state encoding\n    localparam [1:0]\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state & output logic (Moore => output depends only on state)\n    always @(*) begin\n        // defaults\n        next_state = A;\n        out        = 1'b0;\n        case (state)\n            A: begin\n                out        = 1'b0;\n                next_state = in ? B : A;\n            end\n            B: begin\n                out        = 1'b0;\n                next_state = in ? B : C;\n            end\n            C: begin\n                out        = 1'b0;\n                next_state = in ? D : A;\n            end\n            D: begin\n                out        = 1'b1;\n                next_state = in ? B : C;\n            end\n            default: begin\n                out        = 1'b0;\n                next_state = A;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out = sel ? b : a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input        clk,\n    input        L,\n    input        q_in,\n    input        r_in,\n    output reg   Q\n);\n    // On each rising clk edge, select between loading r_in or shifting q_in\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\nmodule full_module(\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three 1\u2011bit mux+FFs\n    // bit 0 gets previous bit2 when shifting\n    top_module ff0 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q2),\n        .r_in  (r[0]),\n        .Q     (q0)\n    );\n\n    // bit 1 gets previous bit0 when shifting\n    top_module ff1 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q0),\n        .r_in  (r[1]),\n        .Q     (q1)\n    );\n\n    // bit 2 gets q1^q2 when shifting\n    top_module ff2 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q1 ^ q2),\n        .r_in  (r[2]),\n        .Q     (q2)\n    );\n\n    assign q = {q2, q1, q0};\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,  // active\u2010high synchronous\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // register to hold previous cycle\u2019s input\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out     <= 32'b0;\n            prev_in <= in;\n        end else begin\n            // detect 1\u21920 transitions and sticky\u2010latch them in out\n            out     <= out | (prev_in & ~in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // 8 D flip\u2011flops clocked on the rising edge of clk\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // 8\u2011bit two's\u2011complement sum (wrap\u2011around on overflow)\n    assign s = a + b;\n\n    // Signed overflow occurs when the operands have the same sign\n    // but the result has a different sign.\n    assign overflow = ( a[7] &  b[7] & ~s[7] ) // both inputs negative, sum positive\n                     | (~a[7] & ~b[7] &  s[7] );// both inputs positive, sum negative\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,      // one\u2010hot: [0]=S, [1]=S1, [2]=S11, [3]=S110,\n                            //          [4]=B0, [5]=B1, [6]=B2, [7]=B3,\n                            //          [8]=Count, [9]=Wait\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n    // next\u2010state logic by inspection\n    // S_next  : S\u2190(S|S1|S110) & d==0\n    assign S_next     = (~d) & (state[0] | state[1] | state[3]);\n\n    // S1_next : S1\u2190S & d==1\n    assign S1_next    = d & state[0];\n\n    // B3_next : B3\u2190B2 (unconditional)\n    assign B3_next    = state[6];\n\n    // Count_next : Count\u2190B3 or (Count & !done_counting)\n    assign Count_next = state[7]\n                      | (state[8] & ~done_counting);\n\n    // Wait_next : Wait\u2190(Count & done_counting) or (Wait & !ack)\n    assign Wait_next  = (state[8] & done_counting)\n                      | (state[9] & ~ack);\n\n    // Moore outputs\n    assign shift_ena  = state[4]\n                      | state[5]\n                      | state[6]\n                      | state[7];\n    assign counting   = state[8];\n    assign done       = state[9];\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic       clk,\n    input  logic       areset,\n    input  logic       train_valid,\n    input  logic       train_taken,\n    output logic [1:0] state\n);\n\n    // 2-bit saturating counter: reset to 2'b01, saturates between 0 and 3\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken) begin\n                // increment, saturate at 3\n                state <= (state == 2'b11) ? 2'b11 : state + 1;\n            end else begin\n                // decrement, saturate at 0\n                state <= (state == 2'b00) ? 2'b00 : state - 1;\n            end\n        end\n        // else keep current state\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casex (in)\n            8'b???????1: pos = 3'd0;  // bit 0 has highest priority\n            8'b??????10: pos = 3'd1;\n            8'b?????100: pos = 3'd2;\n            8'b????1000: pos = 3'd3;\n            8'b???10000: pos = 3'd4;\n            8'b??100000: pos = 3'd5;\n            8'b?1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default:     pos = 3'd0;  // no bits set\n        endcase\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // default all outputs low\n        left  = 0;\n        down  = 0;\n        right = 0;\n        up    = 0;\n\n        // decode the 16\u2011bit scancode\n        case (scancode)\n            16'hE06B: left  = 1;  // left arrow\n            16'hE072: down  = 1;  // down arrow\n            16'hE074: right = 1;  // right arrow\n            16'hE075: up    = 1;  // up arrow\n            default: ;             // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    wire c1, c2, c3, c4;\n\n    // LSB full adder, carry\u2011in = 0\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (1'b0),\n        .s   (sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c1),\n        .s   (sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c2),\n        .s   (sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c3),\n        .s   (sum[3]),\n        .cout(c4)\n    );\n\n    // overflow / MSB of the 5\u2010bit sum\n    assign sum[4] = c4;\n\nendmodule\n\n// simple 1\u2011bit full adder\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output s,\n    output cout\n);\n    assign s    = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n    \n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    logic [31:0] history;\n\n    // expose the current GHR\n    assign predict_history = history;\n\n    // GHR update with async reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 32'd0;\n        end else begin\n            if (train_mispredicted) begin\n                // rollback: take older history bits and the actual outcome\n                history <= {train_history[30:0], train_taken};\n            end\n            else if (predict_valid) begin\n                // shift in the new predicted direction\n                history <= {history[30:0], predict_taken};\n            end\n            // otherwise hold\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // intermediate wires for the AND outputs\n    wire ab_and;\n    wire cd_and;\n\n    // first layer: two AND gates\n    and u_and1(ab_and, a, b);\n    and u_and2(cd_and, c, d);\n\n    // second layer: OR gate drives out\n    or  u_or1(out, ab_and, cd_and);\n\n    // inverted output\n    not u_not1(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // On each rising clock edge, sample D into Q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n\n    // 8\u2010bit shift register\n    reg [7:0] Q;\n    always @(posedge clk) begin\n        if (enable) begin\n            // shift toward higher indices, S \u2192 Q[0]\n            Q <= { Q[6:0], S };\n        end\n    end\n\n    // 8\u2010to\u20101 multiplexer for random access read\n    always @(*) begin\n        case ({A,B,C})\n            3'd0: Z = Q[0];\n            3'd1: Z = Q[1];\n            3'd2: Z = Q[2];\n            3'd3: Z = Q[3];\n            3'd4: Z = Q[4];\n            3'd5: Z = Q[5];\n            3'd6: Z = Q[6];\n            3'd7: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,      // 1 = heating, 0 = cooling\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater is on only in heating mode when it's too cold\n    assign heater = mode & too_cold;\n\n    // Air conditioner is on only in cooling mode when it's too hot\n    assign aircon = ~mode & too_hot;\n\n    // Fan is on if heater or aircon is on, or if user forces fan_on\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,   // active\u2010high synchronous\n    output reg [31:0] q\n);\n\n    // polynomial x^32 + x^22 + x^2 + x + 1\n    localparam [31:0] TAP_MASK = 32'h8020_0003;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            // Galois LFSR: shift right, inject feedback at tap positions\n            // feedback = LSB of current state\n            q <= (q >> 1) ^ ({32{q[0]}} & TAP_MASK);\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n    // q is high whenever {a,b}\u226000 AND {c,d}\u226000\n    assign q = (a | b) & (c | d);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Two independent 4-input NAND gates\n    nand(p1y, p1a, p1b, p1c, p1d);\n    nand(p2y, p2a, p2b, p2c, p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // both this bit and the left neighbor are 1\n    assign out_both[0] = in[0] & in[1];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[2] = in[2] & in[3];\n\n    // this bit or the right neighbor is 1\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // bit differs from its left neighbor, with wrap\u2010around\n    assign out_different[0] = in[0] ^ in[1];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[3] = in[3] ^ in[0];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0] a,\n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // out = in1 AND (NOT in2)\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinationally drive out with in\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // Moore output depends only on current state\n    assign out = (state == B) ? 1'b1 : 1'b0;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            B: next_state = (in == 1'b0) ? A : B;\n            A: next_state = (in == 1'b0) ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // Two edge\u2010sensitive registers\n    reg q_pos;  // sampled at posedge\n    reg q_neg;  // sampled at negedge\n\n    // Sample d on rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Sample d on falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // MUX outputs the most recently sampled value\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // XNOR operation: out is high when a and b are equal\n    assign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    // from the waveform: z = 1 when x==y, else 0 \u2192 XNOR\n    assign z = ~(x ^ y);\nendmodule\n\nmodule top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // intermediate nets\n    wire a1, b1, a2, b2;\n    wire w_or, w_and;\n\n    // first pair: A\u2192OR\u2190B\n    A  uA1 (.x(x), .y(y), .z(a1));\n    B  uB1 (.x(x), .y(y), .z(b1));\n    assign w_or  = a1 | b1;\n\n    // second pair: A\u2192AND\u2190B\n    A  uA2 (.x(x), .y(y), .z(a2));\n    B  uB2 (.x(x), .y(y), .z(b2));\n    assign w_and = a2 & b2;\n\n    // final XOR\n    assign z = w_or ^ w_and;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [1:0]   ena,\n    input      [99:0]  data,\n    output reg [99:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0],     q[99:1]};    // rotate right\n                2'b10: q <= {q[98:0],  q[99]  };    // rotate left\n                default: q <= q;                     // no rotate (00 or 11)\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [9:0] q\n);\n\n    // Synchronous reset, count from 0 to 999 inclusive\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 10'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // NOT gate implementation\n    assign out = ~in;\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    wire nin = ~in;\n\n    // next\u2010state equations (one\u2010hot encoding)\n    assign next_state[0] = nin & ( state[0] | state[1] | state[2]\n                                | state[3] | state[4] | state[7]\n                                | state[8] | state[9] );\n    assign next_state[1] =  in & ( state[0] | state[8] | state[9] );\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & ( state[6] | state[7] );\n    assign next_state[8] = nin &  state[5];\n    assign next_state[9] = nin &  state[6];\n\n    // Moore outputs\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;      // hold\n            2'b01: Q <= 1'b0;   // reset\n            2'b10: Q <= 1'b1;   // set\n            2'b11: Q <= ~Q;     // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Population count: sum up the three input bits\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // pack inputs so that in[0]=a, in[1]=b, in[2]=c, in[3]=d, in[4]=e\n    wire [4:0] in;\n    assign in = {e, d, c, b, a};\n\n    genvar i, j;\n    generate\n        // outer loop over x = a,b,c,d,e  (i=0..4)\n        // inner loop over y = a,b,c,d,e (j=0..4)\n        // out index = (4-i)*5 + (4-j),  \n        // out[k] = 1 if in[i] == in[j]  via ~(in[i] ^ in[j]) = ~in[i] ^ in[j]\n        for (i = 0; i < 5; i = i + 1) begin : X\n            for (j = 0; j < 5; j = j + 1) begin : Y\n                assign out[(4-i)*5 + (4-j)] = ~in[i] ^ in[j];\n            end\n        end\n    endgenerate\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // State encoding\n    localparam LEFT  = 1'b0,\n               RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    // State register with async posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        if (bump_left | bump_right)\n            next_state = ~state;  // flip direction on any bump\n        else\n            next_state = state;   // otherwise stay\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n    // From the waveform: q is high only when a=1 and b=1\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // First OR of two 3-input ANDs\n    assign p1y = (p1a & p1b & p1c)\n               | (p1d & p1e & p1f);\n\n    // Second OR of two 2-input ANDs\n    assign p2y = (p2a & p2b)\n               | (p2c & p2d);\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    // combinational logic for next\u2010state bit Y0 and output z\n    always @(*) begin\n        // Y0 = 1 for (y,x) = 000,1  001,0  010,1  011,0  100,0\n        // which simplifies to:\n        //    ~y2 & (x ^ y0)    covers y={000,001,010,011}\n        //  + y2 & ~y1 & ~y0 & ~x   covers y=100\n        Y0 = (~y[2] & (x ^ y[0]))\n           | ( y[2] & ~y[1] & ~y[0] & ~x );\n\n        // z = 1 in present\u2010state 011 or 100\n        z  = (~y[2] &  y[1] &  y[0])\n           | ( y[2] & ~y[1] & ~y[0]);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    // Continuous assignments to mirror inputs on outputs\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        d,\n    input        ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous active\u2010high reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @* begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk,\n    input        load,\n    input  [9:0] data,\n    output       tc\n);\n\n    reg [9:0] count;\n\n    // Count\u2010down / Load logic\n    always @(posedge clk) begin\n        if (load)\n            count <= data;\n        else if (count != 0)\n            count <= count - 1;\n    end\n\n    // Terminal count flag when counter reaches zero\n    assign tc = (count == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,         // synchronous active\u2011high\n    input        data,\n    output reg   start_shifting\n);\n\n    // state encoding\n    localparam IDLE     = 3'd0;  // nothing matched\n    localparam S1       = 3'd1;  // saw \u201c1\u201d\n    localparam S2       = 3'd2;  // saw \u201c11\u201d\n    localparam S3       = 3'd3;  // saw \u201c110\u201d\n    localparam DETECTED = 3'd4;  // saw \u201c1101\u201d \u2192 latch output\n\n    reg [2:0] state, next_state;\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            IDLE:     next_state = data ? S1       : IDLE;\n            S1:       next_state = data ? S2       : IDLE;\n            S2:       next_state = data ? S2       : S3;\n            S3:       next_state = data ? DETECTED : IDLE;\n            DETECTED: next_state = DETECTED;\n            default:  next_state = IDLE;\n        endcase\n    end\n\n    // output register: set once when \"1101\" is detected\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (state == S3 && data)\n            start_shifting <= 1'b1;\n        // else keep its value\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2011flip\u2011flops with synchronous active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold the previous cycle's input\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        // sample input\n        in_d    <= in;\n        // detect 0->1 transitions: (~in_d & in)\n        anyedge <= (~in_d) & in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous, active\u2010high\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1;\n        end else begin\n            if (q == 4'd10)\n                q <= 4'd1;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4;      // when a=1 always load 4\n        else\n            q <= q + 3'd1;  // when a=0 count up mod 8\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,\n    output reg [4:0] q\n);\n\n    // Galois LFSR with polynomial x^5 + x^3 + 1 (taps at positions 5 and 3)\n    // Left\u2013shift form: output bit = q[4], feedback = q[4]\n    // reset state = 5'b00001 (non\u2010zero)\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001;\n        end else begin\n            // compute feedback from MSB\n            // shift left, XOR feedback into tapped positions\n            // tap at pos5 \u2192 bit[4], tap at pos3 \u2192 bit[2]\n            q[4] <= q[3] ^ q[4];\n            q[3] <= q[2];\n            q[2] <= q[1] ^ q[4];\n            q[1] <= q[0];\n            q[0] <= q[4];\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // zero\u2010flag\n        result_is_zero = (out == 8'd0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // From the K\u2010map the minimal cover is\n    //   f = x3\u00b7!x1  +  x2\u00b7x4\n    assign f = (x[3] & ~x[1]) | (x[2] & x[4]);\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: {valid, out} = {1'b1, 4'd0};  // '0'\n            8'h16: {valid, out} = {1'b1, 4'd1};  // '1'\n            8'h1E: {valid, out} = {1'b1, 4'd2};  // '2'\n            8'h26: {valid, out} = {1'b1, 4'd3};  // '3'\n            8'h25: {valid, out} = {1'b1, 4'd4};  // '4'\n            8'h2E: {valid, out} = {1'b1, 4'd5};  // '5'\n            8'h36: {valid, out} = {1'b1, 4'd6};  // '6'\n            8'h3D: {valid, out} = {1'b1, 4'd7};  // '7'\n            8'h3E: {valid, out} = {1'b1, 4'd8};  // '8'\n            8'h46: {valid, out} = {1'b1, 4'd9};  // '9'\n            default: {valid, out} = {1'b0, 4'd0};\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse bit\u2010order: out[7]=in[0], \u2026, out[0]=in[7]\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : bit_reverse\n            assign out[i] = in[7 - i];\n        end\n    endgenerate\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": ""}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift right, bringing new bit into MSB\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // down\u2010counter\n            q <= q - 1;\n        end\n        // else hold\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Direct wire connection\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  wire clk,\n    input  wire reset,    // synchronous, active\u2010high\n    output reg  shift_ena\n);\n\n    // counter to generate a 4\u2010cycle pulse\n    reg [2:0] cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // load 4 when reset is asserted\n            cnt      <= 3'd4;\n            shift_ena<= 1'b1;\n        end else if (cnt != 3'd0) begin\n            // count down and keep shift_ena asserted\n            cnt      <= cnt - 3'd1;\n            shift_ena<= 1'b1;\n        end else begin\n            // once cnt hits zero, deassert forever (until next reset)\n            shift_ena<= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,   // synchronous, active\u2010high\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;  // 4\u2010bit addition wraps from 15 to 0\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // 2:1 mux using continuous assignment\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // 2:1 mux using procedural if-statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    input  c,\n    output out\n);\n    // From the K\u2010map: out = 1 whenever a=1 or (a=0 and (b=1 or c=1))\n    // Simplifies to: out = a + b + c\n    assign out = a | b | c;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input         clk,\n    input         resetn,    // active\u2010low synchronous reset\n    input   [3:1] r,         // r[1] = req1, r[2]=req2, r[3]=req3\n    output  [3:1] g          // g[1]=grant1, g[2]=grant2, g[3]=grant3\n);\n\n    // State encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State flip\u2010flops (synchronous, active\u2010low reset)\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])      next_state = B;      // highest priority\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else            next_state = A;\n            end\n            B: next_state = r[1] ? B : A;         // stay while req1, else idle\n            C: next_state = r[2] ? C : A;         // stay while req2, else idle\n            D: next_state = r[3] ? D : A;         // stay while req3, else idle\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    // grant1 when in B, grant2 when in C, grant3 when in D\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,  // synchronous, active\u2010high\n    output       done\n);\n\n    // state encoding\n    localparam [1:0]\n        S_WAIT = 2'd0,   // looking for first byte (in[3]==1)\n        S_B1   = 2'd1,   // got byte #1\n        S_B2   = 2'd2,   // got byte #2\n        S_B3   = 2'd3;   // got byte #3 \u2192 assert done\n\n    reg [1:0] state, next_state;\n\n    // done is high for one cycle immediately after the 3rd byte\n    assign done = (state == S_B3);\n\n    // state register, synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S_WAIT;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            S_WAIT: next_state = in[3] ? S_B1 : S_WAIT;\n            S_B1:   next_state = S_B2;\n            S_B2:   next_state = S_B3;\n            S_B3:   next_state = S_WAIT;\n            default: next_state = S_WAIT;\n        endcase\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 mux: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // 4\u2010input reduction gates\n    assign out_and = &in;   // AND of all inputs\n    assign out_or  = |in;   // OR of all inputs\n    assign out_xor = ^in;   // XOR of all inputs\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active\u2010high\n    input        x,\n    output reg   z\n);\n\n    reg [2:0] y, y_next;\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (y)\n            3'b000: y_next = (x ? 3'b001 : 3'b000);\n            3'b001: y_next = (x ? 3'b100 : 3'b001);\n            3'b010: y_next = (x ? 3'b001 : 3'b010);\n            3'b011: y_next = (x ? 3'b010 : 3'b001);\n            3'b100: y_next = (x ? 3'b100 : 3'b011);\n            default: y_next = 3'b000;\n        endcase\n    end\n\n    // Output logic (Moore)\n    always @(*) begin\n        case (y)\n            3'b011,\n            3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            y <= 3'b000;\n        else\n            y <= y_next;\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,  // synchronous active\u2010low\n    input x,\n    input y,\n    output f,\n    output g\n);\n\n    // State encoding (4 bits to cover 9 states)\n    localparam S_A     = 4'd0,\n               S_F1    = 4'd1,\n               S0      = 4'd2,  // waiting for first '1'\n               S1      = 4'd3,  // saw '1', waiting for '0'\n               S2      = 4'd4,  // saw '1','0', waiting for final '1'\n               S_Y0    = 4'd5,  // g=1, check y on this cycle\n               S_Y1    = 4'd6,  // g=1, last chance to see y=1\n               S_GOOD  = 4'd7,  // g=1 permanently\n               S_BAD   = 4'd8;  // g=0 permanently\n\n    reg [3:0] state, next_state;\n\n    // State register with synchronous active-low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= S_A;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state;  // default hold\n        case (state)\n            S_A: begin\n                // after deassert of resetn, take one clock to go to S_F1\n                if (resetn)\n                    next_state = S_F1;\n            end\n            S_F1: begin\n                // f=1 one cycle, then begin watching x\n                next_state = S0;\n            end\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (!x)\n                    next_state = S2;\n                else\n                    // still saw '1', stay in S1\n                    next_state = S1;\n            end\n            S2: begin\n                if (x)\n                    next_state = S_Y0;\n                else\n                    // restart looking for first '1'\n                    next_state = S0;\n            end\n            S_Y0: begin\n                if (y)\n                    next_state = S_GOOD;\n                else\n                    next_state = S_Y1;\n            end\n            S_Y1: begin\n                if (y)\n                    next_state = S_GOOD;\n                else\n                    next_state = S_BAD;\n            end\n            S_GOOD: begin\n                // stay here until reset\n                next_state = S_GOOD;\n            end\n            S_BAD: begin\n                // stay here until reset\n                next_state = S_BAD;\n            end\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Outputs\n    assign f = (state == S_F1);\n    assign g = (state == S_Y0)\n             || (state == S_Y1)\n             || (state == S_GOOD);\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n    // even parity = XOR\u2010reduction of all 8 data bits\n    assign parity = ^in;\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;  // A -> (1->B, 0->A)\n            2'b01: next_state = in ? 2'b01 : 2'b10;  // B -> (1->B, 0->C)\n            2'b10: next_state = in ? 2'b11 : 2'b00;  // C -> (1->D, 0->A)\n            2'b11: next_state = in ? 2'b01 : 2'b10;  // D -> (1->B, 0->C)\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // output logic (Moore)\n    assign out = (state == 2'b11);  // only D produces 1\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z is high when x equals y (XNOR)\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output       z\n);\n\n    // state encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // state register (sequential)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // output logic (Moore)\n    assign z = (state == E) | (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        resetn,\n    input  [1:0] byteena,\n    input  [15:0] d,\n    output reg [15:0] q\n);\n\n    // On every rising clock edge, either reset or update bytes\n    always @(posedge clk) begin\n        if (!resetn) begin\n            // synchronous active\u2010low reset\n            q <= 16'b0;\n        end else begin\n            // byteena[1] enables bits [15:8], byteena[0] enables bits [7:0]\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n            if (byteena[0])\n                q[7:0]  <= d[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    reg [7:0] prev;\n\n    always @(posedge clk) begin\n        pedge <=  in & ~prev;  // detect 0\u21921 per bit, output next cycle\n        prev  <=  in;          // store current for next comparison\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": ""}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // next state of all 512 cells\n    wire [511:0] next_q;\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : rule90\n            wire left  = (i == 0)   ? 1'b0 : q[i-1];\n            wire right = (i == 511) ? 1'b0 : q[i+1];\n            assign next_q[i] = left ^ right;\n        end\n    endgenerate\n\n    // sequential update / load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output        z\n);\n\n    // z is high when both 2\u2010bit inputs are equal\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left neighbour are 1\n    assign out_both       = in[98:0] & in[99:1];\n\n    // (2) this bit or its right neighbour is 1\n    assign out_any[99:1]  = in[99:1]  | in[98:0];\n\n    // (3) this bit differs from its left neighbour (with wrap)\n    //    neighbour vector = { in[0], in[99:1] }\n    assign out_different  = in ^ {in[0], in[99:1]};\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic d,\n    input  logic ena,\n    output logic q\n);\n    // level\u2010sensitive D latch\n    always @(*) begin\n        if (ena)\n            q = d;\n        // else q retains its previous value (latch inferred)\n    end\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n\n    // Use the indexed part-select operator: start at sel*4, take 4 bits\n    assign out = in[sel*4 +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\nalways_comb begin\n    case (sel)\n        4'd0:  out = a;\n        4'd1:  out = b;\n        4'd2:  out = c;\n        4'd3:  out = d;\n        4'd4:  out = e;\n        4'd5:  out = f;\n        4'd6:  out = g;\n        4'd7:  out = h;\n        4'd8:  out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR of corresponding bits\n    assign out_or_bitwise = a | b;\n\n    // Logical OR of the two vectors (true if any bit of a or b is 1)\n    assign out_or_logical = |(a | b);\n\n    // Inverse of b in [5:3], inverse of a in [2:0]\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // One\u2010hot state bits\n    wire A = state[0];\n    wire B = state[1];\n    wire C = state[2];\n    wire D = state[3];\n\n    // Moore output = 1 in state D only\n    assign out = D;\n\n    // Next\u2010state logic\n    // A->A on in=0, A->B on in=1\n    // B->C on in=0, B->B on in=1\n    // C->A on in=0, C->D on in=1\n    // D->C on in=0, D->B on in=1\n    always @(*) begin\n        next_state[0] = (~in & (A | C));      // next_A\n        next_state[1] = ( in & (A | B | D));  // next_B\n        next_state[2] = (~in & (B | D));      // next_C\n        next_state[3] = ( in &  C     );      // next_D\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // Combinational logic to find the minimum of four unsigned 8\u2011bit numbers\n    always @(*) begin\n        min = a;\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // continuous assignments for each logic function\n    assign out_and   = a & b;     // AND\n    assign out_or    = a | b;     // OR\n    assign out_xor   = a ^ b;     // XOR\n    assign out_nand  = ~(a & b);  // NAND\n    assign out_nor   = ~(a | b);  // NOR\n    assign out_xnor  = ~(a ^ b);  // XNOR\n    assign out_anotb = a & ~b;    // A AND NOT B\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // active\u2010high synchronous\n    input        s,\n    input        w,\n    output reg   z\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg      state;\n    reg [1:0] cycle_cnt;  // 0,1,2\n    reg [1:0] ones_cnt;   // counts w==1 over the 3 samples (0\u20133)\n    reg       next_z;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // synchronous reset\n            state      <= A;\n            cycle_cnt  <= 2'd0;\n            ones_cnt   <= 2'd0;\n            next_z     <= 1'b0;\n            z          <= 1'b0;\n        end else begin\n            // shift the previously computed next_z into z\n            z <= next_z;\n\n            case (state)\n            A: begin\n                // stay in A until s==1\n                if (s)\n                    state <= B;\n                else\n                    state <= A;\n                // keep outputs/counters cleared until we enter B\n                cycle_cnt <= 2'd0;\n                ones_cnt  <= 2'd0;\n                next_z    <= 1'b0;\n            end\n\n            B: begin\n                // sample w each cycle\n                // ones_cnt_next = ones_cnt + w\n                // cycle_cnt runs 0,1,2, then rolls back to 0\n                if (cycle_cnt < 2) begin\n                    // first two samples\n                    ones_cnt  <= ones_cnt + w;\n                    cycle_cnt <= cycle_cnt + 1;\n                    next_z    <= 1'b0;     // no output until after 3rd sample\n                end else begin\n                    // cycle_cnt == 2: this is the third sample\n                    // we calculate next_z = (ones_cnt + w == 2)\n                    // then reset both counters for the next 3\u2010cycle window\n                    ones_cnt  <= 2'd0;\n                    cycle_cnt <= 2'd0;\n                    next_z    <= (ones_cnt + w == 2);\n                end\n\n                // remain in B forever\n                state <= B;\n            end\n\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concat with the 8\u2011bit input\n    assign out = {{24{in[7]}}, in};\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  in,\n    output out\n);\n\n    // 4\u2010bit shift register\n    reg [3:0] sr;\n\n    // Synchronous, active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            sr <= 4'b0000;\n        else\n            sr <= {sr[2:0], in};\n    end\n\n    assign out = sr[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        if      (in[3]) pos = 2'd3;\n        else if (in[2]) pos = 2'd2;\n        else if (in[1]) pos = 2'd1;\n        else if (in[0]) pos = 2'd0;\n        else             pos = 2'd0;\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        areset,  // active\u2010high async reset\n    output       out\n);\n\n    // state encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // next\u2010state logic (Moore machine)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // state register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // output logic (Moore: output depends only on state)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Continuously drive the output low\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n\n    // Continuously drive the output high\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @* begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // Compute D as XOR of asynchronous input 'in' and the current 'out'\n    logic d;\n    assign d = in ^ out;\n\n    // Positive\u2010edge\u2010triggered D flip\u2011flop (no reset)\n    always_ff @(posedge clk) begin\n        out <= d;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,  // asynchronous active\u2010high reset\n    input        load,    // synchronous active\u2010high load\n    input        ena,     // synchronous active\u2010high shift enable\n    input  [3:0] data,    // parallel load data\n    output reg [3:0] q     // shift register output\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;               // highest priority\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};     // shift right, MSB\u21900, LSB shifts out\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = 1 for minterms 2,3,5,7\n    // Simplified: f = (~x3 & x2) | (x1 & (x2 | x3))\n    assign f = (x2 & ~x3) | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // 8-bit D\u2010FFs with active\u2010high asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // 100\u2010input reductions\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // Sum is XOR of inputs, carry-out is AND of inputs\n    assign sum  = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input         cpu_overheated,\n    output reg    shut_off_computer,\n    input         arrived,\n    input         gas_tank_empty,\n    output reg    keep_driving\n);\n\n    // combinational logic \u2013 no inferred latches\n    always @(*) begin\n        // shut off computer whenever it\u2019s overheated\n        shut_off_computer = cpu_overheated;\n\n        // keep driving only if not arrived and tank not empty\n        if (!arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate inputs a\u2013f (5 bits each = 30 bits) and two 1's (LSB positions)\n    wire [31:0] all = { a, b, c, d, e, f, 2'b11 };\n\n    // Split the 32-bit vector into four 8-bit outputs\n    assign w = all[31:24];\n    assign x = all[23:16];\n    assign y = all[15: 8];\n    assign z = all[ 7: 0];\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n    // The waveform shows q=1 whenever the number of 1's on {a,b,c,d} is even.\n    // That's the even\u2010parity (XNOR) of all four bits:\n    assign q = ~(a ^ b ^ c ^ d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // AND gate implementation\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,  // active\u2010high synchronous\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic\n    always @(*) begin\n        if (in)\n            next_state = state;    // stay in current state on in=1\n        else\n            next_state = ~state;   // toggle state on in=0\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;            // reset to B\n        else\n            state <= next_state;\n    end\n\n    // Moore output\n    assign out = (state == B) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum is the XOR of all three inputs\n    assign sum  = a ^ b ^ cin;\n    // carry-out is 1 if any two or more inputs are 1\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // Intermediate signal for the XNOR result\n    logic xnor_out;\n\n    // XNOR of in1 and in2\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR of the XNOR result with in3\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n    //\n    // We must realize\n    //   mux_in[0] = f(ab=00) = c | d\n    //   mux_in[1] = f(ab=01) = 0\n    //   mux_in[2] = f(ab=11) = c & d\n    //   mux_in[3] = f(ab=10) = c | ~d\n    //\n    // and we are allowed only 2\u2010to\u20101 muxes (no gates).\n    // Using the Verilog ?: operator implements a 2\u21921 mux.\n    //\n\n    // ab=01 \u2192 constant 0\n    assign mux_in[1] = 1'b0;\n\n    // c|d  = d ? 1 : c\n    assign mux_in[0] = d ? 1'b1 : c;\n\n    // c&d  = d ? c : 0\n    assign mux_in[2] = d ? c      : 1'b0;\n\n    // c|~d = d ? c : 1\n    assign mux_in[3] = d ? c      : 1'b1;\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // async, active\u2010high\n    input  x,\n    output z\n);\n\n    // one\u2010hot state encoding\n    reg state_A, state_B;\n\n    // asynchronous reset, synchronous next\u2010state update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;\n            state_B <= 1'b0;\n        end else begin\n            // next\u2010state equations\n            state_A <= state_A & ~x;                // A->A on x=0; A->B on x=1\n            state_B <= state_B | (state_A & x);     // B->B always; A->B on x=1\n        end\n    end\n\n    // Mealy output: z=1 on A->B or B->B when x=0\n    assign z = (state_A & x) | (state_B & ~x);\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input  wire clk,\n    input  wire a,\n    input  wire b,\n    output wire q,\n    output reg  state\n);\n\n    // combinational output\n    assign q = a ^ b ^ state;\n\n    // 1\u2010bit state register\n    always @(posedge clk) begin\n        state <= q;\n    end\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,   // synchronous active\u2011high\n    input        in,\n    output       disc,\n    output       flag,\n    output       err\n);\n\n    // State encoding\n    localparam S0    = 4'd0;\n    localparam S1    = 4'd1;\n    localparam S2    = 4'd2;\n    localparam S3    = 4'd3;\n    localparam S4    = 4'd4;\n    localparam S5    = 4'd5;\n    localparam S6    = 4'd6;\n    localparam S7    = 4'd7;  // \u22657 ones, no pulse\n    localparam ST_DISC  = 4'd8; \n    localparam ST_FLAG  = 4'd9;\n    localparam ST_ERR   = 4'd10;\n\n    reg [3:0] state, next_state;\n\n    // Next\u2011state logic\n    always @(*) begin\n        case (state)\n            S0:     next_state = in ? S1     : S0;\n            S1:     next_state = in ? S2     : S0;\n            S2:     next_state = in ? S3     : S0;\n            S3:     next_state = in ? S4     : S0;\n            S4:     next_state = in ? S5     : S0;\n            S5:     next_state = in ? S6     : ST_DISC; // 5 ones + 0 \u2192 discard\n            S6:     next_state = in ? ST_ERR : ST_FLAG; // 6 ones +0 \u2192 flag; +1 \u2192 error\n            S7:     next_state = in ? S7     : S0;      // stay on 1s, reset on 0\n            ST_DISC:next_state = in ? S1     : S0;\n            ST_FLAG:next_state = in ? S1     : S0;\n            ST_ERR: next_state = in ? S7     : S0;\n            default:next_state = S0;\n        endcase\n    end\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Moore outputs (one\u2011cycle pulses)\n    assign disc = (state == ST_DISC);\n    assign flag = (state == ST_FLAG);\n    assign err  = (state == ST_ERR);\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire       clk,\n    input  wire       reset,   // active\u2010high synchronous\n    input  wire       data,\n    output wire [3:0] count,\n    output reg        counting,\n    output reg        done,\n    input  wire       ack\n);\n\n    // states\n    localparam IDLE  = 2'd0,\n               SHIFT = 2'd1,\n               COUNT = 2'd2,\n               DONE  = 2'd3;\n\n    reg [1:0]   state;\n    reg [3:0]   shift_reg;      // for detecting 1101\n    reg [2:0]   bit_count;      // 0..3 for SHIFT\n    reg [3:0]   delay_reg;      // shift buffer for the 4 new bits\n    reg [3:0]   segment_count;  // the down\u2010counter for [3:0]\n    reg [9:0]   cycle_count;    // 0..999\n\n    // drive count out\n    assign count = segment_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // sync reset all regs\n            state         <= IDLE;\n            shift_reg     <= 4'd0;\n            bit_count     <= 3'd0;\n            delay_reg     <= 4'd0;\n            segment_count <= 4'd0;\n            cycle_count   <= 10'd0;\n            counting      <= 1'b0;\n            done          <= 1'b0;\n        end else begin\n            // defaults each cycle\n            counting <= 1'b0;\n            done     <= 1'b0;\n            case (state)\n                //////////////////////////////////////////////////////////////////\n                // IDLE: keep shifting in 'data' into shift_reg until it's 1101\n                IDLE: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if ({shift_reg[2:0], data} == 4'b1101) begin\n                        state     <= SHIFT;\n                        bit_count <= 3'd0;\n                        delay_reg <= 4'd0;\n                    end\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // SHIFT: grab next 4 bits MSB first into delay_reg\n                SHIFT: begin\n                    bit_count <= bit_count + 1;\n                    delay_reg <= {delay_reg[2:0], data};\n                    if (bit_count == 3) begin\n                        // after 4th bit, latch the delay and go count\n                        segment_count <= {delay_reg[2:0], data};\n                        cycle_count   <= 10'd0;\n                        state         <= COUNT;\n                    end\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // COUNT: assert counting, run (segment_count+1)*1000 clk cycles,\n                //         decrement segment_count every 1000 cycles\n                COUNT: begin\n                    counting <= 1'b1;\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'd0;\n                        if (segment_count == 4'd0) begin\n                            // finished last 1000\u2010cycle block\n                            state <= DONE;\n                        end else begin\n                            segment_count <= segment_count - 1;\n                        end\n                    end else begin\n                        cycle_count <= cycle_count + 1;\n                    end\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // DONE: assert done, wait for ack to return to IDLE\n                DONE: begin\n                    done <= 1'b1;\n                    if (ack) begin\n                        // restart search\n                        state     <= IDLE;\n                        shift_reg <= 4'd0;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,   // synchronous, active\u2010high\n    input  [3:1] s,       // s[1]=lowest, s[3]=highest\n    output reg   fr3,\n    output reg   fr2,\n    output reg   fr1,\n    output reg   dfr      // supplemental valve\n);\n\n    // count how many sensors are asserted: only legal combinations are\n    //  000, 100, 110, 111\n    wire [1:0] curr_cnt = s[1] + s[2] + s[3];\n\n    // previous count to detect rising/falling\n    reg [1:0] prev_cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // reset into \"been low for a long time\" state:\n            // no sensors => fr1=fr2=fr3=1, dfr=1\n            fr1      <= 1;\n            fr2      <= 1;\n            fr3      <= 1;\n            dfr      <= 1;\n            prev_cnt <= 2'd0;\n        end else begin\n            // 1) update dfr according to direction of level change\n            if      (curr_cnt > prev_cnt) dfr <= 1;\n            else if (curr_cnt < prev_cnt) dfr <= 0;\n            // else keep old dfr\n\n            // 2) remember this count for next cycle\n            prev_cnt <= curr_cnt;\n\n            // 3) nominal flow valves\n            case (curr_cnt)\n                2'd3: begin fr1 <= 0; fr2 <= 0; fr3 <= 0; end  // above s3\n                2'd2: begin fr1 <= 1; fr2 <= 0; fr3 <= 0; end  // between s3 and s2\n                2'd1: begin fr1 <= 1; fr2 <= 1; fr3 <= 0; end  // between s2 and s1\n                2'd0: begin fr1 <= 1; fr2 <= 1; fr3 <= 1; end  // below s1 \n                default: begin fr1 <= 0; fr2 <= 0; fr3 <= 0; end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output done\n);\n\n    // State encoding\n    localparam IDLE      = 3'd0,\n               DATA      = 3'd1,\n               STOP      = 3'd2,\n               WAIT_STOP = 3'd3;\n\n    reg [2:0]  state, next_state;\n    reg [2:0]  bit_cnt;       // counts 0..7 data bits\n    reg        done_reg;\n\n    assign done = done_reg;\n\n    // State register + bit counter\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= IDLE;\n            bit_cnt <= 3'd0;\n        end else begin\n            state <= next_state;\n            // increment or clear data-bit counter in DATA state\n            if (state == DATA)\n                bit_cnt <= bit_cnt + 3'd1;\n            else\n                bit_cnt <= 3'd0;\n        end\n    end\n\n    // Next-state and done logic\n    always @(*) begin\n        // defaults\n        next_state = state;\n        done_reg   = 1'b0;\n\n        case (state)\n            IDLE: begin\n                // wait for start bit (0)\n                if (in == 1'b0)\n                    next_state = DATA;\n            end\n\n            DATA: begin\n                // after capturing 8 data bits, go check stop bit\n                if (bit_cnt == 3'd7)\n                    next_state = STOP;\n            end\n\n            STOP: begin\n                if (in == 1'b1) begin\n                    // good stop bit: byte done\n                    done_reg   = 1'b1;\n                    next_state = IDLE;\n                end else begin\n                    // bad stop bit: wait here for line to return high\n                    next_state = WAIT_STOP;\n                end\n            end\n\n            WAIT_STOP: begin\n                // stay until we see a 1, then go idle\n                if (in == 1'b1)\n                    next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output [7:0] out_byte,\n    output       done\n);\n\n    // State encoding\n    localparam IDLE  = 2'd0,\n               START = 2'd1,\n               DATA  = 2'd2,\n               STOP  = 2'd3;\n\n    reg [1:0]  state, next_state;\n    reg [2:0]  bitcnt;\n    reg [7:0]  shift_reg;\n    reg        done_reg;\n\n    // State register, bit counter, shift register, done\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bitcnt    <= 3'd0;\n            shift_reg <= 8'd0;\n            done_reg  <= 1'b0;\n        end else begin\n            state    <= next_state;\n            done_reg <= 1'b0;        // default\n\n            case (state)\n                START: begin\n                    bitcnt <= 3'd0;     // prepare for first data bit\n                end\n                DATA: begin\n                    shift_reg[bitcnt] <= in;\n                    bitcnt            <= bitcnt + 1;\n                end\n                STOP: begin\n                    if (in)            // correct stop bit?\n                        done_reg <= 1'b1;\n                end\n                default: ;\n            endcase\n        end\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE:  if (in == 1'b0)     next_state = START;\n            START:                      next_state = DATA;\n            DATA:  if (bitcnt == 3'd7) next_state = STOP;\n            STOP:  if (in == 1'b1)     next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Outputs\n    assign out_byte = shift_reg;\n    assign done     = done_reg;\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input             clk,\n    input             areset, \n\n    // prediction interface\n    input             predict_valid,\n    input      [6:0]  predict_pc,\n    output            predict_taken, \n    output reg [6:0]  predict_history,\n\n    // training interface\n    input             train_valid,\n    input             train_taken,\n    input             train_mispredicted,\n    input      [6:0]  train_history, \n    input      [6:0]  train_pc\n);\n\n    // 2-bit saturating PHT, 128 entries\n    reg [1:0] pht [0:127];\n    // global history register\n    reg [6:0] branch_history;\n\n    // indices\n    wire [6:0] predict_idx = predict_pc ^ branch_history;\n    wire [6:0] train_idx   = train_pc   ^ train_history;\n\n    // read PHT for prediction (combinational)\n    wire [1:0] predict_state = pht[predict_idx];\n    assign predict_taken    = predict_state[1];\n\n    // latch out the history used for this prediction\n    always @(*) begin\n        predict_history = branch_history;\n    end\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // init history\n            branch_history <= 7'b0;\n            // initialize PHT to weakly not-taken (2'b01)\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b01;\n        end else begin\n            // 1) train the PHT if requested\n            if (train_valid) begin\n                if (train_taken) begin\n                    // increment up to 3\n                    if (pht[train_idx] != 2'b11)\n                        pht[train_idx] <= pht[train_idx] + 1;\n                end else begin\n                    // decrement down to 0\n                    if (pht[train_idx] != 2'b00)\n                        pht[train_idx] <= pht[train_idx] - 1;\n                end\n            end\n\n            // 2) update or recover global history\n            if (train_valid && train_mispredicted) begin\n                // misprediction: recover history to just\u2010after this branch\n                branch_history <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // normal prediction update (only if no mispredict recovery)\n                branch_history <= { branch_history[5:0], predict_state[1] };\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        bump_left,\n    input        bump_right,\n    input        ground,\n    input        dig,\n    output       walk_left,\n    output       walk_right,\n    output       aaah,\n    output       digging\n);\n\n    // state encoding\n    localparam WL = 3'd0,\n               WR = 3'd1,\n               FL = 3'd2,\n               FR = 3'd3,\n               DL = 3'd4,\n               DR = 3'd5,\n               SP = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_count, next_fall_count;\n\n    // state register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state       <= WL;\n            fall_count  <= 6'd0;\n        end else begin\n            state       <= next_state;\n            fall_count  <= next_fall_count;\n        end\n    end\n\n    // next\u2010state / next\u2010count logic\n    always @(*) begin\n        next_state      = state;\n        next_fall_count = fall_count;\n\n        case(state)\n        // WALK LEFT\n        WL: begin\n            if (!ground) begin\n                next_state      = FL;\n                next_fall_count = 6'd1;\n            end else if (dig) begin\n                next_state = DL;\n            end else if (bump_left || bump_right) begin\n                next_state = WR;\n            end\n        end\n\n        // WALK RIGHT\n        WR: begin\n            if (!ground) begin\n                next_state      = FR;\n                next_fall_count = 6'd1;\n            end else if (dig) begin\n                next_state = DR;\n            end else if (bump_left || bump_right) begin\n                next_state = WL;\n            end\n        end\n\n        // DIG LEFT\n        DL: begin\n            if (!ground) begin\n                next_state      = FL;\n                next_fall_count = 6'd1;\n            end\n        end\n\n        // DIG RIGHT\n        DR: begin\n            if (!ground) begin\n                next_state      = FR;\n                next_fall_count = 6'd1;\n            end\n        end\n\n        // FALL LEFT\n        FL: begin\n            if (!ground) begin\n                next_state      = FL;\n                next_fall_count = fall_count + 1;\n            end else begin\n                if (fall_count > 6'd20)\n                    next_state = SP;\n                else\n                    next_state = WL;\n                next_fall_count = 6'd0;\n            end\n        end\n\n        // FALL RIGHT\n        FR: begin\n            if (!ground) begin\n                next_state      = FR;\n                next_fall_count = fall_count + 1;\n            end else begin\n                if (fall_count > 6'd20)\n                    next_state = SP;\n                else\n                    next_state = WR;\n                next_fall_count = 6'd0;\n            end\n        end\n\n        // SPLATTERED\n        SP: begin\n            next_state      = SP;\n            next_fall_count = fall_count; // doesn't matter\n        end\n\n        endcase\n    end\n\n    // outputs (Moore)\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n    assign digging    = (state == DL) || (state == DR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State encoding\n    localparam S_IDLE   = 3'd0;\n    localparam S_1      = 3'd1;\n    localparam S_11     = 3'd2;\n    localparam S_110    = 3'd3;\n    localparam S_SHIFT  = 3'd4;\n    localparam S_COUNT  = 3'd5;\n    localparam S_DONE   = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [1:0] shift_cnt;\n\n    // State register, shift counter, and outputs\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= S_IDLE;\n            shift_cnt  <= 2'd0;\n            shift_ena  <= 1'b0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            // advance state\n            state <= next_state;\n\n            // manage shift counter when entering and in S_SHIFT\n            if (state == S_110 && data) begin\n                // entering shift state: load 4-cycle counter = 3 down to 0\n                shift_cnt <= 2'd3;\n            end else if (state == S_SHIFT) begin\n                shift_cnt <= shift_cnt - 1'b1;\n            end\n\n            // outputs follow the new (next) state\n            shift_ena <= (next_state == S_SHIFT);\n            counting  <= (next_state == S_COUNT);\n            done      <= (next_state == S_DONE);\n        end\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        next_state = S_IDLE;\n        case (state)\n            // Look for 1101\n            S_IDLE:  next_state = data ? S_1   : S_IDLE;\n            S_1:     next_state = data ? S_11  : S_IDLE;\n            S_11:    next_state = data ? S_11  : S_110;\n            S_110:   next_state = data ? S_SHIFT : S_IDLE;\n\n            // Shift in 4 bits\n            S_SHIFT: next_state = (shift_cnt == 2'd0) ? S_COUNT : S_SHIFT;\n\n            // Wait for data\u2011path to finish counting\n            S_COUNT: next_state = done_counting ? S_DONE : S_COUNT;\n\n            // Notify user, wait for ack\n            S_DONE:  next_state = ack ? S_IDLE : S_DONE;\n\n            default: next_state = S_IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [255:0] data,\n    output reg [255:0] q\n);\n\n    // combinational next state\n    reg [255:0] next_q;\n    integer     i, j, dx, dy;\n    \n    // get a cell with wrap\u2010around\n    function cell;\n        input [3:0] x, y;\n        begin\n            cell = q[{y, x}];\n        end\n    endfunction\n\n    // count live neighbours of (x,y)\n    function [3:0] count_n;\n        input [3:0] x, y;\n        reg   [3:0] c;\n        integer     dx, dy;\n        begin\n            c = 0;\n            for (dx = -1; dx <= 1; dx = dx + 1) begin\n                for (dy = -1; dy <= 1; dy = dy + 1) begin\n                    if (!(dx==0 && dy==0)) begin\n                        c = c + cell( (x + dx + 16) & 4'hF,\n                                      (y + dy + 16) & 4'hF );\n                    end\n                end\n            end\n            count_n = c;\n        end\n    endfunction\n\n    // build next_q combinationally\n    always @(*) begin\n        for (j = 0; j < 16; j = j + 1) begin\n            for (i = 0; i < 16; i = i + 1) begin\n                case (count_n(i[3:0], j[3:0]))\n                    2: next_q[j*16 + i] = q[j*16 + i];\n                    3: next_q[j*16 + i] = 1'b1;\n                    default: next_q[j*16 + i] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    // sequential update / load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n// State encoding\nlocalparam [2:0]\n    WALK_L = 3'd0,\n    WALK_R = 3'd1,\n    FALL_L = 3'd2,\n    FALL_R = 3'd3,\n    DIG_L  = 3'd4,\n    DIG_R  = 3'd5;\n\nreg [2:0] state, next_state;\n\n// state register with asynchronous reset\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= WALK_L;\n    else\n        state <= next_state;\nend\n\n// next state logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        // walking left\n        WALK_L: begin\n            if (!ground)\n                next_state = FALL_L;            // fall has top priority\n            else if (dig)\n                next_state = DIG_L;             // then dig\n            else if (bump_left || bump_right)\n                next_state = WALK_R;            // then bump \u2192 reverse\n            else\n                next_state = WALK_L;\n        end\n        // walking right\n        WALK_R: begin\n            if (!ground)\n                next_state = FALL_R;\n            else if (dig)\n                next_state = DIG_R;\n            else if (bump_left || bump_right)\n                next_state = WALK_L;\n            else\n                next_state = WALK_R;\n        end\n        // falling left\n        FALL_L: begin\n            if (ground)\n                next_state = WALK_L;            // land, resume walk\n            else\n                next_state = FALL_L;\n        end\n        // falling right\n        FALL_R: begin\n            if (ground)\n                next_state = WALK_R;\n            else\n                next_state = FALL_R;\n        end\n        // digging left\n        DIG_L: begin\n            if (!ground)\n                next_state = FALL_L;            // hole ends \u2192 fall\n            else\n                next_state = DIG_L;             // keep digging\n        end\n        // digging right\n        DIG_R: begin\n            if (!ground)\n                next_state = FALL_R;\n            else\n                next_state = DIG_R;\n        end\n        default: next_state = WALK_L;\n    endcase\nend\n\n// Moore outputs\nassign walk_left  = (state == WALK_L);\nassign walk_right = (state == WALK_R);\nassign aaah       = (state == FALL_L) || (state == FALL_R);\nassign digging    = (state == DIG_L)  || (state == DIG_R);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    input        ena,\n    output reg   pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // reset to 12:00:00 AM\n        ss <= 8'h00;\n        mm <= 8'h00;\n        hh <= 8'h12;\n        pm <= 1'b0;\n    end else if (ena) begin\n        // increment seconds\n        if (ss != 8'h59) begin\n            if (ss[3:0] != 4'd9)\n                ss[3:0] <= ss[3:0] + 1;\n            else begin\n                ss[3:0] <= 4'd0;\n                ss[7:4] <= ss[7:4] + 1;\n            end\n        end else begin\n            // wrap seconds -> increment minutes\n            ss <= 8'h00;\n            if (mm != 8'h59) begin\n                if (mm[3:0] != 4'd9)\n                    mm[3:0] <= mm[3:0] + 1;\n                else begin\n                    mm[3:0] <= 4'd0;\n                    mm[7:4] <= mm[7:4] + 1;\n                end\n            end else begin\n                // wrap minutes -> increment hours\n                mm <= 8'h00;\n                // special 12-hour logic\n                if (hh == 8'h11) begin\n                    // 11 -> 12, toggle AM/PM\n                    hh <= 8'h12;\n                    pm <= ~pm;\n                end else if (hh == 8'h12) begin\n                    // 12 -> 1, no toggle\n                    hh <= 8'h01;\n                end else begin\n                    // BCD increment hours 1..9 -> 10..11\n                    if (hh[3:0] != 4'd9)\n                        hh[3:0] <= hh[3:0] + 1;\n                    else begin\n                        hh[3:0] <= 4'd0;\n                        hh[7:4] <= hh[7:4] + 1;\n                    end\n                end\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n//\n// State encoding\nlocalparam SL   = 2'd0,  // walking left\n           SR   = 2'd1,  // walking right\n           SFL  = 2'd2,  // falling, was going left\n           SFR  = 2'd3;  // falling, was going right\n\nreg [1:0] state, next_state;\n\n// State register\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= SL;\n    else\n        state <= next_state;\nend\n\n// Next\u2010state logic (Moore)\nalways @(*) begin\n    case (state)\n        SL: begin\n            if (!ground)\n                next_state = SFL;\n            else if (bump_left || bump_right)\n                next_state = SR;\n            else\n                next_state = SL;\n        end\n        SR: begin\n            if (!ground)\n                next_state = SFR;\n            else if (bump_left || bump_right)\n                next_state = SL;\n            else\n                next_state = SR;\n        end\n        SFL: begin\n            if (ground)\n                next_state = SL;\n            else\n                next_state = SFL;\n        end\n        SFR: begin\n            if (ground)\n                next_state = SR;\n            else\n                next_state = SFR;\n        end\n        default: next_state = SL;\n    endcase\nend\n\n// Outputs (Moore)\nassign walk_left  = (state == SL);\nassign walk_right = (state == SR);\nassign aaah       = (state == SFL) || (state == SFR);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               reset,\n    output reg [3:1]    ena,\n    output reg [15:0]   q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q   <= 16'd0;\n        ena <= 3'b000;\n    end else begin\n        // Digit 0 (ones)\n        if (q[3:0] == 4'd9) begin\n            q[3:0]  <= 4'd0;\n            ena[1]  <= 1'b1;\n        end else begin\n            q[3:0]  <= q[3:0] + 1;\n            ena[1]  <= 1'b0;\n        end\n\n        // Digit 1 (tens)\n        if (ena[1]) begin\n            if (q[7:4] == 4'd9) begin\n                q[7:4]  <= 4'd0;\n                ena[2]  <= 1'b1;\n            end else begin\n                q[7:4]  <= q[7:4] + 1;\n                ena[2]  <= 1'b0;\n            end\n        end else\n            ena[2] <= 1'b0;\n\n        // Digit 2 (hundreds)\n        if (ena[2]) begin\n            if (q[11:8] == 4'd9) begin\n                q[11:8] <= 4'd0;\n                ena[3]  <= 1'b1;\n            end else begin\n                q[11:8] <= q[11:8] + 1;\n                ena[3]  <= 1'b0;\n            end\n        end else\n            ena[3] <= 1'b0;\n\n        // Digit 3 (thousands)\n        if (ena[3]) begin\n            if (q[15:12] == 4'd9)\n                q[15:12] <= 4'd0;\n            else\n                q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input        sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: if sel==0, out=a; if sel==1, out=b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,    // present state: y3 y2 y1\n    input        w,    // input\n    output reg   Y2    // next state bit y2\n);\n\n    // next\u2010state logic for y2\n    always @(*) begin\n        // {y3,y2,y1,w}\n        case ({y,w})\n            // A = 000\n            4'b0000, 4'b0001:  Y2 = 1'b0;\n            // B = 001\n            4'b0010, 4'b0011:  Y2 = 1'b1;\n            // C = 010\n            4'b0100:          Y2 = 1'b0;\n            4'b0101:          Y2 = 1'b1;\n            // D = 011\n            4'b0110, 4'b0111:  Y2 = 1'b0;\n            // E = 100\n            4'b1000:          Y2 = 1'b0;\n            4'b1001:          Y2 = 1'b1;\n            // F = 101\n            4'b1010, 4'b1011:  Y2 = 1'b1;\n            default:          Y2 = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ringing and not in vibrate mode, turn on ringer.\n    // If ringing and in vibrate mode, turn on motor.\n    // Otherwise both are off.\n    assign ringer = ring & ~vibrate_mode;\n    assign motor  = ring &  vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Continuous\u2010assignment AND gate\n    assign out_assign = a & b;\n\n    // Combinational always block AND gate\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Tie the output to a constant 0\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a, \n    output reg   q\n);\n    reg a_prev;\n\n    // optional init so that the very first comparison is against \u20180\u2019\n    initial begin\n        a_prev = 0;\n        q      = 0;\n    end\n\n    always @(posedge clk) begin\n        // two 0\u2019s in a row \u21d2 q\u00a0<=\u00a01\n        if (~a & ~a_prev)\n            q <= 1'b1;\n        // two 1\u2019s in a row \u21d2 q\u00a0<=\u00a00\n        else if (a & a_prev)\n            q <= 1'b0;\n        // otherwise hold q\n\n        // remember this cycle\u2019s a for next time\n        a_prev <= a;\n    end\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": ""}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output       out\n);\n\n    // State encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;  // A -> B on 1, stay on 0\n            B: next_state = in ? B : C;  // B -> B on 1, -> C on 0\n            C: next_state = in ? D : A;  // C -> D on 1, -> A on 0\n            D: next_state = in ? B : C;  // D -> B on 1, -> C on 0\n            default: next_state = A;\n        endcase\n    end\n\n    // State register with asynchronous, active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Moore output\n    assign out = (state == D) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse the order of the four bytes in the 32\u2011bit vector\n    assign out = { in[7:0],\n                   in[15:8],\n                   in[23:16],\n                   in[31:24] };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        d,\n    input        r,    // synchronous, active\u2010high reset\n    output logic q\n);\n\n    // D flip-flop with active\u2010high synchronous reset\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input               ena,\n    input       [1:0]   amount,\n    input       [63:0]  data,\n    output reg  [63:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case(amount)\n                2'b00:    q <= q << 1;                             // shift left by 1\n                2'b01:    q <= q << 8;                             // shift left by 8\n                2'b10:    q <= { q[63],        q[63:1]      };    // arithmetic right by 1\n                2'b11:    q <= {{8{q[63]}},   q[63:8]       };    // arithmetic right by 8\n                default:  q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn, // active\u2010low async reset\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    localparam IDLE = 2'd0,\n               S1   = 2'd1,\n               S10  = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // state register with asynchronous negative\u2010edge reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic and Mealy output\n    always @(*) begin\n        next_state = IDLE;\n        z = 1'b0;\n        case (state)\n            IDLE: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = IDLE;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;   // stay on repeated '1'\n                else\n                    next_state = S10;  // got \"10\"\n            end\n            S10: begin\n                if (x) begin\n                    z = 1'b1;          // detected \"101\"\n                    next_state = S1;   // overlap: last '1' \u2192 S1\n                end else begin\n                    next_state = IDLE; // got \"100\"\n                end\n            end\n            default: begin\n                next_state = IDLE;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output       z\n);\n\n    // State encoding\n    localparam [2:0]\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @* begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": ""}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,   // one\u2010hot state: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1,  // next\u2010state input for y[1] (B)\n    output       Y3   // next\u2010state input for y[3] (D)\n);\n\n    // Only A --1--> B\n    assign Y1 = y[0] & w;\n\n    // B,C,E,F --0--> D\n    assign Y3 = ~w & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec,\n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the 3\u2010bit vector\n    assign outv = vec;\n    // Split into individual bits\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n    // The minterms with output = 1 are exactly those having an odd number of 1\u2019s.\n    // Hence the simplified function is a \u2295 b \u2295 c \u2295 d.\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Lower byte = bits [7:0]\n    assign out_lo = in[7:0];\n    // Upper byte = bits [15:8]\n    assign out_hi = in[15:8];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // NOR gate implementation\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a,\n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) XOR via assign\n    assign out_assign = a ^ b;\n\n    // 2) XOR via combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) XOR via clocked always block (registered, one\u2010cycle delayed)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one\u2011hot state: y[1]=A, y[2]=B, y[3]=C, y[4]=D, y[5]=E, y[6]=F\n    input        w,\n    output       Y2, // next\u2010state bit for B\n    output       Y4  // next\u2010state bit for D\n);\n\n    // Transitions into B: A --0--> B\n    // Y2 = 1 if current=A (y[1]) and w=0\n    assign Y2 = ~w & y[1];\n\n    // Transitions into D: B--1-->D, C--1-->D, E--1-->D, F--1-->D\n    // Y4 = 1 if w=1 and one of {y[2],y[3],y[5],y[6]} is active\n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input   [7:0] sel,\n    output        out\n);\n\n    // Simple indexed\u2010bit multiplexer\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // On each rising edge of the clock:\n    // 1) If load (L) is asserted, load R.\n    // 2) Else if enable (E) is asserted, shift in w.\n    // 3) Otherwise, hold the current Q.\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;\n        else if (E)\n            Q <= w;\n        else\n            Q <= Q;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n    // state bits\n    reg q0, q1, q2;\n\n    // next\u2010state logic\n    wire d0 = x ^  q0;    // XOR with Q\n    wire d1 = x & ~q1;    // AND with not Q\n    wire d2 = x | ~q2;    //  OR with not Q\n\n    // output logic: 3\u2010input XNOR = ~(q0 ^ q1 ^ q2)\n    assign z = ~(q0 ^ q1 ^ q2);\n\n    // state update\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\n    // initial reset to zero\n    initial {q0, q1, q2} = 3'b000;\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n    // From the waveform, q is 0 only when b=0 and c=0 (all other combinations give q=1)\n    // Hence q = b OR c\n    assign q = b | c;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // combinatorial next\u2010state\n    reg [511:0] next_q;\n    integer     i;\n    always @* begin\n        for (i = 0; i < 512; i = i + 1) begin\n            // pick neighbors, with zeros at the boundaries\n            // l = q[i-1] if i>0 else 0\n            // c = q[i]\n            // r = q[i+1] if i<511 else 0\n            if (i == 0) begin\n                // left = 0, center = q[0], right = q[1]\n                // next = (r & ~(l&c)) | (c & ~r)  \u2192 ( q[1] & ~0 ) | (q[0] & ~q[1])\n                next_q[0] =  q[1] | (q[0] & ~q[1]);\n            end\n            else if (i == 511) begin\n                // left = q[510], center = q[511], right = 0\n                // next = (0 & ~(...)) | (q[511] & ~0) \u2192 q[511]\n                next_q[511] = q[511];\n            end\n            else begin\n                // general cell\n                next_q[i] = ( q[i+1] & ~(q[i-1] & q[i]) )\n                          | ( q[i]   & ~ q[i+1]         );\n            end\n        end\n    end\n\n    // sequential update / load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n    // State encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    // Based on the waveform:\n    // c == 0 \u2192 q = b\n    // c == 1 \u2192 q = e\n    // c == 2 \u2192 q = a\n    // c == 3 \u2192 q = d\n    // otherwise \u2192 q = 4'hF\n\n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    // Combinational 2-to-1 mux\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "//-------------------------------------------------------\n// A 2\u2010to\u20101 mux driving a D\u2010FF.  On clk\u2191 Q <= (L ? r_in : q_in)\n//-------------------------------------------------------\nmodule top_module(\n    input        clk,\n    input        L,\n    input        q_in,\n    input        r_in,\n    output reg   Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\n\n//-------------------------------------------------------\n// full_module: 3\u2010bit shift/load with feedback logic\n//-------------------------------------------------------\nmodule full_module(\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    // internal wires for each bit\n    wire q0, q1, q2;\n    // define the feedback for each bit\n    wire q0_in = q2;        // new q[0] = old q[2]\n    wire q1_in = q0;        // new q[1] = old q[0]\n    wire q2_in = q1 ^ q2;   // new q[2] = old q[1] ^ old q[2]\n\n    // instantiate three flip\u2010flop+mux cells\n    top_module u0 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q0_in),\n        .r_in (r[0]),\n        .Q    (q0)\n    );\n\n    top_module u1 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q1_in),\n        .r_in (r[1]),\n        .Q    (q1)\n    );\n\n    top_module u2 (\n        .clk  (clk),\n        .L    (L),\n        .q_in (q2_in),\n        .r_in (r[2]),\n        .Q    (q2)\n    );\n\n    // pack results\n    assign q = {q2, q1, q0};\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,  // synchronous, active\u2011high\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // register to hold previous cycle\u2019s input\n    reg [31:0] in_prev;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out      <= 32'b0;\n            in_prev  <= 32'b0;\n        end else begin\n            // detect falling edge per bit: was 1, now 0\n            out      <= out | (in_prev & ~in);\n            in_prev  <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, capture d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output       overflow\n);\n\n    // sign\u2010extend to 9 bits, do the add, then detect overflow\n    wire [8:0] sum9;\n    assign sum9     = {a[7], a} + {b[7], b};\n    assign s        = sum9[7:0];\n    // overflow in 2's\u2011complement is carry\u2011into MSB ^ carry\u2011out of MSB\n    assign overflow = sum9[8] ^ sum9[7];\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,    // one\u2010hot: [0]=S, [1]=S1, [2]=S11, [3]=S110, [4]=B0, [5]=B1, [6]=B2, [7]=B3, [8]=Count, [9]=Wait\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n    // next\u2010state logic\n    // S_next: from S, S1, S110 on d=0, or from Wait on ack\n    assign S_next    = (~d & (state[0] | state[1] | state[3])) \n                       | ( state[9] &  ack );\n    // S1_next: from S on d=1\n    assign S1_next   = state[0] & d;\n    // B3_next: from B2 (always)\n    assign B3_next   = state[6];\n    // Count_next: from B3 (always) or stay in Count until done_counting\n    assign Count_next= state[7]\n                       | ( state[8] & ~done_counting );\n    // Wait_next: from Count when done_counting, or stay in Wait until ack\n    assign Wait_next = ( state[8] & done_counting )\n                       | ( state[9] & ~ack );\n\n    // Moore outputs\n    // shift_ena = 1 in B0, B1, B2, B3\n    assign shift_ena = state[4] | state[5] | state[6] | state[7];\n    // counting = 1 in Count\n    assign counting  = state[8];\n    // done = 1 in Wait\n    assign done      = state[9];\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,\n    input        train_valid,\n    input        train_taken,\n    output logic [1:0] state\n);\n\n    // Asynchronous active\u2010high reset; on reset state \u2264 2'b01\n    // On each rising clock edge, if train_valid:\n    //   \u2013 train_taken==1 \u21d2 increment up to 2'b11\n    //   \u2013 train_taken==0 \u21d2 decrement down to 2'b00\n    // Otherwise hold state.\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken) begin\n                // saturate at maximum 3\n                if (state != 2'b11)\n                    state <= state + 1;\n                else\n                    state <= state;\n            end else begin\n                // saturate at minimum 0\n                if (state != 2'b00)\n                    state <= state - 1;\n                else\n                    state <= state;\n            end\n        end\n        // else: train_valid==0 \u2192 retain state\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n    \n    always @* begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input      [15:0] scancode,\n    output reg        left,\n    output reg        down,\n    output reg        right,\n    output reg        up\n);\n\n    // Combinational decode of the last two PS/2 scancode bytes\n    always @(*) begin\n        // Default all outputs to 0\n        left  = 0;\n        down  = 0;\n        right = 0;\n        up    = 0;\n\n        // Decode the 16\u2011bit scancode\n        case (scancode)\n            16'he06b: left  = 1; // Left arrow\n            16'he072: down  = 1; // Down arrow\n            16'he074: right = 1; // Right arrow\n            16'he075: up    = 1; // Up arrow\n            default:         ;   // None of the above\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module full_adder (\n    input  wire a,\n    input  wire b,\n    input  wire cin,\n    output wire sum,\n    output wire cout\n);\n    // sum = a \u2295 b \u2295 cin\n    assign sum  = a ^ b ^ cin;\n    // cout = majority(a,b,cin)\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    wire c0, c1, c2, c3, c4;\n\n    assign c0 = 1'b0;     // initial carry\u2010in\n\n    // instantiate four full adders\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (c0),\n        .sum (sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c1),\n        .sum (sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c2),\n        .sum (sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c3),\n        .sum (sum[3]),\n        .cout(c4)\n    );\n\n    // overflow bit / final carry\n    assign sum[4] = c4;\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n    \n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // internal history register\n    logic [31:0] history;\n\n    // expose the history\n    assign predict_history = history;\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // rollback to pre\u2010branch history and append actual result\n            history <= { train_history[30:0], train_taken };\n        end\n        else if (predict_valid) begin\n            // shift in the predicted direction at LSB\n            history <= { history[30:0], predict_taken };\n        end\n        // else retain current history\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // intermediate wires for the outputs of the two AND gates\n    wire ab_and;\n    wire cd_and;\n\n    // first layer: two AND gates\n    and and_ab(ab_and, a, b);\n    and and_cd(cd_and, c, d);\n\n    // second layer: OR gate\n    or  or_out(out, ab_and, cd_and);\n\n    // inverted output\n    not not_out_n(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // On every rising edge of the clock, capture 'd' into 'q'\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  enable,\n    input  S,\n    input  A,\n    input  B,\n    input  C,\n    output reg Z\n);\n\n    // 8\u2010bit shift\u2010in memory\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            // shift left: new Q[0]=S, Q[1]=old Q[0], \u2026, Q[7]=old Q[6]\n            Q <= { Q[6:0], S };\n        end\n    end\n\n    // random\u2010access read via 3\u2010to\u20101 mux tree\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater on in heating mode when too cold\n    assign heater = mode & too_cold;\n    // Air conditioner on in cooling mode when too hot\n    assign aircon = ~mode & too_hot;\n    // Fan on if requested or if heater/aircon is on\n    assign fan    = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous reset\n    output reg [31:0] q\n);\n\n    // Galois\u2010LFSR polynomial x^32 + x^22 + x^2 + x + 1\n    // mask = (poly >> 1) = 32'h8020_0003\n    localparam [31:0] MASK = 32'h8020_0003;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h0000_0001;\n        end else begin\n            // shift right by one; if LSB==1, inject mask\n            if (q[0])\n                q <= (q >> 1) ^ MASK;\n            else\n                q <=  q >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n    assign q = (a | b) & (c | d);\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d, \n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // Two 4\u2011input NAND gates, replicating the 7420\n    nand g1 (p1y, p1a, p1b, p1c, p1d);\n    nand g2 (p2y, p2a, p2b, p2c, p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,       // compare with left neighbour (higher index)\n    output [3:1] out_any,        // compare with right neighbour (lower index)\n    output [3:0] out_different   // wrap\u2010around compare with left neighbour\n);\n\n    // (1) both this bit and its left neighbour are 1\n    //    out_both[0] = in[0]&in[1],\n    //    out_both[1] = in[1]&in[2],\n    //    out_both[2] = in[2]&in[3]\n    assign out_both = in[2:0] & in[3:1];\n\n    // (2) any of this bit or its right neighbour is 1\n    //    out_any[1] = in[1]|in[0],\n    //    out_any[2] = in[2]|in[1],\n    //    out_any[3] = in[3]|in[2]\n    assign out_any  = in[3:1] | in[2:0];\n\n    // (3) this bit differs from its left neighbour, with wrap\n    //    out_different[i] = in[i] ^ in[(i+1)%4]\n    //    bit[3] uses in[0] as left neighbour\n    assign out_different[2:0] = in[2:0] ^ in[3:1];\n    assign out_different[3]   = in[3]   ^ in[0];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0] a, \n    output reg [15:0] q\n);\n    // Combinational lookup table inferred from the waveform\n    always @* begin\n        case(a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd0;\n    end else if (slowena) begin\n        if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;\n    end\n    // else: hold q\nend\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // in2 has a bubble going into the AND gate, so we invert in2\n    // before ANDing with in1.\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinational assignment: out follows in\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic (Moore)\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // output logic (Moore: output depends only on state)\n    assign out = state;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // Internal registers that sample D on each clock edge\n    reg q_pos, q_neg;\n\n    // Sample D on the rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Sample D on the falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Mux between the two samples based on the current clock level\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out\n);\n\n    // XNOR: output is 1 when a and b are equal\n    assign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    // from waveform: z=1 when x==y, else 0 \u21d2 XNOR\n    assign z = ~(x ^ y);\nendmodule\n\nmodule top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1, b1, a2, b2;\n    wire or_out, and_out;\n\n    A  uA1(.x(x), .y(y), .z(a1));\n    B  uB1(.x(x), .y(y), .z(b1));\n    A  uA2(.x(x), .y(y), .z(a2));\n    B  uB2(.x(x), .y(y), .z(b2));\n\n    assign or_out  = a1 | b1;\n    assign and_out = a2 & b2;\n    assign z       = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input       [1:0]   ena,\n    input       [99:0]  data,\n    output reg  [99:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // synchronous load has highest priority\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: // rotate right by 1\n                    q <= { q[0], q[99:1] };\n                2'b10: // rotate left by 1\n                    q <= { q[98:0], q[99] };\n                default: // 2'b00 or 2'b11: hold\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [9:0] q\n);\n\n    // Counts 0\u2026999 and then rolls over, synchronous active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 10'd1;\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Simple NOT gate implementation\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,       // one\u2010hot: state[0]=S0 \u2026 state[9]=S9\n    output [9:0] next_state,  // next state, one\u2010hot\n    output       out1,\n    output       out2\n);\n\n    // decode current one\u2010hot state\n    wire s0 = state[0],\n         s1 = state[1],\n         s2 = state[2],\n         s3 = state[3],\n         s4 = state[4],\n         s5 = state[5],\n         s6 = state[6],\n         s7 = state[7],\n         s8 = state[8],\n         s9 = state[9];\n\n    // next\u2010state logic\n    assign next_state[0] = ~in & (s0 | s1 | s2 | s3 | s4 | s7 | s8 | s9);\n    assign next_state[1] =  in & (s0 | s8 | s9);\n    assign next_state[2] =  in & s1;\n    assign next_state[3] =  in & s2;\n    assign next_state[4] =  in & s3;\n    assign next_state[5] =  in & s4;\n    assign next_state[6] =  in & s5;\n    assign next_state[7] =  in & (s6 | s7);\n    assign next_state[8] = ~in & s5;\n    assign next_state[9] = ~in & s6;\n\n    // output logic\n    // (out1,out2) = (1,0) in S8; (0,1) in S7; (1,1) in S9\n    assign out1 = s8 | s9;\n    assign out2 = s7 | s9;\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;      // no change\n            2'b01: Q <= 1'b0;   // reset\n            2'b10: Q <= 1'b1;   // set\n            2'b11: Q <= ~Q;     // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n    // count the number of 1's in the 3-bit vector\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // out[24] down to out[0] = (~x) ^ y for x,y in {a,b,c,d,e},\n    // in the order: a\u00d7a, a\u00d7b, a\u00d7c, a\u00d7d, a\u00d7e,\n    //               b\u00d7a, b\u00d7b, \u2026, b\u00d7e,\n    //               c\u00d7a, \u2026, c\u00d7e,\n    //               d\u00d7a, \u2026, d\u00d7e,\n    //               e\u00d7a, \u2026, e\u00d7e\n    assign out = {\n        (~a)^a, (~a)^b, (~a)^c, (~a)^d, (~a)^e,\n        (~b)^a, (~b)^b, (~b)^c, (~b)^d, (~b)^e,\n        (~c)^a, (~c)^b, (~c)^c, (~c)^d, (~c)^e,\n        (~d)^a, (~d)^b, (~d)^c, (~d)^d, (~d)^e,\n        (~e)^a, (~e)^b, (~e)^c, (~e)^d, (~e)^e\n    };\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,      // async, posedge reset\n    input        bump_left,\n    input        bump_right,\n    output       walk_left,\n    output       walk_right\n);\n\n    // State encoding\n    localparam WALK_L = 1'b0;\n    localparam WALK_R = 1'b1;\n\n    reg state, next_state;\n\n    // state register with asynchronous, posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_L;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic (Moore)\n    always @(*) begin\n        case (state)\n            WALK_L: begin\n                // if walking left and bump into something on the left \u2192 turn right\n                if (bump_left)\n                    next_state = WALK_R;\n                else\n                    next_state = WALK_L;\n            end\n            WALK_R: begin\n                // if walking right and bump into something on the right \u2192 turn left\n                if (bump_right)\n                    next_state = WALK_L;\n                else\n                    next_state = WALK_R;\n            end\n            default: next_state = WALK_L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WALK_L);\n    assign walk_right = (state == WALK_R);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n\n    // From the timing diagram, q is high only when both a and b are high.\n    assign q = a & b;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // First OR of two 3-input AND gates\n    assign p1y = (p1a & p1b & p1c)\n               | (p1d & p1e & p1f);\n\n    // Second OR of two 2-input AND gates\n    assign p2y = (p2a & p2b)\n               | (p2c & p2d);\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\nalways @(*) begin\n    // Output z is 1 in states 3 (011) or 4 (100)\n    z = (~y[2] &  y[1] &  y[0])   // state == 3\n      | ( y[2] & ~y[1] & ~y[0]);  // state == 4\n\n    // Next\u2010state bit Y0 from the table:\n    //  x=0: Y0=1 for y==001,011,100\n    //  x=1: Y0=1 for y==000,010\n    Y0 = ( x        & ~y[2] & ~y[0])          // x=1, y==000 or 010 (y0=0,y2=0)\n       | (~x        & ~y[2] &  y[0])          // x=0, y==001 or 011 (y2=0,y0=1)\n       | (~x        &  y[2] & ~y[1] & ~y[0]); // x=0, y==100\nend\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2\u2010input NOR: out is high only when both inputs are low\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    // Simple wire connections\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous active\u2010high reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input            clk,\n    input            load,\n    input   [9:0]    data,\n    output           tc\n);\n\n    // internal down\u2010counter\n    reg [9:0] count;\n\n    // terminal\u2010count flag is high when count is zero\n    assign tc = (count == 0);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // load new timeout value\n            count <= data;\n        end else if (count != 0) begin\n            // decrement until zero, then hold\n            count <= count - 1;\n        end\n        // else count==0, hold at 0\n    end\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,       // synchronous active\u2010high\n    input  data,\n    output start_shifting\n);\n\n    // state encoding\n    localparam IDLE  = 3'd0,\n               S1    = 3'd1,   // saw \"1\"\n               S11   = 3'd2,   // saw \"11\"\n               S110  = 3'd3,   // saw \"110\"\n               FOUND = 3'd4;   // saw \"1101\" (terminal)\n\n    reg [2:0] state, next_state;\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            IDLE:   next_state = data ? S1    : IDLE;\n            S1:     next_state = data ? S11   : IDLE;\n            S11:    next_state = data ? S11   : S110;\n            S110:   next_state = data ? FOUND : IDLE;\n            FOUND:  next_state = FOUND;        // stay asserted forever\n            default:next_state = IDLE;\n        endcase\n    end\n\n    // output logic (Moore)\n    assign start_shifting = (state == FOUND);\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // On every rising edge of clk, if reset is high, clear q to zero.\n    // Otherwise, load q with d.\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // Register to hold last-cycle value of 'in'\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        // Rising\u2010edge detect: 1 only if in was 0 last cycle and is 1 now\n        anyedge <=  in & ~in_d;\n        // Update delayed version\n        in_d    <=  in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // Synchronous, active\u2010high reset. Counts 1\u219210 then wraps to 1.\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1;\n        end else if (q == 4'd10) begin\n            q <= 4'd1;\n        end else begin\n            q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    // On each rising edge of clk:\n    //   if a==1 \u2192 synchronously load the constant 4\n    //   else    \u2192 increment q (mod\u20118 by natural 3\u2011bit overflow)\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4;\n        else\n            q <= q + 3'd1;\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous reset\n    output reg [4:0] q\n);\n\n    // Galois 5\u2010bit LFSR for polynomial x^5 + x^3 + 1\n    // taps at bit\u2010positions 5 and 3 (positions 1..5 from LSB=1)\n    // state 00000 is illegal, reset state is 00001\n\n    wire fb = q[0];  // output bit (LSB) feeds back\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001;\n        end else begin\n            // shift right, XOR fb into tapped stage (bit\u20103)\n            // new_q = { fb,\n            //           q[4],        // bit\u20105 \u2192 bit\u20104\n            //           q[3] ^ fb,   // bit\u20104 \u2192 bit\u20103  (tap at pos3)\n            //           q[2],        // bit\u20103 \u2192 bit\u20102\n            //           q[1] }       // bit\u20102 \u2192 bit\u20101\n            q <= { fb,\n                   q[4],\n                   q[3] ^ fb,\n                   q[2],\n                   q[1] };\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // set zero\u2010flag (must assign in all cases)\n        result_is_zero = (out == 8'd0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // From the K\u2010map the minimal cover is\n    //    f = x3&~x1   +   ~x3&x1&x2\n    // where x3 = x[3], x1 = x[1], x2 = x[2]\n\n    always_comb begin\n        f = ( x[3] & ~x[1] )\n          | ( ~x[3] &  x[1] & x[2] );\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @(*) begin\n        // default outputs\n        valid = 1'b0;\n        out   = 4'd0;\n        case (code)\n            8'h45: begin valid = 1'b1; out = 4'd0; end\n            8'h16: begin valid = 1'b1; out = 4'd1; end\n            8'h1E: begin valid = 1'b1; out = 4'd2; end\n            8'h26: begin valid = 1'b1; out = 4'd3; end\n            8'h25: begin valid = 1'b1; out = 4'd4; end\n            8'h2E: begin valid = 1'b1; out = 4'd5; end\n            8'h36: begin valid = 1'b1; out = 4'd6; end\n            8'h3D: begin valid = 1'b1; out = 4'd7; end\n            8'h3E: begin valid = 1'b1; out = 4'd8; end\n            8'h46: begin valid = 1'b1; out = 4'd9; end\n            default: begin /* valid=0; out=0; */ end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse bit order: out[7]\u2190in[0], \u2026, out[0]\u2190in[7]\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,    // unused (don't\u2010care)\n    output reg out\n);\n\n    always @(*) begin\n        // simplified from K\u2010map grouping: out = a + c\u00b7!b\n        out = a | (c & ~b);\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena)       // shift in MSB first\n            q <= {data, q[3:1]};\n        else if (count_ena)  // down\u2010count\n            q <= q - 1;\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // continuous assignment: out follows in like a wire\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,            // synchronous active\u2010high reset\n    input  pattern_detect,   // asserted for one cycle when the right pattern is seen\n    output shift_ena\n);\n\n    // A 3\u2011bit counter that holds the remaining shift\u2011enable cycles.\n    // We load it with 4 on reset or on a new detect (when idle),\n    // then count down to zero.  shift_ena is high whenever cnt!=0.\n    reg [2:0] cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // on reset, enable shift for 4 cycles\n            cnt <= 3'd4;\n        end\n        else if (pattern_detect && cnt == 3'd0) begin\n            // on a new pattern_detect (and not already running),\n            // re\u2011load 4 cycles\n            cnt <= 3'd4;\n        end\n        else if (cnt != 3'd0) begin\n            // keep counting down\n            cnt <= cnt - 3'd1;\n        end\n        // else cnt==0, stay at zero\n    end\n\n    assign shift_ena = (cnt != 3'd0);\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous reset\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Combinational: assign\u2010based mux\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Combinational: procedural if\u2010based mux\n    always @* begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    input  c,\n    output out\n);\n\n    // From the K\u2011map the only 0 is at a=0, b=0, c=0.\n    // Hence out = a OR b OR c\n    assign out = a | b | c;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input  [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                // Priority: r[1] > r[2] > r[3]\n                if      (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else            next_state = A;\n            end\n            B: next_state = r[1] ? B : A;  // hold grant1 while r1==1\n            C: next_state = r[2] ? C : A;  // hold grant2 while r2==1\n            D: next_state = r[3] ? D : A;  // hold grant3 while r3==1\n            default: next_state = A;\n        endcase\n    end\n\n    // State register (synchronous, active\u2010low reset)\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic: one\u2010hot grants based on state\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    // Synchronous reset, decade (0\u20139) counter\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,  // synchronous, active\u2010high\n    output reg   done\n);\n\n    // state encoding\n    localparam [1:0]\n        S_FIND = 2'd0,  // waiting for byte1 (in[3]==1)\n        S_GOT1 = 2'd1,  // saw byte1, now byte2\n        S_GOT2 = 2'd2;  // saw byte2, now byte3\n\n    reg [1:0] state, next_state;\n\n    // synchronous state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= S_FIND;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic & done signal\n    always @(*) begin\n        done       = 1'b0;\n        next_state = S_FIND;\n        case (state)\n            S_FIND: begin\n                if (in[3])\n                    next_state = S_GOT1;\n                else\n                    next_state = S_FIND;\n            end\n\n            S_GOT1: begin\n                // got the 2nd byte, advance to wait for 3rd\n                next_state = S_GOT2;\n            end\n\n            S_GOT2: begin\n                // this is the 3rd byte of the message\n                done       = 1'b1;\n                next_state = S_FIND;\n            end\n\n            default: begin\n                next_state = S_FIND;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n// reduction operators implement 4\u2011input gates\nassign out_and = &in;  // 4\u2011input AND\nassign out_or  = |in;  // 4\u2011input OR\nassign out_xor = ^in;  // 4\u2011input XOR\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active\u2010high\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    reg [2:0] state, next_state;\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state / output logic (Moore)\n    always @(*) begin\n        z = 1'b0;              // default output\n        case (state)\n            3'b000: begin\n                z = 1'b0;\n                next_state = x ? 3'b001 : 3'b000;\n            end\n            3'b001: begin\n                z = 1'b0;\n                next_state = x ? 3'b100 : 3'b001;\n            end\n            3'b010: begin\n                z = 1'b0;\n                next_state = x ? 3'b001 : 3'b010;\n            end\n            3'b011: begin\n                z = 1'b1;\n                next_state = x ? 3'b010 : 3'b001;\n            end\n            3'b100: begin\n                z = 1'b1;\n                next_state = x ? 3'b100 : 3'b011;\n            end\n            default: begin\n                z = 1'b0;\n                next_state = 3'b000;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // synchronous active\u2010low\n    input  x,\n    input  y,\n    output f,\n    output g\n);\n    // state encoding\n    localparam A   = 4'd0,\n               B   = 4'd1,\n               C   = 4'd2,\n               D   = 4'd3,\n               E   = 4'd4,\n               F1  = 4'd5,\n               F2  = 4'd6,\n               ON  = 4'd7,\n               OFF = 4'd8;\n\n    reg [3:0] state, next_state;\n    reg       f_reg, g_reg;\n    assign    f = f_reg;\n    assign    g = g_reg;\n\n    // next\u2010state / output logic (Moore machine)\n    always @(*) begin\n        // defaults\n        next_state = A;\n        f_reg       = 1'b0;\n        g_reg       = 1'b0;\n        case (state)\n            A: begin\n                // after reset, single\u2010cycle in A and go to B\n                next_state = B;\n            end\n            B: begin\n                // one\u2010cycle pulse on f\n                f_reg       = 1'b1;\n                next_state  = C;\n            end\n            C: begin\n                // look for x==1\n                if (x)\n                    next_state = D;\n                else\n                    next_state = C;\n            end\n            D: begin\n                // look for x==0\n                if (!x)\n                    next_state = E;\n                else\n                    // if x==1, stay in D (restart the 1)\n                    next_state = D;\n            end\n            E: begin\n                // look for x==1 to complete 1-0-1\n                if (x)\n                    next_state = F1;\n                else\n                    next_state = C;\n            end\n            F1: begin\n                // g=1, first cycle watching y\n                g_reg = 1'b1;\n                if (y)\n                    next_state = ON;\n                else\n                    next_state = F2;\n            end\n            F2: begin\n                // g=1, second cycle watching y\n                g_reg = 1'b1;\n                if (y)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                // permanent g=1\n                g_reg      = 1'b1;\n                next_state = ON;\n            end\n            OFF: begin\n                // permanent g=0\n                g_reg      = 1'b0;\n                next_state = OFF;\n            end\n            default: begin\n                next_state = A;\n            end\n        endcase\n    end\n\n    // state register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2010flip\u2010flops with active\u2010high synchronous reset to 0x34,\n    // all triggered on the falling edge of clk\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // Even parity: parity = XOR reduction of all 8 bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            2'b00:  next_state = in ? 2'b01 : 2'b00; // A -> B/A\n            2'b01:  next_state = in ? 2'b01 : 2'b10; // B -> B/C\n            2'b10:  next_state = in ? 2'b11 : 2'b00; // C -> D/A\n            2'b11:  next_state = in ? 2'b01 : 2'b10; // D -> B/C\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic (Moore: depends only on current state)\n    assign out = (state == 2'b11);\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // From the waveform:\n    // x y : z\n    // 0 0 : 1\n    // 0 1 : 0\n    // 1 0 : 0\n    // 1 1 : 1\n    // => z = XNOR(x,y)\n    assign z = x ~^ y;\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous active\u2010high\n    input  w,\n    output z\n);\n\n    // state encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // state register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // output logic (Moore: output depends only on state)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             resetn,\n    input      [1:0]  byteena,\n    input      [15:0] d,\n    output reg [15:0] q\n);\n\n    // 16 D\u2010FFs with byte\u2010enable and synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // lower byte\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            // upper byte\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // register to hold previous cycle's input\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        in_d  <= in;             // sample input\n        pedge <= in & ~in_d;     // detect 0->1, output asserted next cycle\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": ""}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    wire [511:0] next_q;\n\n    // boundary cells\n    assign next_q[0]   = q[1];        // q[-1] assumed 0\n    assign next_q[511] = q[510];      // q[512] assumed 0\n\n    // interior cells: next = left ^ right\n    genvar i;\n    generate\n        for (i = 1; i < 511; i = i + 1) begin : rule90\n            assign next_q[i] = q[i-1] ^ q[i+1];\n        end\n    endgenerate\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n    // z is high when A equals B\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left neighbor are 1\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) this bit or its right neighbor is 1\n    assign out_any[99:1] = in[99:1] | in[98:0];\n\n    // (3) this bit different from its left neighbor (with wrap)\n    // left\u2010shifted version of in with wrap: {in[0], in[99:1]}\n    assign out_different = in ^ {in[0], in[99:1]};\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  d,\n    input  ena,\n    output logic q\n);\n\n    // Level-sensitive D\u2010latch: when ena=1, q follows d; when ena=0, q holds\n    always @(*) begin\n        if (ena)\n            q = d;\n        // else q retains its previous value (incomplete assignment infers a latch)\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n\n    // select one 4\u2011bit slice: sel*4 gives the starting bit\n    // \u201c+:\u201d takes a 4\u2011bit range upward from that base\n    assign out = in[{sel,2'b00} +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0:  out = a;\n            4'd1:  out = b;\n            4'd2:  out = c;\n            4'd3:  out = d;\n            4'd4:  out = e;\n            4'd5:  out = f;\n            4'd6:  out = g;\n            4'd7:  out = h;\n            4'd8:  out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output       out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n\n    // logical OR of the two vectors (is any bit in a or b high?)\n    assign out_or_logical = (|a) | (|b);\n\n    // upper half = bitwise NOT of b, lower half = bitwise NOT of a\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,       // one\u2010hot: state[0]=A, state[1]=B, state[2]=C, state[3]=D\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // Combinational next\u2010state logic (one\u2010hot encoding)\n    always @(*) begin\n        // default all zeros\n        next_state = 4'b0000;\n        // A \u2190 A or C when in=0\n        next_state[0] = ~in & (state[0] | state[2]);\n        // B \u2190 A, B or D when in=1\n        next_state[1] =  in & (state[0] | state[1] | state[3]);\n        // C \u2190 B or D when in=0\n        next_state[2] = ~in & (state[1] | state[3]);\n        // D \u2190 C when in=1\n        next_state[3] =  in &  state[2];\n    end\n\n    // Moore\u2010output: high in D\n    assign out = state[3];\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d)\n        min = a;\n    else if (b <= c && b <= d)\n        min = b;\n    else if (c <= d)\n        min = c;\n    else\n        min = d;\nend\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Combinational assignments\n    assign out_and   = a & b;      // AND\n    assign out_or    = a | b;      // OR\n    assign out_xor   = a ^ b;      // XOR\n    assign out_nand  = ~(a & b);   // NAND\n    assign out_nor   = ~(a | b);   // NOR\n    assign out_xnor  = ~(a ^ b);   // XNOR\n    assign out_anotb = a & ~b;     // A and not B\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // active\u2010high synchronous\n    input        s,\n    input        w,\n    output reg   z\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state;\n    reg [1:0] sample_cnt;    // counts 0,1,2 = three samples\n    reg [1:0] ones_cnt;      // counts up to 3 ones\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= A;\n            sample_cnt <= 2'd0;\n            ones_cnt   <= 2'd0;\n            z          <= 1'b0;\n        end\n        else begin\n            case (state)\n                //==================================================\n                A: begin\n                    z <= 1'b0;             // no output in idle\n                    if (s) begin\n                        state      <= B;   // enter sample mode\n                        sample_cnt <= 2'd0;\n                        ones_cnt   <= 2'd0;\n                    end\n                    else begin\n                        state <= A;\n                    end\n                end\n\n                //==================================================\n                B: begin\n                    // Collect the w\u2010sample\n                    if (sample_cnt < 2) begin\n                        // first or second sample\n                        ones_cnt   <= ones_cnt + w;\n                        sample_cnt <= sample_cnt + 1;\n                        z          <= 1'b0;\n                    end\n                    else begin\n                        // third sample: evaluate window\n                        // ones_cnt holds count of first two samples\n                        // add current w and compare to 2\n                        z          <= ((ones_cnt + w) == 2);\n                        // reset for next window\n                        sample_cnt <= 2'd0;\n                        ones_cnt   <= 2'd0;\n                    end\n                    // remain in B indefinitely (s is ignored here)\n                end\n\n                //==================================================\n                default: begin\n                    // guard against illegal states\n                    state      <= A;\n                    sample_cnt <= 2'd0;\n                    ones_cnt   <= 2'd0;\n                    z          <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concatenate with the 8\u2011bit input\n    assign out = { {24{in[7]}}, in };\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // active\u2010low synchronous reset\n    input  in,\n    output out\n);\n\n    reg [3:0] sr;\n\n    // Shift register with synchronous, active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            sr <= 4'b0000;\n        else\n            sr <= {sr[2:0], in};\n    end\n\n    assign out = sr[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n    always @* begin\n        if      (in[0]) pos = 2'd0;\n        else if (in[1]) pos = 2'd1;\n        else if (in[2]) pos = 2'd2;\n        else if (in[3]) pos = 2'd3;\n        else             pos = 2'd0;\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with async active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON : next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n\n    // Always drive output low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Continuously drive the output high\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // On every rising edge of clk, sample D = in ^ out\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,\n    input        load,\n    input        ena,\n    input  [3:0] data,\n    output reg [3:0] q\n);\n\n    // Asynchronous reset, synchronous load/shift-right\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;               // highest priority\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};     // shift right, msb\u21900, lsb out\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n// f = 1 for minterms 010, 011, 101, 111\n// simplified Boolean: f = (~x3 & x2) | (x1 & (x2 | x3))\nassign f = (~x3 & x2) | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // reduction operators implement 100\u2010input gates\n    assign out_and = &in;  // 100\u2010input AND\n    assign out_or  = |in;  // 100\u2010input OR\n    assign out_xor = ^in;  // 100\u2010input XOR\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // sum is XOR of inputs, carry-out is AND of inputs\n    assign sum  = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input  cpu_overheated,\n    output reg shut_off_computer,\n    input  arrived,\n    input  gas_tank_empty,\n    output reg keep_driving\n);\n\n    // Combinational logic for shutting off the computer\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    // Combinational logic for deciding to keep driving\n    always @(*) begin\n        if (!arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  reset,  // active\u2010high synchronous\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j ? ON : OFF);\n            ON:  next_state = (k ? OFF : ON);\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate all inputs (30 bits) and two LSB \u20181\u2019 bits, then split into 4\u00d78-bit outputs\n    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // q is high when the four\u2010bit input has an even number of 1's\n    // i.e. the 4\u2010input XOR is 0 \u2192 invert that\n    assign q = ~(a ^ b ^ c ^ d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    // Implement AND gate\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,  // synchronous, active\u2011high\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @* begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum = a \u2295 b \u2295 cin\n    assign sum  = a ^ b ^ cin;\n\n    // cout = majority(a,b,cin) = ab + bc + ca\n    assign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // intermediate XNOR result\n    logic xnor_out;\n\n    // XNOR of in1 and in2\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR of xnor_out with in3 drives out\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n    // 1) generate d\u0304 = ~d via 2:1 mux:\n    //    when d=0 \u2192 choose 1, when d=1 \u2192 choose 0\n    assign wire_dbar    = d ? 1'b0 : 1'b1;\n\n    // 2) mux_in[3] = c | ~d = d\u0304?1:c\n    assign mux_in[3]    = wire_dbar ? 1'b1 : c;\n\n    // 3) mux_in[2] = c & d = d?c:0\n    assign mux_in[2]    = d ? c : 1'b0;\n\n    // 4) mux_in[1] = 0 (constant zero)\n    assign mux_in[1]    = 1'b0;\n\n    // 5) mux_in[0] = c | d = d?1:c\n    assign mux_in[0]    = d ? 1'b1 : c;\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // asynchronous, active\u2010high\n    input  x,\n    output z\n);\n\n    // one\u2010hot state registers\n    reg A, B;\n    wire next_A, next_B;\n\n    // next\u2010state logic\n    assign next_A = A & ~x;           // from A stay in A if x=0, else 0\n    assign next_B = B | (A & x);      // once in B stay, or go from A if x=1\n\n    // output logic (Mealy)\n    assign z = (A & x) | (B & ~x);\n\n    // state register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            A <= 1'b1;  // state A\n            B <= 1'b0;\n        end else begin\n            A <= next_A;\n            B <= next_B;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // f = (!x2 & !x4)   \ufe31covers m0,m2,m8,m10\n    //   | (!x1 & x3)    \ufe31covers m2,m3,m6,m7\n    //   | ( x2 & x3 & x4)\ufe31covers m7,m15\n    assign f = (~x[2] & ~x[4])\n             | (~x[1] &  x[3])\n             | ( x[2] &  x[3] & x[4]);\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,   // synchronous, active\u2010high\n    input        in,\n    output       disc,\n    output       flag,\n    output       err\n);\n\n    // State encoding\n    localparam S0  = 4'd0,\n               S1  = 4'd1,\n               S2  = 4'd2,\n               S3  = 4'd3,\n               S4  = 4'd4,\n               S5  = 4'd5,\n               S6  = 4'd6,\n               SD  = 4'd7,  // disc output state\n               SF  = 4'd8,  // flag output state\n               SERR= 4'd9;  // error state\n\n    reg [3:0] state, next_state;\n\n    // State register, synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            S0:  next_state = in ? S1  : S0;\n            S1:  next_state = in ? S2  : S0;\n            S2:  next_state = in ? S3  : S0;\n            S3:  next_state = in ? S4  : S0;\n            S4:  next_state = in ? S5  : S0;\n            S5:  next_state = in ? S6  : SD;     // 5 ones then 0 \u2192 disc\n            S6:  next_state = in ? SERR: SF;     // 6 ones then 0 \u2192 flag; 7th 1 \u2192 err\n            SD:  next_state = in ? S1  : S0;     // consume the stuffed zero\n            SF:  next_state = in ? S1  : S0;     // after flag, restart counting\n            SERR:next_state = SERR;              // sticky error\n            default: next_state = S0;\n        endcase\n    end\n\n    // Moore outputs\n    assign disc = (state == SD);\n    assign flag = (state == SF);\n    assign err  = (state == SERR);\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire        clk,\n    input  wire        reset,   // synchronous, active high\n    input  wire        data,\n    output wire [3:0]  count,\n    output reg         counting,\n    output reg         done,\n    input  wire        ack\n);\n\n    // State encoding\n    localparam PATTERN    = 3'd0,\n               READ_DELAY = 3'd1,\n               COUNT_INIT = 3'd2,\n               COUNTING_S = 3'd3,\n               WAIT_ACK   = 3'd4;\n\n    reg [2:0]  state;\n    reg [3:0]  shift_pat;\n    reg [3:0]  delay_reg;\n    reg [3:0]  count_reg;\n    reg [1:0]  dl_cnt;        // index for reading delay bits\n    reg [9:0]  cyc_cnt;       // counts up to 1000\n\n    assign count = count_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= PATTERN;\n            shift_pat  <= 4'd0;\n            delay_reg  <= 4'd0;\n            count_reg  <= 4'd0;\n            dl_cnt     <= 2'd0;\n            cyc_cnt    <= 10'd0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            case (state)\n                // ------------------------\n                PATTERN: begin\n                    counting  <= 1'b0;\n                    done      <= 1'b0;\n                    // shift in for pattern detection\n                    shift_pat <= { shift_pat[2:0], data };\n                    if ({ shift_pat[2:0], data } == 4'b1101) begin\n                        // move to read delay bits\n                        state     <= READ_DELAY;\n                        dl_cnt    <= 2'd3;\n                        delay_reg <= 4'd0;\n                    end\n                end\n\n                // ------------------------\n                READ_DELAY: begin\n                    // capture MSB first\n                    delay_reg[dl_cnt] <= data;\n                    if (dl_cnt == 0) begin\n                        state <= COUNT_INIT;\n                    end else begin\n                        dl_cnt <= dl_cnt - 1;\n                    end\n                end\n\n                // ------------------------\n                COUNT_INIT: begin\n                    // prepare counting\n                    count_reg <= delay_reg;\n                    cyc_cnt   <= 10'd0;\n                    counting  <= 1'b1;\n                    state     <= COUNTING_S;\n                end\n\n                // ------------------------\n                COUNTING_S: begin\n                    // counting in progress\n                    if (cyc_cnt == 10'd999) begin\n                        cyc_cnt <= 10'd0;\n                        if (count_reg == 0) begin\n                            // done counting\n                            counting <= 1'b0;\n                            done     <= 1'b1;\n                            state    <= WAIT_ACK;\n                        end else begin\n                            count_reg <= count_reg - 1;\n                        end\n                    end else begin\n                        cyc_cnt <= cyc_cnt + 1;\n                    end\n                end\n\n                // ------------------------\n                WAIT_ACK: begin\n                    // wait for user ack\n                    if (ack) begin\n                        done      <= 1'b0;\n                        shift_pat <= 4'd0;\n                        state     <= PATTERN;\n                    end\n                end\n\n                default: state <= PATTERN;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input            clk,\n    input            reset,\n    input      [3:1] s,\n    output reg       fr3,\n    output reg       fr2,\n    output reg       fr1,\n    output reg       dfr\n);\n\n    // 2\u2010bit encoding of current and previous water\u2010level bands (0\u20133 sensors asserted)\n    reg [1:0] level, prev_level;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // on reset assume water low for a long time \u21d2 all valves open + supplemental\n            level      <= 2'd0;\n            prev_level <= 2'd0;\n            fr1        <= 1'b1;\n            fr2        <= 1'b1;\n            fr3        <= 1'b1;\n            dfr        <= 1'b1;\n        end else begin\n            // remember previous band\n            prev_level <= level;\n            // compute current band = number of sensors asserted\n            level <= s[1] + s[2] + s[3];\n\n            // nominal flow outputs based on current band\n            case (level)\n                2'd3: begin fr1 <= 0; fr2 <= 0; fr3 <= 0; end // above s3\n                2'd2: begin fr1 <= 1; fr2 <= 0; fr3 <= 0; end // between s3 and s2\n                2'd1: begin fr1 <= 1; fr2 <= 1; fr3 <= 0; end // between s2 and s1\n                2'd0: begin fr1 <= 1; fr2 <= 1; fr3 <= 1; end // below s1\n            endcase\n\n            // supplemental valve on if level is rising\n            dfr <= (prev_level < level) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output done\n);\n    // State encoding\n    localparam IDLE      = 3'd0;\n    localparam START     = 3'd1;\n    localparam DATA      = 3'd2;\n    localparam STOP      = 3'd3;\n    localparam WAIT_STOP = 3'd4;\n\n    reg [2:0] state;\n    reg [3:0] bit_cnt;\n    reg       done_reg;\n\n    assign done = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state    <= IDLE;\n            bit_cnt  <= 0;\n            done_reg <= 0;\n        end else begin\n            // default\n            done_reg <= 0;\n            case (state)\n                IDLE: begin\n                    if (in == 0) begin\n                        state   <= START;\n                        // wait one cycle for start bit validation\n                    end\n                end\n\n                START: begin\n                    // we've sampled the start bit; now go read data bits\n                    bit_cnt <= 0;\n                    state   <= DATA;\n                end\n\n                DATA: begin\n                    bit_cnt <= bit_cnt + 1;\n                    if (bit_cnt == 7) begin\n                        state <= STOP;\n                    end\n                end\n\n                STOP: begin\n                    if (in == 1) begin\n                        // valid stop bit => byte done\n                        done_reg <= 1;\n                        state    <= IDLE;\n                    end else begin\n                        // framing error => wait for line to go idle\n                        state <= WAIT_STOP;\n                    end\n                end\n\n                WAIT_STOP: begin\n                    if (in == 1) begin\n                        // line is idle again, go back to IDLE\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output reg [7:0] out_byte,\n    output reg       done\n);\n\n    // state encoding\n    localparam IDLE       = 2'd0,\n               RECEIVE    = 2'd1,\n               CHECK_STOP = 2'd2,\n               WAIT_STOP  = 2'd3;\n\n    reg [1:0]  state;\n    reg [2:0]  bit_cnt;\n    reg [7:0]  shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bit_cnt   <= 3'd0;\n            shift_reg <= 8'd0;\n            out_byte  <= 8'd0;\n            done      <= 1'b0;\n        end else begin\n            // default\n            done <= 1'b0;\n\n            case (state)\n                // wait for start bit (in == 0)\n                IDLE: begin\n                    if (in == 1'b0) begin\n                        bit_cnt <= 3'd0;\n                        state   <= RECEIVE;\n                    end\n                end\n\n                // collect 8 data bits, LSB first\n                RECEIVE: begin\n                    shift_reg[bit_cnt] <= in;\n                    bit_cnt <= bit_cnt + 3'd1;\n                    if (bit_cnt == 3'd7)\n                        state <= CHECK_STOP;\n                end\n\n                // check stop bit == 1\n                CHECK_STOP: begin\n                    if (in == 1'b1) begin\n                        out_byte <= shift_reg;\n                        done     <= 1'b1;\n                        state    <= IDLE;\n                    end else begin\n                        // bad stop, wait for line to return to idle\n                        state <= WAIT_STOP;\n                    end\n                end\n\n                // if stop was bad, wait for in==1 before next start\n                WAIT_STOP: begin\n                    if (in == 1'b1)\n                        state <= IDLE;\n                end\n\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    // prediction interface\n    input        predict_valid,\n    input  [6:0] predict_pc,\n    output       predict_taken,\n    output [6:0] predict_history,\n\n    // training interface\n    input        train_valid,\n    input        train_taken,\n    input        train_mispredicted,\n    input  [6:0] train_history,\n    input  [6:0] train_pc\n);\n\n    // global history register\n    reg [6:0] gh;\n\n    // 2-bit saturating counters, 0=strong NT, 1=weak NT, 2=weak T, 3=strong T\n    reg [1:0] pht [0:127];\n    integer i;\n\n    // prediction index & reading counter\n    wire [6:0] pred_idx  = predict_pc ^ gh;\n    wire [1:0] pred_cnt  = pht[pred_idx];\n\n    // outputs\n    assign predict_taken   = pred_cnt[1];  // taken if counter >= 2\n    assign predict_history = gh;           // history used for this prediction\n\n    // training index\n    wire [6:0] train_idx = train_pc ^ train_history;\n\n    // sequential logic: update PHT on training, update GH on br prediction or mispredict recovery\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // reset global history\n            gh <= 7'b0;\n            // reset PHT to weakly taken (2)\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b10;\n        end else begin\n            // 1) update PHT on any training\n            if (train_valid) begin\n                // increment / decrement saturating counter\n                if (train_taken) begin\n                    if (pht[train_idx] != 2'b11)\n                        pht[train_idx] <= pht[train_idx] + 1;\n                end else begin\n                    if (pht[train_idx] != 2'b00)\n                        pht[train_idx] <= pht[train_idx] - 1;\n                end\n            end\n\n            // 2) update global history\n            if (train_valid && train_mispredicted) begin\n                // recover history at mispredict and shift in real outcome\n                gh <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // shift in predicted direction\n                gh <= { gh[5:0], predict_taken };\n            end\n            // otherwise hold gh\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam WL = 3'd0,\n               WR = 3'd1,\n               FL = 3'd2,\n               FR = 3'd3,\n               DL = 3'd4,\n               DR = 3'd5,\n               SP = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_cnt;  // counts consecutive cycles in air\n\n    // Next\u2010state combinational logic\n    always @* begin\n        next_state = state;\n        case (state)\n            SP: next_state = SP;  // forever splattered\n\n            // Falling states\n            FL, FR: begin\n                if (ground) begin\n                    // landed: splatter if fell >20, else resume walk\n                    if (fall_cnt > 20)\n                        next_state = SP;\n                    else\n                        next_state = (state==FL ? WL : WR);\n                end\n                // else stay in FL/FR\n            end\n\n            // Digging states\n            DL: begin\n                if (!ground)             next_state = FL;  // ground ended \u2192 fall\n                else                      next_state = DL;  // keep digging\n            end\n            DR: begin\n                if (!ground)             next_state = FR;\n                else                      next_state = DR;\n            end\n\n            // Walking states\n            WL: begin\n                if (!ground)              next_state = FL;  // fall has top priority\n                else if (dig)             next_state = DL;  // then dig\n                else if (bump_left||bump_right)\n                                          next_state = WR;  // bump \u2192 reverse\n                else                       next_state = WL;  // keep walking\n            end\n            WR: begin\n                if (!ground)              next_state = FR;\n                else if (dig)             next_state = DR;\n                else if (bump_left||bump_right)\n                                          next_state = WL;\n                else                       next_state = WR;\n            end\n\n            default: next_state = WL;  // safe default\n        endcase\n    end\n\n    // State & fall-counter update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state    <= WL;\n            fall_cnt <= 0;\n        end else begin\n            // update state\n            state <= next_state;\n            // update fall counter only while actually in air\n            if ((state==FL || state==FR) && !ground)\n                fall_cnt <= fall_cnt + 1;\n            else\n                fall_cnt <= 0;\n        end\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL || state == FR);\n    assign digging    = (state == DL || state == DR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input        clk,\n    input        reset,        // synchronous, active\u2010high\n    input        data,         // serial data in\n    output reg   shift_ena,    // enable shift for 4 cycles\n    output reg   counting,     // high while waiting for counters\n    input        done_counting,// pulses high when counters are done\n    output reg   done,         // high to notify user\n    input        ack           // user acknowledgement\n);\n\n    // state encoding\n    localparam S0    = 3'd0,    // looking for first '1'\n               S1    = 3'd1,    // saw \"1\"\n               S2    = 3'd2,    // saw \"11\"\n               S3    = 3'd3,    // saw \"110\"\n               S4    = 3'd4,    // saw \"1101\" (start shift next)\n               SHIFT = 3'd5,    // shifting in 4 bits\n               COUNT = 3'd6,    // waiting for counter\n               DONE  = 3'd7;    // timer expired, wait for ack\n\n    reg [2:0] state, next_state;\n    reg [1:0] shift_cnt;\n\n    // State register + shift counter\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= S0;\n            shift_cnt <= 2'd0;\n        end else begin\n            state <= next_state;\n            // count only in SHIFT, else clear\n            if (state == SHIFT)\n                shift_cnt <= shift_cnt + 2'd1;\n            else\n                shift_cnt <= 2'd0;\n        end\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S0:   if (data)           next_state = S1;\n            S1:   if (data)           next_state = S2;\n                  else                next_state = S0;\n            S2:   if (!data)          next_state = S3;\n                  else                next_state = S2;  // stay on \"11...\"\n            S3:   if (data)           next_state = S4;\n                  else                next_state = S0;\n            S4:                       next_state = SHIFT; \n            SHIFT: if (shift_cnt == 2'd3) next_state = COUNT;\n            COUNT: if (done_counting) next_state = DONE;\n            DONE:  if (ack)           next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore\u2010style)\n    always @(*) begin\n        // defaults\n        shift_ena = 1'b0;\n        counting  = 1'b0;\n        done      = 1'b0;\n        case (state)\n            SHIFT: shift_ena = 1'b1;\n            COUNT: counting  = 1'b1;\n            DONE:  done      = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n    // next state vector\n    reg [255:0] next_q;\n\n    // loop indices and neighbor count\n    integer i, j, di, dj;\n    integer ni, nj;\n    integer count;\n\n    // combinational: compute next_q from current q\n    always @* begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                count = 0;\n                // sum 8 neighbors with wrap\u2010around\n                for (di = -1; di <= 1; di = di + 1) begin\n                    for (dj = -1; dj <= 1; dj = dj + 1) begin\n                        if (!(di == 0 && dj == 0)) begin\n                            ni = (i + di) & 4'hF;\n                            nj = (j + dj) & 4'hF;\n                            count = count + q[{ni, nj}];\n                        end\n                    end\n                end\n                // apply rules:\n                // 2 neighbors \u2192 keep state\n                // 3 neighbors \u2192 alive\n                // otherwise \u2192 dead\n                if (count == 2)\n                    next_q[{i, j}] = q[{i, j}];\n                else if (count == 3)\n                    next_q[{i, j}] = 1'b1;\n                else\n                    next_q[{i, j}] = 1'b0;\n            end\n        end\n    end\n\n    // sequential: load or advance one step\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam [2:0]\n        S_L = 3'd0,  // walking left\n        S_R = 3'd1,  // walking right\n        F_L = 3'd2,  // falling, remember left\n        F_R = 3'd3,  // falling, remember right\n        D_L = 3'd4,  // digging, left\n        D_R = 3'd5;  // digging, right\n\n    reg [2:0] state, next_state;\n\n    // Asynchronous reset, synchronous state update\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_L;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (priority: fall > dig > bump/switch > hold)\n    always @(*) begin\n        case (state)\n            // walking left\n            S_L: begin\n                if (!ground)\n                    next_state = F_L;\n                else if (dig)\n                    next_state = D_L;\n                else if (bump_left || bump_right)\n                    next_state = S_R;\n                else\n                    next_state = S_L;\n            end\n\n            // walking right\n            S_R: begin\n                if (!ground)\n                    next_state = F_R;\n                else if (dig)\n                    next_state = D_R;\n                else if (bump_left || bump_right)\n                    next_state = S_L;\n                else\n                    next_state = S_R;\n            end\n\n            // falling, then resume walk when ground returns\n            F_L: next_state = ground ? S_L : F_L;\n            F_R: next_state = ground ? S_R : F_R;\n\n            // digging until ground disappears, then fall\n            D_L: next_state = ground ? D_L : F_L;\n            D_R: next_state = ground ? D_R : F_R;\n\n            // should never hit\n            default: next_state = S_L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_L);\n    assign walk_right = (state == S_R);\n    assign aaah       = (state == F_L) || (state == F_R);\n    assign digging    = (state == D_L) || (state == D_R);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    input        ena,\n    output reg   pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 1'b0;        // AM\n            hh <= 8'h12;       // 12\n            mm <= 8'h00;       // 00\n            ss <= 8'h00;       // 00\n        end else if (ena) begin\n            // seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                // minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    // hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm;   // toggle AM/PM\n                    end else begin\n                        // BCD hour increment\n                        if (hh[3:0] == 4'h9) begin\n                            hh[3:0] <= 4'h0;\n                            hh[7:4] <= hh[7:4] + 4'h1;\n                        end else begin\n                            hh[3:0] <= hh[3:0] + 4'h1;\n                        end\n                    end\n                end else begin\n                    // BCD minute increment\n                    if (mm[3:0] == 4'h9) begin\n                        mm[3:0] <= 4'h0;\n                        mm[7:4] <= mm[7:4] + 4'h1;\n                    end else begin\n                        mm[3:0] <= mm[3:0] + 4'h1;\n                    end\n                end\n            end else begin\n                // BCD second increment\n                if (ss[3:0] == 4'h9) begin\n                    ss[3:0] <= 4'h0;\n                    ss[7:4] <= ss[7:4] + 4'h1;\n                end else begin\n                    ss[3:0] <= ss[3:0] + 4'h1;\n                end\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam W_L = 2'b00,\n               W_R = 2'b01,\n               F_L = 2'b10,\n               F_R = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= W_L;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            W_L: begin\n                if (!ground)\n                    next_state = F_L;                                 // start falling\n                else if (bump_left || bump_right)\n                    next_state = W_R;                                // bounce to right\n                else\n                    next_state = W_L;\n            end\n            W_R: begin\n                if (!ground)\n                    next_state = F_R;\n                else if (bump_left || bump_right)\n                    next_state = W_L;                                // bounce to left\n                else\n                    next_state = W_R;\n            end\n            F_L: begin\n                if (ground)\n                    next_state = W_L;                                // land, resume left\n                else\n                    next_state = F_L;                                // keep falling\n            end\n            F_R: begin\n                if (ground)\n                    next_state = W_R;                                // land, resume right\n                else\n                    next_state = F_R;\n            end\n            default: next_state = W_L;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == W_L);\n    assign walk_right = (state == W_R);\n    assign aaah       = (state == F_L) || (state == F_R);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               reset,\n    output      [3:1]   ena,\n    output reg [15:0]   q\n);\n\n    // ena[1] pulses when ones digit rolls over 9\u21920\n    // ena[2] pulses when tens digit rolls over\n    // ena[3] pulses when hundreds digit rolls over\n    assign ena[1] = (q[3:0]   == 4'd9);\n    assign ena[2] = ena[1] &\n                    (q[7:4]   == 4'd9);\n    assign ena[3] = ena[2] &\n                    (q[11:8]  == 4'd9);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // tens digit\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // hundreds digit\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // thousands digit\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,\n    input        w,\n    output reg   Y2\n);\n\n    // next\u2010state logic for y[2]\n    always @(*) begin\n        // Y2 = (~y2 & y1)\n        //    + (y3 & ~y2 & w)\n        //    + (~y3 & y2 & ~y1 & w)\n        Y2 = (~y[2] &  y[1])\n           | ( y[3] & ~y[2] &  w)\n           | (~y[3] &  y[2] & ~y[1] & w);\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring is asserted, choose motor or ringer based on vibrate_mode.\n    // Otherwise both are off.\n    assign motor  = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n// continuous\u2010assignment AND\nassign out_assign = a & b;\n\n// combinational always block AND\nalways @* begin\n    out_alwaysblock = a & b;\nend\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Tie the output to constant 0\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a, \n    output reg   q\n);\n\n    reg a_prev;\n\n    always @(posedge clk) begin\n        // two zeros \u2192 set q; two ones \u2192 clear q; else hold\n        if      (a_prev==0 && a==0) q <= 1;\n        else if (a_prev==1 && a==1) q <= 0;\n        // else q <= q;  // implicit\n        a_prev <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    localparam WAIT1 = 1'b0,  // still looking for the first '1'\n               FLIP  = 1'b1;  // after the first '1', invert all bits\n\n    reg state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WAIT1;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            WAIT1: next_state = x ? FLIP : WAIT1;\n            FLIP : next_state = FLIP;\n            default: next_state = WAIT1;\n        endcase\n    end\n\n    // output logic (registered)\n    // In WAIT1:   z <= x  (copy bits until first '1')\n    // In FLIP:    z <= ~x (invert all remaining bits)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            z <= 1'b0;\n        end else begin\n            case (state)\n                WAIT1: z <= x;\n                FLIP : z <= ~x;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse byte\u2010order: {byte0, byte1, byte2, byte3} \u2192 {byte3, byte2, byte1, byte0}\n    assign out = { in[7:0],\n                   in[15:8],\n                   in[23:16],\n                   in[31:24] };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  d,\n    input  r,\n    output logic q\n);\n\n    // Synchronous active\u2010high reset D\u2010flip\u2010flop\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input              ena,\n    input      [1:0]   amount,\n    input      [63:0]  data,\n    output reg [63:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00:  q <= q << 1;                            // shift left by 1\n                2'b01:  q <= q << 8;                            // shift left by 8\n                2'b10:  q <= {q[63], q[63:1]};                  // arithmetic right by 1\n                2'b11:  q <= {{8{q[63]}}, q[63:8]};             // arithmetic right by 8\n                default: q <= q;\n            endcase\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,  // active\u2010low async reset\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam S0 = 2'b00,  // no bits matched\n               S1 = 2'b01,  // saw '1'\n               S2 = 2'b10;  // saw '10'\n\n    reg [1:0] state, next_state;\n\n    // State register with negative\u2010edge async reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state and Mealy\u2010output logic\n    always @(*) begin\n        next_state = state;\n        z          = 1'b0;\n        case (state)\n            S0: begin\n                if (x) next_state = S1;\n                else   next_state = S0;\n            end\n            S1: begin\n                if (x) next_state = S1; // still have a '1'\n                else   next_state = S2; // saw \"10\"\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1; // overlapping: treat this '1' as new start\n                    z          = 1'b1; // detected \"101\"\n                end else begin\n                    next_state = S0; // \"100\" = no prefix\n                end\n            end\n            default: begin\n                next_state = S0;\n                z          = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output       z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2011state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w ? A : B);\n            B: next_state = (w ? D : C);\n            C: next_state = (w ? D : E);\n            D: next_state = (w ? A : F);\n            E: next_state = (w ? D : E);\n            F: next_state = (w ? D : C);\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,       // synchronous, active\u2010high\n    output [23:0] out_bytes,\n    output       done\n);\n\n    // FSM states\n    localparam WAIT  = 2'b00,\n               BYTE2 = 2'b01,\n               BYTE3 = 2'b10;\n\n    reg [1:0]   state;\n    reg [7:0]   b1, b2;\n    reg [23:0]  out_bytes_reg;\n    reg         done_reg;\n\n    assign out_bytes = out_bytes_reg;\n    assign done      = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state          <= WAIT;\n            done_reg       <= 1'b0;\n            out_bytes_reg  <= 24'd0;\n        end else begin\n            // default\n            done_reg <= 1'b0;\n\n            case (state)\n                // look for first byte (in[3]==1)\n                WAIT: begin\n                    if (in[3]) begin\n                        b1    <= in;\n                        state <= BYTE2;\n                    end\n                end\n\n                // capture 2nd byte\n                BYTE2: begin\n                    b2    <= in;\n                    state <= BYTE3;\n                end\n\n                // capture 3rd byte, assert done, build out_bytes, go back to WAIT\n                BYTE3: begin\n                    out_bytes_reg <= {b1, b2, in};\n                    done_reg      <= 1'b1;\n                    state         <= WAIT;\n                end\n\n                default: state <= WAIT;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,\n    input        w,\n    output       Y1,\n    output       Y3\n);\n\n    // one\u2010hot encoding:\n    // y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n\n    // Next\u2010state for B (y[1]) is only asserted when in A (y[0]) and w=1\n    assign Y1 = y[0] & w;\n\n    // Next\u2010state for D (y[3]) is asserted when in B, C, E or F and w=0\n    assign Y3 = ~w & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass entire vector through\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2010map one finds\n    //   out = (a ^ b) ^ (c ^ d)\n    // which is equivalent to the 4\u2010input parity (XOR) of a, b, c, d.\n\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Upper byte = bits [15:8], Lower byte = bits [7:0]\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // NOR gate: out = ~(a OR b)\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a,\n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) Continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) Combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) Clocked always block XOR (registered, one\u2010cycle delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one\u2010hot current state: A=y[1], B=y[2],\u2026,F=y[6]\n    input        w,\n    output       Y2, // next state = B\n    output       Y4  // next state = D\n);\n\n    // next\u2010B: only from A when w==0\n    assign Y2 = y[1] & ~w;\n\n    // next\u2010D: from B, C, E, or F when w==1\n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input  [7:0]   sel,\n    output         out\n);\n    // 256\u2010to\u20101 mux: variable bit\u2010select\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // First level mux: when load asserted, select R, else select shift\u2010in w\n    wire mux1_out = L ? R : w;\n    // Second level mux: when enable asserted, shift in mux1_out, else hold Q\n    wire D        = E ? mux1_out : Q;\n\n    // D flip\u2010flop\n    always @(posedge clk) begin\n        Q <= D;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state bits (outputs of the 3 D\u2011FFs)\n    reg q0, q1, q2;\n\n    // next\u2010state logic\n    wire d0 = x ^  q0;   // XOR with its own output\n    wire d1 = x & ~q1;   // AND with its own complement\n    wire d2 = x | ~q2;   //  OR with its own complement\n\n    // D\u2011FFs\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\n    // output Z = 3\u2011input XNOR of q0, q1, q2\n    // XNOR = ~(q0 ^ q1 ^ q2)\n    assign z = ~((q0 ^ q1) ^ q2);\n\n    // initial reset to zero\n    initial { q0, q1, q2 } = 3'b000;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n// intermediate next\u2010state vector\nreg [511:0] nextq;\ninteger     i;\n\n// compute nextq combinationally according to Rule\u00a0110\nalways @(*) begin\n    for (i = 0; i < 512; i = i + 1) begin\n        // form the 3\u2010bit neighborhood {left, center, right}\n        // out\u2010of\u2010bounds cells (i==0 or i==511) are treated as 0\n        case ({ (i    ? q[i-1]   : 1'b0),\n                (         q[i]         ),\n                (i<511 ? q[i+1] : 1'b0) })\n            3'b110,  // 1 1 0 \u2192 1\n            3'b101,  // 1 0 1 \u2192 1\n            3'b011,  // 0 1 1 \u2192 1\n            3'b010,  // 0 1 0 \u2192 1\n            3'b001:  // 0 0 1 \u2192 1\n                nextq[i] = 1'b1;\n            default:\n                nextq[i] = 1'b0;\n        endcase\n    end\nend\n\n// on each clock: either load new data or advance one step\nalways @(posedge clk) begin\n    if (load)\n        q <= data;\n    else\n        q <= nextq;\nend\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    always @* begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    // 8\u2011bit 2:1 mux \u2013 select between a and b\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input        clk,\n    input        L,\n    input        q_in,\n    input        r_in,\n    output reg   Q\n);\n    // On each clock, select between parallel load (r_in) or shift input (q_in)\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\nmodule full_module(\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    wire q0, q1, q2;\n    wire feedback0 = q1 ^ q2;\n\n    // bit\u20110: new bit = feedback of q1^q2 or load r[0]\n    top_module u0 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (feedback0),\n        .r_in  (r[0]),\n        .Q     (q0)\n    );\n\n    // bit\u20111: shift from q0 or load r[1]\n    top_module u1 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q0),\n        .r_in  (r[1]),\n        .Q     (q1)\n    );\n\n    // bit\u20112: hold q2 or load r[2]\n    top_module u2 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q2),\n        .r_in  (r[2]),\n        .Q     (q2)\n    );\n\n    assign q = {q2, q1, q0};\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // Holds previous cycle's input to detect 1\u21920 transitions\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out     <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            // detect falling edge on each bit: prev_in=1 & in=0\n            out     <= out | (prev_in & ~in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, capture all 8 bits of d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // 8\u2010bit two's\u2010complement addition\n    assign s = a + b;\n\n    // Overflow occurs if a and b have the same sign\n    // and the result has a different sign\n    assign overflow = ( a[7] &  b[7] & ~s[7])  // adding two negatives yields positive\n                     | (~a[7] & ~b[7] &  s[7]); // adding two positives yields negative\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,      // one-hot: [0]=S, [1]=S1, [2]=S11, [3]=S110, [4]=B0, [5]=B1, [6]=B2, [7]=B3, [8]=Count, [9]=Wait\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n  // decode one\u2010hot state bits\n  wire S    = state[0];\n  wire S1   = state[1];\n  wire S11  = state[2];\n  wire S110 = state[3];\n  wire B0   = state[4];\n  wire B1   = state[5];\n  wire B2   = state[6];\n  wire B3   = state[7];\n  wire Count= state[8];\n  wire Wait = state[9];\n\n  // next\u2010state logic (combinational)\n  assign S_next      = ( (S | S1 | S110) & ~d )   // from S, S1, S110 on d=0\n                       | ( Wait & ack );          // from Wait on ack=1\n  assign S1_next     = S & d;                     // S->S1 on d=1\n  assign B3_next     = B2;                        // B2->B3\n  assign Count_next  = B3                          // B3->Count unconditionally\n                       | ( Count & ~done_counting ); // loop Count until done_counting\n  assign Wait_next   = ( Count & done_counting )   // Count->Wait when done_counting\n                       | ( Wait & ~ack );          // Wait holds until ack=1\n\n  // outputs (Moore)\n  assign shift_ena = B0 | B1 | B2 | B3;\n  assign counting  = Count;\n  assign done      = Wait;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic       clk,\n    input  logic       areset,\n    input  logic       train_valid,\n    input  logic       train_taken,\n    output logic [1:0] state\n);\n\n   // Two\u2010bit saturating counter:\n   //   reset -> 2'b01\n   //   train_valid=1 & train_taken=1  -> state = min(state+1, 3)\n   //   train_valid=1 & train_taken=0  -> state = max(state-1, 0)\n   //   train_valid=0                  -> hold state\n\n   always_ff @(posedge clk or posedge areset) begin\n      if (areset) begin\n         state <= 2'b01;\n      end else if (train_valid) begin\n         if (train_taken) begin\n            // increment up to 3\n            if (state != 2'b11)\n               state <= state + 2'b01;\n         end else begin\n            // decrement down to 0\n            if (state != 2'b00)\n               state <= state - 2'b01;\n         end\n      end\n      // else hold current state\n   end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @* begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;  // no bits set\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // Default all outputs low\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        // Decode arrow\u2010key make codes\n        case (scancode)\n            16'he06b: left  = 1'b1;  // Left arrow\n            16'he072: down  = 1'b1;  // Down arrow\n            16'he074: right = 1'b1;  // Right arrow\n            16'he075: up    = 1'b1;  // Up arrow\n            default: ;               // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    wire c0, c1, c2, c3;\n\n    // Instantiate four full adders\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (1'b0),\n        .sum (sum[0]),\n        .cout(c0)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c0),\n        .sum (sum[1]),\n        .cout(c1)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c1),\n        .sum (sum[2]),\n        .cout(c2)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c2),\n        .sum (sum[3]),\n        .cout(c3)\n    );\n\n    // Final carry is the overflow bit\n    assign sum[4] = c3;\nendmodule\n\n// Full\u2010adder submodule\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n    \n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // 32\u2010bit global history register\n    // bit[0] = youngest branch\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // rollback: drop oldest, shift in actual outcome\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            // shift in predicted outcome\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n        // else retain current history\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // intermediate wires for AND outputs\n    wire and_ab;\n    wire and_cd;\n\n    // first layer: two AND gates\n    and u_and1(and_ab, a, b);\n    and u_and2(and_cd, c, d);\n\n    // second layer: OR gate\n    or  u_or(out, and_ab, and_cd);\n\n    // inverted output\n    not u_not(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // Positive\u2010edge\u2010triggered D flip\u2010flop\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n\n    // 8\u2011bit shift register\n    reg [7:0] Q;\n    always @(posedge clk) begin\n        if (enable) begin\n            // shift toward higher indices, S feeds Q[0]\n            Q <= { Q[6:0], S };\n        end\n    end\n\n    // 3\u2011to\u20118 random\u2010access read via multiplexers\n    wire [2:0] sel = {A, B, C};\n    always @* begin\n        case (sel)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold,\n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater only in heating mode when too cold\n    assign heater = mode & too_cold;\n    // Air conditioner only in cooling mode when too hot\n    assign aircon = ~mode & too_hot;\n    // Fan on if heater or AC is running, or if user requests it\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,  // active\u2010high synchronous reset\n    output reg [31:0] q\n);\n\n    // feedback is the LSB of the current state\n    wire feedback = q[0];\n\n    // compute next state in Galois configuration\n    wire [31:0] next_q;\n    assign next_q[31]    = feedback;                // new MSB (bit 32)\n    assign next_q[30:22] = q[31:23];                // bits 31 down to 23 shift\n    assign next_q[21]    = q[22] ^ feedback;        // tap at bit\u2010position 22\n    assign next_q[20:2]  = q[21:3];                 // bits 21 down to 3 shift\n    assign next_q[1]     = q[2]  ^ feedback;        // tap at bit\u2010position 2\n    assign next_q[0]     = q[1]  ^ feedback;        // tap at bit\u2010position 1\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h0000_0001;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the waveform one can show\n    //    q = (a OR b) AND (c OR d)\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Two independent 4\u2011input NAND gates (7420)\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) both this bit and its left neighbor (higher index) are 1\n    assign out_both = in[2:0] & in[3:1];\n    //    out_both[0] = in[0]&in[1]\n    //    out_both[1] = in[1]&in[2]\n    //    out_both[2] = in[2]&in[3]\n\n    // (2) any of this bit or its right neighbor (lower index) is 1\n    assign out_any = in[3:1] | in[2:0];\n    //    out_any[3] = in[3]|in[2]\n    //    out_any[2] = in[2]|in[1]\n    //    out_any[1] = in[1]|in[0]\n\n    // (3) this bit differs from its left neighbor (wrapping)\n    //     neighbor_left = { in[0], in[3], in[2], in[1] }\n    assign out_different = in ^ { in[0], in[3], in[2], in[1] };\n    //    out_different[3] = in[3]^in[0]\n    //    out_different[2] = in[2]^in[3]\n    //    out_different[1] = in[1]^in[2]\n    //    out_different[0] = in[0]^in[1]\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0]   a,\n    output reg [15:0] q\n);\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,   // synchronous active\u2010high reset\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n        // else: hold current value\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // out = in1 AND (NOT in2)\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\nassign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // next\u2010state logic (Moore machine)\n    always @* begin\n        case (state)\n            B: next_state = in ? B : A;  // B on 1 -> B, on 0 -> A\n            A: next_state = in ? A : B;  // A on 1 -> A, on 0 -> B\n            default: next_state = B;\n        endcase\n    end\n\n    // state register with asynchronous reset to B\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Moore output: B => 1, A => 0\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // two single\u2010edge flops, one on posedge, one on negedge\n    reg q_pos, q_neg;\n\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // mux between the two registers\n    // when clk=1 drive q from q_pos (just updated on posedge),\n    // when clk=0 drive q from q_neg (just updated on negedge)\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // XNOR operation: output is 1 when a equals b\n    assign out = a ~^ b;\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "// Submodule A: z = (x ^ y) & x\nmodule A(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Submodule B: z = XNOR(x,y)  (waveform: 00\u21921, 01\u21920, 10\u21920, 11\u21921)\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = ~(x ^ y);\nendmodule\n\n// Top\u2010level instantiates two A\u2019s and two B\u2019s, then OR/AND into an XOR\nmodule top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1, b1, or_out;\n    wire a2, b2, and_out;\n\n    A uA1(.x(x), .y(y), .z(a1));\n    B uB1(.x(x), .y(y), .z(b1));\n    or  uOR (.a(a1), .b(b1), .y(or_out));\n\n    A uA2(.x(x), .y(y), .z(a2));\n    B uB2(.x(x), .y(y), .z(b2));\n    and uAND(.a(a2), .b(b2), .y(and_out));\n\n    xor uXOR(.a(or_out), .b(and_out), .y(z));\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input       [1:0]   ena,\n    input       [99:0]  data,\n    output reg  [99:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01:  // rotate right\n                    q <= { q[0], q[99:1] };\n                2'b10:  // rotate left\n                    q <= { q[98:0], q[99] };\n                default: // 2'b00 or 2'b11 no change\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous, active high\n    output reg [9:0] q\n);\n\n    // Count 0..999, then roll over\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0;\n        else if (q == 10'd999)\n            q <= 10'd0;\n        else\n            q <= q + 10'd1;\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // NOT gate implementation\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    wire zin = ~in;\n\n    // next\u2010state logic\n    assign next_state[0] = zin & (state[0] | state[1] | state[2] | state[3] | state[4]\n                                | state[7] | state[8] | state[9]);\n    assign next_state[1] =  in & (state[0] | state[8] | state[9]);\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & (state[6] | state[7]);\n    assign next_state[8] = zin &  state[5];\n    assign next_state[9] = zin &  state[6];\n\n    // output logic\n    // S7 => (0,1), S8 => (1,0), S9 => (1,1)\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // hold\n            2'b01: Q <= 1'b0;   // reset\n            2'b10: Q <= 1'b1;   // set\n            2'b11: Q <= ~Q;     // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Sum the three bits to get the population count (0\u20133)\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // 1 if inputs are equal (XNOR), using (~x)^y\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n\n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n\n    assign out[14] = ~c ^ a;\n    assign out[13] = ~c ^ b;\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n\n    assign out[9]  = ~d ^ a;\n    assign out[8]  = ~d ^ b;\n    assign out[7]  = ~d ^ c;\n    assign out[6]  = ~d ^ d;\n    assign out[5]  = ~d ^ e;\n\n    assign out[4]  = ~e ^ a;\n    assign out[3]  = ~e ^ b;\n    assign out[2]  = ~e ^ c;\n    assign out[1]  = ~e ^ d;\n    assign out[0]  = ~e ^ e;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // State encoding\n    localparam LEFT  = 1'b0,\n               RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            LEFT:  next_state = bump_left  ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT  : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State register with asynchronous posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n\n    // From the waveform, q is high only when both a and b are high.\n    assign q = a & b;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // First OR of two 3\u2011input AND gates\n    assign p1y = (p1a & p1b & p1c)\n               | (p1d & p1e & p1f);\n\n    // Second OR of two 2\u2011input AND gates\n    assign p2y = (p2a & p2b)\n               | (p2c & p2d);\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    // Combinational logic for next\u2010state bit Y0 and output z\n    always @(*) begin\n        // next\u2010state bit Y0 = Y[0]\n        case (y)\n            3'b000: Y0 = x;     // 000\u2192000 if x=0; 000\u2192001 if x=1\n            3'b001: Y0 = ~x;    // 001\u2192001 if x=0; 001\u2192100 if x=1\n            3'b010: Y0 = x;     // 010\u2192010 if x=0; 010\u2192001 if x=1\n            3'b011: Y0 = ~x;    // 011\u2192001 if x=0; 011\u2192010 if x=1\n            3'b100: Y0 = ~x;    // 100\u2192011 if x=0; 100\u2192100 if x=1\n            default: Y0 = 1'b0;\n        endcase\n\n        // output z = 1 in states 011 or 100\n        z = (y == 3'b011) | (y == 3'b100);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2-input NOR gate\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    // wire up inputs to outputs\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic ar,\n    output logic q\n);\n\n    // Positive\u2010edge triggered D flip\u2010flop with asynchronous reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk,\n    input        load,\n    input  [9:0] data,\n    output       tc\n);\n\n    reg [9:0] count;\n\n    // tc is high whenever count is zero\n    assign tc = (count == 10'd0);\n\n    always @(posedge clk) begin\n        if (load) \n            count <= data;\n        else if (count != 10'd0)\n            count <= count - 10'd1;\n        // else keep count at 0\n    end\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,         // active\u2010high synchronous reset\n    input  data,\n    output reg start_shifting\n);\n\n    // State encoding\n    localparam S0        = 3'd0,  // no bits matched\n               S1        = 3'd1,  // matched \"1\"\n               S2        = 3'd2,  // matched \"11\"\n               S3        = 3'd3,  // matched \"110\"\n               S_DETECT  = 3'd4;  // detected \"1101\" -> sticky\n\n    reg [2:0] state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            S0:        next_state = data ? S1       : S0;\n            S1:        next_state = data ? S2       : S0;\n            S2:        next_state = data ? S2       : S3;\n            S3:        next_state = data ? S_DETECT : S0;\n            S_DETECT:  next_state = S_DETECT;      // stay asserted forever\n            default:   next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore): sticky once in S_DETECT\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 1'b0;\n        else if (state == S_DETECT)\n            start_shifting <= 1'b1;\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, synchronously reset or load d into q\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'd0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold last\u2010cycle value of \u2018in\u2019\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        prev_in  <= in;\n        // detect 0\u21921 transition: high next cycle if bit was 0 and now is 1\n        anyedge  <= (~prev_in) & in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 4'd1;\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'd4;\n        else if (q == 3'd6)\n            q <= 3'd0;\n        else\n            q <= q + 3'd1;\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [4:0] q\n);\n\n    // Galois\u2010style 5\u2010bit maximal\u2010length LFSR\n    // Polynomial: x^5 + x^2 + 1\n    // Taps at bit positions 5 (MSB) and 3\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // synchronous reset to non\u2010zero seed\n            q <= 5'b00001;\n        end else begin\n            // feedback is the LSB of the current state\n            // shifted\u2010right Galois form:\n            //   q[0] <- q[1]\n            //   q[1] <- q[2]\n            //   q[2] <- q[3] ^ feedback   // tap at bit 3\n            //   q[3] <- q[4]\n            //   q[4] <- feedback          // tap at bit 5 (MSB always gets fb)\n            wire feedback = q[0];\n            q[0] <= q[1];\n            q[1] <= q[2];\n            q[2] <= q[3] ^ feedback;\n            q[3] <= q[4];\n            q[4] <= feedback;\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input             do_sub,\n    input      [7:0]  a,\n    input      [7:0]  b,\n    output reg [7:0]  out,\n    output reg        result_is_zero\n);\n\n    always @(*) begin\n        // perform add or subtract\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // flag zero result\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    // Combinational decode of 8\u2010bit scancodes for keys 0\u20139\n    always @* begin\n        valid = 1'b0;\n        out   = 4'b0000;\n        case (code)\n            8'h45: begin valid = 1'b1; out = 4'd0; end\n            8'h16: begin valid = 1'b1; out = 4'd1; end\n            8'h1E: begin valid = 1'b1; out = 4'd2; end\n            8'h26: begin valid = 1'b1; out = 4'd3; end\n            8'h25: begin valid = 1'b1; out = 4'd4; end\n            8'h2E: begin valid = 1'b1; out = 4'd5; end\n            8'h36: begin valid = 1'b1; out = 4'd6; end\n            8'h3D: begin valid = 1'b1; out = 4'd7; end\n            8'h3E: begin valid = 1'b1; out = 4'd8; end\n            8'h46: begin valid = 1'b1; out = 4'd9; end\n            default: ; // valid=0, out=0\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse the bit order of 'in' into 'out'\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n    // Minimized from K\u2010map with d\u2010cells:\n    // f = a + b c\n\n    always @(*) begin\n        out = a | (b & c);\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             shift_ena,\n    input             count_ena,\n    input             data,\n    output reg [3:0]  q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift in serial data into MSB, push existing bits toward LSB\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // down\u2010count the 4\u2010bit value\n            q <= q - 1;\n        end\n        // if neither enable is high, hold q\n        // if both are high, shift (higher priority) takes effect\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // Simple wire connection\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,      // synchronous, active\u2010high\n    output shift_ena\n);\n\n    // a 3\u2010bit down\u2010counter to generate a 4\u2010cycle pulse\n    reg [2:0] cnt;\n\n    always @(posedge clk) begin\n        if (reset)         // on reset load count=4\n            cnt <= 3'd4;\n        else if (cnt != 3'd0)\n            cnt <= cnt - 3'd1;\n        // else hold at zero\n    end\n\n    // shift_ena is high for exactly 4 clocks after reset\n    assign shift_ena = (cnt != 3'd0);\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // 4\u2011bit synchronous counter with active\u2011high sync reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Continuous\u2010assignment mux\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Procedural mux using always block\n    always @* begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    input  c,\n    output out\n);\n    // K\u2010map shows f = 1 whenever a=1 or b=1 or c=1\n    assign out = a | b | c;\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input  [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    localparam [1:0]\n        A = 2'b00,  // Idle\n        B = 2'b01,  // Grant device 1\n        C = 2'b10,  // Grant device 2\n        D = 2'b11;  // Grant device 3\n\n    reg [1:0] state, state_next;\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])      state_next = B;\n                else if (r[2]) state_next = C;\n                else if (r[3]) state_next = D;\n                else            state_next = A;\n            end\n            B: state_next = r[1] ? B : A;\n            C: state_next = r[2] ? C : A;\n            D: state_next = r[3] ? D : A;\n            default: state_next = A;\n        endcase\n    end\n\n    // State register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= state_next;\n    end\n\n    // Output logic: one-hot grants\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd0;\n    else if (q == 4'd9)\n        q <= 4'd0;\n    else\n        q <= q + 4'd1;\nend\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output       done\n);\n\n    // state encoding\n    localparam WAIT = 2'd0,\n               B1   = 2'd1,\n               B2   = 2'd2,\n               DONE = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= WAIT;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            WAIT:  next_state = in[3] ? B1   : WAIT;\n            B1:    next_state = B2;\n            B2:    next_state = DONE;\n            DONE:  next_state = in[3] ? B1   : WAIT;\n            default: next_state = WAIT;\n        endcase\n    end\n\n    // done is high one cycle in state DONE\n    assign done = (state == DONE);\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // Reduction operators implement 4\u2011input gates\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous active\u2010high\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam S0 = 3'b000,\n               S1 = 3'b001,\n               S2 = 3'b010,\n               S3 = 3'b011,\n               S4 = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // Next\u2010state and output logic\n    always @(*) begin\n        // defaults\n        next_state = S0;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                z = 1'b0;\n                next_state = (x ? S1 : S0);\n            end\n            S1: begin\n                z = 1'b0;\n                next_state = (x ? S4 : S1);\n            end\n            S2: begin\n                z = 1'b0;\n                next_state = (x ? S1 : S2);\n            end\n            S3: begin\n                z = 1'b1;\n                next_state = (x ? S2 : S1);\n            end\n            S4: begin\n                z = 1'b1;\n                next_state = (x ? S4 : S3);\n            end\n            default: begin\n                z = 1'b0;\n                next_state = S0;\n            end\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  x,\n    input  y,\n    output f,\n    output g\n);\n\n    // state encoding\n    localparam A   = 4'd0,\n               B   = 4'd1,\n               S0  = 4'd2,\n               S1  = 4'd3,\n               S2  = 4'd4,\n               Y0  = 4'd5,\n               Y1  = 4'd6,\n               G1  = 4'd7,\n               G0  = 4'd8;\n\n    reg [3:0] state, next_state;\n\n    // synchronous state register with active-low synchronous reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic\n    always @(*) begin\n        next_state = state;  // default hold\n        case (state)\n            A:   next_state = B;            // after reset, go to B\n            B:   next_state = S0;           // one-cycle f=1, then start x-monitor\n            S0:  next_state = x ? S1 : S0;  // wait for first '1'\n            S1:  next_state = (x ? S1 : S2); // saw '1', now want '0'\n            S2:  next_state = x ? Y0 : S0;  // saw '10', now want '1'\n            // on Y0 and Y1 g=1 while sampling y for up to 2 cycles\n            Y0:  next_state = y ? G1 : Y1;  // first cycle of y-sampling\n            Y1:  next_state = y ? G1 : G0;  // second cycle of y-sampling\n            // final states\n            G1:  next_state = G1;           // permanent g=1\n            G0:  next_state = G0;           // permanent g=0\n            default: next_state = A;\n        endcase\n    end\n\n    // outputs (Moore)\n    assign f = (state == B);\n    assign g = (state == Y0) || (state == Y1) || (state == G1);\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,   // active\u2010high synchronous reset\n    output reg [7:0] q\n);\n\n    // On every negative edge of clk, either load reset value 0x34 or capture d\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // even parity = XOR of all bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            2'b00: // A\n                next_state = in ? 2'b01 : 2'b00;  \n            2'b01: // B\n                next_state = in ? 2'b01 : 2'b10;  \n            2'b10: // C\n                next_state = in ? 2'b11 : 2'b00;  \n            2'b11: // D\n                next_state = in ? 2'b01 : 2'b10;  \n            default:\n                next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic (Moore: depends only on current state)\n    assign out = (state == 2'b11); // '1' only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // From the waveform:\n    // x y | z\n    // 0 0 | 1\n    // 0 1 | 0\n    // 1 0 | 0\n    // 1 1 | 1\n    // => z = x XNOR y\n\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous, active\u2010high\n    input  w,\n    output z\n);\n\n    // State encoding\n    localparam A = 3'b000,\n               B = 3'b001,\n               C = 3'b010,\n               D = 3'b011,\n               E = 3'b100,\n               F = 3'b101;\n\n    reg [2:0] state, next_state;\n\n    // State flip\u2010flops (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic: z = 1 in states E or F\n    assign z = (state == E) | (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             resetn,\n    input      [1:0]  byteena,\n    input      [15:0] d,\n    output reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // lower byte\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            // upper byte\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // register to hold previous cycle's input\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        in_d  <= in;             // sample input\n        pedge <= (~in_d) & in;   // detect 0\u21921 per\u2010bit\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clock,\n    input  a,\n    output reg p,\n    output reg q\n);\n\n// master latch: transparent when clock==1\nalways @ (clock or a) begin\n    if (clock)\n        p = a;\n    // else p holds\nend\n\n// slave latch: transparent when clock==0\nalways @ (clock or p) begin\n    if (!clock)\n        q = p;\n    // else q holds\nend\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // Compute next state by XORing left and right neighbors.\n    // Edges automatically see a zero because of the shift operators.\n    wire [511:0] left_neigh  = q << 1;  // left_neigh[i]  = q[i-1], left_neigh[0] = 0\n    wire [511:0] right_neigh = q >> 1;  // right_neigh[i] = q[i+1], right_neigh[511] = 0\n    wire [511:0] next_state  = left_neigh ^ right_neigh;\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_state;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n    // z is high when both 2\u2011bit inputs are equal\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) out_both[i] = in[i] & in[i+1]  for i=0..98\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) out_any[i]  = in[i] | in[i-1]  for i=1..99\n    assign out_any  = in[99:1]  | in[98:0];\n\n    // (3) out_different[i] = in[i] ^ in[(i+1)%100], wrap\u2010around for i=99->0\n    //    Build a rotated version of 'in' where bit99<-in[0], bit98<-in[99], \u2026, bit0<-in[1].\n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic d,\n    input  logic ena,\n    output logic q\n);\n\n    // level\u2013sensitive D latch\n    always @(*) begin\n        if (ena)\n            q = d;\n        // else q retains its value (inferred latch)\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input   [7:0]   sel,\n    output  [3:0]   out\n);\n\n    // compute how many bit\u2011positions to shift right: sel * 4\n    wire [9:0] shift_amt = { sel, 2'b00 };\n\n    // shift the 1024\u2011bit bus right by sel*4, then take the low 4 bits\n    assign out = (in >> shift_amt)[3:0];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\nalways_comb begin\n    case (sel)\n        4'd0:  out = a;\n        4'd1:  out = b;\n        4'd2:  out = c;\n        4'd3:  out = d;\n        4'd4:  out = e;\n        4'd5:  out = f;\n        4'd6:  out = g;\n        4'd7:  out = h;\n        4'd8:  out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // logical OR (true if either vector is non\u2010zero)\n    assign out_or_logical = |a || |b;\n\n    // invert b in bits[5:3], invert a in bits[2:0]\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,       // one\u2010hot: state[0]=A, [1]=B, [2]=C, [3]=D\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // Next\u2010state equations (one\u2010hot)\n    // next_state[0]=A, [1]=B, [2]=C, [3]=D\n    always @(*) begin\n        next_state[0] = ~in & (state[0] | state[2]);            // A\u2190A (in=0) or C\u2190A (in=0)\n        next_state[1] =  in & (state[0] | state[1] | state[3]); // B\u2190A,B,D when in=1\n        next_state[2] = ~in & (state[1] | state[3]);            // C\u2190B,D when in=0\n        next_state[3] =  in &  state[2];                        // D\u2190C when in=1\n    end\n\n    // Output is 1 only in state D (state[3])\n    assign out = state[3];\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // Combinational logic to find min of a, b, c, d\n    always @* begin\n        min = a;\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Combinational logic\n    assign out_and   = a & b;\n    assign out_or    = a | b;\n    assign out_xor   = a ^ b;\n    assign out_nand  = ~(a & b);\n    assign out_nor   = ~(a | b);\n    assign out_xnor  = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out\n);\n\n    // From K\u2010map grouping one finds the minimal SOP\n    //   F = \u00acb\u00b7\u00acc   +   \u00aca\u00b7\u00acd   +   c\u00b7d\u00b7(a+b)\n    assign out = (~b & ~c)\n               | (~a & ~d)\n               | ( c & d & (a | b) );\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // active\u2011high synchronous\n    input  s,\n    input  w,\n    output reg z\n);\n    // state encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    reg        state;\n    reg [1:0]  cnt;  // 0..3\n    reg [1:0]  sum;  // holds sum of three w's\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            cnt   <= 2'd0;\n            sum   <= 2'd0;\n            z     <= 1'b0;\n        end else begin\n            case (state)\n                A: begin\n                    z <= 1'b0;\n                    if (s) begin\n                        state <= B;\n                        cnt   <= 2'd0;\n                        sum   <= 2'd0;\n                    end\n                end\n\n                B: begin\n                    if (cnt == 2'd3) begin\n                        // 4th cycle: output based on sum of last 3 w's\n                        z   <= (sum == 2'd2);\n                        cnt <= 2'd0;     // restart window\n                        sum <= 2'd0;\n                    end else begin\n                        // sample phase\n                        z   <= 1'b0;\n                        sum <= sum + w;  // accumulate w[1] + w[2] + w[3]\n                        cnt <= cnt + 2'd1;\n                    end\n                end\n\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // Sign\u2010extend in[7:0] to 32 bits by replicating the sign bit 24 times\n    assign out = {{24{in[7]}}, in};\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input        in,\n    output       out\n);\n\n    reg [3:0] shift_reg;\n\n    // synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= { shift_reg[2:0], in };\n    end\n\n    assign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        if      (in[0])      pos = 2'd0;\n        else if (in[1])      pos = 2'd1;\n        else if (in[2])      pos = 2'd2;\n        else if (in[3])      pos = 2'd3;\n        else                  pos = 2'd0;  // no bits set\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    input        areset,\n    output       out\n);\n\n    // State encoding\n    parameter OFF = 1'b0,\n              ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Tie the output to logic 0\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Constant\u20101 output\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @* begin\n        for (i = 0; i < 100; i = i + 1)\n            out[i] = in[99 - i];\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // Compute next state\n    wire d = in ^ out;\n\n    // D\u2010FF, positive\u2010edge triggered, no reset\n    always_ff @(posedge clk) begin\n        out <= d;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,\n    input        load,\n    input        ena,\n    input  [3:0] data,\n    output reg [3:0] q\n);\n\n    // Async reset, sync load/shift right\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;                    // load has priority\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};          // shift right, MSB=0\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // Sum of minterms: \u03a3m(2,3,5,7)\n    // Simplified: f = x2 & ~x3  |  x1 & (x2 | x3)\n    assign f = (x2 & ~x3) | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // Eight D flip\u2010flops with async active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // reduction operators implement n\u2011input AND, OR, XOR\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // half\u2010adder logic\n    assign sum  = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input        cpu_overheated,\n    output reg   shut_off_computer,\n    input        arrived,\n    input        gas_tank_empty,\n    output reg   keep_driving\n);\n\n    // Combinational logic for shutting off the computer\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    // Combinational logic for continuing to drive\n    always @(*) begin\n        if (!arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  reset,\n    output out\n);\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state;\n\n    // State register with synchronous active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else begin\n            case (state)\n                OFF: state <= j ? ON : OFF;\n                ON:  state <= k ? OFF : ON;\n                default: state <= OFF;\n            endcase\n        end\n    end\n\n    // Moore output\n    assign out = state;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate a\u2013f (30 bits) with two LSB ones to form 32\u2010bit vector\n    // Then split into 4\u00d78\u2010bit outputs w,x,y,z (MSB to LSB)\n    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // q is 1 when the number of 1\u2019s on {a,b,c,d} is even\n    // reduction xnor (~^) produces 1 on even parity\n    assign q = ~^(a, b, c, d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out\n);\n\n    // implement AND gate\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  wire clk,\n    input  wire in,\n    input  wire reset,  // active\u2010high synchronous\n    output wire out\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // state register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @* begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // Moore output: B=>1, A=>0\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum is the XOR of a, b and cin\n    assign sum  = a ^ b ^ cin;\n\n    // cout is 1 if at least two of the inputs are 1\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // perform XNOR on in1 and in2, then XOR with in3\n    assign out = (in1 ~^ in2) ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n// f0 = c|d   implemented as 2\u21921 mux: if d then 1 else c\nassign mux_in[0] = d ? 1'b1 : c;\n\n// for ab=01 the column is all 0\nassign mux_in[1] = 1'b0;\n\n// f2 = c&d   implemented as 2\u21921 mux: if c then d else 0\nassign mux_in[2] = c ? d : 1'b0;\n\n// f3 = c|~d  implemented as 2\u21921 mux: if d then c else 1\nassign mux_in[3] = d ? c : 1'b1;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,   // asynchronous, active\u2011high\n    input  x,\n    output z\n);\n\n    // one\u2011hot encoding of states\n    localparam A = 2'b10,\n               B = 2'b01;\n    reg [1:0] state, next_state;\n\n    // next\u2011state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Mealy output\n    // In A: z = x\n    // In B: z = ~x\n    assign z = (state == A) ? x : ~x;\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input  clk,\n    input  a,\n    input  b,\n    output q,\n    output state\n);\n\n    reg q_reg;\n    // combinational next\u2010state: odd parity of a, b and current q\n    assign state = a ^ b ^ q_reg;\n    assign q     = q_reg;\n\n    // one D\u2010flip flop\n    always @(posedge clk) begin\n        q_reg <= state;\n    end\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // f = (~x4 & ~x2)    covers the two vertical 2\u2010groups in Column 00/10 of x1x2\n    //   | (x3 & ~x1)      covers the 4\u2010cell block in rows x3=1 and x1=0\n    //   | (x4 & x3 & x2 & x1)  picks up the single remaining cell (m15)\n    assign f = (~x[4] & ~x[2])\n             | ( x[3] & ~x[1])\n             | ( x[4] &  x[3] &  x[2] &  x[1]);\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous, active\u2010high\n    input  in,     // serial HDLC bit stream\n    output disc,   // \u201cstuffed\u201d zero to discard\n    output flag,   // frame boundary flag detected\n    output err     // error: 7 or more consecutive 1s\n);\n\n    // State encoding\n    localparam IDLE = 4'd0,\n               S1   = 4'd1,\n               S2   = 4'd2,\n               S3   = 4'd3,\n               S4   = 4'd4,\n               S5   = 4'd5,\n               S6   = 4'd6,\n               ERR  = 4'd7,\n               S0D  = 4'd8,  // output disc = 1\n               S0F  = 4'd9;  // output flag = 1\n\n    reg [3:0] state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            IDLE:   next_state = in ? S1   : IDLE;\n            S1:     next_state = in ? S2   : IDLE;\n            S2:     next_state = in ? S3   : IDLE;\n            S3:     next_state = in ? S4   : IDLE;\n            S4:     next_state = in ? S5   : IDLE;\n            S5:     next_state = in ? S6   : S0D;      // 5 ones + 0 \u2192 discard\n            S6:     next_state = in ? ERR  : S0F;      // 6 ones + 0 \u2192 flag\n            ERR:    next_state = in ? ERR  : IDLE;     // stay in error on 1s\n            S0D:    next_state = in ? S1   : IDLE;     // one\u2010cycle disc\n            S0F:    next_state = in ? S1   : IDLE;     // one\u2010cycle flag\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Moore outputs\n    assign disc = (state == S0D);\n    assign flag = (state == S0F);\n    assign err  = (state == ERR);\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": ""}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input             clk,\n    input             reset,\n    input      [3:1]  s,\n    output reg        fr3,\n    output reg        fr2,\n    output reg        fr1,\n    output reg        dfr\n);\n\n    // count how many sensors are asserted (0 through 3)\n    wire [1:0] curr_cnt = s[1] + s[2] + s[3];\n    reg  [1:0] prev_cnt;\n    wire       rising   = (curr_cnt > prev_cnt);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // as if level had been low forever\n            fr1      <= 1;\n            fr2      <= 1;\n            fr3      <= 1;\n            dfr      <= 1;\n            prev_cnt <= 0;\n        end else begin\n            // generate outputs based on current level\n            case (curr_cnt)\n                3: begin  // above s3\n                    fr1 <= 0; fr2 <= 0; fr3 <= 0; dfr <= 0;\n                end\n                2: begin  // between s3 and s2\n                    fr1 <= 1; fr2 <= 0; fr3 <= 0; dfr <= rising;\n                end\n                1: begin  // between s2 and s1\n                    fr1 <= 1; fr2 <= 1; fr3 <= 0; dfr <= rising;\n                end\n                0: begin  // below s1\n                    fr1 <= 1; fr2 <= 1; fr3 <= 1; dfr <= 1;\n                end\n            endcase\n\n            // update history for next cycle\n            prev_cnt <= curr_cnt;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,  // active\u2010high sync reset\n    output reg   done\n);\n\n    // state encoding\n    localparam IDLE       = 2'd0,\n               DATA       = 2'd1,\n               STOP_CHECK = 2'd2,\n               WAIT_STOP  = 2'd3;\n\n    reg [1:0]  state;\n    reg [2:0]  bit_cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= IDLE;\n            bit_cnt <= 3'd0;\n            done    <= 1'b0;\n        end else begin\n            // default\n            done <= 1'b0;\n\n            case (state)\n            IDLE: begin\n                // wait for start bit (0)\n                if (in == 1'b0) begin\n                    state   <= DATA;\n                    bit_cnt <= 3'd0;\n                end\n            end\n\n            DATA: begin\n                // count 8 data\u2010bit intervals\n                if (bit_cnt == 3'd7) begin\n                    state <= STOP_CHECK;\n                end else begin\n                    bit_cnt <= bit_cnt + 3'd1;\n                end\n            end\n\n            STOP_CHECK: begin\n                // sample stop bit\n                if (in == 1'b1) begin\n                    done  <= 1'b1;  // valid byte received\n                    state <= IDLE;\n                end else begin\n                    // bad stop -> wait until line returns to idle\n                    state <= WAIT_STOP;\n                end\n            end\n\n            WAIT_STOP: begin\n                // stay here until we see the line go high again\n                if (in == 1'b1) begin\n                    state <= IDLE;\n                end\n            end\n\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output [7:0] out_byte,\n    output       done\n);\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               BIT  = 2'b01,\n               STOP = 2'b10,\n               ERR  = 2'b11;\n\n    reg [1:0]  state;\n    reg [3:0]  bit_cnt;\n    reg [7:0]  byte_reg;\n    reg        done_reg;\n\n    // outputs\n    assign out_byte = byte_reg;\n    assign done     = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state    <= IDLE;\n            bit_cnt  <= 4'd0;\n            byte_reg <= 8'd0;\n            done_reg <= 1'b0;\n        end else begin\n            // default\n            done_reg <= 1'b0;\n            case (state)\n                IDLE: begin\n                    // wait for start bit (in==0)\n                    if (in == 1'b0) begin\n                        state   <= BIT;\n                        bit_cnt <= 4'd0;\n                    end\n                end\n\n                BIT: begin\n                    // shift in data bits LSB first\n                    byte_reg[bit_cnt] <= in;\n                    if (bit_cnt == 4'd7) begin\n                        state <= STOP;\n                    end else begin\n                        bit_cnt <= bit_cnt + 1;\n                    end\n                end\n\n                STOP: begin\n                    // verify stop bit (must be 1)\n                    if (in == 1'b1) begin\n                        done_reg <= 1'b1;\n                        state    <= IDLE;\n                    end else begin\n                        // bad frame: discard until line returns to idle\n                        state <= ERR;\n                    end\n                end\n\n                ERR: begin\n                    // wait for line to return to idle (stop bit)\n                    if (in == 1'b1) begin\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    // Prediction interface (Fetch stage)\n    input               predict_valid,\n    input  [6:0]        predict_pc,\n    output              predict_taken, \n    output [6:0]        predict_history,\n\n    // Training interface (Retire stage)\n    input               train_valid,\n    input               train_taken,\n    input               train_mispredicted,\n    input  [6:0]        train_history, \n    input  [6:0]        train_pc\n);\n\n    // Pattern History Table: 128 entries of 2-bit saturating counters\n    reg [1:0] pht [0:127];\n    // Global History Register\n    reg [6:0] ghr;\n\n    // Indices for PHT lookups\n    wire [6:0] predict_idx = predict_pc ^ ghr;\n    wire [6:0] train_idx   = train_pc    ^ train_history;\n\n    // Read PHT entry for prediction (combinational)\n    wire [1:0] pred_cnt = pht[predict_idx];\n\n    // Outputs\n    assign predict_taken   = pred_cnt[1];   // MSB of counter = prediction\n    assign predict_history = ghr;           // history used for prediction\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronous reset\n            ghr <= 7'b0;\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b10;  // e.g. weakly taken on reset\n        end else begin\n            // 1) Update PHT on any training\n            if (train_valid) begin\n                // read old counter\n                reg [1:0] old_cnt, new_cnt;\n                old_cnt = pht[train_idx];\n                // saturating update\n                if (train_taken) begin\n                    if (old_cnt != 2'b11) new_cnt = old_cnt + 1;\n                    else                   new_cnt = old_cnt;\n                end else begin\n                    if (old_cnt != 2'b00) new_cnt = old_cnt - 1;\n                    else                   new_cnt = old_cnt;\n                end\n                pht[train_idx] <= new_cnt;\n            end\n\n            // 2) Update GHR: training (mispredicted) has priority over speculation\n            if (train_valid && train_mispredicted) begin\n                // recover to the history immediately after the correct outcome\n                ghr <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // speculative update on prediction\n                ghr <= { ghr[5:0], predict_taken };\n            end\n            // otherwise, leave ghr unchanged\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam [2:0]\n        S_WL    = 3'd0,\n        S_WR    = 3'd1,\n        S_FALLL = 3'd2,\n        S_FALLR = 3'd3,\n        S_DIGL  = 3'd4,\n        S_DIGR  = 3'd5,\n        S_SPLAT = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_count;\n\n    // State register and fall counter with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state      <= S_WL;\n            fall_count <= 6'd0;\n        end else begin\n            state <= next_state;\n            // update fall counter\n            if (state == S_FALLL || state == S_FALLR)\n                fall_count <= fall_count + 6'd1;\n            else\n                fall_count <= 6'd0;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            S_WL: begin\n                if (!ground)         next_state = S_FALLL;\n                else if (dig)        next_state = S_DIGL;\n                else if (bump_left)  next_state = S_WR;\n                else                  next_state = S_WL;\n            end\n            S_WR: begin\n                if (!ground)         next_state = S_FALLR;\n                else if (dig)        next_state = S_DIGR;\n                else if (bump_right) next_state = S_WL;\n                else                  next_state = S_WR;\n            end\n            S_DIGL: begin\n                if (!ground)         next_state = S_FALLL;\n                else                  next_state = S_DIGL;\n            end\n            S_DIGR: begin\n                if (!ground)         next_state = S_FALLR;\n                else                  next_state = S_DIGR;\n            end\n            S_FALLL: begin\n                if (ground) begin\n                    if (fall_count > 6'd20) next_state = S_SPLAT;\n                    else                     next_state = S_WL;\n                end else\n                    next_state = S_FALLL;\n            end\n            S_FALLR: begin\n                if (ground) begin\n                    if (fall_count > 6'd20) next_state = S_SPLAT;\n                    else                     next_state = S_WR;\n                end else\n                    next_state = S_FALLR;\n            end\n            S_SPLAT: begin\n                next_state = S_SPLAT;\n            end\n            default: next_state = S_WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_WL);\n    assign walk_right = (state == S_WR);\n    assign aaah       = (state == S_FALLL) || (state == S_FALLR);\n    assign digging    = (state == S_DIGL)  || (state == S_DIGR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input  clk,\n    input  reset,         // synchronous, active\u2011high\n    input  data,\n    output reg shift_ena,\n    output reg counting,\n    input  done_counting,\n    output reg done,\n    input  ack\n);\n    // State encoding\n    localparam S0     = 3'd0,  // look for first '1'\n               S1     = 3'd1,  // got \"1\"\n               S2     = 3'd2,  // got \"11\"\n               S3     = 3'd3,  // got \"110\"\n               SHIFT  = 3'd4,  // shift_ena for 4 clocks\n               CNT    = 3'd5,  // counting until done_counting\n               DONE   = 3'd6;  // done until ack\n\n    reg [2:0] state, next_state;\n    reg [1:0] shift_cnt, next_shift_cnt;\n\n    // 1) Next-state logic\n    always @(*) begin\n        next_state     = state;\n        next_shift_cnt = shift_cnt;\n        case(state)\n            // --- sequence detector 1101 ---\n            S0: begin\n                if (data) next_state = S1;\n            end\n            S1: begin\n                if (data)      next_state = S2;\n                else           next_state = S0;\n            end\n            S2: begin\n                if (~data)     next_state = S3;\n                // if data==1 stay in S2 (we still have \"11\")\n            end\n            S3: begin\n                if (data)      next_state = SHIFT; // detected 1101\n                else           next_state = S0;\n            end\n\n            // --- shift phase ---\n            SHIFT: begin\n                if (shift_cnt == 2'd3)\n                    next_state = CNT;\n                else begin\n                    next_state     = SHIFT;\n                    next_shift_cnt = shift_cnt + 1;\n                end\n            end\n\n            // --- counting phase ---\n            CNT: begin\n                if (done_counting)\n                    next_state = DONE;\n            end\n\n            // --- done/ack phase ---\n            DONE: begin\n                if (ack)\n                    next_state = S0;\n            end\n\n            default: next_state = S0;\n        endcase\n    end\n\n    // 2) Output & state registers\n    always @ (posedge clk) begin\n        if (reset) begin\n            state      <= S0;\n            shift_cnt  <= 2'd0;\n            shift_ena  <= 1'b0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            state     <= next_state;\n            shift_cnt <= (state == SHIFT ? next_shift_cnt : 2'd0);\n\n            // Default outputs\n            shift_ena <= 1'b0;\n            counting  <= 1'b0;\n            done      <= 1'b0;\n            // Assert outputs in the proper states\n            case(next_state)\n                SHIFT:  shift_ena <= 1'b1;\n                CNT:    counting  <= 1'b1;\n                DONE:   done      <= 1'b1;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input  clk,\n    input  load,\n    input  [255:0] data,\n    output reg [255:0] q\n);\n\n    reg [255:0] next_q;\n    integer     i, j;\n    reg   [3:0] im, ip, jm, jp;\n    reg   [3:0] sum;\n\n    // compute next generation\n    always @* begin\n        for (i = 0; i < 16; i = i + 1) begin\n            im = (i == 0  ? 15 : i - 1);\n            ip = (i == 15 ?  0 : i + 1);\n            for (j = 0; j < 16; j = j + 1) begin\n                jm  = (j == 0  ? 15 : j - 1);\n                jp  = (j == 15 ?  0 : j + 1);\n                sum = 0;\n                sum = sum + q[{im,4'b0000} + jm];\n                sum = sum + q[{im,4'b0000} + j ];\n                sum = sum + q[{im,4'b0000} + jp];\n                sum = sum + q[{i,  4'b0000} + jm];\n                sum = sum + q[{i,  4'b0000} + jp];\n                sum = sum + q[{ip, 4'b0000} + jm];\n                sum = sum + q[{ip, 4'b0000} + j ];\n                sum = sum + q[{ip, 4'b0000} + jp];\n\n                if      (sum == 2) next_q[{i,4'b0000} + j] = q[{i,4'b0000} + j];\n                else if (sum == 3) next_q[{i,4'b0000} + j] = 1'b1;\n                else               next_q[{i,4'b0000} + j] = 1'b0;\n            end\n        end\n    end\n\n    // state register\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        bump_left,\n    input        bump_right,\n    input        ground,\n    input        dig,\n    output       walk_left,\n    output       walk_right,\n    output       aaah,\n    output       digging\n);\n    // State encoding\n    localparam WL = 3'd0,\n               WR = 3'd1,\n               DL = 3'd2,\n               DR = 3'd3,\n               FL = 3'd4,\n               FR = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WL;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            // walking left\n            WL: begin\n                if (!ground)\n                    next_state = FL;            // start falling\n                else if (dig)\n                    next_state = DL;            // start digging\n                else if (bump_left || bump_right)\n                    next_state = WR;            // reverse\n                else\n                    next_state = WL;\n            end\n            // walking right\n            WR: begin\n                if (!ground)\n                    next_state = FR;\n                else if (dig)\n                    next_state = DR;\n                else if (bump_left || bump_right)\n                    next_state = WL;\n                else\n                    next_state = WR;\n            end\n            // digging left\n            DL: begin\n                if (!ground)\n                    next_state = FL;            // fall off\n                else\n                    next_state = DL;            // keep digging\n            end\n            // digging right\n            DR: begin\n                if (!ground)\n                    next_state = FR;\n                else\n                    next_state = DR;\n            end\n            // falling left\n            FL: begin\n                if (ground)\n                    next_state = WL;            // land, resume walking left\n                else\n                    next_state = FL;\n            end\n            // falling right\n            FR: begin\n                if (ground)\n                    next_state = WR;\n                else\n                    next_state = FR;\n            end\n            default: next_state = WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign digging    = (state == DL) || (state == DR);\n    assign aaah       = (state == FL) || (state == FR);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,  // synchronous, active\u2010high\n    input            ena,    // one\u2010pulse per second\n    output reg       pm,     // 0=AM, 1=PM\n    output reg [7:0] hh,     // BCD hours 01\u201312\n    output reg [7:0] mm,     // BCD minutes 00\u201359\n    output reg [7:0] ss      // BCD seconds 00\u201359\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        ss <= 8'h00;\n        mm <= 8'h00;\n        hh <= 8'h12;\n        pm <= 1'b0;\n    end\n    else if (ena) begin\n        //---- seconds ----\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'h00;\n                //---- minutes ----\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'h00;\n                        //---- hours ----\n                        case (hh)\n                            8'h01: hh <= 8'h02;\n                            8'h02: hh <= 8'h03;\n                            8'h03: hh <= 8'h04;\n                            8'h04: hh <= 8'h05;\n                            8'h05: hh <= 8'h06;\n                            8'h06: hh <= 8'h07;\n                            8'h07: hh <= 8'h08;\n                            8'h08: hh <= 8'h09;\n                            8'h09: hh <= 8'h10;\n                            8'h10: hh <= 8'h11;\n                            8'h11: begin\n                                        hh <= 8'h12;\n                                        pm <= ~pm;   // toggle at 11\u219212\n                                    end\n                            8'h12: hh <= 8'h01;\n                            default: hh <= 8'h01;\n                        endcase\n                    end\n                    else begin\n                        // increment minute tens\n                        mm <= { mm[7:4] + 1'b1, 4'd0 };\n                    end\n                end\n                else begin\n                    // increment minute ones\n                    mm <= mm + 8'h01;\n                end\n            end\n            else begin\n                // increment second tens\n                ss <= { ss[7:4] + 1'b1, 4'd0 };\n            end\n        end\n        else begin\n            // increment second ones\n            ss <= ss + 8'h01;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam LEFT   = 2'd0,\n               RIGHT  = 2'd1,\n               FALL_L = 2'd2,\n               FALL_R = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground)\n                    next_state = FALL_L;\n                else if (bump_left | bump_right)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground)\n                    next_state = FALL_R;\n                else if (bump_left | bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            FALL_L: begin\n                if (ground)\n                    next_state = LEFT;\n                else\n                    next_state = FALL_L;\n            end\n            FALL_R: begin\n                if (ground)\n                    next_state = RIGHT;\n                else\n                    next_state = FALL_R;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah       = (state == FALL_L) || (state == FALL_R);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:1] ena,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q   <= 16'd0;\n        ena <= 3'd0;\n    end else begin\n        // Ones digit\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            ena[1] <= 1'b1;\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n            ena[1] <= 1'b0;\n        end\n\n        // Tens digit\n        if (ena[1]) begin\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                ena[2]  <= 1'b1;\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n                ena[2]  <= 1'b0;\n            end\n        end else\n            ena[2] <= 1'b0;\n\n        // Hundreds digit\n        if (ena[2]) begin\n            if (q[11:8] == 4'd9) begin\n                q[11:8] <= 4'd0;\n                ena[3]   <= 1'b1;\n            end else begin\n                q[11:8] <= q[11:8] + 1;\n                ena[3]   <= 1'b0;\n            end\n        end else\n            ena[3] <= 1'b0;\n\n        // Thousands digit\n        if (ena[3]) begin\n            if (q[15:12] == 4'd9)\n                q[15:12] <= 4'd0;\n            else\n                q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,  // y = {y3,y2,y1} coding A=000, B=001, C=010, D=011, E=100, F=101\n    input        w,\n    output reg   Y2  // next\u2010state bit y[2]\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0; // A -> 000 or 000\n            3'b001: Y2 = 1'b1; // B -> 010/011  (y2=1)\n            3'b010: Y2 = w;    // C -> 100(y2=0) on 0, 011(y2=1) on 1\n            3'b011: Y2 = 1'b0; // D -> 101/000 (y2=0)\n            3'b100: Y2 = w;    // E -> 100(y2=0) on 0, 011(y2=1) on 1\n            3'b101: Y2 = 1'b1; // F -> 010/011 (y2=1)\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring, \n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring is asserted, select between ringer and motor\n    // based on vibrate_mode. Otherwise both outputs are 0.\n    assign ringer = ring & ~vibrate_mode;\n    assign motor  = ring &  vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Continuous\u2010assignment AND\n    assign out_assign = a & b;\n\n    // Combinational always block AND\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Continuously drive zero low\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg   q\n);\n    // shift register for the last two samples of 'a'\n    reg prev_a;\n\n    always @(posedge clk) begin\n        // sample and decision\n        if (!prev_a && !a)\n            q <= 1;\n        else if (prev_a && a)\n            q <= 0;\n        // else q <= q;  // hold implicit\n\n        // shift in the new sample\n        prev_a <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // active\u2011high asynchronous reset\n    input  x,       // serial input LSB first\n    output z        // serial 2\u2019s\u2011complement output\n);\n\n    // State encoding\n    localparam WAIT = 1'b0,   // haven\u2019t seen the first \u20181\u2019 yet\n               FLIP = 1'b1;   // after the first \u20181\u2019, invert all bits\n\n    reg state, next_state;\n\n    // State register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WAIT;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @* begin\n        case (state)\n            WAIT:  next_state = x ? FLIP : WAIT;\n            FLIP:  next_state = FLIP;\n            default: next_state = WAIT;\n        endcase\n    end\n\n    // Output logic (Moore\u2010style: fully determined by state and input)\n    // before first \u20181\u2019: pass x; after first \u20181\u2019: invert x\n    assign z = (state == WAIT) ? x : ~x;\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous posedge reset to A\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;  // in=0\u2192A, in=1\u2192B\n            B: next_state = in ? B : C;  // in=0\u2192C, in=1\u2192B\n            C: next_state = in ? D : A;  // in=0\u2192A, in=1\u2192D\n            D: next_state = in ? B : C;  // in=0\u2192C, in=1\u2192B\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output logic\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse the byte order: {B3, B2, B1, B0} -> {B0, B1, B2, B3}\n    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // D\u2010flip\u2010flop with active\u2010high synchronous reset\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input               ena,\n    input       [1:0]   amount,\n    input       [63:0]  data,\n    output reg  [63:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case(amount)\n                2'b00:  q <= q << 1;                               // logical left shift by 1\n                2'b01:  q <= q << 8;                               // logical left shift by 8\n                2'b10:  q <= {q[63], q[63:1]};                     // arithmetic right shift by 1\n                2'b11:  q <= {{8{q[63]}}, q[63:8]};                // arithmetic right shift by 8\n                default:q <= q;\n            endcase\n        end\n        // else: hold q\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,  // active\u2010low asynchronous reset\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam S0 = 2'd0,  // no 1 seen\n               S1 = 2'd1,  // seen a '1'\n               S2 = 2'd2;  // seen \"10\"\n\n    reg [1:0] state, next_state;\n\n    // State register with negative\u2010edge async reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic and Mealy output\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;  // stay on multiple 1's\n                else\n                    next_state = S2;  // got \"10\"\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;  // overlap: the '1' can be start of next\n                    z = 1'b1;         // \"101\" detected\n                end else begin\n                    next_state = S0;  // dead end on 0\n                    z = 1'b0;\n                end\n            end\n            default: begin\n                next_state = S0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        w,\n    output       z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = (w==1'b0) ? B : A;\n            B: next_state = (w==1'b0) ? C : D;\n            C: next_state = (w==1'b0) ? E : D;\n            D: next_state = (w==1'b0) ? F : A;\n            E: next_state = (w==1'b0) ? E : D;\n            F: next_state = (w==1'b0) ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register (with asynchronous reset)\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine: z depends only on state)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input            clk,\n    input      [7:0] in,\n    input            reset,      // synchronous, active\u2010high\n    output reg [23:0] out_bytes, // {byte1, byte2, byte3}\n    output           done\n);\n\n    // count == 0 : waiting for header (in[3]==1)\n    // count == 1 : saw header, next byte will be byte2\n    // count == 2 : next byte will be byte3\n    // count == 3 : we've just latched byte3, out_bytes is valid, done==1\n    reg [1:0] count;\n\n    assign done = (count == 2'd3);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count      <= 2'd0;\n            out_bytes  <= 24'd0;\n        end else begin\n            case (count)\n                2'd0: begin\n                    if (in[3]) begin\n                        // start of a new packet\n                        count             <= 2'd1;\n                        out_bytes[23:16]  <= in;\n                    end\n                    // else remain in 0\n                end\n                2'd1: begin\n                    // second byte\n                    count             <= 2'd2;\n                    out_bytes[15:8]   <= in;\n                end\n                2'd2: begin\n                    // third byte\n                    count             <= 2'd3;\n                    out_bytes[7:0]    <= in;\n                end\n                2'd3: begin\n                    // one cycle with done==1\n                    if (in[3]) begin\n                        // immediately start next packet\n                        count             <= 2'd1;\n                        out_bytes[23:16]  <= in;\n                    end else begin\n                        // go back to searching\n                        count             <= 2'd0;\n                    end\n                end\n                default: count <= 2'd0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,   // one\u2010hot state {F,E,D,C,B,A} = y[5:0]\n    input        w,\n    output       Y1,  // next\u2010state bit for B (y[1])\n    output       Y3   // next\u2010state bit for D (y[3])\n);\n\n    // Y1 = go to B only from A on w=1\n    assign Y1 = y[0] & w;\n\n    // Y3 = go to D from B,C,E,F on w=0\n    assign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass the entire vector through\n    assign outv = vec;\n\n    // Split the vector into individual bits\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2010map we observe a checkerboard (odd\u2010parity) pattern:\n    // out = 1 whenever the number of 1\u2019s among {a,b,c,d} is odd.\n    // That simplifies to a ^ b ^ c ^ d.\n\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Combinational split of 16\u2010bit input into upper and lower bytes\n    assign out_lo = in[7:0];\n    assign out_hi = in[15:8];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // NOR gate: output is high only when both inputs are low\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a,\n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) Continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) Combinational always block XOR\n    always @* begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) Clocked always block XOR (registered, one\u2010cycle delayed)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one\u2011hot current state: A=y[1], B=y[2], C=y[3], D=y[4], E=y[5], F=y[6]\n    input        w,\n    output       Y2, // next\u2011state bit for B\n    output       Y4  // next\u2011state bit for D\n);\n\n    // next\u2011state B = Y2 = 1 only when currently in A (y[1]) and w==0\n    assign Y2 = y[1] & ~w;\n\n    // next\u2011state D = Y4 = 1 when currently in B,C,E or F and w==1\n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input  [7:0]   sel,\n    output         out\n);\n\n    // 256-to-1 mux by variable bit\u2010select\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        if (L)         // parallel load has highest priority\n            Q <= R;\n        else if (E)    // shift enable\n            Q <= w;\n        else           // hold\n            Q <= Q;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state bits for the three D\u2010FFs\n    reg q_xor, q_and, q_or;\n\n    // next\u2010state logic\n    wire d_xor = x ^  q_xor;   // XOR gate with its own output\n    wire d_and = x & ~q_and;   // AND gate with complemented output\n    wire d_or  = x | ~q_or;    // OR  gate with complemented output\n\n    // output: 3\u2010input XNOR of the flip\u2010flop outputs\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\n    // initialize all FFs to zero before start\n    initial begin\n        q_xor = 1'b0;\n        q_and = 1'b0;\n        q_or  = 1'b0;\n    end\n\n    // register update on rising clock edge\n    always @(posedge clk) begin\n        q_xor <= d_xor;\n        q_and <= d_and;\n        q_or  <= d_or;\n    end\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n    // From the truth\u2011table, q is '1' exactly when b=1 or c=1\n    assign q = b | c;\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input         clk,\n    input         load,\n    input  [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer     i;\n\n    // combinational: compute next generation from current q\n    always @(*) begin\n        // left boundary (q[-1]=0)\n        next_q[0]   = q[0] | q[1];         // Rule110 with L=0\n\n        // interior cells\n        for (i = 1; i < 511; i = i + 1) begin\n            // next = (L & (C ^ R)) | (~L & (C | R))\n            next_q[i] = (q[i-1] & (q[i] ^ q[i+1]))\n                      | (~q[i-1] & (q[i] | q[i+1]));\n        end\n\n        // right boundary (q[512]=0)\n        // simplifies to next_q[511] = q[511]\n        next_q[511] = q[511];\n    end\n\n    // sequential: load or advance\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n    // State encoding\n    localparam [1:0]\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case(state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output: 1 only in state D\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    always @* begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input        clk,\n    input        L,\n    input        q_in,\n    input        r_in,\n    output reg   Q\n);\n    // On each clock, choose between r_in (load) and q_in (feedback)\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\nmodule full_module (\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    // Wires to carry the outputs of each flip\u2011flop\n    wire q0, q1, q2;\n\n    // MSB: feedback = q1 ^ q2\n    top_module u2 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q1 ^ q2),\n        .r_in  (r[2]),\n        .Q     (q2)\n    );\n\n    // Middle bit: feedback = q0\n    top_module u1 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q0),\n        .r_in  (r[1]),\n        .Q     (q1)\n    );\n\n    // LSB: feedback = q2\n    top_module u0 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q2),\n        .r_in  (r[0]),\n        .Q     (q0)\n    );\n\n    // Bundle the three outputs\n    assign q = {q2, q1, q0};\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,  // active\u2010high synchronous reset\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // register to hold previous cycle's input\n    reg [31:0] prev;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out  <= 32'b0;\n            prev <= in;       // resync prev to avoid false edges\n        end else begin\n            // detect 1\u21920 per bit: prev & ~in\n            // latch detections until next reset\n            out  <= out | (prev & ~in);\n            prev <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, capture the 8\u2010bit input d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output       overflow\n);\n\n    // 8\u2010bit two\u2019s\u2010complement addition (truncates carry out)\n    assign s = a + b;\n\n    // signed overflow: when a and b have the same sign but s has the opposite\n    assign overflow = ( a[7] &  b[7] & ~s[7])  // both negative, result positive\n                     |(~a[7] & ~b[7] &  s[7]); // both positive, result negative\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,    // one-hot: {Wait,Count,B3,B2,B1,B0,S110,S11,S1,S} = state[9:0]\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n  // one\u2010hot current state bits\n  wire S    = state[0];\n  wire S1   = state[1];\n  wire S11  = state[2];\n  wire S110 = state[3];\n  wire B0   = state[4];\n  wire B1   = state[5];\n  wire B2   = state[6];\n  wire B3   = state[7];\n  wire Count= state[8];\n  wire Wait = state[9];\n\n  // next\u2010state logic (by inspection)\n  assign S_next      = (S    & ~d)\n                     | (S1   & ~d)\n                     | (S110 & ~d)\n                     | (Wait &  ack);\n\n  assign S1_next     =  S & d;\n\n  assign B3_next     =  B2;              // B2 --> B3 unconditionally\n\n  assign Count_next  =  B3              // B3 --> Count unconditionally\n                     | (Count & ~done_counting);\n\n  assign Wait_next   =  (Count & done_counting)\n                     | (Wait  & ~ack);\n\n  // output logic (Moore)\n  assign done        = Wait;\n  assign counting    = Count;\n  assign shift_ena   = B0 | B1 | B2 | B3;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        train_valid,\n    input  logic        train_taken,\n    output logic [1:0]  state\n);\n\n  // 2-bit saturating counter with async reset to weakly not\u2010taken (2'b01)\n  always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= 2'b01;\n    end else if (train_valid) begin\n      if (train_taken) begin\n        // increment but saturate at 3\n        if (state != 2'b11)\n          state <= state + 1;\n      end else begin\n        // decrement but saturate at 0\n        if (state != 2'b00)\n          state <= state - 1;\n      end\n    end\n    // else: hold state\n  end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        // default output if no bits are high\n        pos = 3'd0;\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // default outputs\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        // decode the 16\u2010bit scancode\n        case (scancode)\n            16'hE06B: left  = 1'b1;  // left arrow\n            16'hE072: down  = 1'b1;  // down arrow\n            16'hE074: right = 1'b1;  // right arrow\n            16'hE075: up    = 1'b1;  // up arrow\n            default: ;               // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    wire c0, c1, c2, c3, c4;\n    assign c0 = 1'b0;\n\n    // instantiate four full\u2010adders\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (c0),\n        .sum (sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c1),\n        .sum (sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c2),\n        .sum (sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c3),\n        .sum (sum[3]),\n        .cout(c4)\n    );\n\n    // overflow bit\n    assign sum[4] = c4;\nendmodule\n\n// simple full adder\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n    \n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // 32\u2011bit global history register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else begin\n            // misprediction rollback has priority\n            if (train_mispredicted) begin\n                // load history before the mispredicted branch, shift in actual outcome\n                predict_history <= { train_history[30:0], train_taken };\n            end\n            else if (predict_valid) begin\n                // shift in the predicted direction\n                predict_history <= { predict_history[30:0], predict_taken };\n            end\n            // else hold\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // intermediate wires between ANDs and OR\n    wire w_and1;\n    wire w_and2;\n\n    // first layer: two AND gates\n    and u_and1 (w_and1, a, b);\n    and u_and2 (w_and2, c, d);\n\n    // second layer: OR gate driving 'out'\n    or  u_or   (out,   w_and1, w_and2);\n\n    // inverted output\n    not u_not  (out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // On the rising edge of clk, sample d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n\n    // 8-bit shift\u2010register storage\n    reg [7:0] Q;\n\n    // Synchronous shift on posedge clk when enable=1\n    always @(posedge clk) begin\n        if (enable)\n            // Q[0] <= S; Q[i] <= Q[i-1] for i=1..7\n            Q <= { Q[6:0], S };\n    end\n\n    // Combinational 8-to-1 mux controlled by address {A,B,C}\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater only in heating mode when too cold\n    assign heater = mode & too_cold;\n    // Air\u2011con only in cooling mode when too hot\n    assign aircon = ~mode & too_hot;\n    // Fan if requested or whenever heater or air\u2011con is on\n    assign fan = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input            reset,  // active\u2010high synchronous reset\n    output reg [31:0] q\n);\n\n    // polynomial: x^32 + x^22 + x^2 + x^1 + 1\n    // Galois LFSR update:\n    //   if lsb==1: state <= (state>>1) ^ (POLY>>1)\n    //   else       state <=  state>>1\n    localparam [31:0] TAP_MASK = 32'h0020_0003;  \n    //                ^ bit21    + bit1 + bit0\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h0000_0001;\n        end else begin\n            if (q[0])\n                q <= (q >> 1) ^ TAP_MASK;\n            else\n                q <=  q >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table: q=1 whenever at least one of {a,b} is 1 AND at least one of {c,d} is 1\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d, \n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n// Two independent 4\u2010input NAND gates\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // both this bit and its left\u2010neighbour (higher index) are 1\n    assign out_both      = in[2:0] & in[3:1];\n\n    // this bit or its right\u2010neighbour (lower index) is 1\n    assign out_any       = in[3:1] | in[2:0];\n\n    // this bit differs from its left\u2010neighbour (wrap\u2010around)\n    // neighbour of [3] is [0], of [i] is [i+1]\n    assign out_different = in ^ { in[0], in[3:1] };\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0]  a,\n    output reg [15:0] q\n);\n\n    // Combinational lookup table\n    always @* begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // Synchronous decade counter with active\u2010high synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n        // else retain the current value of q\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // AND gate with a bubble (inversion) on in2\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // combinational passthrough\n    assign out = in;\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous reset to B\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            B: next_state = (in == 1'b0) ? A : B;\n            A: next_state = (in == 1'b0) ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Moore output: out = 1 in state B, 0 in state A\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // Two single\u2010edge flip\u2010flops\n    reg q_pos, q_neg;\n\n    // Sample on rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Sample on falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Mux between the two samples based on clock level\n    always @(*) begin\n        q = clk ? q_pos : q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out\n);\n\n    // XNOR implementation\n    assign out = a ~^ b;\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // internal nets\n    wire a1, a2, b1, b2;\n    wire or_out, and_out;\n\n    // first A and B, ORed\n    A uA1 (.x(x), .y(y), .z(a1));\n    B uB1 (.x(x), .y(y), .z(b1));\n    assign or_out = a1 | b1;\n\n    // second A and B, ANDed\n    A uA2 (.x(x), .y(y), .z(a2));\n    B uB2 (.x(x), .y(y), .z(b2));\n    assign and_out = a2 & b2;\n\n    // final XOR\n    assign z = or_out ^ and_out;\nendmodule\n\n// Module A: z = (x^y) & x\nmodule A(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Module B: implements XNOR (matches the given waveform)\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    assign z = x ~^ y;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [1:0]   ena,\n    input      [99:0]  data,\n    output reg [99:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= { q[0],    q[99:1]  };  // rotate right\n                2'b10: q <= { q[98:0], q[99]    };  // rotate left\n                default: q <= q;                     // no operation\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,\n    output reg [9:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 10'd0;\n        else if (q == 10'd999) \n            q <= 10'd0;\n        else \n            q <= q + 10'd1;\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Invert the input\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    // next\u2010state logic (one\u2010hot)\n    assign next_state[0] = ~in & (state[0] | state[1] | state[2] |\n                                  state[3] | state[4] | state[7] |\n                                  state[8] | state[9]);\n    assign next_state[1] =  in & (state[0] | state[8] | state[9]);\n    assign next_state[2] =  in & state[1];\n    assign next_state[3] =  in & state[2];\n    assign next_state[4] =  in & state[3];\n    assign next_state[5] =  in & state[4];\n    assign next_state[6] =  in & state[5];\n    assign next_state[7] =  in & (state[6] | state[7]);\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // hold\n            2'b01: Q <= 1'b0;   // reset\n            2'b10: Q <= 1'b1;   // set\n            2'b11: Q <= ~Q;     // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Simple popcount: sum the three 1\u2010bit inputs.\n    assign out = in[0] + in[1] + in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // pack inputs into vector[4:0] = {a,b,c,d,e}\n    wire [4:0] in;\n    assign in = {a,b,c,d,e};\n\n    genvar i,j;\n    generate\n        // row i = 0 (a) \u2026 4 (e), col j likewise\n        // out index: (4-i)*5 + (4-j) so that\n        // i=0,j=0 \u2192 (4-0)*5+(4-0)=24 \u2192 a==a\n        // i=0,j=1 \u2192 23 \u2192 a==b  \u2026 etc.\n        for (i = 0; i < 5; i = i + 1) begin : ROW\n            for (j = 0; j < 5; j = j + 1) begin : COL\n                assign out[(4-i)*5 + (4-j)] = in[i] ^~ in[j];\n            end\n        end\n    endgenerate\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // State encoding\n    localparam WALK_L = 1'b0,\n               WALK_R = 1'b1;\n\n    reg state, next_state;\n\n    // State flip\u2010flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_L;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        if (bump_left && bump_right)\n            // both bumps: reverse direction\n            next_state = ~state;\n        else if (bump_left)\n            // bump on left: walk right\n            next_state = WALK_R;\n        else if (bump_right)\n            // bump on right: walk left\n            next_state = WALK_L;\n        else\n            // no bump: remain\n            next_state = state;\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WALK_L);\n    assign walk_right = (state == WALK_R);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n    // From the waveform, q is high only when both a and b are high:\n    assign q = a & b;\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // Intermediate signals for the four AND gates\n    wire p1_and1 = p1a & p1b & p1c;\n    wire p1_and2 = p1d & p1e & p1f;\n    wire p2_and1 = p2a & p2b;\n    wire p2_and2 = p2c & p2d;\n\n    // OR the results to form the two outputs\n    assign p1y = p1_and1 | p1_and2;\n    assign p2y = p2_and1 | p2_and2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,   // not used in this combinational example\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    always @(*) begin\n        // Output z = 1 in states 011 or 100\n        z  = (~y[2] &  y[1] &  y[0])  // 011\n           | ( y[2] & ~y[1] & ~y[0]); // 100\n\n        // Next\u2010state bit Y0\n        // Truth\u2010table reduction gives:\n        //    Y0 = (~y2 & (x ^ y0)) \n        //       | (~x & y2 & ~y1 & ~y0);\n        Y0 = (~y[2] & (x ^ y[0]))\n           | (~x    &  y[2] & ~y[1] & ~y[0]);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2\u2011input NOR gate\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic ar,\n    output logic q\n);\n\n    // Positive\u2010edge triggered D\u2010FF with asynchronous active\u2010high reset (ar)\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk, \n    input        load, \n    input  [9:0] data, \n    output       tc\n);\n\n    reg [9:0] counter;\n\n    // terminal count is asserted when counter == 0\n    assign tc = (counter == 10'd0);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // load new count value\n            counter <= data;\n        end else if (counter != 10'd0) begin\n            // decrement until 0, then hold at 0\n            counter <= counter - 10'd1;\n        end\n        // else counter == 0: stay there\n    end\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,       // synchronous, active\u2010high\n    input  data,\n    output start_shifting\n);\n\n    // state encoding\n    localparam S0 = 2'b00;\n    localparam S1 = 2'b01;\n    localparam S2 = 2'b10;\n    localparam S3 = 2'b11;\n\n    reg [1:0] state;\n    reg       found;\n\n    // state & found register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            found <= 1'b0;\n        end else begin\n            // once found, latch it forever\n            if (found) begin\n                found <= 1'b1;\n                // keep state (optional)\n            end else begin\n                case (state)\n                    S0: state <= data ? S1 : S0;\n                    S1: state <= data ? S2 : S0;\n                    S2: state <= data ? S2 : S3;\n                    S3: begin\n                        if (data) begin\n                            found <= 1'b1;  // 1101 detected\n                            state <= S1;    // overlap: last '1' may start new match\n                        end else begin\n                            state <= S0;\n                        end\n                    end\n                    default: state <= S0;\n                endcase\n            end\n        end\n    end\n\n    assign start_shifting = found;\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, if reset is high, clear q to zero;\n    // otherwise, load it with input d.\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold previous cycle's input\n    reg [7:0] prev;\n\n    always @(posedge clk) begin\n        // detect 0->1 transitions: high next cycle if in=1 and prev=0\n        anyedge <= (~prev) & in;\n        // store current input for next comparison\n        prev    <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1;\n        end else begin\n            if (q == 4'd10)\n                q <= 4'd1;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            // when a=1, synchronously load 4\n            q <= 3'd4;\n        end else begin\n            // when a=0, count up modulo\u20137 (4\u21925\u21926\u21920\u21921\u2026)\n            q <= (q == 3'd6) ? 3'd0 : q + 3'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [4:0] q\n);\n\n    // Galois LFSR for polynomial x^5 + x^3 + 1 (taps at bit\u2010positions 5 and 3)\n    always @(posedge clk) begin\n        if (reset) begin\n            // active\u2010high synchronous reset to state 00001\n            q <= 5'b00001;\n        end else begin\n            // feedback = LSB\n            // new state (from MSB to LSB):\n            //   q[4] <= feedback\n            //   q[3] <= old q[4]\n            //   q[2] <= old q[3] ^ feedback  (tap at position 3)\n            //   q[1] <= old q[2]\n            //   q[0] <= old q[1]\n            q <= { q[0],\n                   q[4],\n                   q[3] ^ q[0],\n                   q[2],\n                   q[1] };\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // zero\u2010flag must be assigned in all cases\n        if (out == 8'b0)\n            result_is_zero = 1'b1;\n        else\n            result_is_zero = 1'b0;\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @(*) begin\n        valid = 1'b0;\n        out   = 4'd0;\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1e: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2e: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3d: begin out = 4'd7; valid = 1'b1; end\n            8'h3e: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin out = 4'd0; valid = 1'b0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Simple bit\u2010reverse: out[i] = in[7\u2010i]\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // Simplified from the K\u2010map (treating 'd' cells as 1 where useful):\n    // out = a + (~a & ~b & c)  ==>  a | (~b & c)\n\n    always @(*) begin\n        out = a | (~b & c);\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // shift right, new bit into MSB\n        q <= {data, q[3:1]};\n    end else if (count_ena) begin\n        // down\u2010count\n        q <= q - 1;\n    end\n    // else retain q\nend\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // pass\u2010through wire\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,      // active\u2010high synchronous reset\n    output shift_ena\n);\n\n    // we need to count 4 clocks (4\u2019b100=4 down to 0)\n    reg [2:0] cnt;\n    // count down when non\u2010zero, reload to 4 on reset\n    always @(posedge clk) begin\n        if (reset)\n            cnt <= 3'd4;\n        else if (cnt != 3'd0)\n            cnt <= cnt - 3'd1;\n        else\n            cnt <= 3'd0;\n    end\n\n    // enable as long as counter is non\u2010zero\n    assign shift_ena = (cnt != 3'd0);\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // On each rising clock edge, either reset to 0 or count up\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Combinational mux using continuous assignment\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Combinational mux using procedural block\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    input  c,\n    output out\n);\n\n    // From the K\u2010map, the only 0\u2010cell is at a=0, b=0, c=0.\n    // Hence out = 1 whenever any of a, b, or c is 1.\n    assign out = a | b | c;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input         clk,\n    input         resetn,\n    input   [3:1] r,\n    output  [3:1] g\n);\n\n    // State encoding\n    localparam [1:0]\n        A = 2'b00,   // idle, no grant\n        B = 2'b01,   // grant device 1\n        C = 2'b10,   // grant device 2\n        D = 2'b11;   // grant device 3\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: next_state = r[1] ? B : A;\n            C: next_state = r[2] ? C : A;\n            D: next_state = r[3] ? D : A;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (one\u2010hot grants)\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n    // Synchronous, active\u2010high reset; modulo\u201010 counter (0\u20139)\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;\n    end\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output       done\n);\n\n    // state encoding\n    localparam WAIT = 2'b00,\n               GOT1 = 2'b01,\n               GOT2 = 2'b10;\n\n    reg [1:0] state;\n    reg       done_reg;\n    assign    done = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state    <= WAIT;\n            done_reg <= 1'b0;\n        end else begin\n            // done goes high in the cycle immediately after the 3rd byte\n            done_reg <= (state == GOT2);\n\n            case (state)\n                WAIT:  state <= in[3] ? GOT1 : WAIT;\n                GOT1:  state <= GOT2;\n                GOT2:  state <= in[3] ? GOT1 : WAIT;\n                default: state <= WAIT;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // 4\u2011input AND\n    assign out_and = &in;\n\n    // 4\u2011input OR\n    assign out_or  = |in;\n\n    // 4\u2011input XOR (parity)\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active\u2010high\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam S0 = 3'd0,\n               S1 = 3'd1,\n               S2 = 3'd2,\n               S3 = 3'd3,\n               S4 = 3'd4;\n\n    reg [2:0] state, next_state;\n\n    // Combinational next\u2010state & output logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                z          = 1'b0;\n                next_state = x ? S1 : S0;\n            end\n            S1: begin\n                z          = 1'b0;\n                next_state = x ? S4 : S1;\n            end\n            S2: begin\n                z          = 1'b0;\n                next_state = x ? S1 : S2;\n            end\n            S3: begin\n                z          = 1'b1;\n                next_state = x ? S2 : S1;\n            end\n            S4: begin\n                z          = 1'b1;\n                next_state = x ? S4 : S3;\n            end\n            default: begin\n                z          = 1'b0;\n                next_state = S0;\n            end\n        endcase\n    end\n\n    // Sequential state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  x,\n    input  y,\n    output f,\n    output g\n);\n\n    // State encoding\n    localparam A   = 4'd0,\n               B   = 4'd1,\n               C0  = 4'd2,\n               C1  = 4'd3,\n               C2  = 4'd4,\n               E   = 4'd5,\n               F0  = 4'd6,\n               F1  = 4'd7,\n               G1  = 4'd8,\n               G0  = 4'd9;\n\n    reg [3:0] state, next_state;\n\n    // State register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            A:   if (resetn)       next_state = B;\n            B:                       next_state = C0;\n            C0:  if (x)             next_state = C1;\n                  else              next_state = C0;\n            C1:  if (!x)            next_state = C2;\n                  else              next_state = C1;\n            C2:  if (x)             next_state = E;\n                  else              next_state = C0;\n            E:                       next_state = F0;\n            F0:  if (y)             next_state = G1;\n                  else              next_state = F1;\n            F1:  if (y)             next_state = G1;\n                  else              next_state = G0;\n            G1:                      next_state = G1;\n            G0:                      next_state = G0;\n            default:                 next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == E)  ||\n               (state == F0) ||\n               (state == F1) ||\n               (state == G1);\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;   // synchronous active\u2010high reset to 0x34\n    else\n        q <= d;       // on negative edge, capture d\nend\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // even parity: XOR\u2010reduce all 8 bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            2'b00: // A\n                next_state = in ? 2'b01 : 2'b00; \n            2'b01: // B\n                next_state = in ? 2'b01 : 2'b10;\n            2'b10: // C\n                next_state = in ? 2'b11 : 2'b00;\n            2'b11: // D\n                next_state = in ? 2'b01 : 2'b10;\n            default:\n                next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic (Moore)\n    assign out = (state == 2'b11);\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z is high when x and y are equal (00 or 11)\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous, active\u2011high\n    input  w,\n    output z\n);\n\n    // state encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state flip\u2011flops\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore\u2010type output\n    assign z = (state == E) | (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             resetn,   // active\u2010low synchronous reset\n    input      [1:0]  byteena,  // byteena[1] = upper byte, byteena[0] = lower byte\n    input      [15:0] d,        // data inputs\n    output reg [15:0] q         // data outputs\n);\n\n// On each rising edge of clk, either reset or selectively update bytes\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        // Lower byte\n        if (byteena[0])\n            q[7:0] <= d[7:0];\n        // Upper byte\n        if (byteena[1])\n            q[15:8] <= d[15:8];\n        // Bytes not enabled retain their previous value\n    end\nend\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // register to hold previous cycle's input\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // detect a 0->1 transition: new is 1 and old was 0\n        pedge    <= (~prev_in) & in;\n        // save current input for next cycle comparison\n        prev_in  <= in;\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clock,\n    input  a,\n    output reg p,\n    output reg q\n);\n\n// master latch, transparent when clock==1\nalways @(clock or a) begin\n    if (clock)\n        p <= a;\nend\n\n// slave latch, transparent when clock==0\nalways @(clock or p) begin\n    if (!clock)\n        q <= p;\nend\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    wire [511:0] next_q;\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : calc_next\n            if (i == 0) begin\n                // left boundary = 0, right = q[1]\n                assign next_q[i] = q[1];\n            end else if (i == 511) begin\n                // left = q[510], right boundary = 0\n                assign next_q[i] = q[510];\n            end else begin\n                assign next_q[i] = q[i-1] ^ q[i+1];\n            end\n        end\n    endgenerate\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n\n    // z is high if and only if A equals B\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left neighbor (higher index) are 1\n    // out_both[i] = in[i] & in[i+1], for i=0..98\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) any of this bit and its right neighbor (lower index) is 1\n    // out_any[i] = in[i] | in[i-1], for i=1..99\n    assign out_any  = in[99:1] | in[98:0];\n\n    // (3) this bit is different from its left neighbor (wrapping)\n    // neighbor vector = { in[0]/*left of 99*/, in[99:1] } \n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  d,\n    input  ena,\n    output logic q\n);\n\n    // Level\u2010sensitive D\u2010latch: when ena=1 q follows d; when ena=0 q holds its value\n    always @(d or ena) begin\n        if (ena)\n            q = d;\n        // else q retains its previous value (implicit latch)\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n\n    // Use a variable part\u2010select to pick 4 bits at sel*4\n    assign out = in[sel*4 +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0:  out = a;\n            4'd1:  out = b;\n            4'd2:  out = c;\n            4'd3:  out = d;\n            4'd4:  out = e;\n            4'd5:  out = f;\n            4'd6:  out = g;\n            4'd7:  out = h;\n            4'd8:  out = i;\n            default: out = 16'hFFFF; // sel = 9..15\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of each bit\n    assign out_or_bitwise = a | b;\n\n    // logical OR of the two vectors: high if any bit in a or b is 1\n    assign out_or_logical = |a || |b;\n    // alternatively: assign out_or_logical = |(a | b);\n\n    // upper half = ~b[2:0], lower half = ~a[2:0]\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,       // one-hot: state[0]=A, [1]=B, [2]=C, [3]=D\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // next-state primitives by inspection (one-hot)\n    wire next_A = ~in & (state[0] | state[2]);        // A\u2190A or C when in=0\n    wire next_B =  in & (state[0] | state[1] | state[3]); // B\u2190A,B,D when in=1\n    wire next_C = ~in & (state[1] | state[3]);        // C\u2190B,D when in=0\n    wire next_D =  in &  state[2];                    // D\u2190C when in=1\n\n    // Moore output is '1' only in state D\n    assign out = state[3];\n\n    // pack next_state\n    always @(*) begin\n        next_state = 4'b0000;\n        next_state[0] = next_A;\n        next_state[1] = next_B;\n        next_state[2] = next_C;\n        next_state[3] = next_D;\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        // start with a as the tentative minimum\n        min = a;\n        if (b < min) min = b;\n        if (c < min) min = c;\n        if (d < min) min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Combinational logic assignments\n    assign out_and   = a & b;\n    assign out_or    = a | b;\n    assign out_xor   = a ^ b;\n    assign out_nand  = ~(a & b);\n    assign out_nor   = ~(a | b);\n    assign out_xnor  = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active high\n    input        s,\n    input        w,\n    output reg   z\n);\n    // State encoding\n    localparam A = 1'b0, B = 1'b1;\n    reg state;\n    // sample\u2010window counters\n    reg [1:0] cyc;   // counts 0,1,2 (three samples)\n    reg [1:0] ones;  // counts number of '1's seen in window\n    reg       result; // holds the evaluation of the last window\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // initialize everything\n            state  <= A;\n            z      <= 1'b0;\n            result <= 1'b0;\n            cyc    <= 2'd0;\n            ones   <= 2'd0;\n        end else begin\n            // update output synchronously\n            z <= result;\n\n            case (state)\n            A: begin\n                // wait here until s==1\n                if (s) begin\n                    state  <= B;\n                    // start first window\n                    cyc    <= 2'd0;\n                    ones   <= 2'd0;\n                    result <= 1'b0;  // no output yet\n                end\n            end\n\n            B: begin\n                // we are in the 3\u2010sample window phase\n                if (cyc == 2) begin\n                    // this is the 3rd sample in the window\n                    // compute result for next cycle\n                    if (ones + w == 2)\n                        result <= 1'b1;\n                    else\n                        result <= 1'b0;\n                    // restart window\n                    cyc  <= 2'd0;\n                    ones <= 2'd0;\n                end else begin\n                    // accumulate\n                    cyc  <= cyc + 2'd1;\n                    ones <= ones + w;\n                end\n            end\n\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n    // replicate the sign bit (in[7]) 24 times, then concatenate with the original 8\u2011bit input\n    assign out = { {24{in[7]}}, in };\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // active\u2010low synchronous reset\n    input  in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    // Output is the MSB of the 4\u2010stage shift register\n    assign out = shift_reg[3];\n\n    // On each rising edge of clk, either reset synchronously or shift in new bit\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= { shift_reg[2:0], in };\n    end\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @* begin\n        if      (in[3])      pos = 2'd3;\n        else if (in[2])      pos = 2'd2;\n        else if (in[1])      pos = 2'd1;\n        else                  pos = 2'd0;\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output out\n);\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j   ? ON  : OFF;\n            ON:  next_state = k   ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register with async. active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore: depends only on state)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n\n    // Continuously drive the output low\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Constant drive of logic 1\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    output logic out\n);\n\n    // Compute next state\n    logic d;\n    assign d = in ^ out;\n\n    // Positive\u2010edge\u2013triggered D flip\u2010flop, no reset\n    always_ff @(posedge clk) begin\n        out <= d;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,  // asynchronous, active\u2010high\n    input        load,    // synchronous load, active\u2010high\n    input        ena,     // synchronous shift\u2010enable, active\u2010high\n    input  [3:0] data,    // parallel data in\n    output reg [3:0] q     // shift\u2010register output\n);\n\n    // Asynchronous reset, synchronous load/shift/hold\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;                 // load has priority over shift\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};      // shift right, MSB <= 0\n        end\n        // else hold current q\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = \u03a3m(2,3,5,7) = (x2 & ~x3) | (x1 & (x2 | x3))\n    assign f = (x2 & ~x3) | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2010FFs with async active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // 100\u2011input reductions\n    assign out_and = &in;  // reduction AND of all 100 bits\n    assign out_or  = |in;  // reduction OR  of all 100 bits\n    assign out_xor = ^in;  // reduction XOR of all 100 bits\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // Half\u2010adder: sum = a \u2295 b, carry = a \u00b7 b\n    assign sum  = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input        cpu_overheated,\n    output reg   shut_off_computer,\n    input        arrived,\n    input        gas_tank_empty,\n    output reg   keep_driving\n);\n\n    // Combinational logic for shut_off_computer and keep_driving\n    always @(*) begin\n        // Default assignments to avoid inferred latches\n        shut_off_computer = 1'b0;\n        keep_driving      = 1'b0;\n\n        // Shut off computer if CPU overheats\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n\n        // Keep driving if not arrived and tank is not empty\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output out\n);\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output is purely a function of the state (Moore)\n    assign out = state;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate inputs a\u2013f (30 bits) with two LSBs = 1, then split into 4\u00d78\u2010bit outputs\n    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table, q = 1 when the number of 1\u2019s on {a,b,c,d} is even\n    // i.e. even parity \u2192 q = ~(a ^ b ^ c ^ d)\n    assign q = ~(a ^ b ^ c ^ d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,  // synchronous active\u2010high\n    output out\n);\n\n    // State encoding\n    localparam B = 1'b1,  // reset state, out=1\n               A = 1'b0;  // out=0\n\n    reg state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    // On in=1 stay, on in=0 toggle between A/B\n    always @(*) begin\n        if (in)\n            next_state = state;\n        else\n            next_state = ~state;\n    end\n\n    // Moore output\n    assign out = state;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // Sum is XOR of all three inputs\n    assign sum  = a ^ b ^ cin;\n    // Carry-out is when any two or more inputs are 1\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // intermediate net for XNOR result of in1 and in2\n    logic xnor12;\n\n    // compute XNOR of in1 and in2\n    assign xnor12 = ~(in1 ^ in2);\n\n    // XOR the XNOR result with in3 to produce out\n    assign out = xnor12 ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n    // mux_in[0] = f when ab=00 = 0,1,1,1 on cd=00,01,11,10 \u21d2 c|d\n    // implement c|d as a 2:1 mux: if d=1 \u2192 1 else \u2192 c\n    assign mux_in[0] = d ? 1'b1 : c;\n\n    // mux_in[1] = f when ab=01 = all zeros\n    assign mux_in[1] = 1'b0;\n\n    // mux_in[2] = f when ab=11 = 1 only at cd=11 \u21d2 c&d\n    // implement c&d as a 2:1 mux: if d=1 \u2192 c else \u2192 0\n    assign mux_in[2] = d ? c : 1'b0;\n\n    // mux_in[3] = f when ab=10 = 1 at cd=00,11,10 \u21d2 c|~d\n    // implement c|~d as a 2:1 mux: if d=1 \u2192 c else \u2192 1\n    assign mux_in[3] = d ? c : 1'b1;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  x,\n    output z\n);\n\n    // one-hot state encoding\n    reg state_A, state_B;\n    wire next_A, next_B;\n\n    // Next\u2010state logic (combinational)\n    assign next_A = state_A & ~x;           // stay in A on x=0\n    assign next_B = (state_A & x) | state_B; // A->B on x=1, B stays in B\n\n    // Output logic (Mealy)\n    assign z = (state_A & x) | (state_B & ~x);\n\n    // State register with async active-high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;\n            state_B <= 1'b0;\n        end else begin\n            state_A <= next_A;\n            state_B <= next_B;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,   // synchronous, active high\n    input  in,\n    output disc,\n    output flag,\n    output err\n);\n\n    // State encoding\n    localparam ZERO  = 4'd0,\n               ONE1  = 4'd1,\n               ONE2  = 4'd2,\n               ONE3  = 4'd3,\n               ONE4  = 4'd4,\n               ONE5  = 4'd5,\n               ONE6  = 4'd6,\n               S7    = 4'd7,   // error state (>=7 ones)\n               DISC  = 4'd8,   // one cycle disc=1\n               FLAG  = 4'd9;   // one cycle flag=1\n\n    reg [3:0] state, next_state;\n\n    // Moore outputs\n    assign disc = (state == DISC);\n    assign flag = (state == FLAG);\n    assign err  = (state == S7);\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            ZERO:  next_state = in ? ONE1 : ZERO;\n            ONE1:  next_state = in ? ONE2 : ZERO;\n            ONE2:  next_state = in ? ONE3 : ZERO;\n            ONE3:  next_state = in ? ONE4 : ZERO;\n            ONE4:  next_state = in ? ONE5 : ZERO;\n            ONE5:  next_state = in ? ONE6 : DISC;   // 5 ones + 0 \u2192 DISC\n            ONE6:  next_state = in ? S7   : FLAG;   // 6 ones + 0 \u2192 FLAG; 6\u21927 ones \u2192 S7\n            S7:    next_state = in ? S7   : ZERO;   // stay in error on 1; reset count on 0\n            DISC:  next_state = in ? ONE1 : ZERO;   // after DISC, treat the zero as boundary\n            FLAG:  next_state = in ? ONE1 : ZERO;   // after FLAG, same\n            default: next_state = ZERO;\n        endcase\n    end\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= ZERO;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire       clk,\n    input  wire       reset,   // active-high synchronous\n    input  wire       data,\n    output wire [3:0] count,\n    output reg        counting,\n    output reg        done,\n    input  wire       ack\n);\n\n    // State encoding\n    localparam IDLE  = 2'd0;\n    localparam SHIFT = 2'd1;\n    localparam COUNT = 2'd2;\n    localparam DONE  = 2'd3;\n\n    reg [1:0]  state;\n    reg [3:0]  pattern_reg;\n    reg [3:0]  delay_reg;\n    reg [3:0]  rem_cnt;\n    reg [2:0]  bit_cnt;\n    reg [9:0]  cycle_cnt;\n\n    // Output the remaining 4\u2010bit count when counting; zero otherwise (don't care)\n    assign count = (state == COUNT) ? rem_cnt : 4'b0000;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Initialize everything\n            state        <= IDLE;\n            pattern_reg  <= 4'b0000;\n            delay_reg    <= 4'b0000;\n            rem_cnt      <= 4'b0000;\n            bit_cnt      <= 3'd0;\n            cycle_cnt    <= 10'd0;\n            counting     <= 1'b0;\n            done         <= 1'b0;\n        end else begin\n            case (state)\n                //==================================================\n                IDLE: begin\n                    counting    <= 1'b0;\n                    done        <= 1'b0;\n                    // shift in serial data looking for 1101\n                    if ({pattern_reg[2:0], data} == 4'b1101) begin\n                        state       <= SHIFT;\n                        bit_cnt     <= 3'd0;\n                        delay_reg   <= 4'b0000;\n                    end\n                    pattern_reg <= {pattern_reg[2:0], data};\n                end\n\n                //==================================================\n                // Shift in 4 bits MSB-first into delay_reg\n                SHIFT: begin\n                    // shift one bit\n                    delay_reg <= {delay_reg[2:0], data};\n                    bit_cnt   <= bit_cnt + 1'b1;\n                    if (bit_cnt == 3) begin\n                        // after 4th bit, capture delay and start counting\n                        rem_cnt    <= {delay_reg[2:0], data};\n                        cycle_cnt  <= 10'd0;\n                        counting   <= 1'b1;\n                        state      <= COUNT;\n                    end\n                end\n\n                //==================================================\n                // Count for (delay+1)*1000 cycles, decrement rem_cnt every 1000 cycles\n                COUNT: begin\n                    counting <= 1'b1;\n                    done     <= 1'b0;\n                    if (cycle_cnt == 10'd999) begin\n                        cycle_cnt <= 10'd0;\n                        if (rem_cnt == 4'd0) begin\n                            // finished last 1000-cycle block\n                            counting <= 1'b0;\n                            done     <= 1'b1;\n                            state    <= DONE;\n                        end else begin\n                            rem_cnt <= rem_cnt - 1'b1;\n                        end\n                    end else begin\n                        cycle_cnt <= cycle_cnt + 1'b1;\n                    end\n                end\n\n                //==================================================\n                // Wait for user to ack, then go back to IDLE\n                DONE: begin\n                    counting <= 1'b0;\n                    done     <= 1'b1;\n                    if (ack) begin\n                        state       <= IDLE;\n                        pattern_reg <= 4'b0000;\n                    end\n                end\n\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // active\u2010high synchronous reset\n    input  [3:1] s,      // s[1]=low sensor \u2026 s[3]=high sensor\n    output reg   fr3,    // nominal flow bit 3\n    output reg   fr2,    // nominal flow bit 2\n    output reg   fr1,    // nominal flow bit 1\n    output reg   dfr     // supplemental flow\n);\n\n    // state encoding for the four water\u2010level regions:\n    localparam L0 = 2'd0,  // below s[1]\n               L1 = 2'd1,  // between s[1] and s[2]\n               L2 = 2'd2,  // between s[2] and s[3]\n               L3 = 2'd3;  // above s[3]\n\n    reg [1:0] state, next_state;\n\n    // compute the 'instantaneous' level from the sensor inputs\n    wire [1:0] current_level = s[3] ? L3\n                            : s[2] ? L2\n                            : s[1] ? L1\n                                    : L0;\n\n    // did we just rise from a lower region?\n    wire rising = (current_level > state);\n\n    // next_state combinational logic\n    always @(*) begin\n        next_state = current_level;\n    end\n\n    // synchronous state update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= L0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // outputs: nominal flow bits and supplemental flow\n    // apply reset behavior for outputs in the same cycle\n    always @(posedge clk) begin\n        if (reset) begin\n            // on reset, \"all four outputs asserted\"\n            {fr3, fr2, fr1, dfr} <= 4'b1111;\n        end else begin\n            case (current_level)\n                L0: // below s[1]\n                    // maximum flow = all three nominal bits\n                    // table does not assert dfr for L0\n                    {fr3, fr2, fr1, dfr} <= 4'b1110;\n\n                L1: // between s[1] and s[2]\n                    // nominal = fr1+fr2, plus supplemental if rising\n                    {fr3, fr2, fr1, dfr} <= {1'b0,\n                                            1'b1,\n                                            1'b1,\n                                            rising ? 1'b1 : 1'b0};\n\n                L2: // between s[2] and s[3]\n                    // nominal = fr1, plus supplemental if rising\n                    {fr3, fr2, fr1, dfr} <= {1'b0,\n                                            1'b0,\n                                            1'b1,\n                                            rising ? 1'b1 : 1'b0};\n\n                L3: // above s[3]\n                    // no flow\n                    {fr3, fr2, fr1, dfr} <= 4'b0000;\n\n                default:\n                    {fr3, fr2, fr1, dfr} <= 4'b0000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE      = 2'd0,\n               START     = 2'd1,\n               DATA      = 2'd2,\n               STOP_WAIT = 2'd3;\n\n    reg [1:0] state;\n    reg [2:0] bit_cnt;  // counts 0..7\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= IDLE;\n            bit_cnt <= 3'd0;\n            done    <= 1'b0;\n        end else begin\n            // default\n            done <= 1'b0;\n            case (state)\n                IDLE: begin\n                    // line idle = 1, look for start = 0\n                    if (in == 1'b0) begin\n                        state <= START;\n                    end\n                end\n\n                START: begin\n                    // consume the start bit, now sample 8 data bits\n                    bit_cnt <= 3'd0;\n                    state   <= DATA;\n                end\n\n                DATA: begin\n                    // shift or sample data bit here if you want to capture it\n                    bit_cnt <= bit_cnt + 3'd1;\n                    if (bit_cnt == 3'd7) begin\n                        // after 8 data bits, go check stop bit\n                        state <= STOP_WAIT;\n                    end\n                end\n\n                STOP_WAIT: begin\n                    if (in == 1'b1) begin\n                        // good stop bit\n                        done  <= 1'b1;\n                        state <= IDLE;\n                    end\n                    // else stay here until in==1 to re\u2011synchronize\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output [7:0] out_byte,\n    output       done\n);\n\n    // FSM states\n    localparam IDLE      = 2'd0,\n               RECEIVE   = 2'd1,\n               WAIT_STOP = 2'd2;\n\n    reg [1:0]  state;\n    reg [3:0]  bitcnt;\n    reg [7:0]  shift_reg;\n    reg        done_reg;\n\n    // FSM and data shift\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bitcnt    <= 4'd0;\n            shift_reg <= 8'd0;\n            done_reg  <= 1'b0;\n        end else begin\n            // default\n            done_reg <= 1'b0;\n            case (state)\n                IDLE: begin\n                    if (in == 1'b0) begin       // detect start bit\n                        state  <= RECEIVE;\n                        bitcnt <= 4'd0;\n                    end\n                end\n\n                RECEIVE: begin\n                    if (bitcnt < 4'd8) begin\n                        // shift LSB first\n                        shift_reg[bitcnt] <= in;\n                        bitcnt           <= bitcnt + 4'd1;\n                    end else begin\n                        // now in is stop bit\n                        if (in == 1'b1) begin\n                            done_reg <= 1'b1;\n                            state    <= IDLE;\n                        end else begin\n                            // bad stop bit \u2192 wait for next '1'\n                            state <= WAIT_STOP;\n                        end\n                    end\n                end\n\n                WAIT_STOP: begin\n                    if (in == 1'b1) begin\n                        // found stop bit\n                        done_reg <= 1'b1;\n                        state    <= IDLE;\n                    end\n                end\n\n            endcase\n        end\n    end\n\n    assign out_byte = shift_reg;\n    assign done     = done_reg;\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input             clk,\n    input             areset,\n\n    // prediction interface\n    input             predict_valid,\n    input   [6:0]     predict_pc,\n    output            predict_taken,\n    output  [6:0]     predict_history,\n\n    // training interface\n    input             train_valid,\n    input             train_taken,\n    input             train_mispredicted,\n    input   [6:0]     train_history,\n    input   [6:0]     train_pc\n);\n\n    // global history\n    reg [6:0] ghist;\n\n    // pattern history table: 2-bit saturating counters\n    reg [1:0] pht [0:127];\n\n    integer i;\n    // reset and updates\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            ghist <= 7'd0;\n            for(i=0;i<128;i=i+1)\n                pht[i] <= 2'b01;  // weakly not-taken\n        end else begin\n            // 1) PHT training (always on train_valid)\n            if (train_valid) begin\n                case (pht[train_history ^ train_pc])\n                    2'b00: pht[train_history ^ train_pc] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_history ^ train_pc] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_history ^ train_pc] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_history ^ train_pc] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n            // 2) global-history update\n            if (train_valid && train_mispredicted) begin\n                // restore to state immediately after mispredicted branch\n                ghist <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // advance history with predicted outcome\n                ghist <= { ghist[5:0], pht[ghist ^ predict_pc][1] };\n            end\n        end\n    end\n\n    // combinational prediction outputs\n    wire [6:0] idx_pred = ghist ^ predict_pc;\n    assign predict_taken  = pht[idx_pred][1];\n    assign predict_history = ghist;\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        bump_left,\n    input        bump_right,\n    input        ground,\n    input        dig,\n    output       walk_left,\n    output       walk_right,\n    output       aaah,\n    output       digging\n);\n\n    // state encoding\n    localparam S_WL = 3'd0,\n               S_WR = 3'd1,\n               S_FL = 3'd2,\n               S_FR = 3'd3,\n               S_DL = 3'd4,\n               S_DR = 3'd5,\n               S_SP = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_count, next_count;  // to count up past 20\n\n    // sequential state + counter update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state      <= S_WL;\n            fall_count <= 6'd0;\n        end else begin\n            state      <= next_state;\n            fall_count <= next_count;\n        end\n    end\n\n    // combinational next-state + next-count logic\n    always @(*) begin\n        // defaults\n        next_state = state;\n        next_count = fall_count;\n\n        case (state)\n            // walking left\n            S_WL: begin\n                if (!ground) begin\n                    next_state = S_FL;\n                    next_count = 6'd1;\n                end else if (dig) begin\n                    next_state = S_DL;\n                    next_count = 6'd0;\n                end else if (bump_left || bump_right) begin\n                    next_state = S_WR;\n                    next_count = 6'd0;\n                end else begin\n                    next_state = S_WL;\n                    next_count = 6'd0;\n                end\n            end\n\n            // walking right\n            S_WR: begin\n                if (!ground) begin\n                    next_state = S_FR;\n                    next_count = 6'd1;\n                end else if (dig) begin\n                    next_state = S_DR;\n                    next_count = 6'd0;\n                end else if (bump_left || bump_right) begin\n                    next_state = S_WL;\n                    next_count = 6'd0;\n                end else begin\n                    next_state = S_WR;\n                    next_count = 6'd0;\n                end\n            end\n\n            // digging left\n            S_DL: begin\n                if (!ground) begin\n                    next_state = S_FL;\n                    next_count = 6'd1;\n                end else begin\n                    next_state = S_DL;\n                    next_count = 6'd0;\n                end\n            end\n\n            // digging right\n            S_DR: begin\n                if (!ground) begin\n                    next_state = S_FR;\n                    next_count = 6'd1;\n                end else begin\n                    next_state = S_DR;\n                    next_count = 6'd0;\n                end\n            end\n\n            // falling left\n            S_FL: begin\n                if (ground) begin\n                    if (fall_count > 6'd20) begin\n                        next_state = S_SP;\n                        next_count = 6'd0;\n                    end else begin\n                        next_state = S_WL;\n                        next_count = 6'd0;\n                    end\n                end else begin\n                    next_state = S_FL;\n                    next_count = fall_count + 6'd1;\n                end\n            end\n\n            // falling right\n            S_FR: begin\n                if (ground) begin\n                    if (fall_count > 6'd20) begin\n                        next_state = S_SP;\n                        next_count = 6'd0;\n                    end else begin\n                        next_state = S_WR;\n                        next_count = 6'd0;\n                    end\n                end else begin\n                    next_state = S_FR;\n                    next_count = fall_count + 6'd1;\n                end\n            end\n\n            // splattered forever\n            S_SP: begin\n                next_state = S_SP;\n                next_count = 6'd0;\n            end\n\n            default: begin\n                next_state = S_WL;\n                next_count = 6'd0;\n            end\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_WL);\n    assign walk_right = (state == S_WR);\n    assign aaah       = (state == S_FL) || (state == S_FR);\n    assign digging    = (state == S_DL) || (state == S_DR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input  clk,\n    input  reset,\n    input  data,\n    output reg shift_ena,\n    output reg counting,\n    input  done_counting,\n    output reg done,\n    input  ack\n);\n\n    // State encoding\n    localparam S0    = 3'd0,  // waiting for first '1'\n               S1    = 3'd1,  // saw \"1\"\n               S2    = 3'd2,  // saw \"11\"\n               S3    = 3'd3,  // saw \"110\"\n               SHIFT = 3'd4,  // shift in next 4 bits\n               COUNT = 3'd5,  // wait for done_counting\n               DONE  = 3'd6;  // assert done, wait for ack\n\n    reg [2:0] state, next_state;\n    reg [2:0] shift_cnt;\n\n    // State register and shift counter\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= S0;\n            shift_cnt <= 3'd0;\n        end else begin\n            state <= next_state;\n            // shift counter logic\n            if (state == SHIFT)\n                shift_cnt <= shift_cnt + 3'd1;\n            else\n                shift_cnt <= 3'd0;\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        // default\n        next_state = state;\n\n        case (state)\n            S0: begin\n                if (data)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n\n            S1: begin\n                if (data)\n                    next_state = S2;\n                else\n                    next_state = S0;\n            end\n\n            S2: begin\n                if (data)\n                    next_state = S2;   // stay if '1','11','111'...\n                else\n                    next_state = S3;   // saw \"110\"\n            end\n\n            S3: begin\n                if (data)\n                    next_state = SHIFT; // saw full \"1101\"\n                else\n                    next_state = S0;\n            end\n\n            SHIFT: begin\n                // shift for exactly 4 cycles (cnt = 0,1,2,3) then go COUNT\n                if (shift_cnt == 3'd3)\n                    next_state = COUNT;\n                else\n                    next_state = SHIFT;\n            end\n\n            COUNT: begin\n                if (done_counting)\n                    next_state = DONE;\n                else\n                    next_state = COUNT;\n            end\n\n            DONE: begin\n                if (ack)\n                    next_state = S0;\n                else\n                    next_state = DONE;\n            end\n\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore outputs)\n    always @(*) begin\n        // defaults\n        shift_ena = 1'b0;\n        counting  = 1'b0;\n        done      = 1'b0;\n\n        case (state)\n            SHIFT: shift_ena = 1'b1;\n            COUNT: counting  = 1'b1;\n            DONE:  done      = 1'b1;\n            default: ;\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input      [255:0]  data,\n    output reg [255:0]  q\n);\n\n    // next state\n    reg [255:0] next_q;\n    integer r, c, nr, nc;\n    integer sum;\n    integer idx, nidx;\n    integer rwrap, cwrap;\n\n    // compute next generation combinationally\n    always @* begin\n        for (r = 0; r < 16; r = r + 1) begin\n            for (c = 0; c < 16; c = c + 1) begin\n                sum = 0;\n                // accumulate 8 neighbors with toroidal wrap\n                for (nr = r - 1; nr <= r + 1; nr = nr + 1) begin\n                    for (nc = c - 1; nc <= c + 1; nc = nc + 1) begin\n                        if (!(nr == r && nc == c)) begin\n                            rwrap = (nr + 16) % 16;\n                            cwrap = (nc + 16) % 16;\n                            nidx  = rwrap * 16 + cwrap;\n                            sum   = sum + q[nidx];\n                        end\n                    end\n                end\n                idx = r * 16 + c;\n                // apply rules:\n                // sum == 3 => cell alive\n                // sum == 2 => cell retains current state\n                // otherwise    => dead\n                if (sum == 3)\n                    next_q[idx] = 1'b1;\n                else if (sum == 2)\n                    next_q[idx] = q[idx];\n                else\n                    next_q[idx] = 1'b0;\n            end\n        end\n    end\n\n    // state register with synchronous load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input       clk,\n    input       areset,\n    input       bump_left,\n    input       bump_right,\n    input       ground,\n    input       dig,\n    output      walk_left,\n    output      walk_right,\n    output      aaah,\n    output      digging\n);\n\n    // State encoding\n    localparam WL = 3'd0, // walking left\n               WR = 3'd1, // walking right\n               FL = 3'd2, // falling left\n               FR = 3'd3, // falling right\n               DL = 3'd4, // digging left\n               DR = 3'd5; // digging right\n\n    reg [2:0] state, next_state;\n    wire bumped = bump_left | bump_right;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WL;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;  // default: stay\n        case (state)\n            // WALKING LEFT\n            WL: begin\n                if (!ground)      next_state = FL;       // fall\n                else if (dig)     next_state = DL;       // dig\n                else if (bumped)  next_state = WR;       // switch\n            end\n            // WALKING RIGHT\n            WR: begin\n                if (!ground)      next_state = FR;\n                else if (dig)     next_state = DR;\n                else if (bumped)  next_state = WL;\n            end\n            // FALLING LEFT\n            FL: begin\n                if (ground)       next_state = WL;       // land and walk left\n                else              next_state = FL;\n            end\n            // FALLING RIGHT\n            FR: begin\n                if (ground)       next_state = WR;\n                else              next_state = FR;\n            end\n            // DIGGING LEFT\n            DL: begin\n                if (!ground)      next_state = FL;       // dig off cliff \u2192 fall\n                else              next_state = DL;\n            end\n            // DIGGING RIGHT\n            DR: begin\n                if (!ground)      next_state = FR;\n                else              next_state = DR;\n            end\n            default: next_state = WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n    assign digging    = (state == DL) || (state == DR);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00:00 AM\n            hh <= 8'h12;  \n            mm <= 8'h00;\n            ss <= 8'h00;\n            pm <= 1'b0;\n        end else if (ena) begin\n            // Seconds BCD increment\n            if (ss[3:0] != 4'd9) begin\n                ss[3:0] <= ss[3:0] + 1;\n            end else begin\n                ss[3:0] <= 4'd0;\n                if (ss[7:4] != 4'd5) begin\n                    ss[7:4] <= ss[7:4] + 1;\n                end else begin\n                    ss[7:4] <= 4'd0;\n                    // Minutes BCD increment\n                    if (mm[3:0] != 4'd9) begin\n                        mm[3:0] <= mm[3:0] + 1;\n                    end else begin\n                        mm[3:0] <= 4'd0;\n                        if (mm[7:4] != 4'd5) begin\n                            mm[7:4] <= mm[7:4] + 1;\n                        end else begin\n                            mm[7:4] <= 4'd0;\n                            // Hours 12\u2011hour BCD increment with AM/PM toggle\n                            if (hh == 8'h11) begin\n                                hh <= 8'h12;\n                                pm <= ~pm;\n                            end else if (hh == 8'h12) begin\n                                hh <= 8'h01;\n                            end else if (hh[3:0] != 4'd9) begin\n                                hh[3:0] <= hh[3:0] + 1;\n                            end else begin\n                                // e.g. from 09 to 10\n                                hh[3:0] <= 4'd0;\n                                hh[7:4] <= hh[7:4] + 1;\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        bump_left,\n    input        bump_right,\n    input        ground,\n    output       walk_left,\n    output       walk_right,\n    output       aaah\n);\n\n    // State encoding\n    localparam [1:0]\n        W_L = 2'b00,  // walking left\n        W_R = 2'b01,  // walking right\n        F_L = 2'b10,  // falling (was walking left)\n        F_R = 2'b11;  // falling (was walking right)\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous, posedge-reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= W_L;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            W_L: begin\n                if (!ground)\n                    next_state = F_L;\n                else if (bump_left | bump_right)\n                    next_state = W_R;\n            end\n            W_R: begin\n                if (!ground)\n                    next_state = F_R;\n                else if (bump_left | bump_right)\n                    next_state = W_L;\n            end\n            F_L: begin\n                if (ground)\n                    next_state = W_L;\n            end\n            F_R: begin\n                if (ground)\n                    next_state = W_R;\n            end\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == W_L);\n    assign walk_right = (state == W_R);\n    assign aaah       = (state == F_L) || (state == F_R);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input       clk,\n    input       reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n    // Generate enable pulses for carry\u2010out of each BCD digit\n    // ena[1] \u2192 increment tens when ones == 9\n    // ena[2] \u2192 increment hundreds when ones==9 & tens==9\n    // ena[3] \u2192 increment thousands when ones==9 & tens==9 & hundreds==9\n    assign ena[1] = (q[3:0]   == 4'd9);\n    assign ena[2] = ena[1] & (q[7:4]   == 4'd9);\n    assign ena[3] = ena[2] & (q[11:8]  == 4'd9);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 1'b1;\n\n            // tens digit\n            if (ena[1]) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 1'b1;\n            end\n\n            // hundreds digit\n            if (ena[2]) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 1'b1;\n            end\n\n            // thousands digit\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 1'b1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: when sel=0 -> a, when sel=1 -> b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,\n    input        w,\n    output reg   Y2\n);\n\n    // Next\u2010state bit y[2] for states A=000, B=001, C=010, D=011, E=100, F=101\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0;   // A: next = B (001) \u2192 bit2=0\n            3'b001: Y2 = 1'b1;   // B: next = C/D (010/011) \u2192 bit2=1\n            3'b010: Y2 = w;      // C: next = E(100)/D(011) \u2192 bit2 = 0/1 \u2192 w\n            3'b011: Y2 = 1'b0;   // D: next = F/A (101/000) \u2192 bit2=0\n            3'b100: Y2 = w;      // E: next = E/D (100/011) \u2192 bit2 = 0/1 \u2192 w\n            3'b101: Y2 = 1'b1;   // F: next = C/D (010/011) \u2192 bit2=1\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring,\n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If ring is asserted, choose ringer or motor based on vibrate_mode\n    assign motor  = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // Continuous\u2010assignment AND\n    assign out_assign = a & b;\n\n    // Combinational\u2010always AND\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Constant zero output\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clk,\n    input  a,\n    output reg q\n);\n    // we need one flip\u2010flop to remember the previous 'a'\n    reg prev_a;\n\n    always @(posedge clk) begin\n        // Detect two consecutive 0's \u2192 set q=1\n        if (!prev_a && !a)\n            q <= 1;\n        // Detect two consecutive 1's \u2192 set q=0\n        else if (prev_a && a)\n            q <= 0;\n        // else keep q unchanged\n\n        // shift in the current 'a' for next comparison\n        prev_a <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  x,\n    output z\n);\n\n    // State encoding\n    localparam ADD  = 1'b0;  // still propagating the +1 carry\n    localparam INV  = 1'b1;  // carry has been absorbed; now invert remaining bits\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= ADD;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            ADD:  next_state = x ? INV : ADD;  // on first '1' move to INV\n            INV:  next_state = INV;            // stay inverted\n            default: next_state = ADD;\n        endcase\n    end\n\n    // Output logic (Moore\u2010type except z depends on input)\n    assign z = (state == ADD) ? x    // still adding the +1, so pass x\n                            : ~x;   // after carry is gone, output bitwise invert\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output reg   out\n);\n\n    // State encoding\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state and output logic (Moore machine)\n    always @(*) begin\n        // defaults\n        next_state = A;\n        out        = 1'b0;\n        case (state)\n            A: begin\n                out        = 1'b0;\n                next_state = in ? B : A;\n            end\n            B: begin\n                out        = 1'b0;\n                next_state = in ? B : C;\n            end\n            C: begin\n                out        = 1'b0;\n                next_state = in ? D : A;\n            end\n            D: begin\n                out        = 1'b1;\n                next_state = in ? B : C;\n            end\n        endcase\n    end\n\n    // State register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse byte order: {B0, B1, B2, B3} -> {B3, B2, B1, B0}\n    assign out = { in[7:0],\n                   in[15:8],\n                   in[23:16],\n                   in[31:24] };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // Synchronous active\u2010high reset D\u2010FF\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input  clk,\n    input  load,\n    input  ena,\n    input  [1:0] amount,\n    input  [63:0] data,\n    output reg [63:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00:  q <= {q[62:0],      1'b0};                 // shift left by 1\n                2'b01:  q <= {q[55:0],      8'b0};                 // shift left by 8\n                2'b10:  q <= {q[63],        q[63:1]};              // arithmetic right by 1\n                2'b11:  q <= {{8{q[63]}},   q[63:8]};              // arithmetic right by 8\n                default: q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  aresetn,\n    input  x,\n    output reg z\n);\n\n    // state encoding\n    localparam S0 = 2'd0,  // no bits matched\n               S1 = 2'd1,  // seen \"1\"\n               S2 = 2'd2;  // seen \"10\"\n\n    reg [1:0] state, next_state;\n\n    // state register with negative\u2010edge async reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // next state logic and Mealy output\n    always @(*) begin\n        // defaults\n        next_state = state;\n        z          = 1'b0;\n\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n\n            S1: begin\n                if (x)\n                    next_state = S1;  // still just \"1\"\n                else\n                    next_state = S2;  // \"10\"\n            end\n\n            S2: begin\n                if (x) begin\n                    next_state = S1;  // overlap: last '1'\n                    z          = 1'b1; // detected \"101\"\n                end else begin\n                    next_state = S0;  // \"100\" \u2192 no match\n                end\n            end\n\n            default: begin\n                next_state = S0;\n                z          = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,\n    input  w,\n    output reg z\n);\n    // state encoding\n    localparam [2:0]\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // output logic (Moore: output depends only on state)\n    always @(*) begin\n        case (state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output [23:0] out_bytes,\n    output       done\n);\n\n    // State encoding\n    localparam IDLE = 2'd0,\n               B1   = 2'd1,\n               B2   = 2'd2;\n\n    reg [1:0]    state;\n    reg [23:0]   out_reg;\n    reg          done_reg;\n\n    // synchronous FSM + datapath\n    always @(posedge clk) begin\n        if (reset) begin\n            state    <= IDLE;\n            out_reg  <= 24'b0;\n            done_reg <= 1'b0;\n        end else begin\n            // default\n            done_reg <= 1'b0;\n            case (state)\n                IDLE: begin\n                    if (in[3]) begin\n                        // first byte\n                        out_reg[23:16] <= in;\n                        state          <= B1;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n\n                B1: begin\n                    // second byte\n                    out_reg[15:8] <= in;\n                    state         <= B2;\n                end\n\n                B2: begin\n                    // third byte, assert done\n                    out_reg[7:0] <= in;\n                    done_reg     <= 1'b1;\n                    state        <= IDLE;\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign out_bytes = out_reg;\n    assign done      = done_reg;\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,\n    input        w,\n    output       Y1,\n    output       Y3\n);\n\n    // One\u2010hot state encoding:\n    // y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n\n    // Y1 = next\u2010state input for B: only A--1-->B\n    assign Y1 = y[0] & w;\n\n    // Y3 = next\u2010state input for D: B--0-->D, C--0-->D, E--0-->D, F--0-->D\n    assign Y3 = ~w & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the entire vector\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // From the K\u2011map one finds\n    // out = a \u2295 b \u2295 c \u2295 d\n\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Split the 16\u2011bit half\u2011word into upper and lower bytes\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // NOR gate implementation\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a, \n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) clocked always block (registered) XOR\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one-hot: y[1]=A, y[2]=B, y[3]=C, y[4]=D, y[5]=E, y[6]=F\n    input        w,\n    output       Y2, // next\u2010state bit for B\n    output       Y4  // next\u2010state bit for D\n);\n\n    // Next\u2010state for B occurs only when current state is A (y[1]) and w=0\n    assign Y2 = y[1] & ~w;\n\n    // Next\u2010state for D occurs when any of B, C, E, or F sees w=1\n    // (B->D, C->D, E->D, F->D on w=1)\n    assign Y4 = w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input  [7:0]   sel,\n    output         out\n);\n    // 256\u2010to\u20101 mux: select bit sel of vector in\n    assign out = in[sel];\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // On each rising clock edge, choose between load, shift, or hold\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;      // load mode\n        else if (E)\n            Q <= w;      // shift mode\n        // else hold Q (no assignment needed)\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  x,\n    output z\n);\n\n    // state bits Q[2:0] correspond to the three D\u2010flip\u2010flops\n    reg [2:0] Q;\n    wire [2:0] D;\n\n    // next\u2010state logic:  \n    // D[0] = x XOR Q[0]\n    // D[1] = x AND ~Q[1]\n    // D[2] = x OR  ~Q[2]\n    assign D[0] = x ^  Q[0];\n    assign D[1] = x & ~Q[1];\n    assign D[2] = x | ~Q[2];\n\n    // state registers\n    always @(posedge clk) begin\n        Q <= D;\n    end\n\n    // three\u2010input XNOR output\n    // reduction XNOR (~^) produces 1 if an even number of 1\u2019s in Q\n    assign z = ~^Q;\n\n    // initialize flip\u2010flops to zero\n    initial Q = 3'b000;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table, q = 1 whenever b=1 or c=1, else q=0.\n    assign q = b | c;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // Compute neighbours with zero boundary\n    wire [511:0] left, right, next_q;\n    assign left   = {q[510:0], 1'b0};   // left neighbour; q[-1] = 0\n    assign right  = {1'b0, q[511:1]};   // right neighbour; q[512] = 0\n\n    // Rule 110: next = (~left & center) | (center ^ right)\n    assign next_q = (~left & q) | (q ^ right);\n\n    // synchronous load or advance\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // state encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    // combinational 8\u2011bit 2:1 mux\n    always @(*) begin\n        out = sel ? b : a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input        clk,\n    input        L,\n    input        q_in,\n    input        r_in,\n    output reg   Q\n);\n\n    // select load vs. shift data\n    wire D;\n    assign D = L ? r_in : q_in;\n\n    // rising\u2010edge D\u2010FF\n    always @(posedge clk) begin\n        Q <= D;\n    end\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,  // active\u2010high synchronous reset\n    input      [31:0] in,\n    output reg [31:0] out\n);\n\n    // register to hold the previous cycle's 'in' value\n    reg [31:0] in_d;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out  <= 32'b0;\n            in_d <= 32'b0;\n        end else begin\n            // detect 1->0 transitions: previous=1 and current=0\n            // OR it into 'out' so once set it stays high until reset\n            out  <= out | (in_d & ~in);\n            // update previous value\n            in_d <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, capture the 8\u2010bit input into 8 DFFs\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // 9\u2011bit addition with sign\u2011extension\n    wire [8:0] sum9;\n    assign sum9     = {a[7], a} + {b[7], b};\n    assign s        = sum9[7:0];\n    // signed overflow if the carry into the sign bit differs from the carry out\n    assign overflow = sum9[8] ^ sum9[7];\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input  d,\n    input  done_counting,\n    input  ack,\n    input  [9:0] state,    // one\u2010hot: [0]=S, [1]=S1, [2]=S11, [3]=S110, [4]=B0, [5]=B1, [6]=B2, [7]=B3, [8]=Count, [9]=Wait\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n  // next\u2010state logic\n  // S_next: from S,S1,S110 on d=0, or from Wait on ack=1\n  assign S_next      = (state[0] & ~d)\n                     | (state[1] & ~d)\n                     | (state[3] & ~d)\n                     | (state[9] &  ack);\n\n  // S1_next: from S on d=1\n  assign S1_next     = (state[0] & d);\n\n  // B3_next: from B2 always\n  assign B3_next     = state[6];\n\n  // Count_next: from B3 always, or stay in Count while !done_counting\n  assign Count_next  = state[7]\n                     | (state[8] & ~done_counting);\n\n  // Wait_next: from Count when done_counting, or stay in Wait while ack=0\n  assign Wait_next   = (state[8] &  done_counting)\n                     | (state[9] & ~ack);\n\n  // output logic\n  assign done        = state[9];             // Wait state\n  assign counting    = state[8];             // Count state\n  assign shift_ena   = state[4]\n                     | state[5]\n                     | state[6]\n                     | state[7];             // B0\u2013B3\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic       clk,\n    input  logic       areset,\n    input  logic       train_valid,\n    input  logic       train_taken,\n    output logic [1:0] state\n);\n\n  // Asynchronous reset to weakly not\u2011taken (2\u2019b01), saturating 2\u2011bit counter\n  always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= 2'b01;\n    end else begin\n      if (train_valid) begin\n        if (train_taken) begin\n          // increment, saturate at 3\n          if (state != 2'b11)\n            state <= state + 1'b1;\n        end else begin\n          // decrement, saturate at 0\n          if (state != 2'b00)\n            state <= state - 1'b1;\n        end\n      end\n      // else keep current state\n    end\n  end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;  // no bits set\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\n    always @(*) begin\n        // default all outputs low\n        left  = 1'b0;\n        down  = 1'b0;\n        right = 1'b0;\n        up    = 1'b0;\n\n        case (scancode)\n            16'he06b: left  = 1'b1;  // left arrow\n            16'he072: down  = 1'b1;  // down arrow\n            16'he074: right = 1'b1;  // right arrow\n            16'he075: up    = 1'b1;  // up arrow\n            default:               ;  // none\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n    // internal carry signals\n    wire c0, c1, c2, c3;\n\n    // initial carry in = 0\n    assign c0 = 1'b0;\n\n    // instantiate four full adders\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (c0),\n        .sum (sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c1),\n        .sum (sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c2),\n        .sum (sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c3),\n        .sum (sum[3]),\n        .cout(sum[4])   // overflow bit\n    );\nendmodule\n\n\n// simple full adder\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    // sum = a \u2295 b \u2295 cin\n    // cout = majority(a,b,cin)\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n    \n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // history register: [0] = most recent branch outcome\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            // rollback to just\u2010after actual outcome of mispredicted branch\n            predict_history <= { train_history[30:0], train_taken };\n        end else if (predict_valid) begin\n            // shift in speculative prediction\n            predict_history <= { predict_history[30:0], predict_taken };\n        end\n        // else hold\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n\n    // intermediate wires\n    wire w1;\n    wire w2;\n\n    // first layer: two AND gates\n    and and1(w1, a, b);\n    and and2(w2, c, d);\n\n    // second layer: OR gate driving out\n    or  or1(out, w1, w2);\n\n    // inverted output\n    not not1(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // On every rising edge of the clock, capture d\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        enable,\n    input        S,\n    input        A,\n    input        B,\n    input        C,\n    output reg   Z\n);\n    // 8\u2011bit shift register\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            // shift right: new Q[0] <= S, Q[i] <= old Q[i-1]\n            Q[7] <= Q[6];\n            Q[6] <= Q[5];\n            Q[5] <= Q[4];\n            Q[4] <= Q[3];\n            Q[3] <= Q[2];\n            Q[2] <= Q[1];\n            Q[1] <= Q[0];\n            Q[0] <= S;\n        end\n    end\n\n    // 8\u2011to\u20111 multiplexer controlled by ABC\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold, \n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater on only in heating mode when it's too cold\n    assign heater = mode & too_cold;\n\n    // Air conditioner on only in cooling mode when it's too hot\n    assign aircon = ~mode & too_hot;\n\n    // Fan on if heater or aircon is on, or if user requests it\n    assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [31:0] q\n);\n\n    // tap positions: 32,22,2,1 \u2192 bits [31,21,1,0]\n    localparam [31:0] TAP_MASK = 32'h8020_0003;\n\n    wire feedback    = q[0];\n    wire [31:0] sh    = {feedback, q[31:1]};\n    wire [31:0] nextq = sh ^ ({32{feedback}} & TAP_MASK);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 32'h0000_0001;\n        else\n            q <= nextq;\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table one finds\n    //    q = (a OR b) AND (c OR d)\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Two independent 4\u2010input NAND gates\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @* begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1)\n            out = out + in[i];\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) both this bit and its left\u2010neighbour are 1\n    //   out_both[2] = in[3]&in[2], out_both[1] = in[2]&in[1], out_both[0] = in[1]&in[0]\n    assign out_both      = in[3:1] & in[2:0];\n\n    // (2) any of this bit or its right\u2010neighbour is 1\n    //   out_any[3] = in[3]|in[2], out_any[2] = in[2]|in[1], out_any[1] = in[1]|in[0]\n    assign out_any       = in[3:1] | in[2:0];\n\n    // (3) this bit differs from its left\u2010neighbour (wrapping)\n    //   neighbour\u2010left vector = {in[0],in[3],in[2],in[1]}\n    assign out_different = in ^ { in[0], in[3:1] };\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0] a, \n    output reg [15:0] q\n);\n\n    // Combinational lookup table implemented with a case statement\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        slowena,\n    input        reset,   // synchronous active\u2010high reset\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n        // else: hold q\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // out is asserted when in1 is high AND in2 is low (bubble on in2)\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Combinational assignment\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding: A = 0, B = 1\n    reg state, next_state;\n\n    // Moore output depends only on current state\n    assign out = state;\n\n    // Next\u2010state logic\n    // From B(1): in=0 \u2192 A(0), in=1 \u2192 B(1)\n    // From A(0): in=0 \u2192 B(1), in=1 \u2192 A(0)\n    always @(*) begin\n        case (state)\n            1'b0: next_state = (in ? 1'b0 : 1'b1); // A\n            1'b1: next_state = (in ? 1'b1 : 1'b0); // B\n            default: next_state = 1'b1;\n        endcase\n    end\n\n    // State register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 1'b1;  // reset \u2192 B\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // Internal registers to capture on posedge and negedge\n    reg q_pos, q_neg;\n\n    // Capture d on the rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // Capture d on the falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // Mux between the two captures based on current clock level\n    always @(*) begin\n        if (clk)\n            q = q_pos;\n        else\n            q = q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // XNOR implementation: out is high when a and b are equal\n    assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    // From the waveform B outputs 1 when x==y, else 0 \u21d2 XNOR\n    assign z = ~(x ^ y);\nendmodule\n\nmodule top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1, b1, a2, b2;\n    wire or_out, and_out;\n\n    // First A\u2013B pair into OR\n    A A1(.x(x), .y(y), .z(a1));\n    B B1(.x(x), .y(y), .z(b1));\n    assign or_out  = a1 | b1;\n\n    // Second A\u2013B pair into AND\n    A A2(.x(x), .y(y), .z(a2));\n    B B2(.x(x), .y(y), .z(b2));\n    assign and_out = a2 & b2;\n\n    // Final XOR\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input       [1:0]   ena,\n    input       [99:0]  data,\n    output reg  [99:0]  q\n);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else if (ena == 2'b01)        // rotate right\n            q <= {q[0], q[99:1]};\n        else if (ena == 2'b10)        // rotate left\n            q <= {q[98:0], q[99]};\n        // else ena==00 or 11: hold q\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous\n    output reg [9:0] q    // counts 0..999\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 10'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Invert the input\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    // next\u2010state logic for one\u2010hot encoded FSM\n    assign next_state[0] = ~in & (state[0] | state[1] | state[2] |\n                                  state[3] | state[4] | state[7] |\n                                  state[8] | state[9]);\n    assign next_state[1] =  in & (state[0] | state[8] | state[9]);\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & (state[6] | state[7]);\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // output logic\n    // S7: (0,1), S8: (1,0), S9: (1,1)\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // no change\n            2'b01: Q <= 1'b0;   // reset\n            2'b10: Q <= 1'b1;   // set\n            2'b11: Q <= ~Q;     // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n\n    // Zero\u2010extend each bit to 2 bits, then add.\n    assign out = {1'b0, in[0]}\n               + {1'b0, in[1]}\n               + {1'b0, in[2]};\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // 5\u00d75 comparisons: out[24]=~a^a, out[23]=~a^b, \u2026, out[1]=~e^d, out[0]=~e^e\n    assign out = {\n        ~a ^ a, ~a ^ b, ~a ^ c, ~a ^ d, ~a ^ e,\n        ~b ^ a, ~b ^ b, ~b ^ c, ~b ^ d, ~b ^ e,\n        ~c ^ a, ~c ^ b, ~c ^ c, ~c ^ d, ~c ^ e,\n        ~d ^ a, ~d ^ b, ~d ^ c, ~d ^ d, ~d ^ e,\n        ~e ^ a, ~e ^ b, ~e ^ c, ~e ^ d, ~e ^ e\n    };\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,      // async, active\u2010high\n    input        bump_left,\n    input        bump_right,\n    output       walk_left,\n    output       walk_right\n);\n\n    // state encoding: 0 = walking left, 1 = walking right\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 1'b0;      // reset to walk_left\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    // if any bump => flip direction, else stay\n    always @(*) begin\n        if (bump_left | bump_right)\n            next_state = ~state;\n        else\n            next_state = state;\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == 1'b0);\n    assign walk_right = (state == 1'b1);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n\n    // From the waveform: q is 1 only when a=1 and b=1\n    assign q = a & b;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Intermediate wires for the four AND\u2010gates\n    wire p1g1, p1g2;\n    wire p2g1, p2g2;\n\n    // 3\u2010input ANDs for p1\n    assign p1g1 = p1a & p1b & p1c;\n    assign p1g2 = p1d & p1e & p1f;\n    // OR them for p1y\n    assign p1y  = p1g1 | p1g2;\n\n    // 2\u2010input ANDs for p2\n    assign p2g1 = p2a & p2b;\n    assign p2g2 = p2c & p2d;\n    // OR them for p2y\n    assign p2y  = p2g1 | p2g2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,  // not used \u2013 next\u2010state and output are purely combinational\n    input        x,\n    input  [2:0] y,\n    output reg   Y0,\n    output reg   z\n);\n\n    // Combinational logic for next\u2010state bit Y[0] and output z\n    always @(*) begin\n        // default values\n        Y0 = 1'b0;\n        z  = 1'b0;\n\n        // next\u2010state LSB\n        case (y)\n            3'b000: Y0 =  x;   // 000 \u2192 (x?001:000)\n            3'b001: Y0 = ~x;   // 001 \u2192 (x?100:001)\n            3'b010: Y0 =  x;   // 010 \u2192 (x?001:010)\n            3'b011: Y0 = ~x;   // 011 \u2192 (x?010:001)\n            3'b100: Y0 = ~x;   // 100 \u2192 (x?100:011)\n            default: Y0 = 1'b0;\n        endcase\n\n        // output z = 1 in states 011 or 100 (Moore\u2010type output)\n        if (y == 3'b011 || y == 3'b100)\n            z = 1'b1;\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2-input NOR: out is 1 only when both in1 and in2 are 0\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n    // wire-like connections\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        d,\n    input        ar,\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous reset (active high)\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] count;\n\n    // On each rising clock edge, either load the counter or decrement it\n    always @(posedge clk) begin\n        if (load) begin\n            count <= data;         // load new timeout value\n        end else if (count != 0) begin\n            count <= count - 1;    // count down until zero\n        end\n        // else count == 0: hold at zero\n    end\n\n    // terminal count is asserted when counter has reached zero\n    assign tc = (count == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,          // active\u2010high synchronous reset\n    input        data,\n    output       start_shifting\n);\n\n    // state encoding\n    localparam S0   = 3'd0;  // no bits matched\n    localparam S1   = 3'd1;  // seen \"1\"\n    localparam S2   = 3'd2;  // seen \"11\"\n    localparam S3   = 3'd3;  // seen \"110\"\n    localparam DONE = 3'd4;  // seen \"1101\", latch forever\n\n    reg [2:0] state, next_state;\n\n    // state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            S0:   next_state = data ? S1   : S0;\n            S1:   next_state = data ? S2   : S0;\n            S2:   next_state = data ? S2   : S3;  // stay on S2 if '1', else go to S3\n            S3:   next_state = data ? DONE : S0;  // if '1' complete sequence, else restart\n            DONE: next_state = DONE;              // once done, stay here\n            default: next_state = S0;\n        endcase\n    end\n\n    // output: asserted in DONE state forever until reset\n    assign start_shifting = (state == DONE);\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // On each rising edge of clk, if reset is high, clear q to zero,\n    // otherwise load q with d.\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // register to hold previous cycle's inputs\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        // capture previous input\n        in_d    <= in;\n        // detect rising edge (0->1)\n        // this will go high one cycle after the transition\n        anyedge <= in & ~in_d;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // synchronous active\u2010high reset\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 4'd1;\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            // when a is high, force q to 4\n            q <= 3'd4;\n        end else begin\n            // when a is low, count 4\u21925\u21926\u21920\u21921\u2026 modulo\u20107\n            if (q == 3'd6)\n                q <= 3'd0;\n            else\n                q <= q + 3'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": ""}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input             do_sub,\n    input      [7:0]  a,\n    input      [7:0]  b,\n    output reg [7:0]  out,\n    output reg        result_is_zero\n);\n\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // set zero flag\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // x[3]\u00b7!x[1]  +  !x[3]\u00b7x[1]\u00b7x[2]\n    assign f = (x[3] & ~x[1]) \n             | (~x[3] &  x[1] & x[2]);\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n    always @(*) begin\n        valid = 1'b0;\n        out   = 4'd0;\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1'b1; end\n            8'h16: begin out = 4'd1; valid = 1'b1; end\n            8'h1E: begin out = 4'd2; valid = 1'b1; end\n            8'h26: begin out = 4'd3; valid = 1'b1; end\n            8'h25: begin out = 4'd4; valid = 1'b1; end\n            8'h2E: begin out = 4'd5; valid = 1'b1; end\n            8'h36: begin out = 4'd6; valid = 1'b1; end\n            8'h3D: begin out = 4'd7; valid = 1'b1; end\n            8'h3E: begin out = 4'd8; valid = 1'b1; end\n            8'h46: begin out = 4'd9; valid = 1'b1; end\n            default: begin\n                out   = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse bit order\n    assign out = {in[0], in[1], in[2], in[3],\n                  in[4], in[5], in[6], in[7]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a, \n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // Simplified from the K\u2010map (using d\u2010care to maximize groupings):\n    //  f = \u03a3m(2,3,6,7,8,10,11,12,14,15) with dc at (4,9,13)\n    //  yields f = a + c\n\n    always @(*) begin\n        out = a | c;\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift left, MSB first\n            q <= { q[2:0], data };\n        end else if (count_ena) begin\n            // down\u2010count\n            q <= q - 1;\n        end\n        // else q retains its value\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // simply connect input to output\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,               // active\u2010high synchronous reset\n    input  pattern_detected,    // one\u2010cycle pulse when pattern is seen\n    output shift_ena\n);\n\n    reg [2:0] cnt;\n\n    // count down 4 cycles on reset or on a new pattern_detected,\n    // then stay at 0 until the next pattern_detected or reset\n    always @(posedge clk) begin\n        if (reset || (pattern_detected && cnt==0))\n            cnt <= 3'd4;\n        else if (cnt > 0)\n            cnt <= cnt - 3'd1;\n    end\n\n    assign shift_ena = (cnt != 0);\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;  // 4-bit wrap-around yields period 16\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Combinational mux using continuous assignment\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Combinational mux using procedural if\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a, \n    input  b,\n    input  c,\n    output out\n);\n\n    // From the K\u2010map, out = 1 for every combination except a=b=c=0\n    // which is exactly the 3\u2010input OR function.\n    assign out = a | b | c;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,   // active\u2010low synchronous reset\n    input  [3:1] r,        // request lines r[1],r[2],r[3]\n    output [3:1] g         // grant lines g[1],g[2],g[3]\n);\n\n    // State encoding\n    localparam A = 2'b00, \n               B = 2'b01, \n               C = 2'b10, \n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with synchronous active\u2010low reset\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;  // default: hold\n        case (state)\n            A: begin\n                // priority 1 > 2 > 3\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                // stay in B while r[1]=1, else go back to A\n                next_state = r[1] ? B : A;\n            end\n            C: begin\n                // stay in C while r[2]=1, else go back to A\n                next_state = r[2] ? C : A;\n            end\n            D: begin\n                // stay in D while r[3]=1, else go back to A\n                next_state = r[3] ? D : A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 4'd1;\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,  // synchronous, active\u2010high\n    output       done\n);\n\n    reg [1:0] cnt;\n    reg       done_reg;\n    assign    done = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cnt      <= 2'd0;\n            done_reg <= 1'b0;\n        end else begin\n            // default: only one\u2010cycle pulse\n            done_reg <= 1'b0;\n            case (cnt)\n                2'd0: begin\n                    // waiting for start byte\n                    if (in[3])\n                        cnt <= 2'd1;\n                    else\n                        cnt <= 2'd0;\n                end\n                2'd1: begin\n                    // second byte\n                    cnt <= 2'd2;\n                end\n                2'd2: begin\n                    // third byte \u2192 signal done next cycle\n                    cnt      <= 2'd0;\n                    done_reg <= 1'b1;\n                end\n                default: begin\n                    cnt <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 multiplexer: when sel==0 choose a, when sel==1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // 4\u2011input AND, OR, XOR using Verilog reduction operators\n    assign out_and = &in;   // reduction AND of all bits\n    assign out_or  = |in;   // reduction OR  of all bits\n    assign out_xor = ^in;   // reduction XOR of all bits\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // synchronous, active\u2011high\n    input        x,\n    output reg   z\n);\n\n    // state encoding\n    reg [2:0] state, next_state;\n    \n    // synchronous state register\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state and output logic (Moore)\n    always @(*) begin\n        // defaults to avoid latches\n        next_state = 3'b000;\n        z          = 1'b0;\n        case (state)\n            3'b000: begin\n                z          = 1'b0;\n                next_state = (x ? 3'b001 : 3'b000);\n            end\n            3'b001: begin\n                z          = 1'b0;\n                next_state = (x ? 3'b100 : 3'b001);\n            end\n            3'b010: begin\n                z          = 1'b0;\n                next_state = (x ? 3'b001 : 3'b010);\n            end\n            3'b011: begin\n                z          = 1'b1;\n                next_state = (x ? 3'b010 : 3'b001);\n            end\n            3'b100: begin\n                z          = 1'b1;\n                next_state = (x ? 3'b100 : 3'b011);\n            end\n            default: begin\n                // safe reset fallback\n                z          = 1'b0;\n                next_state = 3'b000;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // synchronous, active low\n    input  x,\n    input  y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    localparam IDLE    = 4'd0,\n               PULSEF  = 4'd1,\n               S0      = 4'd2,  // waiting for first '1'\n               S1      = 4'd3,  // saw '1'\n               S10     = 4'd4,  // saw '10'\n               D0      = 4'd5,  // g=1, cycle 0 of y-monitor\n               D1      = 4'd6,  // g=1, cycle 1 of y-monitor\n               G_OK    = 4'd7,  // g=1 forever\n               G_FAIL  = 4'd8;  // g=0 forever\n\n    reg [3:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                // wait for resetn deassertion\n                if (resetn)\n                    next_state = PULSEF;\n            end\n\n            PULSEF: begin\n                // one cycle of f=1\n                next_state = S0;\n            end\n\n            // 1\u20100\u20101 sequence detector\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n\n            S1: begin\n                if (!x)\n                    next_state = S10;\n                else\n                    next_state = S1; // stay if x==1 (overlap support)\n            end\n\n            S10: begin\n                if (x)\n                    next_state = D0; // detected 1-0-1\n                else\n                    next_state = S0; // restart\n            end\n\n            // g=1 for up to two cycles, watch y\n            D0: begin\n                if (y)\n                    next_state = G_OK;\n                else\n                    next_state = D1;\n            end\n\n            D1: begin\n                if (y)\n                    next_state = G_OK;\n                else\n                    next_state = G_FAIL;\n            end\n\n            // permanent end states\n            G_OK:   next_state = G_OK; \n            G_FAIL: next_state = G_FAIL;\n\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic (Moore)\n    always @(*) begin\n        // default outputs\n        f = 1'b0;\n        g = 1'b0;\n        case (state)\n            PULSEF: f = 1'b1;\n            D0,\n            D1,\n            G_OK:   g = 1'b1;\n            // G_FAIL, S*, IDLE: f=0, g=0\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // Synchronous, active\u2010high reset to 0x34 on the negedge of clk\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n\n    // even parity bit = XOR\u2010reduction of all 8 data bits\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n// Next\u2010state logic\nalways @(*) begin\n    case (state)\n        2'b00: next_state = in ? 2'b01 : 2'b00;  // A: in=0->A, in=1->B\n        2'b01: next_state = in ? 2'b01 : 2'b10;  // B: in=0->C, in=1->B\n        2'b10: next_state = in ? 2'b11 : 2'b00;  // C: in=0->A, in=1->D\n        2'b11: next_state = in ? 2'b01 : 2'b10;  // D: in=0->C, in=1->B\n        default: next_state = 2'b00;\n    endcase\nend\n\n// Output logic (Moore)\nassign out = (state == 2'b11);  // Only state D produces out=1\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z is high when x and y are equal (XNOR)\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,  // synchronous, active\u2010high\n    input  w,\n    output z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // Output logic (Moore): z = 1 in E or F\n    assign z = (state == E) || (state == F);\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input            resetn,\n    input      [1:0] byteena,\n    input     [15:0] d,\n    output reg[15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // Upper byte\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n            // Lower byte\n            if (byteena[0])\n                q[7:0]  <= d[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n    // register to hold last-cycle inputs\n    reg [7:0] in_d;\n\n    always @(posedge clk) begin\n        in_d   <= in;\n        // detect 0->1 per bit: output asserted one cycle after transition\n        pedge  <= (~in_d) & in;\n    end\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clock,\n    input        a,\n    output reg   p,\n    output reg   q\n);\n\n    // combinational drive for p\n    always @(*) begin\n        p = a & clock;\n    end\n\n    // q captures p on the falling edge of clock\n    always @(negedge clock) begin\n        q <= p;\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            // Rule 90: next[i] = q[i-1] ^ q[i+1]\n            // q<<1 has q[i]\u2190old q[i-1] (q[0]\u21900); \n            // q>>1 has q[i]\u2190old q[i+1] (q[511]\u21900);\n            q <= (q << 1) ^ (q >> 1);\n        end\n    end\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n    // z is 1 when A equals B\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left\u2010hand neighbour are 1\n    //     out_both[i] = in[i] & in[i+1], for i=0..98\n    assign out_both = in[98:0] & in[99:1];\n\n    // (2) this bit or its right\u2010hand neighbour is 1\n    //     out_any[i] = in[i] | in[i-1], for i=1..99\n    assign out_any  = in[99:1] | in[98:0];\n\n    // (3) this bit differs from its left\u2010hand neighbour,\n    //     with wrap\u2010around (neighbour of in[99] is in[0])\n    //     out_different[i] = in[i] ^ in[(i+1)%100]\n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input        d,\n    input        ena,\n    output logic q\n);\n\n    // Level\u2010sensitive D\u2011latch: transparent when ena=1, holds q otherwise\n    always_latch begin\n        if (ena)\n            q = d;\n        // else q retains its last value (inferred latch)\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n\n    // select 4 bits starting at index = sel*4\n    // {sel,2'b00} concatenates sel<<2\n    assign out = in[{sel,2'b00} +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;  // sel = 9..15\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of corresponding bits\n    assign out_or_bitwise = a | b;\n\n    // logical OR: true if any bit of a or b is '1'\n    assign out_or_logical = (|a) | (|b);\n\n    // concatenate inverted b in [5:3] and inverted a in [2:0]\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // Moore\u2010output: '1' only in state D (one\u2010hot bit 3)\n    assign out = state[3];\n\n    // Combinational next\u2010state logic (one\u2010hot)\n    always @(*) begin\n        // default all zeros\n        next_state = 4'b0000;\n\n        // A <= A(in=0) or C(in=0)\n        next_state[0] = ~in & (state[0] | state[2]);\n\n        // B <= A(in=1) or B(in=1) or D(in=1)\n        next_state[1] =  in & (state[0] | state[1] | state[3]);\n\n        // C <= B(in=0) or D(in=0)\n        next_state[2] = ~in & (state[1] | state[3]);\n\n        // D <= C(in=1)\n        next_state[3] =  in &  state[2];\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    // First level: find min of (a,b) and (c,d)\n    wire [7:0] ab_min = (a < b) ? a : b;\n    wire [7:0] cd_min = (c < d) ? c : d;\n\n    // Second level: find min of those two results\n    always @(*) begin\n        if (ab_min < cd_min)\n            min = ab_min;\n        else\n            min = cd_min;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Combinational logic\n    assign out_and   = a & b;\n    assign out_or    = a | b;\n    assign out_xor   = a ^ b;\n    assign out_nand  = ~(a & b);\n    assign out_nor   = ~(a | b);\n    assign out_xnor  = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,  // active\u2010high synchronous\n    input s,\n    input w,\n    output reg z\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg        state, next_state;\n    reg [1:0]  cycle_cnt;   // 0,1,2\n    reg [1:0]  ones_cnt;    // count of w==1, up to 3\n    reg        next_z;      // holds z for next cycle\n\n    // next\u2010state and datapath\n    always @(*) begin\n        // defaults\n        next_state = state;\n        // defaults for signals that are not purely sequential\n        // (we do all sequential updates in the clocked block)\n        // so nothing here\n        case(state)\n            A: begin\n                if (s)\n                    next_state = B;\n            end\n            B: begin\n                next_state = B;\n            end\n        endcase\n    end\n\n    // sequential block: state, counters, output\n    always @(posedge clk) begin\n        if (reset) begin\n            // synchronous reset\n            state      <= A;\n            z          <= 1'b0;\n            cycle_cnt  <= 2'd0;\n            ones_cnt   <= 2'd0;\n            next_z     <= 1'b0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                A: begin\n                    // stay in A as long as s==0, z=0\n                    z         <= 1'b0;\n                    cycle_cnt <= 2'd0;\n                    ones_cnt  <= 2'd0;\n                    next_z    <= 1'b0;\n                end\n\n                B: begin\n                    // output the result of the previous 3-cycle window\n                    z <= next_z;\n\n                    if (cycle_cnt < 2) begin\n                        // still collecting the 3\u2010cycle window\n                        cycle_cnt <= cycle_cnt + 1;\n                        ones_cnt  <= ones_cnt + w;\n                    end else begin\n                        // this is the 3rd cycle of the window\n                        // include w, decide next_z for the following cycle\n                        next_z    <= (ones_cnt + w == 2);\n                        cycle_cnt <= 2'd0;\n                        ones_cnt  <= 2'd0;\n                    end\n                end\n\n                default: begin\n                    // shouldn't happen\n                    state <= A;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concatenate the original 8\u2011bit value\n    assign out = { {24{in[7]}}, in };\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        if      (in[0]) pos = 2'd0;\n        else if (in[1]) pos = 2'd1;\n        else if (in[2]) pos = 2'd2;\n        else if (in[3]) pos = 2'd3;\n        else             pos = 2'd0;\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic (Moore: depends only on state)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n\n    // Constant-0 output\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Continuously drive \u2018one\u2019 high\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @* begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // On each rising edge of clk, out <= in XOR out\n    always_ff @(posedge clk) begin\n        out <= in ^ out;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             areset,\n    input             load,\n    input             ena,\n    input      [3:0]  data,\n    output reg [3:0]  q\n);\n\n    // Asynchronous reset, synchronous load and shift-right\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            // Right shift: new MSB = 0, LSB is shifted out\n            q <= {1'b0, q[3:1]};\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // f = 1 for minterms 2,3,5,7 \u2192 f = (~x3 & x2) | (x3 & x1)\n    assign f = x3 ? x1 : x2;\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input            clk,\n    input      [7:0] d,\n    input            areset,\n    output reg [7:0] q\n);\n\n    // Eight D\u2010flip\u2010flops with active\u2010high asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // Reduction operators implement N\u2011input AND, OR, XOR\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // sum is XOR of inputs\n    assign sum  = a ^ b;\n\n    // carry-out is AND of inputs\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input        cpu_overheated,\n    output reg   shut_off_computer,\n    input        arrived,\n    input        gas_tank_empty,\n    output reg   keep_driving\n);\n\n    // combinational logic -- no inferred latches\n    always @(*) begin\n        // shut off computer whenever CPU overheats\n        shut_off_computer = cpu_overheated;\n\n        // keep driving only if you haven't arrived AND the tank isn't empty\n        keep_driving = (~arrived) && (~gas_tank_empty);\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,    // active\u2010high synchronous\n    output out\n);\n    // State encoding\n    parameter OFF = 1'b0,\n              ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default:      next_state = OFF;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // concatenate the six 5\u2010bit inputs (30 bits) and two LSBs = \u201c11\u201d (2 bits) into one 32\u2010bit vector\n    // then split it into four 8\u2010bit outputs\n    assign {w, x, y, z} = { a, b, c, d, e, f, 2'b11 };\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n    // From the truth\u2010table, q is 1 exactly when the number of 1\u2019s on a,b,c,d is even.\n    // That's the even\u2010parity function: q = ~(a ^ b ^ c ^ d)\n    assign q = ~(a ^ b ^ c ^ d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // AND gate implementation\n    assign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // state encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // state register (synchronous, active\u2010high reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // next-state logic\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default:   next_state = B;\n        endcase\n    end\n\n    // Moore output\n    // out = 1 in state B, 0 in state A\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum = a \u2295 b \u2295 cin\n    assign sum  = a ^ b ^ cin;\n    // cout = majority(a, b, cin)\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // compute XNOR of in1 and in2, then XOR with in3\n    assign out = (in1 ~^ in2) ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n\n    // Implement all logic using only 2:1 muxes (via ?:), no gates.\n    // f00(c,d) = c|d  = c ? 1 : d\n    assign mux_in[0] = c ? 1'b1 : d;\n\n    // f01 = 0\n    assign mux_in[1] = 1'b0;\n\n    // f11(c,d) = c&d = c ? d : 0\n    assign mux_in[2] = c ? d    : 1'b0;\n\n    // Need ~d for f10 = c|~d\n    wire notd;\n    assign notd      = d ? 1'b0 : 1'b1;      // ~d via mux\n    // f10 = c ? 1 : ~d\n    assign mux_in[3] = c ? 1'b1 : notd;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // asynchronous active\u2010high reset\n    input  x,\n    output z\n);\n\n    // one\u2010hot state encoding\n    reg state_A, state_B;\n    wire next_A, next_B;\n\n    // next\u2010state logic\n    assign next_A = state_A & ~x;                     // A --0--> A\n    assign next_B = (state_A &  x) | state_B;         // A --1--> B; B --0/1--> B\n\n    // Mealy output logic\n    assign z = (state_A &  x) | (state_B & ~x);\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;\n            state_B <= 1'b0;\n        end else begin\n            state_A <= next_A;\n            state_B <= next_B;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,\n    output logic f\n);\n\n    // f = (~x1 & x3)  |  (~x2 & ~x4)  |  (x2 & x3 & x4)\n    always_comb begin\n        f = (~x[1] & x[3])\n          | (~x[2] & ~x[4])\n          | ( x[2] & x[3] & x[4]);\n    end\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,\n    input  in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    localparam IDLE  = 4'd0;  // \u201cprevious bit was 0\u201d\n    localparam ONE   = 4'd1;\n    localparam TWO   = 4'd2;\n    localparam THREE = 4'd3;\n    localparam FOUR  = 4'd4;\n    localparam FIVE  = 4'd5;  // seen five consecutive 1s\n    localparam SIX   = 4'd6;  // seen six consecutive 1s\n    localparam DISC  = 4'd7;  // output disc = 1\n    localparam FLAG  = 4'd8;  // output flag = 1\n    localparam ERR   = 4'd9;  // output err  = 1\n\n    reg [3:0] state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        next_state = IDLE;\n        case (state)\n            IDLE:  next_state = in ? ONE  : IDLE;\n            ONE:   next_state = in ? TWO  : IDLE;\n            TWO:   next_state = in ? THREE: IDLE;\n            THREE: next_state = in ? FOUR : IDLE;\n            FOUR:  next_state = in ? FIVE : IDLE;\n            FIVE:  next_state = in ? SIX  : DISC;   // five 1s + 0 \u2192 DISC\n            SIX:   next_state = in ? ERR  : FLAG;   // six 1s + 0 \u2192 FLAG; six 1s + 1 \u2192 ERR\n            DISC:  next_state = in ? ONE  : IDLE;   // after DISC treat this 0 as \u201cprevious 0\u201d\n            FLAG:  next_state = in ? ONE  : IDLE;   // after FLAG treat this 0 as \u201cprevious 0\u201d\n            ERR:   next_state = in ? ERR  : IDLE;   // stay in ERR on 1, clear on 0\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Moore outputs\n    always @(*) begin\n        disc = (state == DISC);\n        flag = (state == FLAG);\n        err  = (state == ERR);\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire       clk,\n    input  wire       reset,    // synchronous, active high\n    input  wire       data,     // serial data in\n    output wire [3:0] count,    // current remaining time\n    output reg        counting, // high while counting\n    output reg        done,     // high when timeout reached\n    input  wire       ack\n);\n\n    // State encoding\n    localparam [1:0]\n        S_WAIT   = 2'd0,  // scanning for 1101\n        S_SHIFT  = 2'd1,  // shifting in 4\u2010bit delay\n        S_COUNT  = 2'd2,  // counting cycles\n        S_DONE   = 2'd3;  // timeout, waiting for ack\n\n    reg [1:0] state, next_state;\n\n    // For pattern detection\n    reg [3:0] pat_shift;\n\n    // For loading delay\n    reg [2:0] bit_ctr;\n    reg [3:0] delay_reg;\n\n    // Counting logic\n    reg [9:0] cycle_ctr;  // 0..999\n    reg [3:0] cnt_reg;    // downcounter: delay_reg down to 0\n\n    assign count = cnt_reg;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state       <= S_WAIT;\n            pat_shift   <= 4'b0000;\n            bit_ctr     <= 3'd0;\n            delay_reg   <= 4'd0;\n            cycle_ctr   <= 10'd0;\n            cnt_reg     <= 4'd0;\n            counting    <= 1'b0;\n            done        <= 1'b0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                //========================================================\n                // S_WAIT: scan for 1101\n                S_WAIT: begin\n                    done     <= 1'b0;\n                    counting <= 1'b0;\n                    // shift in new bit\n                    pat_shift <= { pat_shift[2:0], data };\n                end\n\n                //========================================================\n                // S_SHIFT: grab next 4 bits as delay[3:0]\n                S_SHIFT: begin\n                    pat_shift <= 4'b0000; // no longer needed\n                    // shift data into delay_reg MSB\u2010first\n                    delay_reg <= { delay_reg[2:0], data };\n                    bit_ctr   <= bit_ctr + 1'b1;\n                end\n\n                //========================================================\n                // S_COUNT: counting cycles\n                S_COUNT: begin\n                    counting <= 1'b1;\n                    // step cycle counter\n                    if (cycle_ctr == 10'd999) begin\n                        cycle_ctr <= 10'd0;\n                        // at rollover, decrement cnt_reg unless it's already zero\n                        if (cnt_reg != 4'd0)\n                            cnt_reg <= cnt_reg - 1'b1;\n                    end else begin\n                        cycle_ctr <= cycle_ctr + 1'b1;\n                    end\n                end\n\n                //========================================================\n                // S_DONE: asserted done, wait for ack\n                S_DONE: begin\n                    counting <= 1'b0;\n                    done     <= 1'b1;\n                end\n            endcase\n        end\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            //========================================================\n            S_WAIT: begin\n                // detect 1101\n                if (pat_shift == 4'b1101)\n                    next_state = S_SHIFT;\n            end\n\n            //========================================================\n            S_SHIFT: begin\n                if (bit_ctr == 3'd3) begin\n                    // we've just captured the 4th bit of delay\n                    next_state = S_COUNT;\n                end\n            end\n\n            //========================================================\n            S_COUNT: begin\n                // done when we've just completed the 1000\u2010cycle segment at cnt_reg==0\n                if ((cycle_ctr == 10'd999) && (cnt_reg == 4'd0))\n                    next_state = S_DONE;\n            end\n\n            //========================================================\n            S_DONE: begin\n                if (ack)\n                    next_state = S_WAIT;\n            end\n        endcase\n    end\n\n    // Entry actions / initializations on state transitions\n    always @(posedge clk) begin\n        if (!reset) begin\n            case (next_state)\n                S_SHIFT: begin\n                    // prepare to shift in 4 bits\n                    bit_ctr   <= 3'd0;\n                    delay_reg <= 4'd0;\n                end\n\n                S_COUNT: begin\n                    // initialize cycle counter and downcounter\n                    cycle_ctr <= 10'd0;\n                    cnt_reg   <= delay_reg;\n                end\n\n                S_WAIT: begin\n                    // clear everything for a fresh scan\n                    pat_shift <= 4'b0000;\n                end\n\n                default: ; // nothing\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input         clk,\n    input         reset,  // synchronous, active\u2010high\n    input  [3:1]  s,      // s[1]=bottom, s[2]=mid, s[3]=top\n    output reg    fr3,\n    output reg    fr2,\n    output reg    fr1,\n    output reg    dfr\n);\n\n    // state encoding for the 4 water\u2010level bands\n    localparam BELOW    = 2'd0; // s=000\n    localparam S1_ONLY  = 2'd1; // s=001\n    localparam S1_S2    = 2'd2; // s=011\n    localparam ABOVE    = 2'd3; // s=111\n\n    reg [1:0] state, next_state;\n    reg       dir, next_dir; // dir=1 if last transition was rising\n\n    // decode current sensor\u2010vector to one of our 4 levels\n    function [1:0] decode_level(input [3:1] s);\n        if      (s==3'b000) decode_level = BELOW;\n        else if (s==3'b001) decode_level = S1_ONLY;\n        else if (s==3'b011) decode_level = S1_S2;\n        else if (s==3'b111) decode_level = ABOVE;\n        else                decode_level = BELOW; // safe fallback\n    endfunction\n\n    wire [1:0] lvl = decode_level(s);\n\n    // next\u2010state logic\n    always @(*) begin\n        // default hold\n        next_state = state;\n        next_dir   = dir;\n\n        // on any change in lvl, update state, and set dir\n        if (lvl != state) begin\n            next_state = lvl;\n            next_dir   = (lvl > state) ? 1'b1 : 1'b0;\n        end\n    end\n\n    // state + dir registers\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BELOW;\n            dir   <= 1'b1; // so that dfr=1 in the reset condition\n        end else begin\n            state <= next_state;\n            dir   <= next_dir;\n        end\n    end\n\n    // output logic\n    always @(*) begin\n        // defaults\n        fr1 = 1'b0; \n        fr2 = 1'b0;\n        fr3 = 1'b0;\n        dfr = 1'b0;\n\n        case (state)\n            BELOW: begin\n                // below s1 => fr1,fr2,fr3 + supplemental\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 1;\n            end\n            S1_ONLY: begin\n                // between s1 & s2 => fr1,fr2; supplemental if rising\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 0;\n                dfr = dir;\n            end\n            S1_S2: begin\n                // between s2 & s3 => fr1 only; supplemental if rising\n                fr1 = 1;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = dir;\n            end\n            ABOVE: begin\n                // above s3 => all off\n                fr1 = 0;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output done\n);\n\n    // States\n    localparam IDLE = 2'd0;\n    localparam DATA = 2'd1;\n    localparam STOP = 2'd2;\n    localparam ERR  = 2'd3;\n\n    reg [1:0] state, next_state;\n    reg [3:0] bit_cnt;\n    reg       done_reg;\n\n    // state, counter, done register\n    always @(posedge clk) begin\n        if (reset) begin\n            state    <= IDLE;\n            bit_cnt  <= 4'd0;\n            done_reg <= 1'b0;\n        end else begin\n            state    <= next_state;\n            done_reg <= 1'b0;\n            case (state)\n                IDLE: begin\n                    // on start\u2010bit (0), initialize bit counter\n                    if (~in)\n                        bit_cnt <= 4'd0;\n                end\n                DATA: begin\n                    // count through 8 data bits\n                    bit_cnt <= bit_cnt + 1'b1;\n                end\n                STOP: begin\n                    // if stop\u2010bit ok, pulse done\n                    if (in)\n                        done_reg <= 1'b1;\n                end\n                ERR: begin\n                    // wait for line to return high\n                end\n            endcase\n        end\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (~in)\n                    next_state = DATA;\n            end\n            DATA: begin\n                if (bit_cnt == 4'd7)\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in)\n                    next_state = IDLE;  // good frame\n                else\n                    next_state = ERR;   // bad stop, flush until high\n            end\n            ERR: begin\n                if (in)\n                    next_state = IDLE;  // line idle again\n            end\n        endcase\n    end\n\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output reg [7:0] out_byte,\n    output reg       done\n);\n\n    // State encoding\n    localparam IDLE = 2'd0,\n               DATA = 2'd1,\n               STOP = 2'd2,\n               ERR  = 2'd3;\n\n    reg [1:0]       state;\n    reg [2:0]       bit_cnt;\n    reg [7:0]       shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state     <= IDLE;\n            bit_cnt   <= 3'd0;\n            shift_reg <= 8'd0;\n            out_byte  <= 8'd0;\n            done      <= 1'b0;\n        end else begin\n            // default\n            done <= 1'b0;\n\n            case (state)\n                // wait for start bit = 0\n                IDLE: begin\n                    if (in == 1'b0) begin\n                        state     <= DATA;\n                        bit_cnt   <= 3'd0;\n                        shift_reg <= 8'd0;\n                    end\n                end\n\n                // shift in 8 data bits, LSB first\n                DATA: begin\n                    // accumulate bits\n                    shift_reg <= shift_reg | ({8{in}} << bit_cnt);\n                    if (bit_cnt == 3'd7) begin\n                        state <= STOP;\n                    end else begin\n                        bit_cnt <= bit_cnt + 1'b1;\n                    end\n                end\n\n                // check stop bit = 1\n                STOP: begin\n                    if (in == 1'b1) begin\n                        out_byte <= shift_reg;\n                        done     <= 1'b1;\n                        state    <= IDLE;\n                    end else begin\n                        // bad stop, wait for a '1' before resync\n                        state <= ERR;\n                    end\n                end\n\n                // error recovery: wait until line returns to '1'\n                ERR: begin\n                    if (in == 1'b1) begin\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input             clk,\n    input             areset, \n\n    // prediction interface\n    input             predict_valid,\n    input  [6:0]      predict_pc,\n    output            predict_taken, \n    output [6:0]      predict_history,\n\n    // training interface\n    input             train_valid,\n    input             train_taken,\n    input             train_mispredicted,\n    input  [6:0]      train_history, \n    input  [6:0]      train_pc\n);\n\n    // 7\u2010bit global history register\n    reg [6:0] ghr;\n\n    // 2\u2010bit saturating counters PHT\n    reg [1:0] PHT [0:127];\n    integer   i;\n\n    // hash indices\n    wire [6:0] idx_pred  = predict_pc    ^ ghr;\n    wire [6:0] idx_train = train_pc      ^ train_history;\n\n    // read the counter for prediction\n    wire [1:0] cnt_pred = PHT[idx_pred];\n\n    // prediction outputs\n    assign predict_taken   = cnt_pred[1];\n    assign predict_history = ghr;\n\n    // compute new counter value for training\n    reg [1:0] new_cnt;\n    always @(*) begin\n        case (PHT[idx_train])\n            2'b00: new_cnt = train_taken ? 2'b01 : 2'b00;\n            2'b01: new_cnt = train_taken ? 2'b10 : 2'b00;\n            2'b10: new_cnt = train_taken ? 2'b11 : 2'b01;\n            2'b11: new_cnt = train_taken ? 2'b11 : 2'b10;\n            default: new_cnt = PHT[idx_train];\n        endcase\n    end\n\n    // synchronous update of PHT and GHR; asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            ghr <= 7'b0;\n            for (i = 0; i < 128; i = i + 1)\n                PHT[i] <= 2'b01;    // initialize to weakly not\u2010taken\n        end else begin\n            // update the PHT on training\n            if (train_valid)\n                PHT[idx_train] <= new_cnt;\n\n            // update or recover the GHR\n            if (train_valid && train_mispredicted) begin\n                // recover to state immediately after the mispredicted branch\n                // shift left and insert the actual outcome\n                ghr <= { train_history[5:0], train_taken };\n            end\n            else if (predict_valid) begin\n                // fold in predicted direction\n                ghr <= { ghr[5:0], cnt_pred[1] };\n            end\n            // else: keep the current ghr\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam WL   = 3'd0,\n               WR   = 3'd1,\n               DL   = 3'd2,\n               DR   = 3'd3,\n               FL   = 3'd4,\n               FR   = 3'd5,\n               SPL  = 3'd6;\n\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State register and fall counter\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state      <= WL;\n            fall_count <= 5'd0;\n        end else begin\n            state <= next_state;\n            // fall counter logic\n            if ((state == FL || state == FR) && !ground)\n                fall_count <= fall_count + 1;\n            else\n                fall_count <= 5'd0;\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        next_state = state;  // default hold\n        case (state)\n            WL: begin\n                if (!ground)\n                    next_state = FL;\n                else if (dig)\n                    next_state = DL;\n                else if (bump_left || bump_right)\n                    next_state = WR;\n            end\n            WR: begin\n                if (!ground)\n                    next_state = FR;\n                else if (dig)\n                    next_state = DR;\n                else if (bump_left || bump_right)\n                    next_state = WL;\n            end\n            DL: begin\n                if (!ground)\n                    next_state = FL;\n            end\n            DR: begin\n                if (!ground)\n                    next_state = FR;\n            end\n            FL: begin\n                if (ground) begin\n                    if (fall_count > 5'd20)\n                        next_state = SPL;\n                    else\n                        next_state = WL;\n                end\n            end\n            FR: begin\n                if (ground) begin\n                    if (fall_count > 5'd20)\n                        next_state = SPL;\n                    else\n                        next_state = WR;\n                end\n            end\n            SPL: begin\n                next_state = SPL;\n            end\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n    assign digging    = (state == DL) || (state == DR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    input        data,\n    output reg   shift_ena,\n    output reg   counting,\n    input        done_counting,\n    output reg   done,\n    input        ack\n);\n\n    // State encoding\n    localparam IDLE       = 2'd0,\n               SHIFT      = 2'd1,\n               WAIT_COUNT = 2'd2,\n               NOTIFY     = 2'd3;\n\n    reg [1:0] state, next_state;\n    reg [1:0] shift_cnt;\n    reg [3:0] seq;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // 4\u2011bit shift register for pattern detection (only in IDLE)\n    always @(posedge clk) begin\n        if (reset)\n            seq <= 4'b0000;\n        else if (state == IDLE)\n            seq <= {seq[2:0], data};\n    end\n\n    // shift counter for 4 cycles of shift_ena\n    always @(posedge clk) begin\n        if (reset)\n            shift_cnt <= 2'd0;\n        else if (state == SHIFT)\n            shift_cnt <= shift_cnt + 2'd1;\n        else\n            shift_cnt <= 2'd0;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE:\n                if (seq == 4'b1101)\n                    next_state = SHIFT;\n            SHIFT:\n                if (shift_cnt == 2'd3)\n                    next_state = WAIT_COUNT;\n            WAIT_COUNT:\n                if (done_counting)\n                    next_state = NOTIFY;\n            NOTIFY:\n                if (ack)\n                    next_state = IDLE;\n        endcase\n    end\n\n    // Output logic (registered)\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b0;\n            counting  <= 1'b0;\n            done      <= 1'b0;\n        end else begin\n            // defaults\n            shift_ena <= 1'b0;\n            counting  <= 1'b0;\n            done      <= 1'b0;\n            case (state)\n                SHIFT:      shift_ena <= 1'b1;\n                WAIT_COUNT: counting  <= 1'b1;\n                NOTIFY:     done      <= 1'b1;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input               clk,\n    input               load,\n    input      [255:0]  data,\n    output reg [255:0]  q\n);\n\n    reg [255:0] next_q;\n    integer     i, j, dr, dc;\n    integer     r, c;\n    integer     cnt;\n\n    // compute next generation\n    always @(*) begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                cnt = 0;\n                // sum 8 neighbours, with wrap\u2010around\n                for (dr = -1; dr <= 1; dr = dr + 1) begin\n                    for (dc = -1; dc <= 1; dc = dc + 1) begin\n                        if (dr != 0 || dc != 0) begin\n                            // wrap row\n                            r = i + dr;\n                            if      (r <  0) r = 15;\n                            else if (r > 15) r =  0;\n                            // wrap col\n                            c = j + dc;\n                            if      (c <  0) c = 15;\n                            else if (c > 15) c =  0;\n                            if ( q[r*16 + c] )\n                                cnt = cnt + 1;\n                        end\n                    end\n                end\n                // apply rules: 3 \u21d2 alive, 2 \u21d2 keep state, else \u21d2 dead\n                next_q[i*16 + j] = (cnt == 3) || (cnt == 2 && q[i*16 + j]);\n            end\n        end\n    end\n\n    // register update or load\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        S_WL = 3'd0,  // walking left\n        S_WR = 3'd1,  // walking right\n        S_DL = 3'd2,  // digging left\n        S_DR = 3'd3,  // digging right\n        S_FL = 3'd4,  // falling left\n        S_FR = 3'd5   // falling right\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register with async reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_WL;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always_comb begin\n        // default stay\n        next_state = state;\n        case (state)\n            // Walking states\n            S_WL: begin\n                if (ground == 1'b0)              next_state = S_FL;                // fall\n                else if (dig == 1'b1)            next_state = S_DL;                // start digging\n                else if (bump_left == 1'b1)      next_state = S_WR;                // bump => turn right\n                else                              next_state = S_WL;                // keep walking left\n            end\n            S_WR: begin\n                if (ground == 1'b0)              next_state = S_FR;                // fall\n                else if (dig == 1'b1)            next_state = S_DR;                // start digging\n                else if (bump_right == 1'b1)     next_state = S_WL;                // bump => turn left\n                else                              next_state = S_WR;                // keep walking right\n            end\n\n            // Digging states\n            S_DL: begin\n                if (ground == 1'b0)              next_state = S_FL;                // dig out => fall\n                else                              next_state = S_DL;                // keep digging\n            end\n            S_DR: begin\n                if (ground == 1'b0)              next_state = S_FR;                // dig out => fall\n                else                              next_state = S_DR;                // keep digging\n            end\n\n            // Falling states\n            S_FL: begin\n                if (ground == 1'b1)              next_state = S_WL;                // landed => walk left\n                else                              next_state = S_FL;                // keep falling\n            end\n            S_FR: begin\n                if (ground == 1'b1)              next_state = S_WR;                // landed => walk right\n                else                              next_state = S_FR;                // keep falling\n            end\n\n            default: next_state = S_WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_WL);\n    assign walk_right = (state == S_WR);\n    assign digging    = (state == S_DL) || (state == S_DR);\n    assign aaah       = (state == S_FL) || (state == S_FR);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    input        ena,\n    output reg   pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // 12:00:00 AM\n        hh <= 8'h12;\n        mm <= 8'h00;\n        ss <= 8'h00;\n        pm <= 1'b0;\n    end else if (ena) begin\n        // increment seconds\n        if (ss[3:0] != 4'd9) begin\n            ss[3:0] <= ss[3:0] + 1;\n        end else begin\n            ss[3:0] <= 4'd0;\n            if (ss[7:4] != 4'd5) begin\n                ss[7:4] <= ss[7:4] + 1;\n            end else begin\n                ss[7:4] <= 4'd0;\n                // increment minutes\n                if (mm[3:0] != 4'd9) begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end else begin\n                    mm[3:0] <= 4'd0;\n                    if (mm[7:4] != 4'd5) begin\n                        mm[7:4] <= mm[7:4] + 1;\n                    end else begin\n                        mm[7:4] <= 4'd0;\n                        // increment hours (12-hour BCD)\n                        case (hh)\n                            8'h12: begin\n                                hh <= 8'h01;\n                                pm <= ~pm;\n                            end\n                            8'h09: hh <= 8'h10;\n                            default: hh <= hh + 8'h01;\n                        endcase\n                    end\n                end\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam S_L  = 2'b00,  // walking left\n               S_R  = 2'b01,  // walking right\n               S_FL = 2'b10,  // falling (was walking left)\n               S_FR = 2'b11;  // falling (was walking right)\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state logic (Moore)\n    always @(*) begin\n        case(state)\n            S_L: begin\n                if (ground == 0)              next_state = S_FL;\n                else if (bump_left|bump_right) next_state = S_R;\n                else                            next_state = S_L;\n            end\n            S_R: begin\n                if (ground == 0)              next_state = S_FR;\n                else if (bump_left|bump_right) next_state = S_L;\n                else                            next_state = S_R;\n            end\n            S_FL: begin\n                if (ground == 1) next_state = S_L;\n                else              next_state = S_FL;\n            end\n            S_FR: begin\n                if (ground == 1) next_state = S_R;\n                else              next_state = S_FR;\n            end\n            default: next_state = S_L;\n        endcase\n    end\n\n    // State register with asynchronous posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_L;\n        else\n            state <= next_state;\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_L);\n    assign walk_right = (state == S_R);\n    assign aaah       = (state == S_FL) || (state == S_FR);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,      // synchronous, active\u2011high\n    output [3:1] ena,        // enable to increment digits 1 (tens)..3 (thousands)\n    output reg [15:0] q      // BCD digits: q[3:0]=ones, [7:4]=tens, [11:8]=hundreds, [15:12]=thousands\n);\n\n    // generate carry\u2011out enables when a digit reaches 9\n    wire ena1 = (q[3:0]   == 4'd9);\n    wire ena2 = ena1 & (q[7:4]   == 4'd9);\n    wire ena3 = ena2 & (q[11:8]  == 4'd9);\n\n    // map to output bus\n    assign ena = {ena3, ena2, ena1};\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit always increments\n            if (q[3:0] == 4'd9)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // tens digit increments when ones rolls over\n            if (ena1) begin\n                if (q[7:4] == 4'd9)\n                    q[7:4] <= 4'd0;\n                else\n                    q[7:4] <= q[7:4] + 4'd1;\n            end\n\n            // hundreds digit increments when tens rolls over\n            if (ena2) begin\n                if (q[11:8] == 4'd9)\n                    q[11:8] <= 4'd0;\n                else\n                    q[11:8] <= q[11:8] + 4'd1;\n            end\n\n            // thousands digit increments when hundreds rolls over\n            if (ena3) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] a,\n    input  [99:0] b,\n    input         sel,\n    output [99:0] out\n);\n\n    // 2-to-1 multiplexer: when sel=0, out=a; when sel=1, out=b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input  [3:1] y,    // y = {y3,y2,y1}\n    input        w,\n    output reg   Y2    // next\u2010state bit y2\n);\n\n    wire y3 = y[3];\n    wire y2 = y[2];\n    wire y1 = y[1];\n\n    // y2_next = (!y2 & y1)                // covers 001\u2192010/011 and 101\u2192010/011\n    //         | ( w & !y1 & (y2 ^ y3) );  // covers 010\u2192011, 100\u2192011, 001\u2192011, 101\u2192011\n    always @(*) begin\n        Y2 = (~y2 & y1)\n           | ( w  & ~y1 & (y2 ^ y3) );\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input  ring, \n    input  vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // When ring=1 enable exactly one output:\n    // if vibrate_mode==1 \uf0e0 motor, else \uf0e0 ringer\n    assign motor  = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    // AND using continuous assignment\n    assign out_assign = a & b;\n\n    // AND using a combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero\n);\n\n    // Constant 0 assigned to output\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a,\n    output reg   q\n);\n    // one\u2010cycle delayed version of a\n    reg a_del;\n\n    always @(posedge clk) begin\n        // detect two consecutive 1\u2019s on a\n        // if a and a_del are both 1, q\u21920; otherwise q\u21921\n        q     <= ~(a & a_del);\n        a_del <= a;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        areset,\n    input        x,\n    output reg   z\n);\n\n    // State encoding\n    localparam S_PASS   = 1'b0;  // still looking for the first '1'\n    localparam S_INVERT = 1'b1;  // after the first '1', invert all bits\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_PASS;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            S_PASS:   next_state = x ? S_INVERT : S_PASS;\n            S_INVERT: next_state = S_INVERT;\n            default:  next_state = S_PASS;\n        endcase\n    end\n\n    // Output logic (Moore\u2010style with combinatorial output)\n    always @(*) begin\n        case (state)\n            // before the first '1', output = input (pass through)\n            S_PASS:   z = x;\n            // after seeing the first '1', output = inverted input\n            S_INVERT: z = ~x;\n            default:  z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        areset,\n    output       out\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse byte order: {byte0, byte1, byte2, byte3} -> {byte3, byte2, byte1, byte0}\n    assign out = { in[7:0],\n                   in[15:8],\n                   in[23:16],\n                   in[31:24] };\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic r,\n    output logic q\n);\n\n    // D\u2010flip\u2010flop with active\u2010high synchronous reset\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x XOR y) AND x\n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input              ena,\n    input       [1:0]  amount,\n    input      [63:0]  data,\n    output reg [63:0]  q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;                              // shift left by 1\n                2'b01: q <= q << 8;                              // shift left by 8\n                2'b10: q <= {q[63], q[63:1]};                    // arithmetic right by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]};               // arithmetic right by 8\n                default: q <= q;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        aresetn,\n    input        x,\n    output reg   z\n);\n    // State encoding\n    localparam S0 = 2'd0,\n               S1 = 2'd1,\n               S2 = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // Next\u2010state logic and output logic (Mealy)\n    always @(*) begin\n        next_state = state;\n        z = 1'b0;\n        case(state)\n            S0: begin\n                if (x)      next_state = S1;\n                else        next_state = S0;\n            end\n            S1: begin\n                if (x)      next_state = S1;\n                else        next_state = S2;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b1;    // \"101\" detected\n                end else begin\n                    next_state = S0;\n                end\n            end\n            default: begin\n                next_state = S0;\n            end\n        endcase\n    end\n\n    // State register with negedge asynchronous reset\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,\n    input  w,\n    output z\n);\n\n    // state encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // state register with asynchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2011state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;  // A(0): 0\u2192B, 1\u2192A\n            B: next_state = w ? D : C;  // B(0): 0\u2192C, 1\u2192D\n            C: next_state = w ? D : E;  // C(0): 0\u2192E, 1\u2192D\n            D: next_state = w ? A : F;  // D(0): 0\u2192F, 1\u2192A\n            E: next_state = w ? D : E;  // E(1): 0\u2192E, 1\u2192D\n            F: next_state = w ? D : C;  // F(1): 0\u2192C, 1\u2192D\n            default: next_state = A;\n        endcase\n    end\n\n    // output logic (Moore)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output [23:0] out_bytes,\n    output       done\n);\n\n    reg [1:0]      cnt;\n    reg [23:0]     buf;\n    reg            done_reg;\n\n    // outputs\n    assign out_bytes = buf;\n    assign done      = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cnt      <= 2'd0;\n            buf      <= 24'd0;\n            done_reg <= 1'b0;\n        end else begin\n            // default: de\u2011assert done\n            done_reg <= 1'b0;\n            case (cnt)\n                2'd0: begin\n                    if (in[3]) begin\n                        // first boundary byte\n                        buf   <= {in,16'd0};\n                        cnt   <= 2'd1;\n                    end else begin\n                        cnt   <= 2'd0;\n                    end\n                end\n                2'd1: begin\n                    // second byte\n                    buf   <= {buf[15:0], in};\n                    cnt   <= 2'd2;\n                end\n                2'd2: begin\n                    // third byte, signal done\n                    buf       <= {buf[15:0], in};\n                    done_reg  <= 1'b1;\n                    cnt       <= 2'd0;\n                end\n                default: begin\n                    cnt <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input  [5:0] y,  // one\u2011hot state vector: y[0]=A, y[1]=B, y[2]=C, y[3]=D, y[4]=E, y[5]=F\n    input        w,\n    output       Y1, // next\u2010state input for flip\u2010flop y[1] (state B)\n    output       Y3  // next\u2010state input for flip\u2010flop y[3] (state D)\n);\n\n    // Y1 = 1 whenever the machine is in A (y[0]) and input w=1 \u2192 next state B\n    assign Y1 = y[0] & w;\n\n    // Y3 = 1 whenever the machine is in B, C, E, or F with w=0 \u2192 next state D\n    assign Y3 = (~w) & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input  [2:0] vec, \n    output [2:0] outv,\n    output       o2,\n    output       o1,\n    output       o0\n);\n\n    // Pass through the whole vector\n    assign outv = vec;\n\n    // Split into individual bits\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    // The K\u2011map implements odd parity of all four inputs:\n    // out = (a\u2295b)\u2295(c\u2295d) = a\u2295b\u2295c\u2295d\n    always @(*) begin\n        out = a ^ b ^ c ^ d;\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input  [15:0] in,\n    output [7:0]  out_hi,\n    output [7:0]  out_lo\n);\n\n    // Combinational split of 16\u2011bit half\u2011word into two bytes\n    assign out_hi = in[15:8];  // upper byte\n    assign out_lo = in[7:0];   // lower byte\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // NOR gate implementation\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input        clk,\n    input        a, \n    input        b,\n    output       out_assign,\n    output reg   out_always_comb,\n    output reg   out_always_ff\n);\n\n    // 1) Continuous\u2010assignment XOR\n    assign out_assign = a ^ b;\n\n    // 2) Combinational always block XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3) Clocked always block XOR (with one\u2010cycle register delay)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input  [6:1] y,  // one\u2010hot: y[1]=A, y[2]=B, y[3]=C, y[4]=D, y[5]=E, y[6]=F\n    input        w,\n    output       Y2, // next\u2010state bit for B\n    output       Y4  // next\u2010state bit for D\n);\n\n    // Next\u2010state = B only when in A and w==0\n    assign Y2 =  y[1] & ~w;\n\n    // Next\u2010state = D when in B,C,E or F and w==1\n    assign Y4 =  w & (y[2] | y[3] | y[5] | y[6]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "module top_module (\n    input  [255:0] in,\n    input  [7:0]   sel,\n    output         out\n);\n\n    // 256-to-1 mux: variable indexed part\u2010select\n    assign out = in[sel];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        w,\n    input        R,\n    input        E,\n    input        L,\n    output reg   Q\n);\n\n    // Next\u2010state combinational logic (2\u2010to\u20101 multiplexers in a chain)\n    // Priority: Load (L) > Shift (E) > Hold\n    wire D = L ? R      // If load asserted, take R\n           : E ? w      // Else if enable asserted, take shift input w\n           : Q;         // Else hold current state\n\n    // Edge\u2010triggered D\u2010flip\u2010flop\n    always @(posedge clk) begin\n        Q <= D;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // flip\u2010flop state registers\n    reg q0, q1, q2;\n\n    // next\u2010state logic\n    wire d0 = x ^  q0;    // XOR with Q\n    wire d1 = x & ~q1;    // AND with Q'\n    wire d2 = x | ~q2;    // OR  with Q'\n\n    // output logic: 3\u2010input XNOR of current state\n    assign z = ~(q0 ^ q1 ^ q2);\n\n    // state updates on rising clock edge\n    always @(posedge clk) begin\n        q0 <= d0;\n        q1 <= d1;\n        q2 <= d2;\n    end\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a, \n    input  b, \n    input  c, \n    input  d,\n    output q\n);\n\n    // From the truth\u2010table, q=1 exactly when b=1 or c=1\n    assign q = b | c;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input  [511:0]     data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    integer     i;\n\n    // Combinational logic: compute next state for each cell\n    always @(*) begin\n        for (i = 0; i < 512; i = i + 1) begin\n            // extract neighborhood, with zero\u2010padding at edges\n            case ({ (i==0)      ? 1'b0 : q[i-1],\n                    /* center */         q[i],\n                    (i==511)    ? 1'b0 : q[i+1] })\n                // patterns 110, 101, 011, 010, 001 => next = 1\n                3'b110, 3'b101, 3'b011, 3'b010, 3'b001:\n                    next_q[i] = 1'b1;\n                default:\n                    next_q[i] = 1'b0;\n            endcase\n        end\n    end\n\n    // Sequential logic: load or update\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // state encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // state register with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Moore output\n    assign out = (state == D);\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input  [3:0] a, \n    input  [3:0] b, \n    input  [3:0] c, \n    input  [3:0] d,\n    input  [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out\n);\n\n    // Combinational 2\u2011to\u20111 mux\n    always @* begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "//------------------------------------------------------------------------------\n// Submodule: top_module\n// A single D\u2010flipflop with a 2:1 mux on its D\u2010input.\n//------------------------------------------------------------------------------\n\nmodule top_module(\n    input        clk,\n    input        L,\n    input        q_in,   // feedback path\n    input        r_in,   // load data\n    output reg   Q       // flop output\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\n\n//------------------------------------------------------------------------------\n// Top\u2010level: full_module\n// Implements a 3\u2010bit LFSR/loader by instantiating top_module three times.\n// q[0] \u2190 L?r[0] : q[1]^q[2]\n// q[1] \u2190 L?r[1] : q[0]\n// q[2] \u2190 L?r[2] : q[2]\n//------------------------------------------------------------------------------\n\nmodule full_module(\n    input  [2:0] r,\n    input        L,\n    input        clk,\n    output [2:0] q\n);\n    wire [2:0] q_w;\n    wire       feedback0 = q_w[1] ^ q_w[2];\n\n    // bit 0\n    top_module u0 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (feedback0),\n        .r_in  (r[0]),\n        .Q     (q_w[0])\n    );\n\n    // bit 1\n    top_module u1 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q_w[0]),\n        .r_in  (r[1]),\n        .Q     (q_w[1])\n    );\n\n    // bit 2\n    top_module u2 (\n        .clk   (clk),\n        .L     (L),\n        .q_in  (q_w[2]),\n        .r_in  (r[2]),\n        .Q     (q_w[2])\n    );\n\n    assign q = q_w;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input              clk,\n    input              reset,  // synchronous, active\u2010high\n    input      [31:0]  in,\n    output reg [31:0]  out\n);\n\n    // register to hold previous-cycle input\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            prev_in <= 32'b0;\n            out     <= 32'b0;\n        end else begin\n            // latch a '1' when bit goes from 1 to 0, and hold until reset\n            out     <= out | (prev_in & ~in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    output reg [7:0] q\n);\n\n    // On every rising edge of clk, capture the 8\u2010bit input d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s,\n    output        overflow\n);\n\n    // Extend to 9 bits to catch carry out of MSB\n    wire [8:0] sum_ext;\n    assign sum_ext = {a[7], a} + {b[7], b};\n\n    // Result is the lower 8 bits\n    assign s = sum_ext[7:0];\n\n    // Two's\u2010complement overflow = carry into MSB \u2295 carry out of MSB\n    assign overflow = sum_ext[8] ^ sum_ext[7];\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input        d,\n    input        done_counting,\n    input        ack,\n    input  [9:0] state,    // one\u2010hot: 0=S, 1=S1, 2=S11, 3=S110, 4=B0, 5=B1, 6=B2, 7=B3, 8=Count, 9=Wait\n    output       B3_next,\n    output       S_next,\n    output       S1_next,\n    output       Count_next,\n    output       Wait_next,\n    output       done,\n    output       counting,\n    output       shift_ena\n);\n\n  // state bits\n  wire S    = state[0];\n  wire S1   = state[1];\n  wire S11  = state[2];\n  wire S110 = state[3];\n  wire B0   = state[4];\n  wire B1   = state[5];\n  wire B2   = state[6];\n  wire B3   = state[7];\n  wire Cnt  = state[8];\n  wire W    = state[9];\n\n  // next\u2010state logic\n  // S  <= S&~d   or S1&~d  or S110&~d   or Wait&ack\n  assign S_next  = (~d & (S | S1 | S110)) | (W & ack);\n\n  // S1 <= S&d\n  assign S1_next = S & d;\n\n  // B3 <= B2\n  assign B3_next = B2;\n\n  // Count <= B3  or Count&~done_counting\n  assign Count_next = B3 | (Cnt & ~done_counting);\n\n  // Wait <= Count&done_counting  or Wait&~ack\n  assign Wait_next = (Cnt & done_counting) | (W & ~ack);\n\n  // output logic\n  assign shift_ena = B0 | B1 | B2 | B3;\n  assign counting  = Cnt;\n  assign done      = W;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        train_valid,\n    input  logic        train_taken,\n    output logic [1:0]  state\n);\n\n  // Asynchronous reset, synchronous saturating increment/decrement\n  always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= 2'b01;        // weakly not-taken on reset\n    end else if (train_valid) begin\n      if (train_taken) begin\n        // increment but saturate at 3\n        if (state != 2'b11)\n          state <= state + 1;\n      end else begin\n        // decrement but saturate at 0\n        if (state != 2'b00)\n          state <= state - 1;\n      end\n    end\n    // else: keep state unchanged\n  end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output reg [2:0] pos\n);\n    \n    always @* begin\n        if      (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n        else             pos = 3'd0;  // no bits set\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input  [15:0] scancode,\n    output reg    left,\n    output reg    down,\n    output reg    right,\n    output reg    up\n);\n\nalways @(*) begin\n    // default outputs\n    left  = 1'b0;\n    down  = 1'b0;\n    right = 1'b0;\n    up    = 1'b0;\n\n    case (scancode)\n        16'he06b: left  = 1'b1;  // left arrow\n        16'he072: down  = 1'b1;  // down arrow\n        16'he074: right = 1'b1;  // right arrow\n        16'he075: up    = 1'b1;  // up arrow\n        default: begin\n            // no arrow pressed\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input  [3:0] x,\n    input  [3:0] y,\n    output [4:0] sum\n);\n\n    wire c0, c1, c2, c3;\n\n    // initial carry-in is 0\n    assign c0 = 1'b0;\n\n    // instantiate four full adders\n    full_adder fa0 (\n        .a   (x[0]),\n        .b   (y[0]),\n        .cin (c0),\n        .sum (sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a   (x[1]),\n        .b   (y[1]),\n        .cin (c1),\n        .sum (sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a   (x[2]),\n        .b   (y[2]),\n        .cin (c2),\n        .sum (sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a   (x[3]),\n        .b   (y[3]),\n        .cin (c3),\n        .sum (sum[3]),\n        .cout(sum[4]) // MSB is the final carry-out (overflow)\n    );\n\nendmodule\n\n// Full adder submodule\nmodule full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input  logic        clk,\n    input  logic        areset,\n    input  logic        predict_valid,\n    input  logic        predict_taken,\n    output logic [31:0] predict_history,\n\n    input  logic        train_mispredicted,\n    input  logic        train_taken,\n    input  logic [31:0] train_history\n);\n\n    // 32\u2010bit global history with rollback on mispredict.\n    // predict_history[0] is the newest branch.\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'd0;\n        end\n        else if (train_mispredicted) begin\n            // Roll back to history before mispredicted branch,\n            // then shift in the actual outcome as the newest bit.\n            predict_history <= { train_history[30:0],\n                                 train_taken          };\n        end\n        else if (predict_valid) begin\n            // Shift in the predicted direction as newest bit\n            predict_history <= { predict_history[30:0],\n                                 predict_taken       };\n        end\n        // else retain current history\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output out,\n    output out_n\n);\n    // intermediate wires\n    wire w1;\n    wire w2;\n\n    // first layer: two AND gates\n    and u_and1(w1, a, b);\n    and u_and2(w2, c, d);\n\n    // second layer: OR gate driving out\n    or  u_or (out, w1, w2);\n\n    // inverted output\n    not u_not(out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input  clk,\n    input  d,\n    output reg q\n);\n\n    // Single D flip\u2011flop: on rising edge of clk, sample d into q\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input            clk,\n    input            enable,\n    input            S,\n    input            A,\n    input            B,\n    input            C,\n    output reg       Z\n);\n\n    // 8\u2010bit shift register\n    reg [7:0] Q;\n    always @(posedge clk) begin\n        if (enable)\n            Q <= { Q[6:0], S };  // shift right, S into Q[0]\n        // else Q holds\n    end\n\n    // 8\u21921 mux: Z = Q[{A,B,C}]\n    always @(*) begin\n        Z = Q[{A,B,C}];\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input  mode,\n    input  too_cold,\n    input  too_hot,\n    input  fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // heater on in heating mode when too cold\n    assign heater = mode & too_cold;\n    // aircon on in cooling mode when too hot\n    assign aircon = ~mode & too_hot;\n    // fan on if user requests or whenever heater/aircon is on\n    assign fan = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": ""}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input             clk,\n    input             reset,  // active\u2010high synchronous\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        // feedback bit\n        // taps at positions 32,22,2,1 correspond to q[31],q[21],q[1],q[0]\n        // Galois LFSR: shift right, XOR tap\u2010positions with old q[0]\n        q[0]   <= q[1]   ^ q[0];     // tap at bit\u2011position 1\n        q[1]   <= q[2]   ^ q[0];     // tap at bit\u2011position 2\n        q[21]  <= q[22]  ^ q[0];     // tap at bit\u2011position 22\n        q[31]  <= q[0];              // new MSB \u2190 old LSB (tap at 32)\n        // all the untouched positions just shift right by one\n        q[30:22] <= q[31:23];\n        q[20:2]  <= q[21:3];\n    end\nend\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n\n    // From the truth\u2010table, q is high exactly when (a OR b) AND (c OR d) is true\n    assign q = (a | b) & (c | d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a,\n    input  p1b,\n    input  p1c,\n    input  p1d,\n    output p1y,\n    input  p2a,\n    input  p2b,\n    input  p2c,\n    input  p2d,\n    output p2y\n);\n\n    // Two independent 4\u2011input NAND gates\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input  [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    always @* begin\n        out = 8'd0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // (1) both this bit and its left\u2010neighbour are 1\n    assign out_both    = in[2:0] & in[3:1];\n    // (2) any of this bit or its right\u2010neighbour is 1\n    assign out_any     = in[3:1] | in[2:0];\n    // (3) this bit differs from its left neighbor, with wrap\n    //    left\u2010neighbour of bit i is in[(i+1)%4]:\n    //    {in[0],in[3:1]} gives left\u2010neighbours [3:0]\n    assign out_different = in ^ { in[0], in[3:1] };\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input  [2:0]    a,\n    output reg [15:0] q\n);\n\n    // purely combinational lookup table inferred from the waveform\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'hAEE0;\n            3'd2: q = 16'h27D4;\n            3'd3: q = 16'h5A0E;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64CE;\n            3'd6: q = 16'hC526;\n            3'd7: q = 16'h2F19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // Bubble on in2 into an AND gate -> out = in1 AND (NOT in2)\n    assign out = in1 & ~in2;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // Combinationally drive out with the value of in\n    assign out = in;\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  areset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic (Moore machine)\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore: depends only on state)\n    assign out = (state == B);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input        clk,\n    input        d,\n    output reg   q\n);\n\n    // two single\u2011edge registers\n    reg q_pos, q_neg;\n\n    // sample on rising edge\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    // sample on falling edge\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    // mux between the two samples\n    always @(*) begin\n        // when clk=1, use the rising\u2010edge sample;\n        // when clk=0, use the falling\u2010edge sample\n        q = clk ? q_pos : q_neg;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n    // XNOR implementation\n    assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input  x,\n    input  y,\n    output z\n);\n    // z = (x ^ y) & x\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input  x,\n    input  y,\n    output z\n);\n    // From the waveform, B implements XNOR\n    assign z = ~(x ^ y);\nendmodule\n\nmodule top_module(\n    input  x,\n    input  y,\n    output z\n);\n    wire a1_z, b1_z;\n    wire a2_z, b2_z;\n    wire or_out, and_out;\n\n    // first pair drives OR\n    A  uA1 (.x(x), .y(y), .z(a1_z));\n    B  uB1 (.x(x), .y(y), .z(b1_z));\n    assign or_out  = a1_z | b1_z;\n\n    // second pair drives AND\n    A  uA2 (.x(x), .y(y), .z(a2_z));\n    B  uB2 (.x(x), .y(y), .z(b2_z));\n    assign and_out = a2_z & b2_z;\n\n    // final XOR\n    assign z = or_out ^ and_out;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input       [1:0]  ena,\n    input       [99:0] data,\n    output reg  [99:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // synchronous load\n            q <= data;\n        end else begin\n            // synchronous rotate\n            case (ena)\n                2'b01: // rotate right by one\n                    q <= { q[0],    q[99:1] };\n                2'b10: // rotate left by one\n                    q <= { q[98:0], q[99]   };\n                default: // 2'b00 or 2'b11: hold\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,  // active\u2010high synchronous\n    output reg [9:0] q\n);\n\n    // Count from 0 to 999 inclusive, then wrap back to 0\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0;\n        end else if (q == 10'd999) begin\n            q <= 10'd0;\n        end else begin\n            q <= q + 10'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n\n    // Continuous assignment implementing NOT gate\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input        in,\n    input  [9:0] state,\n    output [9:0] next_state,\n    output       out1,\n    output       out2\n);\n\n    // next_state logic (one\u2010hot encoded)\n    assign next_state[0] = ~in & (state[0] | state[1] | state[2] \n                                | state[3] | state[4] | state[7]\n                                | state[8] | state[9]);\n    assign next_state[1] =  in & (state[0] | state[8] | state[9]);\n    assign next_state[2] =  in &  state[1];\n    assign next_state[3] =  in &  state[2];\n    assign next_state[4] =  in &  state[3];\n    assign next_state[5] =  in &  state[4];\n    assign next_state[6] =  in &  state[5];\n    assign next_state[7] =  in & (state[6] | state[7]);\n    assign next_state[8] = ~in &  state[5];\n    assign next_state[9] = ~in &  state[6];\n\n    // output logic\n    // S7 => (out1=0,out2=1)\n    // S8 => (out1=1,out2=0)\n    // S9 => (out1=1,out2=1)\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        j,\n    input        k,\n    output reg   Q\n);\n\n    always @(posedge clk) begin\n        case ({j,k})\n            2'b00: Q <= Q;    // hold\n            2'b01: Q <= 1'b0; // reset\n            2'b10: Q <= 1'b1; // set\n            2'b11: Q <= ~Q;   // toggle\n        endcase\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] in,\n    output [1:0] out\n);\n    // count the number of '1's in the 3-bit input\n    assign out = in[0] + in[1] + in[2];\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    input  e,\n    output [24:0] out\n);\n\n    // pack inputs into an array for indexed access\n    wire [4:0] s = { a, b, c, d, e };\n\n    genvar i, j;\n    generate\n        for (i = 0; i < 5; i = i + 1) begin : ROW\n            for (j = 0; j < 5; j = j + 1) begin : COL\n                // bit\u2010position = (4\u2010i)*5 + (4\u2010j), XNOR = ~(s[i]^s[j])\n                assign out[(4-i)*5 + (4-j)] = s[i] ~^ s[j];\n            end\n        end\n    endgenerate\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // State encoding\n    localparam LEFT  = 1'b0,\n               RIGHT = 1'b1;\n\n    reg state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    // On any bump, invert direction (Moore machine)\n    always @(*) begin\n        if (bump_left | bump_right)\n            next_state = ~state;\n        else\n            next_state = state;\n    end\n\n    // Output logic (Moore: outputs = function of state only)\n    assign walk_left  = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output q\n);\n\n    // From the waveform: q is high only when both a and b are high\n    assign q = a & b;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input  p1a, \n    input  p1b, \n    input  p1c, \n    input  p1d,\n    input  p1e,\n    input  p1f,\n    output p1y, \n    input  p2a, \n    input  p2b, \n    input  p2c, \n    input  p2d, \n    output p2y\n);\n\n    // intermediate AND gate outputs\n    wire and1_p1;\n    wire and2_p1;\n    wire and1_p2;\n    wire and2_p2;\n\n    // p1: two 3\u2011input ANDs feeding a 2\u2011input OR\n    assign and1_p1 = p1a & p1b & p1c;\n    assign and2_p1 = p1d & p1e & p1f;\n    assign p1y     = and1_p1 | and2_p1;\n\n    // p2: two 2\u2011input ANDs feeding a 2\u2011input OR\n    assign and1_p2 = p2a & p2b;\n    assign and2_p2 = p2c & p2d;\n    assign p2y     = and1_p2 | and2_p2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,    // not used in combinational next\u2010state logic\n    input        x,\n    input  [2:0] y,      // present state\n    output reg   Y0,     // next\u2010state bit 0\n    output reg   z       // Moore output\n);\n\n    always @* begin\n        // next\u2010state bit Y0\n        //   For y<2:0> = 000,001,010,011,100 as per table\n        //   Y0 = 1 for (000,x=1),(001,x=0),(010,x=1),(011,x=0),(100,x=0)\n        //   which simplifies to:\n        Y0 = (~y[2] & (x ^ y[0]))\n           | ( y[2] & ~y[1] & ~y[0] & ~x);\n\n        // Moore output z = 1 in states 011 or 100\n        z  = (~y[2] &  y[1] &  y[0])\n           | ( y[2] & ~y[1] & ~y[0]);\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    output logic out\n);\n\n    // 2-input NOR: out is true when both in1 and in2 are 0\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n    // continuous assignments to wire outputs\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic d,\n    input  logic ar,   // asynchronous reset, active\u2010high\n    output logic q\n);\n\n    // Positive\u2010edge\u2010triggered D\u2010FF with asynchronous reset\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input  [2:0] sel,\n    input  [3:0] data0,\n    input  [3:0] data1,\n    input  [3:0] data2,\n    input  [3:0] data3,\n    input  [3:0] data4,\n    input  [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input        clk, \n    input        load, \n    input  [9:0] data, \n    output       tc\n);\n\n    reg [9:0] count;\n\n    // On each clock, either load a new value or decrement until zero\n    always @(posedge clk) begin\n        if (load)\n            count <= data;\n        else if (count != 10'd0)\n            count <= count - 10'd1;\n    end\n\n    // Terminal count flag is high when count is zero\n    assign tc = (count == 10'd0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,        // active\u2010high synchronous\n    input  data,\n    output start_shifting\n);\n\n    // State encoding\n    localparam IDLE = 2'd0,\n               S1   = 2'd1,  // saw \u201c1\u201d\n               S2   = 2'd2,  // saw \u201c11\u201d\n               S3   = 2'd3;  // saw \u201c110\u201d\n\n    reg [1:0] state, next_state;\n    reg       shifting_reg;\n\n    // output register\n    assign start_shifting = shifting_reg;\n\n    // State and output register update\n    always @(posedge clk) begin\n        if (reset) begin\n            state         <= IDLE;\n            shifting_reg  <= 1'b0;\n        end else begin\n            state <= next_state;\n            // latch on the 1 of \u201c1101\u201d\n            if (state == S3 && data)\n                shifting_reg <= 1'b1;\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = data ? S1   : IDLE;\n            S1:   next_state = data ? S2   : IDLE;\n            S2:   next_state = data ? S2   : S3;\n            S3:   next_state = data ? S1   : IDLE;  // on \u20181\u2019 we've seen 1101, overlap to S1\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // Eight D\u2010FFs with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    reg [7:0] prev;\n\n    always @(posedge clk) begin\n        // detect 0\u21921 on each bit (rising edge)\n        anyedge <= (~prev) & in;\n        // save input for next\u2010cycle comparison\n        prev     <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd1;\n        else if (q == 4'd10)\n            q <= 4'd1;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input        clk,\n    input        a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            // when a==1, load/hold 4\n            q <= 3'd4;\n        end else begin\n            // when a==0, count 0\u20136, wrap 6\u21920\n            if (q == 3'd6)\n                q <= 3'd0;\n            else\n                q <= q + 3'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": ""}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input        do_sub,\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [7:0] out,\n    output reg   result_is_zero\n);\n\n    always @(*) begin\n        // compute sum or difference\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n\n        // set zero flag\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": ""}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input  [7:0] code,\n    output reg [3:0] out,\n    output reg       valid\n);\n\n    always @* begin\n        valid = 1'b0;\n        out   = 4'd0;\n        case (code)\n            8'h45: begin out = 4'd0; valid = 1; end\n            8'h16: begin out = 4'd1; valid = 1; end\n            8'h1e: begin out = 4'd2; valid = 1; end\n            8'h26: begin out = 4'd3; valid = 1; end\n            8'h25: begin out = 4'd4; valid = 1; end\n            8'h2e: begin out = 4'd5; valid = 1; end\n            8'h36: begin out = 4'd6; valid = 1; end\n            8'h3d: begin out = 4'd7; valid = 1; end\n            8'h3e: begin out = 4'd8; valid = 1; end\n            8'h46: begin out = 4'd9; valid = 1; end\n            default: begin out = 4'd0; valid = 0; end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output [7:0] out\n);\n\n    // Reverse bit order: out[7] = in[0], out[6] = in[1], \u2026, out[0] = in[7]\n    assign out = { in[0], in[1], in[2], in[3],\n                   in[4], in[5], in[6], in[7] };\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output reg out\n);\n\n    always @(*) begin\n        out = a | (~b & c);\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        shift_ena,\n    input        count_ena,\n    input        data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // shift in MSB\u2010first\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // down\u2010count\n            q <= q - 1;\n        end\n        // else retain q\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input  in,\n    output out\n);\n    // simply wire the input to the output\n    assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input  clk,\n    input  reset,       // synchronous, active\u2010high\n    output shift_ena\n);\n\n    // count down 4 clocks after reset\n    reg [2:0] cnt;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cnt <= 3'd4;        // preload 4 cycles\n        end else if (cnt != 3'd0) begin\n            cnt <= cnt - 3'd1;  // count down\n        end\n        // else hold at 0\n    end\n\n    // shift_ena is high while count>0\n    assign shift_ena = (cnt != 3'd0);\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    // 4\u2011bit synchronous counter with active\u2011high reset\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1;\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel_b1,\n    input  sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Continuous\u2010assignment version\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Procedural\u2010always version\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    input  c,\n    output out\n);\n\n    // Function is 1 for all inputs except a=b=c=0\n    // So out = a OR b OR c\n    assign out = a | b | c;\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input        clk,\n    input        resetn,\n    input  [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    reg [1:0] state, next_state;\n\n    // State register (synchronous, active\u2010low reset)\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1])\n                    next_state = B;     // grant device 1\n                else if (r[2])\n                    next_state = C;     // grant device 2\n                else if (r[3])\n                    next_state = D;     // grant device 3\n                else\n                    next_state = A;     // no requests\n            end\n\n            B: // stay in B while r1 remains asserted\n                next_state = r[1] ? B : A;\n\n            C: // stay in C while r2 remains asserted\n                next_state = r[2] ? C : A;\n\n            D: // stay in D while r3 remains asserted\n                next_state = r[3] ? D : A;\n\n            default:\n                next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    output reg [3:0] q\n);\n\n    // Synchronous active\u2010high reset decade counter (0\u20139)\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else begin\n            if (q == 4'd9)\n                q <= 4'd0;\n            else\n                q <= q + 4'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input  [7:0] in,\n    input        reset,\n    output       done\n);\n\n    // count = number of bytes seen in current packet (0\u20132)\n    reg [1:0] count;\n\n    // done is high for one cycle just after the 3rd byte arrives\n    assign done = (count == 2);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            case (count)\n                0: begin\n                    // wait for a byte with in[3]=1 \u2192 first byte\n                    if (in[3])\n                        count <= 1;\n                end\n                1: begin\n                    // we have byte #1, next is byte #2\n                    count <= 2;\n                end\n                2: begin\n                    // byte #3 received; signal done (via combinational done)\n                    // and restart looking for next sync\n                    count <= 0;\n                end\n                default: count <= 0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  sel,\n    output out\n);\n\n    // 2-to-1 multiplexer: when sel=0 choose a, when sel=1 choose b\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output       out_and,\n    output       out_or,\n    output       out_xor\n);\n\n    // reduction operators perform multi\u2010input logic in one line\n    assign out_and = &in;   // 4\u2010input AND\n    assign out_or  = |in;   // 4\u2010input OR\n    assign out_xor = ^in;   // 4\u2010input XOR\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,\n    input        x,\n    output reg   z\n);\n\n    reg [2:0] y, y_next;\n    reg       z_next;\n\n    // next\u2010state and output logic (Moore machine)\n    always @(*) begin\n        y_next = 3'b000;\n        z_next = 1'b0;\n        case (y)\n            3'b000: begin\n                z_next = 1'b0;\n                y_next = x ? 3'b001 : 3'b000;\n            end\n            3'b001: begin\n                z_next = 1'b0;\n                y_next = x ? 3'b100 : 3'b001;\n            end\n            3'b010: begin\n                z_next = 1'b0;\n                y_next = x ? 3'b001 : 3'b010;\n            end\n            3'b011: begin\n                z_next = 1'b1;\n                y_next = x ? 3'b010 : 3'b001;\n            end\n            3'b100: begin\n                z_next = 1'b1;\n                y_next = x ? 3'b100 : 3'b011;\n            end\n            default: begin\n                z_next = 1'b0;\n                y_next = 3'b000;\n            end\n        endcase\n    end\n\n    // state register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            y <= y_next;\n            z <= z_next;\n        end\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,\n    input  x,\n    input  y,\n    output f,\n    output g\n);\n\n    // State encoding\n    localparam S_A     = 4'd0,  // Idle / after reset\n               S_B     = 4'd1,  // f = 1 for one cycle\n               S_X1    = 4'd2,  // saw nothing yet, wait x=1\n               S_X2    = 4'd3,  // got 1, wait x=0\n               S_X3    = 4'd4,  // got 1,0, wait x=1\n               S_Y0    = 4'd5,  // asserted g=1, check y (cycle 0)\n               S_Y1    = 4'd6,  // g=1, check y (cycle 1)\n               S_HOLD  = 4'd7,  // permanent g=1\n               S_FAIL  = 4'd8;  // permanent g=0\n\n    reg [3:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= S_A;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case(state)\n            S_A: begin\n                // stay until resetn de\u2010asserts, then go to B\n                if (resetn)\n                    next_state = S_B;\n            end\n\n            S_B: begin\n                // one\u2010cycle pulse on f\n                next_state = S_X1;\n            end\n\n            S_X1: begin\n                // wait for first '1'\n                if (x)\n                    next_state = S_X2;\n                else\n                    next_state = S_X1;\n            end\n\n            S_X2: begin\n                // wait for '0'\n                if (x == 1'b0)\n                    next_state = S_X3;\n                else\n                    // treat a '1' as a new start\n                    next_state = S_X2;\n            end\n\n            S_X3: begin\n                // wait for final '1'\n                if (x)\n                    next_state = S_Y0;\n                else\n                    next_state = S_X1;\n            end\n\n            S_Y0: begin\n                // g=1, check y on this cycle\n                if (y)\n                    next_state = S_HOLD;\n                else\n                    next_state = S_Y1;\n            end\n\n            S_Y1: begin\n                // second chance to see y=1\n                if (y)\n                    next_state = S_HOLD;\n                else\n                    next_state = S_FAIL;\n            end\n\n            S_HOLD: begin\n                // stay here, g=1 permanently\n                next_state = S_HOLD;\n            end\n\n            S_FAIL: begin\n                // stay here, g=0 permanently\n                next_state = S_FAIL;\n            end\n\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Outputs (Moore)\n    reg f_reg, g_reg;\n    always @(*) begin\n        f_reg = 1'b0;\n        g_reg = 1'b0;\n        case(state)\n            S_B:    f_reg = 1'b1;            // one\u2010cycle f\n            S_Y0,\n            S_Y1,\n            S_HOLD: g_reg = 1'b1;            // g=1 during Y0, Y1, HOLD\n            default: ;\n        endcase\n    end\n\n    assign f = f_reg;\n    assign g = g_reg;\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        reset,\n    output reg [7:0] q\n);\n\n    // 8 D\u2010FFs with negative\u2010edge clock and synchronous, active\u2010high reset to 0x34\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input  [7:0] in,\n    output       parity\n);\n    // even parity bit: XOR reduction of all data bits\n    assign parity = ^in;\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [1:0] state,\n    output reg [1:0] next_state,\n    output       out\n);\n\n    // Next\u2010state Logic\n    always @(*) begin\n        case (state)\n            2'b00: // A\n                next_state = (in ? 2'b01 : 2'b00); // B : A\n            2'b01: // B\n                next_state = (in ? 2'b01 : 2'b10); // B : C\n            2'b10: // C\n                next_state = (in ? 2'b11 : 2'b00); // D : A\n            2'b11: // D\n                next_state = (in ? 2'b01 : 2'b10); // B : C\n            default:\n                next_state = 2'b00;\n        endcase\n    end\n\n    // Output Logic (Moore: only depends on current state)\n    assign out = (state == 2'b11); // 1 only in state D\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input  x,\n    input  y,\n    output z\n);\n\n    // z is high when x and y are equal (XNOR function)\n    assign z = x ~^ y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  reset,\n    input  w,\n    output z\n);\n\n    // State encoding\n    localparam A = 3'd0,\n               B = 3'd1,\n               C = 3'd2,\n               D = 3'd3,\n               E = 3'd4,\n               F = 3'd5;\n\n    reg [2:0] state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register (synchronous, reset active-high)\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic (Moore machine: z=1 in E or F)\n    assign z = (state == E) || (state == F);\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        resetn,\n    input  [1:0] byteena,\n    input  [15:0] d,\n    output reg [15:0] q\n);\n\n    // On each rising clk edge: synchronous active\u2010low reset,\n    // then conditional byte\u2010wide writes\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            // Lower byte [7:0]\n            if (byteena[0])\n                q[7:0] <= d[7:0];\n            // Upper byte [15:8]\n            if (byteena[1])\n                q[15:8] <= d[15:8];\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // register to hold previous-cycle input\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // detect 0\u21921 per bit: output in the cycle after transition\n        pedge   <= (~prev_in) & in;\n        // update previous-input register\n        prev_in <= in;\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input  clock,\n    input  a,\n    output reg p,\n    output reg q\n);\n\n// master latch: transparent when clock=1, holds when clock=0\nalways @(*) begin\n    if (clock)\n        p = a;\nend\n\n// slave latch: transparent when clock=0, holds when clock=1\nalways @(*) begin\n    if (!clock)\n        q = p;\nend\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [511:0] data,\n    output reg [511:0] q\n);\n\n    // compute next state for each cell under Rule 90\n    wire [511:0] next_q;\n\n    // boundary cells (outside array are zero)\n    assign next_q[0]   = q[1]      ^ 1'b0;\n    assign next_q[511] = q[510]    ^ 1'b0;\n\n    // interior cells\n    genvar i;\n    generate\n        for (i = 1; i < 511; i = i + 1) begin : rule90\n            assign next_q[i] = q[i-1] ^ q[i+1];\n        end\n    endgenerate\n\n    // state register\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input  [1:0] A,\n    input  [1:0] B,\n    output       z\n);\n\n    // z is 1 when A equals B\n    assign z = (A == B);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // (1) both this bit and its left neighbour (higher index) are '1'\n    assign out_both      = in[98:0] & in[99:1];\n\n    // (2) any of this bit and its right neighbour (lower index) is '1'\n    assign out_any       = in[99:1] | in[98:0];\n\n    // (3) bit differs from its left neighbour, with wrap\u2010around\n    //     neighbour vector = {in[0], in[99:1]}\n    assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input  logic d,\n    input  logic ena,\n    output logic q\n);\n\n    // Infer a transparent latch:\n    always @ (ena or d) begin\n        if (ena)\n            q = d;\n        // else: q retains its previous value (latch)\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module top_module (\n    input  [1023:0] in,\n    input  [7:0]   sel,\n    output [3:0]   out\n);\n\n    // compute bit\u2010offset = sel*4\n    wire [9:0] start = sel << 2;\n\n    // extract 4\u2010bit slice starting at that offset\n    assign out = in[start +: 4];\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input  [15:0] a,\n    input  [15:0] b,\n    input  [15:0] c,\n    input  [15:0] d,\n    input  [15:0] e,\n    input  [15:0] f,\n    input  [15:0] g,\n    input  [15:0] h,\n    input  [15:0] i,\n    input  [3:0]  sel,\n    output logic [15:0] out\n);\n\n    always_comb begin\n        case (sel)\n            4'd0:  out = a;\n            4'd1:  out = b;\n            4'd2:  out = c;\n            4'd3:  out = d;\n            4'd4:  out = e;\n            4'd5:  out = f;\n            4'd6:  out = g;\n            4'd7:  out = h;\n            4'd8:  out = i;\n            default: out = 16'hFFFF;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input  [2:0] a, \n    input  [2:0] b, \n    output [2:0] out_or_bitwise,\n    output        out_or_logical,\n    output [5:0] out_not\n);\n\n    // bitwise OR of the two vectors\n    assign out_or_bitwise = a | b;\n\n    // logical OR of the two vectors (1 if any bit in a or b is 1)\n    assign out_or_logical = |(a | b);\n\n    // upper half = NOT b; lower half = NOT a\n    assign out_not = { ~b, ~a };\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input        in,\n    input  [3:0] state,\n    output reg [3:0] next_state,\n    output       out\n);\n\n    // next_state bits: one\u2010hot encoding A=state[0], B=state[1], C=state[2], D=state[3]\n    always @(*) begin\n        // A\u2192A/B, B\u2192C/B, C\u2192A/D, D\u2192C/B\n        next_state[0] = ~in & (state[0] | state[2]);            // A \u2190 (A & ~in) or (C & ~in)\n        next_state[1] =  in & (state[0] | state[1] | state[3]); // B \u2190 (A|B|D) & in\n        next_state[2] = ~in & (state[1] | state[3]);            // C \u2190 (B|D) & ~in\n        next_state[3] =  in &  state[2];                        // D \u2190 C & in\n    end\n\n    // Moore output: 1 only in state D\n    assign out = state[3];\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input  [7:0] a,\n    input  [7:0] b,\n    input  [7:0] c,\n    input  [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    // Basic logic gate implementations\n    assign out_and   = a & b;\n    assign out_or    = a | b;\n    assign out_xor   = a ^ b;\n    assign out_nand  = ~(a & b);\n    assign out_nor   = ~(a | b);\n    assign out_xnor  = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": ""}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input        clk,\n    input        reset,  // active\u2010high synchronous\n    input        s,\n    input        w,\n    output reg   z\n);\n\n    // state encoding\n    localparam A   = 3'd0,\n               B0  = 3'd1,\n               B1  = 3'd2,\n               B2  = 3'd3,\n               ZS  = 3'd4;\n\n    reg [2:0] state;\n    reg [1:0] count_w;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= A;\n            count_w <= 2'd0;\n            z       <= 1'b0;\n        end else begin\n            // default\n            z <= 1'b0;\n            case (state)\n                // wait for s=1\n                A: begin\n                    if (s)\n                        state <= B0;\n                    else\n                        state <= A;\n                end\n\n                // sample 1st w\n                B0: begin\n                    count_w <= w ? 2'd1 : 2'd0;\n                    state   <= B1;\n                end\n\n                // sample 2nd w\n                B1: begin\n                    count_w <= count_w + (w ? 2'd1 : 2'd0);\n                    state   <= B2;\n                end\n\n                // sample 3rd w\n                B2: begin\n                    count_w <= count_w + (w ? 2'd1 : 2'd0);\n                    state   <= ZS;\n                end\n\n                // assert z if exactly two 1's were seen\n                ZS: begin\n                    z       <= (count_w == 2);\n                    count_w <= 2'd0;\n                    state   <= B0; \n                end\n\n                default: begin\n                    state   <= A;\n                    count_w <= 2'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input  [7:0]  in,\n    output [31:0] out\n);\n\n    // replicate the sign bit (in[7]) 24 times, then concatenate with the original 8\u2010bit value\n    assign out = {{24{in[7]}}, in};\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  resetn,  // active\u2010low synchronous reset\n    input  in,\n    output out\n);\n\n    // 4-bit shift register\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0000;       // synchronous reset when resetn is low\n        else\n            shift_reg <= { shift_reg[2:0], in }; // shift left, LSB gets 'in'\n    end\n\n    assign out = shift_reg[3]; // MSB of the 4\u2010stage shift register\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input  [3:0] in,\n    output reg [1:0] pos\n);\n    always @(*) begin\n        if      (in[0]) pos = 2'b00;\n        else if (in[1]) pos = 2'b01;\n        else if (in[2]) pos = 2'b10;\n        else if (in[3]) pos = 2'b11;\n        else             pos = 2'b00;\n    end\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // State register with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic (Moore FSM)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic (Moore: output depends only on state)\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out\n);\n    // Constantly drive out to logic 0\n    assign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one\n);\n    // Continuously drive the output high\n    assign one = 1'b1;\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1)\n            out[i] = in[99 - i];\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  logic clk,\n    input  logic in,\n    output logic out\n);\n\n    // D input is XOR of in and out\n    logic d;\n    assign d = in ^ out;\n\n    // Positive\u2010edge\u2010triggered D\u2010FF, no reset\n    always_ff @(posedge clk) begin\n        out <= d;\n    end\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        areset,  // asynchronous, active\u2010high\n    input        load,    // synchronous, active\u2010high\n    input        ena,     // synchronous, active\u2010high\n    input  [3:0] data,    // parallel load data\n    output reg [3:0] q     // shift\u2010register state\n);\n\n    // on posedge clk or posedge areset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // async reset\n            q <= 4'b0000;\n        end else begin\n            // sync operations: load has priority over shift\n            if (load) begin\n                q <= data;\n            end else if (ena) begin\n                // right shift: MSB \u2190 0, LSB is lost\n                q <= {1'b0, q[3:1]};\n            end\n            // else retain q\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input  x3,\n    input  x2,\n    input  x1,\n    output f\n);\n\n    // Simplified Boolean expression from the truth\u2010table\n    // f = x2\u00b7~x3 + x1\u00b7(x2 + x3)\n    assign f = (x2 & ~x3) | (x1 & (x2 | x3));\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input  [7:0] d,\n    input        areset,\n    output reg [7:0] q\n);\n\n    // 8 DFFs with active\u2010high asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input  [99:0] in,\n    output        out_and,\n    output        out_or,\n    output        out_xor\n);\n\n    // 100\u2011input reductions\n    assign out_and = &in;\n    assign out_or  = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    output sum,\n    output cout\n);\n\n    // Sum is XOR of inputs, carry is AND of inputs\n    assign sum  = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input  cpu_overheated,\n    output reg shut_off_computer,\n    input  arrived,\n    input  gas_tank_empty,\n    output reg keep_driving\n);\n\n    // combinational logic for shutting off the computer\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    // combinational logic for deciding to keep driving\n    always @(*) begin\n        if (!arrived && !gas_tank_empty)\n            keep_driving = 1'b1;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  j,\n    input  k,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam OFF = 1'b0,\n               ON  = 1'b1;\n\n    reg state, next_state;\n\n    // Next\u2010state logic (combinational)\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON  : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register (synchronous active\u2010high reset)\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Moore output\n    assign out = (state == ON);\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input  [4:0] a,\n    input  [4:0] b,\n    input  [4:0] c,\n    input  [4:0] d,\n    input  [4:0] e,\n    input  [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n    // Concatenate a\u2013f (30\u2009bits) then two '1' bits \u2192 32\u2009bits,\n    // and split into four 8\u2011bit outputs w, x, y, z.\n    assign {w, x, y, z} = {a, b, c, d, e, f, 1'b1, 1'b1};\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  c,\n    input  d,\n    output q\n);\n    // q = 1 if and only if {a,b,c,d} has even parity\n    assign q = ~(a ^ b ^ c ^ d);\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input  a,\n    input  b,\n    output out\n);\n\n    // AND gate implementation\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input  clk,\n    input  in,\n    input  reset,\n    output out\n);\n\n    // State encoding\n    localparam A = 1'b0,\n               B = 1'b1;\n\n    reg state, next_state;\n\n    // Output logic (Moore)\n    assign out = (state == B);\n\n    // State register with synchronous active\u2010high reset\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input  a,\n    input  b,\n    input  cin,\n    output cout,\n    output sum\n);\n\n    // sum = a \u2295 b \u2295 cin\n    assign sum  = a ^ b ^ cin;\n\n    // cout = majority(a, b, cin)\n    assign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input  in1,\n    input  in2,\n    input  in3,\n    output logic out\n);\n\n    // intermediate signal for the XNOR of in1 and in2\n    logic xnor_out;\n\n    // 2\u2011input XNOR\n    assign xnor_out = in1 ~^ in2;\n\n    // 2\u2011input XOR of the XNOR result with in3\n    assign out = xnor_out ^ in3;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input  c,\n    input  d,\n    output [3:0] mux_in\n);\n    // mux_in[0] = c OR d  = c?1:d\n    assign mux_in[0] = c ? 1'b1 : d;\n    // mux_in[1] = 0\n    assign mux_in[1] = 1'b0;\n    // mux_in[2] = c AND d = c?d:0\n    assign mux_in[2] = c ? d : 1'b0;\n    // First form \u00acd using one 2\u22361 mux:\n    wire nd;\n    assign nd        = d ? 1'b0 : 1'b1;\n    // mux_in[3] = \u00acd OR c = c?1:nd\n    assign mux_in[3] = c ? 1'b1 : nd;\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,  // asynchronous, active\u2010high reset\n    input  x,\n    output z\n);\n\n    // one\u2010hot state encoding\n    reg state_A, state_B;\n    reg next_A,  next_B;\n\n    // Mealy output logic\n    // In A: z = x\n    // In B: z = ~x\n    assign z = state_A ? x : ~x;\n\n    // next\u2010state logic (combinational)\n    always @(*) begin\n        // default: de\u2010assert all\n        next_A = 1'b0;\n        next_B = 1'b0;\n        if (state_A) begin\n            // state A\n            if (x)\n                next_B = 1'b1;\n            else\n                next_A = 1'b1;\n        end else begin\n            // state B (once in B, stay in B)\n            next_B = 1'b1;\n        end\n    end\n\n    // state register with asynchronous active\u2010high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;  // reset to A\n            state_B <= 1'b0;\n        end else begin\n            state_A <= next_A;\n            state_B <= next_B;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": ""}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input  [4:1] x,    // x[1]=x1, x[2]=x2, x[3]=x3, x[4]=x4\n    output logic f\n);\n\n    // from K\u2011map grouping:\n    //   f = ~x2&~x4  +  x3&~x1  +  x2&x3&x4\n    assign f = (~x[2] & ~x[4])\n             | ( x[3] & ~x[1])\n             | ( x[2] &  x[3] & x[4]);\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": ""}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n    input  wire       clk,\n    input  wire       reset,   // synchronous active\u2010high\n    input  wire       data,\n    output wire [3:0] count,\n    output reg        counting,\n    output reg        done,\n    input  wire       ack\n);\n\n    // State encoding\n    localparam SEARCH      = 2'd0,\n               READ_DELAY  = 2'd1,\n               COUNT       = 2'd2,\n               DONE        = 2'd3;\n\n    reg [1:0]  state;\n    reg [3:0]  shift_reg;    // for detecting 1101\n    reg [3:0]  delay_reg;    // shifting in the 4 delay bits\n    reg [3:0]  rem_time;     // remaining time\n    reg [2:0]  bit_cnt;      // counts 0..3 for the 4 delay bits\n    reg [9:0]  cyc_cnt;      // counts 0..999 for the 1000\u2010cycle periods\n\n    // Output count is the current remaining time\n    assign count = rem_time;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state      <= SEARCH;\n            shift_reg  <= 4'd0;\n            delay_reg  <= 4'd0;\n            rem_time   <= 4'd0;\n            bit_cnt    <= 3'd0;\n            cyc_cnt    <= 10'd0;\n            counting   <= 1'b0;\n            done       <= 1'b0;\n        end else begin\n            case (state)\n                //--------------------------------------------------\n                SEARCH: begin\n                    counting  <= 1'b0;\n                    done      <= 1'b0;\n                    // shift in the serial data looking for 1101\n                    shift_reg <= { shift_reg[2:0], data };\n                    if ({ shift_reg[2:0], data } == 4'b1101) begin\n                        state     <= READ_DELAY;\n                        bit_cnt   <= 3'd0;\n                        delay_reg <= 4'd0;\n                    end\n                end\n\n                // read next 4 bits MSB first into delay_reg\n                READ_DELAY: begin\n                    counting  <= 1'b0;\n                    done      <= 1'b0;\n                    delay_reg <= { delay_reg[2:0], data };\n                    if (bit_cnt == 3) begin\n                        // latch the full 4\u2010bit delay and start counting\n                        rem_time <= { delay_reg[2:0], data };\n                        cyc_cnt  <= 10'd0;\n                        state    <= COUNT;\n                    end\n                    bit_cnt <= bit_cnt + 3'd1;\n                end\n\n                // perform the timer: (delay+1) * 1000 cycles\n                COUNT: begin\n                    counting <= 1'b1;\n                    done     <= 1'b0;\n                    if (cyc_cnt == 10'd999) begin\n                        // one 1000\u2010cycle period done\n                        cyc_cnt <= 10'd0;\n                        if (rem_time != 0) begin\n                            rem_time <= rem_time - 4'd1;\n                        end else begin\n                            // we just finished the last 1000\u2010cycle chunk at rem_time==0\n                            state <= DONE;\n                        end\n                    end else begin\n                        cyc_cnt <= cyc_cnt + 10'd1;\n                    end\n                end\n\n                // signal done until ack comes high\n                DONE: begin\n                    counting <= 1'b0;\n                    done     <= 1'b1;\n                    if (ack) begin\n                        state     <= SEARCH;\n                        shift_reg <= 4'd0;  // optional: clear detectors\n                    end\n                end\n\n                default: begin\n                    state <= SEARCH;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": ""}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output       done\n);\n\n    // State encoding\n    localparam IDLE      = 2'd0;\n    localparam GET_DATA  = 2'd1;\n    localparam STOP      = 2'd2;\n    localparam WAIT_STOP = 2'd3;\n\n    reg [1:0]  state, next_state;\n    reg [3:0]  bit_cnt;\n\n    // State and bit counter update\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= IDLE;\n            bit_cnt <= 4'd0;\n        end else begin\n            state <= next_state;\n            if (state == GET_DATA)\n                bit_cnt <= bit_cnt + 4'd1;\n            else\n                bit_cnt <= 4'd0;\n        end\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                // wait for start bit (0)\n                if (in == 1'b0)\n                    next_state = GET_DATA;\n            end\n\n            GET_DATA: begin\n                // count 8 data bits, then go sample stop\n                if (bit_cnt == 4'd8)\n                    next_state = STOP;\n            end\n\n            STOP: begin\n                // if stop bit is 1, byte done; otherwise wait for a 1\n                if (in == 1'b1)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_STOP;\n            end\n\n            WAIT_STOP: begin\n                // stay here until line returns to idle (1)\n                if (in == 1'b1)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // done is asserted for one cycle when a valid stop bit is seen\n    assign done = (state == STOP && in == 1'b1);\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input        clk,\n    input        in,\n    input        reset,\n    output [7:0] out_byte,\n    output       done\n);\n    // State encoding\n    localparam IDLE      = 2'b00;\n    localparam DATA      = 2'b01;\n    localparam STOP      = 2'b10;\n    localparam WAIT_STOP = 2'b11;\n\n    reg [1:0]  state;\n    reg [2:0]  bit_cnt;\n    reg [7:0]  data_reg;\n\n    // Output assignments\n    assign out_byte = data_reg;\n    assign done     = (state == STOP && in == 1'b1);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state   <= IDLE;\n            bit_cnt <= 3'd0;\n            data_reg<= 8'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    // Wait for start bit (0)\n                    if (in == 1'b0) begin\n                        state   <= DATA;\n                        bit_cnt <= 3'd0;\n                    end\n                end\n\n                DATA: begin\n                    // Sample 8 data bits, LSB first\n                    data_reg[bit_cnt] <= in;\n                    if (bit_cnt == 3'd7) begin\n                        state <= STOP;\n                    end\n                    bit_cnt <= bit_cnt + 3'd1;\n                end\n\n                STOP: begin\n                    // Check stop bit\n                    if (in == 1'b1) begin\n                        // Good stop bit \u2192 done will pulse for one cycle\n                        state <= IDLE;\n                    end else begin\n                        // Bad stop bit \u2192 wait for returning to idle line\n                        state <= WAIT_STOP;\n                    end\n                end\n\n                WAIT_STOP: begin\n                    // Stay here until line goes high again\n                    if (in == 1'b1) begin\n                        state <= IDLE;\n                    end\n                end\n\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input        clk,\n    input        areset, \n\n    // Prediction interface (Fetch stage)\n    input             predict_valid,\n    input      [6:0]  predict_pc,\n    output            predict_taken,\n    output     [6:0]  predict_history,\n\n    // Training interface (Execute stage)\n    input             train_valid,\n    input             train_taken,\n    input             train_mispredicted,\n    input      [6:0]  train_history,\n    input      [6:0]  train_pc\n);\n\n    // 128-entry PHT of 2-bit saturating counters\n    reg  [1:0] pht [0:127];\n    // global history register\n    reg  [6:0] history;\n\n    // combinational indices\n    wire [6:0] predict_index = predict_pc ^ history;\n    wire [6:0] train_index   = train_pc   ^ train_history;\n\n    // outputs from current state\n    assign predict_taken   = pht[predict_index][1];\n    assign predict_history = history;\n\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 7'b0;\n            // initialize PHT to weakly-taken (2'b10)\n            for (i = 0; i < 128; i = i + 1)\n                pht[i] <= 2'b10;\n        end else begin\n            // 1) Update PHT on training\n            if (train_valid) begin\n                // saturating increment/decrement\n                if (train_taken) begin\n                    if (pht[train_index] != 2'b11)\n                        pht[train_index] <= pht[train_index] + 1;\n                end else begin\n                    if (pht[train_index] != 2'b00)\n                        pht[train_index] <= pht[train_index] - 1;\n                end\n            end\n\n            // 2) Update global history:\n            //    train_valid has priority over predict_valid\n            if (train_valid) begin\n                // recover or advance history with actual outcome\n                history <= { train_history[5:0], train_taken };\n            end else if (predict_valid) begin\n                // speculative update with predicted outcome\n                history <= { history[5:0], predict_taken };\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    localparam [2:0]\n        S_WL   = 3'd0,  // walking left\n        S_WR   = 3'd1,  // walking right\n        S_FL   = 3'd2,  // falling, remembers left\n        S_FR   = 3'd3,  // falling, remembers right\n        S_DL   = 3'd4,  // digging to the left\n        S_DR   = 3'd5,  // digging to the right\n        S_SPLAT= 3'd6;  // splattered\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_cnt, next_cnt; // up to >20\n\n    // State register + fall counter\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state    <= S_WL;\n            fall_cnt <= 0;\n        end else begin\n            state    <= next_state;\n            fall_cnt <= next_cnt;\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        // default carry-forward of counter if still falling\n        if (state==S_FL || state==S_FR)\n            next_cnt = fall_cnt + 1;\n        else\n            next_cnt = 0;\n\n        case (state)\n        // SPLAT: terminal, never leaves\n        S_SPLAT: begin\n            next_state = S_SPLAT;\n        end\n\n        // WALKING\n        S_WL, S_WR: begin\n            // 1) fall if no ground\n            if (!ground) begin\n                next_state = (state==S_WL ? S_FL : S_FR);\n            end\n            // 2) dig if ground & dig request\n            else if (dig) begin\n                next_state = (state==S_WL ? S_DL : S_DR);\n            end\n            // 3) bump\n            else if (bump_left && bump_right) begin\n                // flip direction\n                next_state = (state==S_WL ? S_WR : S_WL);\n            end else if (bump_left) begin\n                next_state = S_WR;\n            end else if (bump_right) begin\n                next_state = S_WL;\n            end\n            // 4) stay walking\n            else begin\n                next_state = state;\n            end\n        end\n\n        // FALLING\n        S_FL, S_FR: begin\n            if (ground) begin\n                // hit ground: splat if fall_cnt>20, else resume walk\n                if (fall_cnt > 20)\n                    next_state = S_SPLAT;\n                else\n                    next_state = (state==S_FL ? S_WL : S_WR);\n            end else begin\n                // keep falling\n                next_state = state;\n            end\n        end\n\n        // DIGGING\n        S_DL, S_DR: begin\n            if (!ground) begin\n                // reached hole => fall\n                next_state = (state==S_DL ? S_FL : S_FR);\n            end else begin\n                // keep digging\n                next_state = state;\n            end\n        end\n\n        default: begin\n            next_state = S_WL;\n        end\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == S_WL);\n    assign walk_right = (state == S_WR);\n    assign aaah       = (state == S_FL || state == S_FR);\n    assign digging    = (state == S_DL || state == S_DR);\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": ""}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input              clk,\n    input              load,\n    input      [255:0] data,\n    output reg [255:0] q\n);\n\n    // next state\n    reg [255:0] next_q;\n\n    // loop indices\n    integer row, col;\n\n    // base addresses for a row and its neighbors (0..255)\n    reg [7:0] base, base_up, base_down;\n\n    // column indices for left/right and flat index\n    integer col_left, col_right, idx;\n\n    // neighbor count (0..8)\n    reg [3:0] count;\n\n    // combinational: compute next_q\n    always @(*) begin\n        for (row = 0; row < 16; row = row + 1) begin\n            // starting address of this row and its up/down wraps\n            base      = row        << 4;\n            base_up   = ((row == 0)  ? 15 : row - 1) << 4;\n            base_down = ((row == 15) ?  0 : row + 1) << 4;\n            for (col = 0; col < 16; col = col + 1) begin\n                // wrap columns\n                col_left  = (col == 0)  ? 15 : col - 1;\n                col_right = (col == 15) ?  0 : col + 1;\n\n                // sum the 8 neighbors\n                count =\n                    q[base_up   + col_left]  +\n                    q[base_up   + col]       +\n                    q[base_up   + col_right] +\n                    q[base      + col_left]  +\n                    q[base      + col_right] +\n                    q[base_down + col_left]  +\n                    q[base_down + col]       +\n                    q[base_down + col_right];\n\n                // flat index of current cell\n                idx = base + col;\n\n                // apply rules:\n                // 2 neighbors \u2192 stay the same\n                // 3 neighbors \u2192 alive\n                // else \u2192 dead\n                case (count)\n                    2: next_q[idx] = q[idx];\n                    3: next_q[idx] = 1'b1;\n                    default:      next_q[idx] = 1'b0;\n                endcase\n            end\n        end\n    end\n\n    // sequential: load or advance one timestep\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input  clk,\n    input  areset,\n    input  bump_left,\n    input  bump_right,\n    input  ground,\n    input  dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        WL = 3'd0,  // walking left\n        WR = 3'd1,  // walking right\n        FL = 3'd2,  // falling left\n        FR = 3'd3,  // falling right\n        DL = 3'd4,  // digging left\n        DR = 3'd5   // digging right\n    } state_t;\n\n    state_t state, next_state;\n\n    // Next\u2010state logic\n    always @(*) begin\n        case(state)\n            WL: begin\n                if (!ground)                 next_state = FL;      // fall\n                else if (dig)                next_state = DL;      // dig\n                else if (bump_left || bump_right) next_state = WR;  // bounce\n                else                         next_state = WL;\n            end\n            WR: begin\n                if (!ground)                 next_state = FR;\n                else if (dig)                next_state = DR;\n                else if (bump_left || bump_right) next_state = WL;\n                else                         next_state = WR;\n            end\n            FL: begin\n                if (ground)                  next_state = WL;      // land \u2192 resume left\n                else                         next_state = FL;\n            end\n            FR: begin\n                if (ground)                  next_state = WR;      // land \u2192 resume right\n                else                         next_state = FR;\n            end\n            DL: begin\n                if (!ground)                 next_state = FL;      // fall off end of dig\n                else                         next_state = DL;\n            end\n            DR: begin\n                if (!ground)                 next_state = FR;\n                else                         next_state = DR;\n            end\n            default: next_state = WL;\n        endcase\n    end\n\n    // State register with async posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WL;\n        else\n            state <= next_state;\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n    assign digging    = (state == DL) || (state == DR);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,\n    input        ena,\n    output reg   pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            ss <= 8'h00;      // 00 seconds\n            mm <= 8'h00;      // 00 minutes\n            hh <= 8'h12;      // 12 hours\n            pm <= 1'b0;       // AM\n        end else if (ena) begin\n            // increment seconds (BCD)\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                // increment minutes (BCD)\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    // increment hours (1\u201312 BCD)\n                    case (hh)\n                        8'h12: begin\n                            hh <= 8'h01;\n                            pm <= ~pm;\n                        end\n                        8'h09: hh <= 8'h10;    // 9\u219210\n                        default: hh <= hh + 8'h01;\n                    endcase\n                end else begin\n                    // BCD\u2010add 1 to mm\n                    if (mm[3:0] == 4'h9)\n                        mm <= { mm[7:4] + 4'h1, 4'h0 };\n                    else\n                        mm <= mm + 8'h01;\n                end\n            end else begin\n                // BCD\u2010add 1 to ss\n                if (ss[3:0] == 4'h9)\n                    ss <= { ss[7:4] + 4'h1, 4'h0 };\n                else\n                    ss <= ss + 8'h01;\n            end\n        end\n    end\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    // State encoding\n    localparam WL = 2\u2019d0,  // walking left\n               WR = 2\u2019d1,  // walking right\n               FL = 2\u2019d2,  // falling (remember walking\u2010left direction)\n               FR = 2\u2019d3;  // falling (remember walking\u2010right direction)\n\n    reg [1:0] state, next_state;\n\n    // State register with async. posedge reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WL;\n        else\n            state <= next_state;\n    end\n\n    // Next\u2010state logic\n    always @(*) begin\n        case (state)\n            WL: begin\n                if (!ground)\n                    next_state = FL;\n                else if (bump_left | bump_right)\n                    next_state = WR;\n                else\n                    next_state = WL;\n            end\n            WR: begin\n                if (!ground)\n                    next_state = FR;\n                else if (bump_left | bump_right)\n                    next_state = WL;\n                else\n                    next_state = WR;\n            end\n            FL: begin\n                if (ground)\n                    next_state = WL;\n                else\n                    next_state = FL;\n            end\n            FR: begin\n                if (ground)\n                    next_state = WR;\n                else\n                    next_state = FR;\n            end\n            default: next_state = WL;\n        endcase\n    end\n\n    // Moore outputs\n    assign walk_left  = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah       = (state == FL) || (state == FR);\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input        clk,\n    input        reset,    // synchronous, active\u2010high\n    output [3:1] ena,      // enable for digit 1 (tens), 2 (hundreds), 3 (thousands)\n    output reg [15:0] q     // BCD digits: q[3:0]=ones, q[7:4]=tens, q[11:8]=hundreds, q[15:12]=thousands\n);\n\n    // detect maximum (9) on each digit\n    wire one_max  = (q[3:0]   == 4'd9);\n    wire ten_max  = (q[7:4]   == 4'd9);\n    wire hun_max  = (q[11:8]  == 4'd9);\n\n    // ena[1] when ones rolls over, ena[2] when tens rolls over, ena[3] when hundreds rolls over\n    wire enable1 = one_max;\n    wire enable2 = one_max & ten_max;\n    wire enable3 = one_max & ten_max & hun_max;\n\n    assign ena[1] = enable1;\n    assign ena[2] = enable2;\n    assign ena[3] = enable3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'd0;\n        end else begin\n            // ones digit\n            if (enable1)\n                q[3:0] <= 4'd0;\n            else\n                q[3:0] <= q[3:0] + 4'd1;\n\n            // tens digit\n            if (enable2)\n                q[7:4] <= 4'd0;\n            else if (enable1)\n                q[7:4] <= q[7:4] + 4'd1;\n\n            // hundreds digit\n            if (enable3)\n                q[11:8] <= 4'd0;\n            else if (enable2)\n                q[11:8] <= q[11:8] + 4'd1;\n\n            // thousands digit (wraps from 9\u21920 on full rollover)\n            if (enable3) begin\n                if (q[15:12] == 4'd9)\n                    q[15:12] <= 4'd0;\n                else\n                    q[15:12] <= q[15:12] + 4'd1;\n            end\n        end\n    end\n\nendmodule"}
