{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tcase (y)\n\t\t3'b000: Y2 = (w) ? 1'b1 : 1'b0;\n\t\t3'b001: Y2 = (w) ? 1'b0 : 1'b1;\n\t\t3'b010: Y2 = (w) ? 1'b1 : 1'b0;\n\t\t3'b011: Y2 = (w) ? 1'b0 : 1'b1;\n\t\t3'b100: Y2 = (w) ? 1'b1 : 1'b0;\n\t\t3'b101: Y2 = (w) ? 1'b0 : 1'b1;\n\t\t3'b110: Y2 = (w) ? 1'b1 : 1'b0;\n\t\t3'b111: Y2 = (w) ? 1'b0 : 1'b1;\n\tendcase\nend\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "Then, add the logic for the circuit. In this case, if the phone is in vibrate mode, turn on the motor. Otherwise, turn on the ringer.\n```verilog\nassign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tout_alwaysblock = a & b;\nend\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "assign zero = 0;\n\t\t\t\t\t\t\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    reg [1:0] state;\n\n    always @(posedge clk) begin\n        case(state)\n            2'b00: begin\n                if(a) state <= 2'b01;\n            end\n            2'b01: begin\n                state <= 2'b10;\n            end\n            2'b10: begin\n                state <= 2'b00;\n            end\n            2'b11: begin\n                state <= 2'b00;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        case(state)\n            2'b00: q <= 1'b0;\n            2'b01: q <= 1'b1;\n            2'b10: q <= 1'b1;\n            2'b11: q <= 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "endmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n\n// Moore state machine\nreg [1:0] state, next_state;\nreg out_reg;\n\n// state encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// state transition logic\nalways @ (posedge clk, posedge areset) begin\n\tif (areset) begin\n\t\tstate <= A;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\tend\nend\n\n// output logic\nalways @ (state, in) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = D;\n\t\t\t\tout_reg = 1'b1;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout_reg = 1'b1;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    wire [7:0] byte0 = in[7:0];\n    wire [7:0] byte1 = in[15:8];\n    wire [7:0] byte2 = in[23:16];\n    wire [7:0] byte3 = in[31:24];\n\n    assign out = {byte3, byte2, byte1, byte0};\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        if (r) begin\n            q_reg <= 1'b0;\n        end else begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "// Voltage supply signals\n\t\tsupply1 VPWR;\n\t\tsupply0 VGND;\n\t\tsupply1 VPB ;\n\t\tsupply0 VNB ;\n\t\t\n\t\t// Boolean function implementation\n\t\tassign z = (x ^ y) & x;\n\t\t\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    reg [63:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};\n                2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};\n                2'b10: shift_reg <= {shift_reg[7:0], shift_reg[63:8]};\n                2'b11: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // Define the states\n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n\n    // Define the outputs\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg output_reg;\n\n    // Define the combinational logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n                output_reg = 0;\n            end\n            S1: begin\n                if (x)\n                    next_state = S2;\n                else\n                    next_state = S0;\n                output_reg = 0;\n            end\n            S2: begin\n                if (x)\n                    next_state = S0;\n                else\n                    next_state = S1;\n                output_reg = 1;\n            end\n        endcase\n    end\n\n    // Define the state transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (~aresetn) begin\n            state <= S0;\n            z <= 0;\n        end\n        else begin\n            state <= next_state;\n            z <= output_reg;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// Define states and outputs\n`define A 0\n`define B 1\n`define C 2\n`define D 3\n`define E 4\n`define F 5\n`define Z 1\n`define W 0\n\n// Define state register and output register\nreg [2:0] state, next_state;\nreg [0:0] output_reg;\n\n// Define state transition and output logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= A;\n\t\toutput_reg <= 0;\n\tend else begin\n\t\tstate <= next_state;\n\t\toutput_reg <= z;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tz = 0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tz = 0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = D;\n\t\t\t\tz = 0;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tz = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = C;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tend\n\t\tE: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = E;\n\t\t\t\tz = 0;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\t\tz = 1;\n\t\t\tend\n\t\tend\n\t\tF: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tz = 0;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\t\tz = 1;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n// FSM states\nlocalparam IDLE = 2'b00;\nlocalparam BYTE1 = 2'b01;\nlocalparam BYTE2 = 2'b10;\nlocalparam BYTE3 = 2'b11;\n\n// FSM registers\nreg [1:0] state_reg;\nreg [7:0] byte1_reg;\nreg [7:0] byte2_reg;\nreg [7:0] byte3_reg;\nreg done_reg;\n\n// Assign output_bytes and done\nassign out_bytes = {byte3_reg, byte2_reg, byte1_reg};\nassign done = done_reg;\n\n// FSM\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        state_reg <= IDLE;\n        byte1_reg <= 8'h00;\n        byte2_reg <= 8'h00;\n        byte3_reg <= 8'h00;\n        done_reg <= 1'b0;\n    end else begin\n        case (state_reg)\n            IDLE: begin\n                if (in[3]) begin\n                    state_reg <= BYTE1;\n                end\n            end\n            BYTE1: begin\n                byte1_reg <= in;\n                state_reg <= BYTE2;\n            end\n            BYTE2: begin\n                byte2_reg <= in;\n                state_reg <= BYTE3;\n            end\n            BYTE3: begin\n                byte3_reg <= in;\n                done_reg <= 1'b1;\n                state_reg <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // Define state encoding\n    parameter A = 6'b000001;\n    parameter B = 6'b000010;\n    parameter C = 6'b000100;\n    parameter D = 6'b001000;\n    parameter E = 6'b010000;\n    parameter F = 6'b100000;\n\n    // Define signal encoding\n    reg [5:0] state;\n    wire [5:0] next_state;\n    wire [5:0] next_state_3;\n    wire [5:0] next_state_1;\n\n    // Define state flip-flops\n    always @(posedge w)\n    begin\n        state <= next_state;\n    end\n\n    // Define state transitions\n    assign next_state = (y == A) ? A : (y == B) ? B : (y == C) ? C : (y == D) ? D : (y == E) ? E : (y == F) ? F : state;\n    assign next_state_3 = (y == A) ? A : (y == B) ? B : (y == C) ? C : (y == D) ? D : (y == E) ? E : (y == F) ? F : state;\n    assign next_state_1 = (y == A) ? A : (y == B) ? B : (y == C) ? C : (y == D) ? D : (y == E) ? E : (y == F) ? F : state;\n\n    // Define signal outputs\n    assign Y1 = (state == A) ? 1'b1 : (state == B) ? 1'b0 : (state == C) ? 1'b0 : (state == D) ? 1'b0 : (state == E) ? 1'b1 : 1'b0;\n    assign Y3 = (state == A) ? 1'b0 : (state == B) ? 1'b1 : (state == C) ? 1'b0 : (state == D) ? 1'b1 : (state == E) ? 1'b0 : 1'b0;\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case ({a,b,c,d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b1;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b1;\n        4'b0100: out = 1'b1;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b1;\n        4'b0111: out = 1'b0;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b0;\n        4'b1010: out = 1'b0;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b0;\n        4'b1101: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "// Split the input half-word into lower and upper bytes\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "In Verilog, assign is a statement and always block is a construct. assign is used to assign values to variables, and always block is used to define the behavior of the variables. The behavior can be either combinational or sequential. Combinational behavior is defined using always @(*) block, and sequential behavior is defined using always @(posedge clk) block. \n\n// assign statement\nassign out_assign = a ^ b;\n\n// combinational always block\nalways @(*) begin\n\tout_always_comb = a ^ b;\nend\n\n// clocked always block\nalways @(posedge clk) begin\n\tout_always_ff <= a ^ b;\nend\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "// Y2 = 0, 1, 0, 0, 1, 0 for states A, B,..., F, respectively\n\n// Y4 = 0, 0, 0, 1, 0, 1 for states A, B,..., F, respectively\n\n// Use the one-hot encoding to derive the logic equations for Y2 and Y4.\n\n// Use the next-state logic equations to derive the output signals Y2 and Y4.\n\n// Y2 = 1'b0 for state A\n// Y2 = 1'b1 for state B\n// Y2 = 1'b0 for state C\n// Y2 = 1'b0 for state D\n// Y2 = 1'b1 for state E\n// Y2 = 1'b0 for state F\n\n// Y4 = 1'b0 for state A\n// Y4 = 1'b0 for state B\n// Y4 = 1'b0 for state C\n// Y4 = 1'b1 for state D\n// Y4 = 1'b0 for state E\n// Y4 = 1'b1 for state F\n\n// Write Verilog for the next-state logic equations.\n\n// Y2:\n\n// Y2[0] = 1'b0 for state A\n// Y2[1] = 1'b0 for state B\n// Y2[2] = 1'b0 for state C\n// Y2[3] = 1'b0 for state D\n// Y2[4] = 1'b1 for state E\n// Y2[5] = 1'b0 for state F\n\n// Y2 = {1'b0, 1'b0, 1'b0, 1'b0, y[4], 1'b0}\n\n// Y4:\n\n// Y4[0] = 1'b0 for state A\n// Y4[1] = 1'b0 for state B\n// Y4[2] = 1'b0 for state C\n// Y4[3] = 1'b1 for state D\n// Y4[4] = 1'b0 for state E\n// Y4[5] = 1'b1 for state F\n\n// Y4 = {1'b0, 1'b0, 1'b0, 1'b1, 1'b0, 1'b1}\n\n// Use the one-hot encoding to derive the logic equations for Y2 and Y4.\n\n// Y2:\n\n// Y2[2] = y[6]\n// Y2[4] = y[5]\n\n// Y4:\n\n// Y4[2] = y[6]\n// Y4[4] = y[5]\n\n// Use the next-state logic equations to derive the output signals Y2 and Y4.\n\n// Y2:\n\n// Y2 = Y2[0:1] & Y2[2] | Y2[3:4] & Y2[4]\n\n// Y2 = (y[6] & 1'b0) | (y[5] & 1'b1)\n\n// Y2 = 1'b0\n\n// Y4:\n\n// Y4 = Y4[0:1] & Y4[2] | Y4[3:4] & Y4[4]\n\n// Y4 = (y[6] & 1'b0) | (y[5] & 1'b0)\n\n// Y4 = 1'b0\n\n// Output signals Y2 and Y4:\n\n// Y2 = 1'b0\n// Y4 = 1'b0\n\n// Assign the output signals to Y2 and Y4:\n\n// Y2 = 1'b0\n// Y4 = 1'b0\n\n// Write Verilog for the next-state logic:\n\n// Y2 = Y2[0:1] & Y2[2] | Y2[3:4] & Y2[4]\n\n// Y2 = (y[6] & 1'b0) | (y[5] & 1'b1)\n\n// Y2 = 1'b0\n\n// Y4 = Y4[0:1] & Y4[2] | Y4[3:4] & Y4[4"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "always @(posedge clk) begin\n    if (L) begin\n        if (R) begin\n            Q <= w;\n        end else begin\n            Q <= Q;\n        end\n    end else begin\n        if (E) begin\n            Q <= {Q[n-2:0], w};\n        end else begin\n            Q <= Q;\n        end\n    end\nend"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// D flip-flops\nreg [2:0] q;\n\n// XOR gate\nwire x_ff1;\nassign x_ff1 = q[0] ^ x;\n\n// AND gate\nwire a_ff2;\nassign a_ff2 = q[1] & x;\n\n// OR gate\nwire o_ff3;\nassign o_ff3 = q[2] | x;\n\n// XNOR gate\nwire z_xnor;\nassign z_xnor = ~(x_ff1 | a_ff2 | o_ff3);\n\n// D flip-flop 1\nalways @(posedge clk) begin\n\tif (q[0] == 1'b0) begin\n\t\tq[0] <= x;\n\tend\nend\n\n// D flip-flop 2\nalways @(posedge clk) begin\n\tif (q[1] == 1'b0) begin\n\t\tq[1] <= a_ff2;\n\tend\nend\n\n// D flip-flop 3\nalways @(posedge clk) begin\n\tif (q[2] == 1'b0) begin\n\t\tq[2] <= o_ff3;\n\tend\nend\n\n// Output\nassign z = z_xnor;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (a & b & c & ~d) | (a & b & ~c & d) | (a & ~b & c & d) | (~a & b & c & d) | (~a & b & c & ~d) | (~a & b & ~c & d) | (~a & ~b & c & d) | (~a & ~b & ~c & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Load the initial state on the first clock cycle\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\nend\n\n// Advance the state by one time step\nalways @(posedge clk) begin\n\tfor (i = 1; i < 512; i = i + 1) begin\n\t\tq[i] <= q[i-1] & q[i+1] | q[i-1] & q[i] | q[i] & q[i+1];\n\tend\nend\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// States\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\t\n\t// State register\n\treg [1:0] state;\n\t\n\t// Output register\n\treg out_reg;\n\t\n\t// State transition and output logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\t\tout_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Output assignment\n\tassign out = out_reg;\n\t\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) begin\n\t\tcase ({a,b})\n\t\t\t4'b0000: q = 4'b0000; // x\n\t\t\t4'b0001: q = 4'b0000; // x\n\t\t\t4'b0010: q = 4'b0000; // x\n\t\t\t4'b0011: q = 4'b0000; // x\n\t\t\t4'b0100: q = 4'b0000; // x\n\t\t\t4'b0101: q = 4'b0000; // x\n\t\t\t4'b0110: q = 4'b0000; // x\n\t\t\t4'b0111: q = 4'b0000; // x\n\t\t\t4'b1000: q = 4'b0000; // x\n\t\t\t4'b1001: q = 4'b0000; // x\n\t\t\t4'b1010: q = 4'b0000; // x\n\t\t\t4'b1011: q = 4'b0000; // x\n\t\t\t4'b1100: q = 4'b0000; // x\n\t\t\t4'b1101: q = 4'b0000; // x\n\t\t\t4'b1110: q = 4'b0000; // x\n\t\t\t4'b1111: q = 4'b0000; // x\n\t\t\tdefault: begin\n\t\t\t\tcase (d)\n\t\t\t\t\t4'b0000: q = 4'b0000; // x\n\t\t\t\t\t4'b0001: q = 4'b0000; // x\n\t\t\t\t\t4'b0010: q = 4'b0000; // x\n\t\t\t\t\t4'b0011: q = 4'b0000; // x\n\t\t\t\t\t4'b0100: q = 4'b0000; // x\n\t\t\t\t\t4'b0101: q = 4'b0000; // x\n\t\t\t\t\t4'b0110: q = 4'b0000; // x\n\t\t\t\t\t4'b0111: q = 4'b0000; // x\n\t\t\t\t\t4'b1000: q = 4'b0000; // x\n\t\t\t\t\t4'b1001: q = 4'b0000; // x\n\t\t\t\t\t4'b1010: q = 4'b0000; // x\n\t\t\t\t\t4'b1011: q = 4'b0000; // x\n\t\t\t\t\t4'b1100: q = 4'b0000; // x\n\t\t\t\t\t4'b1101: q = 4'b0000; // x\n\t\t\t\t\t4'b1110: q = 4'b0000; // x\n\t\t\t\t\t4'b1111: q = 4'b0000; // x\n\t\t\t\tendcase\n\t\t\t\tcase (e)\n\t\t\t\t\t4'b0000: q = 4'b0000; // x\n\t\t\t\t\t4'b0001: q = 4'b0000; // x\n\t\t\t\t\t4'b0010: q ="}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @(*) begin\n        if (sel == 1'b0) begin\n            out = a;\n        end\n        else begin\n            out = b;\n        end\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module three times\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\nreg [2:0] q_reg;\n\nflipflop_mux mux1(\n    .clk(clk),\n    .L(L),\n    .r(r_in),\n    .select(q_in),\n    .q(q_reg[0])\n);\n\nflipflop_mux mux2(\n    .clk(clk),\n    .L(L),\n    .r(q_reg[0]),\n    .select(q_in),\n    .q(q_reg[1])\n);\n\nflipflop_mux mux3(\n    .clk(clk),\n    .L(L),\n    .r(q_reg[1]),\n    .select(q_in),\n    .q(q_reg[2])\n);\n\nalways @(posedge clk) begin\n    Q <= q_reg[2];\nend\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "Do not add any comments. Your code should be self-explanatory.\n```verilog\n\treg [31:0] prev_in;\n\treg [31:0] curr_in;\n\treg [31:0] out_reg;\n\treg [31:0] change_mask;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tprev_in <= 0;\n\t\t\tcurr_in <= 0;\n\t\t\tout_reg <= 0;\n\t\t\tchange_mask <= 0;\n\t\tend else begin\n\t\t\tprev_in <= curr_in;\n\t\t\tcurr_in <= in;\n\t\t\tout_reg <= change_mask & prev_in | ~change_mask & curr_in;\n\t\t\tchange_mask <= curr_in & ~prev_in;\n\t\tend\n\tend\n\t\n\tassign out = out_reg;\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    reg [7:0] q_temp;\n\n    always @(posedge clk) begin\n        q_temp[0] <= d[0];\n        q_temp[1] <= d[1];\n        q_temp[2] <= d[2];\n        q_temp[3] <= d[3];\n        q_temp[4] <= d[4];\n        q_temp[5] <= d[5];\n        q_temp[6] <= d[6];\n        q_temp[7] <= d[7];\n    end\n\n    assign q = q_temp;\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] temp;\n    wire carry_out;\n\n    assign temp = {1'b0, a} + {1'b0, b};\n    assign carry_out = temp[8];\n\n    assign s = temp[7:0];\n    assign overflow = (a[7] == b[7] && s[7] != a[7]) || (a[7] != b[7] && s[7] == carry_out);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n // Define state encoding for the Moore state machine\n // S () --d=0--> S\n // S () --d=1--> S1\n // S1 () --d=0--> S\n // S1 () --d=1--> S11\n // S11 () --d=0--> S110\n // S11 () --d=1--> S11\n // S110 () --d=0--> S\n // S110 () --d=1--> B0\n // B0 (shift_ena=1) -- (always go to next cycle) --> B1\n // B1 (shift_ena=1) -- (always go to next cycle) --> B2\n // B2 (shift_ena=1) -- (always go to next cycle) --> B3\n // B3 (shift_ena=1) -- (always go to next cycle) --> Count\n // Count (counting=1) --!(done_counting)--> Count\n // Count (counting=1) --(done_counting)--> Wait\n // Wait (done=1) --ack=0--> Wait\n // Wait (done=1) --ack=1--> S\n\n // Define state encoding for the Moore state machine\n // One-hot encoding for each state\n // S = 10'b0000000001\n // S1 = 10'b0000000010\n // S11 = 10'b0000000100\n // S110 = 10'b0000001000\n // B0 = 10'b0000010000\n // B1 = 10'b0000100000\n // B2 = 10'b0001000000\n // B3 = 10'b0010000000\n // Count = 10'b1000000000\n // Wait = 10'b0100000000\n\n // Define state transition logic\n // State B3\n // B3_next -- next-state logic for state B3\n // If counting is 1 and done_counting is 0, go to state Count\n // If counting is 1 and done_counting is 1, go to state Wait\n // If counting is 0, go to state S\n assign B3_next = (counting && !done_counting) ? Count : (counting && done_counting) ? Wait : S;\n\n // State S\n // S_next\n // If d is 1, go to state S1\n // If d is 0, go to state S\n assign S_next = (d) ? S1 : S;\n\n // State S1\n // S1_next\n // If d is 1, go to state S11\n // If d is 0, go to state S\n assign S1_next = (d) ? S11 : S;\n\n // State S11\n // Count_next\n // If counting is 1, go to state Count\n // If counting is 0, go to state S110\n assign Count_next = (counting) ? Count : S110;\n\n // State S110\n // Wait_next\n // If done is 1, go to state Wait\n // If done is 0, go to state B0\n assign Wait_next = (done) ? Wait : B0;\n\n // Define output logic\n // done\n // If done is 1, output 1\n // If done is 0, output 0\n assign done = (done) ? 1 : 0;\n\n // counting\n // If counting is 1, output 1\n // If counting is 0, output 0\n assign counting = (counting) ? 1 : 0;\n\n // shift_ena\n // If state is B0, B1, B2, B3, output"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            counter <= 2'b01; // weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (counter == 2'b11) begin\n                    counter <= 2'b11; // saturation\n                end else begin\n                    counter <= counter + 1;\n                end\n            end else begin\n                if (counter == 2'b00) begin\n                    counter <= 2'b00; // saturation\n                end else begin\n                    counter <= counter - 1;\n                end\n            end\n        end\n    end\n\n    assign state = counter;\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tcase(scancode[15:0])\n\t\t16'he06b: begin\n\t\t\tleft = 1'b1;\n\t\t\tdown = 1'b0;\n\t\t\tright = 1'b0;\n\t\t\tup = 1'b0;\n\t\tend\n\t\t16'he072: begin\n\t\t\tleft = 1'b0;\n\t\t\tdown = 1'b1;\n\t\t\tright = 1'b0;\n\t\t\tup = 1'b0;\n\t\tend\n\t\t16'he074: begin\n\t\t\tleft = 1'b0;\n\t\t\tdown = 1'b0;\n\t\t\tright = 1'b1;\n\t\t\tup = 1'b0;\n\t\tend\n\t\t16'he075: begin\n\t\t\tleft = 1'b0;\n\t\t\tdown = 1'b0;\n\t\t\tright = 1'b0;\n\t\t\tup = 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tleft = 1'b0;\n\t\t\tdown = 1'b0;\n\t\t\tright = 1'b0;\n\t\t\tup = 1'b0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n    wire [3:0] c;\n\n    full_adder fa0(x[0], y[0], 1'b0, sum[0], c[0]);\n    full_adder fa1(x[1], y[1], c[0], sum[1], c[1]);\n    full_adder fa2(x[2], y[2], c[1], sum[2], c[2]);\n    full_adder fa3(x[3], y[3], c[2], sum[3], c[3]);\n    full_adder fa4(c[3], 1'b0, 1'b0, sum[4], c[4]);\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "// Branch history register\nreg [31:0] history_reg;\n\n// Counter for history register\nreg [4:0] history_counter;\n\n// Branch history shift register\nreg [31:0] history_shift_reg;\n\n// Counter for history shift register\nreg [4:0] history_shift_counter;\n\n// Prediction history register\nreg [31:0] predict_history_reg;\n\n// Counter for prediction history register\nreg [4:0] predict_history_counter;\n\n// Verilog code for branch history shift register\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        history_reg <= 0;\n        history_counter <= 0;\n    end else begin\n        if (history_counter == 31) begin\n            history_reg <= {history_reg[30:0], history_shift_reg[0]};\n            history_counter <= 0;\n        end else begin\n            history_reg <= {history_reg[30:0], history_shift_reg[history_counter]};\n            history_counter <= history_counter + 1;\n        end\n    end\nend\n\n// Verilog code for history shift register\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        history_shift_reg <= 0;\n        history_shift_counter <= 0;\n    end else begin\n        if (history_shift_counter == 31) begin\n            history_shift_reg <= {history_shift_reg[30:0], history_reg[0]};\n            history_shift_counter <= 0;\n        end else begin\n            history_shift_reg <= {history_shift_reg[30:0], history_reg[history_shift_counter]};\n            history_shift_counter <= history_shift_counter + 1;\n        end\n    end\nend\n\n// Verilog code for prediction history register\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history_reg <= 0;\n        predict_history_counter <= 0;\n    end else begin\n        if (predict_history_counter == 31) begin\n            predict_history_reg <= {predict_history_reg[30:0], predict_taken};\n            predict_history_counter <= 0;\n        end else begin\n            predict_history_reg <= {predict_history_reg[30:0], predict_taken};\n            predict_history_counter <= predict_history_counter + 1;\n        end\n    end\nend\n\n// Verilog code for assigning prediction history register to output\nassign predict_history = predict_history_reg;\n\n// Verilog code for handling branch misprediction\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        history_reg <= 0;\n        history_shift_reg <= 0;\n        predict_history_reg <= 0;\n        history_counter <= 0;\n        history_shift_counter <= 0;\n        predict_history_counter <= 0;\n    end else begin\n        if (train_mispredicted) begin\n            history_reg <= {train_history, train_taken};\n            history_shift_reg <= {train_history, train_taken};\n            predict_history_reg <= {predict_history_reg[30:0], predict_taken};\n            history_counter <= 0;\n            history_shift_counter <= 0;\n            predict_history_counter <= 0;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// The intermediate wires.\nwire and1_out;\nwire and2_out;\n\n// The first layer of the circuit.\nand and1 (\n\t.out(and1_out),\n\t.a(a),\n\t.b(b)\n);\n\nand and2 (\n\t.out(and2_out),\n\t.a(c),\n\t.b(d)\n);\n\n// The second layer of the circuit.\nor or1 (\n\t.out(out),\n\t.a(and1_out),\n\t.b(and2_out)\n);\n\n// The inverted output.\nnot not1 (\n\t.out(out_n),\n\t.a(out)\n);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "--------------------------------------------------------------------------------\n\nModule top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]};\n        end\n    end\n\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module code is given below.\n\nmodule top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Define internal signals\n    wire should_heat;\n    wire should_cool;\n    wire should_fan;\n\n    // Set default values for output signals\n    assign heater = 0;\n    assign aircon = 0;\n    assign fan = 0;\n\n    // Calculate whether heating or cooling is required\n    assign should_heat = (mode == 1) && too_cold;\n    assign should_cool = (mode == 0) && too_hot;\n\n    // Calculate whether the fan should be turned on\n    assign should_fan = heater || aircon || fan_on;\n\n    // Turn on the heater or air conditioner if required\n    assign heater = should_heat;\n    assign aircon = should_cool;\n\n    // Turn on the fan if required\n    assign fan = should_fan;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    wire a_b_c_d_0 = ~(a | b | c | d);\n    wire a_b_c_d_1 = (a & b & c & d);\n    wire a_b_c_d_2 = (a & b & c & ~d);\n    wire a_b_c_d_3 = (a & b & ~c & d);\n    wire a_b_c_d_4 = (a & b & ~c & ~d);\n    wire a_b_c_d_5 = (a & ~b & c & d);\n    wire a_b_c_d_6 = (a & ~b & ~c & d);\n    wire a_b_c_d_7 = (a & ~b & c & ~d);\n    wire a_b_c_d_8 = (a & ~b & ~c & ~d);\n    wire a_b_c_d_9 = (~a & b & c & d);\n    wire a_b_c_d_10 = (~a & b & c & ~d);\n    wire a_b_c_d_11 = (~a & b & ~c & d);\n    wire a_b_c_d_12 = (~a & b & ~c & ~d);\n    wire a_b_c_d_13 = (~a & ~b & c & d);\n    wire a_b_c_d_14 = (~a & ~b & ~c & d);\n    wire a_b_c_d_15 = (~a & ~b & c & ~d);\n\n    assign out_sop = (a_b_c_d_0 | a_b_c_d_2 | a_b_c_d_7 | a_b_c_d_15) ? 1'b1 : 1'b0;\n    assign out_pos = (a_b_c_d_1 & a_b_c_d_3 & a_b_c_d_4 & a_b_c_d_5 & a_b_c_d_6 & a_b_c_d_8 & a_b_c_d_9 & a_b_c_d_10 & a_b_c_d_11 & a_b_c_d_12 & a_b_c_d_13 & a_b_c_d_14) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "Module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n  );\n\n    reg [31:0] lfsr;\n\n    always @(posedge clk) begin\n      if (reset) begin\n        lfsr <= 32'h1;\n        q <= 32'h1;\n      end else begin\n        lfsr[31] <= lfsr[30] ^ lfsr[29] ^ lfsr[22] ^ lfsr[2] ^ lfsr[1];\n        lfsr[30:2] <= lfsr[29:1];\n        q <= lfsr[31];\n      end\n    end\n\n  endmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    // combinational circuit\n    assign q = a & b & c & d;\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Name the module as top_module.\n// Define the output signals as p1y and p2y.\n// Define the input signals as p1a, p1b, p1c, p1d, p2a, p2b, p2c, p2d.\n\n// Create two 4-input NAND gates and connect them to the output signals.\n// Name the NAND gates as nand1 and nand2.\n\n// Define the logic for the NAND gates.\n// The NAND gates will have two inputs each. The inputs will be the AND of two input signals.\n// The output signals of the NAND gates will be the AND of two input signals.\n\n// Connect the output signals of the NAND gates to the output signals of the module.\n\n// Name the module as top_module.\n// Return the complete module code.\n\n// module top_module(\n//\tinput p1a, \n//\tinput p1b, \n//\tinput p1c, \n//\tinput p1d, \n//\toutput p1y, \n//\tinput p2a, \n//\tinput p2b, \n//\tinput p2c, \n//\tinput p2d, \n//\toutput p2y\n//);\n\n//\tNAND gate 1\n//\tInputs: p1a AND p1b, p1c AND p1d\n//\tOutput: p1y\n//\tLogic: ~(p1a & p1b) & ~(p1c & p1d)\n//\tName: nand1\n//\tConnect output to module output signal\n//\tName output signal as p1y\n\n//\tNAND gate 2\n//\tInputs: p2a AND p2b, p2c AND p2d\n//\tOutput: p2y\n//\tLogic: ~(p2a & p2b) & ~(p2c & p2d)\n//\tName: nand2\n//\tConnect output to module output signal\n//\tName output signal as p2y\n\n//\tModule code\n//\tName the module as top_module\n//\tReturn the complete module code\n\n//\tModule code\n//\tStart with the module definition\n\n//\tDefine the input signals\n//\tName the input signals as per the module definition\n\n//\tCreate the NAND gates\n//\tConnect the inputs to the AND gates\n//\tConnect the AND gates to the NAND gates\n//\tName the NAND gates as per the module definition\n\n//\tConnect the output signals of the NAND gates to the output signals of the module\n\n//\tModule code\n\n//\tName the module as top_module\n\n//\tReturn the complete module code\n\n//\tModule code\n\n//\tModule definition\n//\tName the module as top_module\n\n//\tEnd of module code\n\n//\t7420 equivalent module\n//\tStart with the module definition\n\n//\tDefine the input signals\n//\tName the input signals as per the module definition\n\n//\tCreate the NAND gates\n//\tConnect the inputs to the AND gates\n//\tConnect the AND gates to the NAND gates\n//\tName the NAND gates as per the module definition\n\n//\tConnect the output signals of the NAND gates to the output signals of the module\n\n//\tModule code\n\n//\tName the module as top_module\n\n//\tReturn the complete module code\n\n//\t7420 equivalent module code\n\n//\tModule code\n\n//\tEnd of module code\n\n//\tModule definition\n//\tName the module as top_module\n\n//\tModule code\n//\tReturn the complete module code\n\n//\t7420 equivalent module code\n//\tName the NAND gates as per the module definition\n\n//\tModule code\n//\tName the output signals as per the module definition\n\n//\tName the module as top_module\n\n//\tReturn the complete module code\n\n//\tModule code\n\n//\t7420 equivalent module code\n\n//\tModule code\n\n//\t7420 equivalent module code\n\n//\tEnd of module code\n\n//\tModule code\n//\tEnd of module\n\n//\t7420 equivalent module code\n//\tModule code\n//\tName the module as top_module\n\n//\tReturn the complete module code\n\n//\tModule code\n//\tName the output signals as per the module definition\n\n//\tModule code\n//\tEnd of module\n\n//\t7"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "endmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend\n\t\telse if (slowena) begin\n\t\t\tq <= q + 1;\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "// AND gate with bubble\n\t\tand and_gate (\n\t\t\t.a(in1),\n\t\t\t.b(in2),\n\t\t\t.y(out)\n\t\t);\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n    assign out = in;\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Define states\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// Define outputs\nparameter outA = 1'b0;\nparameter outB = 1'b1;\n\n// Define inputs\nparameter a = 1'b0;\nparameter b = 1'b1;\n\n// Define outputs for each state\nreg [1:0] state_next;\nreg [1:0] state;\nreg out_next;\nwire [1:0] output_comb;\n\n// Define the combinational logic\nassign output_comb = {state[1], state[0]};\n\n// Define the state transition and output logic\nalways @(posedge clk or negedge areset) begin\n\tif (~areset) begin\n\t\tstate <= B;\n\t\tout_next <= outB;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in == a) begin\n\t\t\t\t\tstate_next <= B;\n\t\t\t\t\tout_next <= outB;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_next <= A;\n\t\t\t\t\tout_next <= outA;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in == b) begin\n\t\t\t\t\tstate_next <= B;\n\t\t\t\t\tout_next <= outB;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_next <= A;\n\t\t\t\t\tout_next <= outA;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Assign the state and output\nassign state = state_next;\nassign out = out_next;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "Do not add comments and explanations in the Verilog code. If necessary, add comments to the top of the module.\n\nYour Verilog code should be readable and understandable.\n\nModule top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\n\treg q_next;\n\n\talways @(posedge clk or negedge clk) begin\n\t\tif (clk == 1'b0) begin\n\t\t\tq_next <= d;\n\t\tend\n\t\tif (clk == 1'b1) begin\n\t\t\tq <= q_next;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "Comment out the explanation.\n\nDo not add unnecessary details or comments.\n\nFocus on the essentials and be concise.\n\nUse Verilog keywords and operators where required.\n\nModule top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\n\tassign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module\n    module A(\n        input x,\n        input y,\n        output z);\n    \n    // Implement (x^y) & x boolean function\n    assign z = (x ^ y) & x;\n    \n    // Instantiate B module\n    module B(\n        input x,\n        input y,\n        output z);\n    \n    // Implement the simulation waveform\n    assign z = x & ~y;\n    \nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else if (ena == 2'b01) begin\n            shift_reg <= {shift_reg[0], shift_reg[99:1]};\n        end else if (ena == 2'b10) begin\n            shift_reg <= {shift_reg[98:0], shift_reg[99]};\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "// Reset the counter to 0 when reset is high\n  always @(posedge clk) begin\n    if (reset) begin\n      q <= 0;\n    end\n    else begin\n      // Increment the counter\n      q <= q + 1;\n    end\n  end\n  \n  // Output the counter value\n  assign q = q < 1000 ? q : 0;\n  \nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "// State transition logic\n\t// State 0 (S0)\n\tassign next_state[0] = (state[0] & ~state[1]) | (state[0] & state[2]) | (state[0] & state[3]) | (state[0] & state[4]) | (state[0] & state[5]) | (state[0] & state[6]) | (state[0] & state[7]) | (state[0] & state[8]) | (state[0] & state[9]);\n\tassign out1 = (state[0] & ~state[1]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[0] & ~state[1]) ? 1'b0 : 1'b1;\n\t// State 1 (S1)\n\tassign next_state[1] = (state[1] & state[2]) | (state[1] & state[3]) | (state[1] & state[4]) | (state[1] & state[5]) | (state[1] & state[6]) | (state[1] & state[7]) | (state[1] & state[8]) | (state[1] & state[9]);\n\tassign out1 = (state[1] & state[0]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[1] & state[0]) ? 1'b0 : 1'b1;\n\t// State 2 (S2)\n\tassign next_state[2] = (state[2] & state[3]) | (state[2] & state[4]) | (state[2] & state[5]) | (state[2] & state[6]) | (state[2] & state[7]) | (state[2] & state[8]) | (state[2] & state[9]);\n\tassign out1 = (state[2] & state[0]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[2] & state[0]) ? 1'b0 : 1'b1;\n\t// State 3 (S3)\n\tassign next_state[3] = (state[3] & state[4]) | (state[3] & state[5]) | (state[3] & state[6]) | (state[3] & state[7]) | (state[3] & state[8]) | (state[3] & state[9]);\n\tassign out1 = (state[3] & state[0]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[3] & state[0]) ? 1'b0 : 1'b1;\n\t// State 4 (S4)\n\tassign next_state[4] = (state[4] & state[5]) | (state[4] & state[6]) | (state[4] & state[7]) | (state[4] & state[8]) | (state[4] & state[9]);\n\tassign out1 = (state[4] & state[0]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[4] & state[0]) ? 1'b0 : 1'b1;\n\t// State 5 (S5)\n\tassign next_state[5] = (state[5] & state[6]) | (state[5] & state[7]) | (state[5] & state[8]) | (state[5] & state[9]);\n\tassign out1 = (state[5] & state[0]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[5] & state[0]) ? 1'b0 : 1'b1;\n\t// State 6 (S6)\n\tassign next_state[6] = (state[6] & state[7]) | (state[6] & state[8]) | (state[6] & state[9]);\n\tassign out1 = (state[6] & state[0]) ? 1'b0 : 1'b1;\n\tassign out2 = (state[6] & state[0]) ? 1'b0 : 1'b1;\n\t// State 7 (S"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "// JK flip-flop\nalways @(posedge clk) begin\n\tif (j & ~k) begin\n\t\tQ <= 1;\n\tend else if (~j & k) begin\n\t\tQ <= 0;\n\tend else if (j & k) begin\n\t\tQ <= ~Q;\n\tend\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    wire [2:0] xor_out;\n    wire [1:0] and_out;\n\n    assign xor_out = {in[2]^in[1], in[1]^in[0], in[0]};\n    assign and_out = {xor_out[2]&xor_out[1], xor_out[1]&xor_out[0]};\n\n    assign out = {and_out[1], and_out[0]};\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n    assign out[14] = ~c ^ a;\n    assign out[13] = ~c ^ b;\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n    assign out[ 9] = ~d ^ a;\n    assign out[ 8] = ~d ^ b;\n    assign out[ 7] = ~d ^ c;\n    assign out[ 6] = ~d ^ d;\n    assign out[ 5] = ~d ^ e;\n    assign out[ 4] = ~e ^ a;\n    assign out[ 3] = ~e ^ b;\n    assign out[ 2] = ~e ^ c;\n    assign out[ 1] = ~e ^ d;\n    assign out[ 0] = ~e ^ e;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "Follow the state machine FSM diagram below.\n```verilog\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\treg [1:0] state_reg, state_next;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate_reg <= walk_left_state;\n\t\tend\n\t\telse begin\n\t\t\tstate_reg <= state_next;\n\t\tend\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state_reg)\n\t\t\twalk_left_state: begin\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tstate_next = walk_right_state;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = walk_left_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\twalk_right_state: begin\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tstate_next = walk_left_state;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = walk_right_state;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\tassign walk_left = (state_reg == walk_left_state) ? 1'b1 : 1'b0;\n\tassign walk_right = (state_reg == walk_right_state) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = a & ~b | b & ~a | a & b;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// The first AND gate takes three inputs and creates an intermediate wire p1a_and_p1b_and_p1c\n  assign p1a_and_p1b_and_p1c = p1a & p1b & p1c;\n  \n  // The second AND gate takes three inputs and creates an intermediate wire p1d_and_p1e_and_p1f\n  assign p1d_and_p1e_and_p1f = p1d & p1e & p1f;\n  \n  // The first OR gate takes two intermediate wires and creates the output p1y\n  assign p1y = p1a_and_p1b_and_p1c | p1d_and_p1e_and_p1f;\n  \n  // The first AND gate takes two inputs and creates an intermediate wire p2a_and_p2b\n  assign p2a_and_p2b = p2a & p2b;\n  \n  // The second AND gate takes two inputs and creates an intermediate wire p2c_and_p2d\n  assign p2c_and_p2d = p2c & p2d;\n  \n  // The second OR gate takes two intermediate wires and creates the output p2y\n  assign p2y = p2a_and_p2b | p2c_and_p2d;\n  \nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "// state_assign_table: state_y[2:0] | state_Y[2:0] x=0 | state_Y[2:0] x=1 | output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n// \n// state_y[2:0] | state_Y[2:0] x=0 | state_Y[2:0] x=1 | state_Y[2:0] next\n// 000 | 000, 001 | 000 | 000\n// 001 | 001, 100 | 001 | 001\n// 010 | 010, 001 | 010 | 011\n// 011 | 001, 010 | 001 | 001\n// 100 | 011, 100 | 011 | 100\n// \n// state_y[2:0] | state_Y[2:0] x=0 | state_Y[2:0] x=1 | state_Y[2:0] next\n// 000 | 000, 001 | 000 | 000\n// 001 | 001, 100 | 001 | 001\n// 010 | 010, 001 | 010 | 011\n// 011 | 001, 010 | 001 | 001\n// 100 | 011, 100 | 011 | 100\n// \n// Y0_assign_table: state_y[2:0] | Y0\n// 000 | 0\n// 001 | 0\n// 010 | 0\n// 011 | 1\n// 100 | 1\n// \n// z_assign_table: state_y[2:0] | z\n// 000 | 0\n// 001 | 0\n// 010 | 0\n// 011 | 1\n// 100 | 1\n// \n// logic_table: state_y[2:0] | state_Y[2:0] x=0 | state_Y[2:0] x=1 | state_Y[2:0] next\n// 000 | 000 | 001 | 000\n// 001 | 001 | 100 | 001\n// 010 | 010 | 001 | 011\n// 011 | 001 | 010 | 001\n// 100 | 011 | 100 | 100\n// \n// logic_table: state_y[2:0] | Y0 | z\n// 000 | 0 | 0\n// 001 | 0 | 0\n// 010 | 0 | 0\n// 011 | 1 | 1\n// 100 | 1 | 1\n// \n// Y0_assign: state_y[2:0] | Y0\n// 000 | Y0 = 0\n// 001 | Y0 = 0\n// 010 | Y0 = 0\n// 011 | Y0 = 1\n// 100 | Y0 = 1\n// \n// z_assign: state_y[2:0] | z\n// 000 | z = 0\n// 001 | z = 0\n// 010 | z = 0\n// 011 | z = 1\n// 100 | z = 1\n//"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "The Verilog code for a 2-input NOR gate is:\n```verilog\n\tassign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "assign w = a;\n\t\tassign x = b;\n\t\tassign y = b;\n\t\tassign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge clk, negedge ar) begin\n        if (!ar) begin\n            q_reg <= 1'b0;\n        end else begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        0: out = data0;\n        1: out = data1;\n        2: out = data2;\n        3: out = data3;\n        4: out = data4;\n        5: out = data5;\n        default: out = 4'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] count;\n    reg tc_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            count <= data;\n            tc_reg <= 0;\n        end else begin\n            if (count == 0) begin\n                tc_reg <= 1;\n            end else begin\n                count <= count - 1;\n                tc_reg <= 0;\n            end\n        end\n    end\n\n    assign tc = tc_reg;\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "// I/O declarations\n\treg [3:0] state;\n\treg [3:0] next_state;\n\treg start_shifting;\n\tparameter S0 = 4'b0000;\n\tparameter S1 = 4'b0001;\n\tparameter S2 = 4'b0010;\n\tparameter S3 = 4'b0011;\n\tparameter S4 = 4'b0100;\n\tparameter S5 = 4'b0101;\n\tparameter S6 = 4'b0110;\n\tparameter S7 = 4'b0111;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tstart_shifting <= 0;\n\t\tend\n\tend\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: begin\n\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\tnext_state = S2;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\tnext_state = S3;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\tnext_state = S4;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS4: begin\n\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\tnext_state = S5;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS5: begin\n\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\tnext_state = S6;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS6: begin\n\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\tnext_state = S7;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS7: begin\n\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tstart_shifting <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "Do not add any comments in the Verilog code.\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n\treg [7:0] q_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq_reg <= 8'b0;\n\t\tend else begin\n\t\t\tq_reg <= d;\n\t\tend\n\tend\n\n\tassign q = q_reg;\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tanyedge <= {anyedge[6:0], in[0] & ~anyedge[0]};\n\tend\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\nreg [2:0] q_next;\n\nalways @(posedge clk) begin\n    q_next <= {q[1:0], a};\nend\n\nalways @(posedge clk) begin\n    q <= q_next;\nend\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q);\n\n    reg [4:0] lfsr;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            lfsr <= 5'b10001;\n            q <= 5'b1;\n        end else begin\n            lfsr[4] <= lfsr[3] ^ lfsr[2] ^ lfsr[1] ^ lfsr[0];\n            lfsr[3] <= lfsr[2] ^ lfsr[1] ^ lfsr[0];\n            lfsr[2] <= lfsr[1] ^ lfsr[0];\n            lfsr[1] <= lfsr[0];\n            lfsr[0] <= 1'b0;\n            q <= lfsr[4];\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        if (do_sub == 0) begin\n            out = a + b;\n        end\n        else begin\n            out = a - b;\n        end\n\n        if (out == 0) begin\n            result_is_zero = 1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always_comb begin\n        case (x)\n            5'b00000: f = 1'b0;\n            5'b00001: f = 1'b1;\n            5'b00010: f = 1'b0;\n            5'b00011: f = 1'b1;\n            5'b00100: f = 1'b1;\n            5'b00101: f = 1'b0;\n            5'b00110: f = 1'b1;\n            5'b00111: f = 1'b1;\n            5'b01000: f = 1'b0;\n            5'b01001: f = 1'b1;\n            5'b01010: f = 1'b1;\n            5'b01011: f = 1'b0;\n            5'b01100: f = 1'b1;\n            5'b01101: f = 1'b0;\n            5'b01110: f = 1'b1;\n            5'b01111: f = 1'b1;\n            5'b10000: f = 1'b1;\n            5'b10001: f = 1'b0;\n            5'b10010: f = 1'b1;\n            5'b10011: f = 1'b1;\n            5'b10100: f = 1'b1;\n            5'b10101: f = 1'b0;\n            5'b10110: f = 1'b1;\n            5'b10111: f = 1'b1;\n            5'b11000: f = 1'b0;\n            5'b11001: f = 1'b1;\n            5'b11010: f = 1'b1;\n            5'b11011: f = 1'b0;\n            5'b11100: f = 1'b1;\n            5'b11101: f = 1'b0;\n            5'b11110: f = 1'b1;\n            5'b11111: f = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\nalways @(*) begin\n    case (code)\n        8'h45: begin\n            out = 4'b0000;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'b0001;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'b0010;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'b0011;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'b0100;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'b0101;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'b0110;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'b0111;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'b1000;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'b1001;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'b0000;\n            valid = 1'b0;\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "No need to add comments or whitespace.\n\nFollow the Verilog coding convention and style.\n\nKeep the code clean and readable.\n\nDon't introduce new variables or functions that are not needed.\n\nUse Verilog keywords and statements correctly.\n\nDon't use C syntax in Verilog code.\n\nBe consistent with the Verilog coding style.\n\n 8 bits input: [7:0] in\n 8 bits output: [7:0] out\n\n reverse the bit ordering of in and assign to out\n```verilog\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\n\nalways @(*) begin\n\tcase({a,b,c,d})\n\t\t4'b0000: out = 1'b1;\n\t\t4'b0001: out = 1'b0;\n\t\t4'b0010: out = 1'b0;\n\t\t4'b0011: out = 1'b0;\n\t\t4'b0100: out = 1'b1;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0110: out = 1'b0;\n\t\t4'b0111: out = 1'b0;\n\t\t4'b1000: out = 1'b0;\n\t\t4'b1001: out = 1'b0;\n\t\t4'b1010: out = 1'b0;\n\t\t4'b1011: out = 1'b0;\n\t\t4'b1100: out = 1'b0;\n\t\t4'b1101: out = 1'b0;\n\t\t4'b1110: out = 1'b0;\n\t\t4'b1111: out = 1'b1;\n\t\tdefault: out = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module consists of a four-bit shift register and a counter. The counter decrements the value of the shift register when count_ena is 1. The shift register shifts in the new data when shift_ena is 1.\n\nThe Verilog code should be as concise and focused as possible. Avoid unnecessary variables and comments.\n\nmodule top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    reg [3:0] shift_reg;\n    reg [3:0] count_reg;\n\n    always @(posedge clk) begin\n        if (count_ena) begin\n            count_reg <= count_reg - 1;\n        end\n        if (shift_ena) begin\n            shift_reg <= {shift_reg[2:0], data};\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module                                         |\n  Function:   This is a wire module that behaves like a wire.        |\n  Inputs:     in                                                 |\n  Outputs:    out                                                |\n  Coding Style:                                                   |\n  - Use consistent indentation and line breaks                     |\n  - Do not use tabs                                               |\n  - Do not add any Verilog design or code that is not required       |\n  - Do not add any Verilog code that is not portable                 |\n  - Do not use any Verilog extension or vendor specific constructs  |\n  - Do not use any Verilog design or code that is not relevant to the  |\n    key points                                                    |\n  Key Points:                                                      |\n  - Be concise and focused on the key points                         |\n  - Follow the Verilog coding standards and style guide              |\n  - Do not add any Verilog code that is not relevant to the key points |\n  - Use the Verilog code design and constructs that are easy to       |\n    understand and maintain                                        |\n  - Use appropriate Verilog keywords and constructs                  |\n  - Do not use any Verilog code that is not required                  |\n  - Use the Verilog code design and constructs that are self-explanatory|\n                                                                                                                                                                                            |\n  Module Content:                                                  |\n  -------------------------------------------------------------------  |\n  The Verilog code design and constructs should be easy to understand |\n  and maintain.                                                    |\n  Do not add any Verilog code that is not required.                   |\n                                                                                                                                                                                        |\n  ///////////////////////////////////////////////////////////////////  |\n  // Implement the module by assigning the input to the output          //\n  ///////////////////////////////////////////////////////////////////  |\n  assign out = in;\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "// Registers\n\t\treg [1:0] state;\n\t\treg [1:0] next_state;\n\t\treg [1:0] shift_count;\n\t\treg [1:0] shift_next_count;\n\t\treg shift_ena_reg;\n\n\t\t// Assign initial values\n\t\tinitial begin\n\t\t\tstate = 2'b00;\n\t\t\tshift_count = 2'b00;\n\t\t\tshift_ena_reg = 1'b0;\n\t\tend\n\n\t\t// FSM\n\t\talways @(posedge clk) begin\n\t\t\tif (reset) begin\n\t\t\t\tstate <= 2'b00;\n\t\t\t\tshift_count <= 2'b00;\n\t\t\t\tshift_ena_reg <= 1'b0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate <= next_state;\n\t\t\t\tshift_count <= shift_next_count;\n\t\t\t\tshift_ena_reg <= shift_ena;\n\t\t\tend\n\t\tend\n\n\t\t// Next state logic\n\t\talways @(*) begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: next_state = 2'b01;\n\t\t\t\t2'b01: next_state = 2'b10;\n\t\t\t\t2'b10: next_state = 2'b00;\n\t\t\t\t2'b11: next_state = 2'b00;\n\t\t\tendcase\n\t\tend\n\n\t\t// Next shift count logic\n\t\talways @(*) begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: shift_next_count = 2'b00;\n\t\t\t\t2'b01: shift_next_count = 2'b01;\n\t\t\t\t2'b10: shift_next_count = 2'b10;\n\t\t\t\t2'b11: shift_next_count = 2'b00;\n\t\t\tendcase\n\t\tend\n\n\t\t// Shift enable logic\n\t\tassign shift_ena = shift_ena_reg & (shift_count == 2'b10);\n\n\tendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "Do not add any comment above the module. Each line of Verilog code should be indented with two spaces.\n\n Avoid using tabs in your code. Do not use spaces after a colon (:), or after the keyword input or output.\n\n Do not use spaces before the assignment operator (=).\n\n Module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "// Assign statement\nassign out_assign = sel_b1 & sel_b2 ? b : a;\n\n// Procedural if statement\nalways @(*) begin\n\tif (sel_b1 & sel_b2) begin\n\t\tout_always = b;\n\tend else begin\n\t\tout_always = a;\n\tend\nend\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "Module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\n\twire p, n;\n\t\n\tassign p = ~(a ^ b);\n\tassign n = ~(c ^ b);\n\t\n\tassign out = (p & n) ? 1'b1 : 1'b0;\n\t\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "reg [1:0] state;\nalways @ (posedge clk, negedge resetn) begin\n    if (~resetn) begin\n        state <= 2'b00; // Reset to state A\n    end else begin\n        case (state)\n            2'b00: // A\n                if (r[3:1] != 3'b000) begin\n                    state <= (r[3]) ? 2'b11 : (r[2]) ? 2'b10 : 2'b01; // B or C or D\n                end\n            2'b11: // B\n                if (r[3:1] != 3'b000) begin\n                    state <= (r[3]) ? 2'b11 : 2'b00; // B or A\n                end\n            2'b10: // C\n                if (r[3:1] != 3'b000) begin\n                    state <= (r[3]) ? 2'b11 : (r[2]) ? 2'b10 : 2'b01; // C or B or D\n                end\n            2'b01: // D\n                if (r[3:1] != 3'b000) begin\n                    state <= (r[3]) ? 2'b11 : (r[2]) ? 2'b10 : (r[1]) ? 2'b01 : 2'b00; // D or B or C or A\n                end\n        endcase\n    end\nend"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend\n\t\telse begin\n\t\t\tcase (q)\n\t\t\t\t4'b0000: q <= 4'b0001;\n\t\t\t\t4'b0001: q <= 4'b0010;\n\t\t\t\t4'b0010: q <= 4'b0011;\n\t\t\t\t4'b0011: q <= 4'b0100;\n\t\t\t\t4'b0100: q <= 4'b0101;\n\t\t\t\t4'b0101: q <= 4'b0110;\n\t\t\t\t4'b0110: q <= 4'b0111;\n\t\t\t\t4'b0111: q <= 4'b1000;\n\t\t\t\t4'b1000: q <= 4'b1001;\n\t\t\t\t4'b1001: q <= 4'b1010;\n\t\t\t\t4'b1010: q <= 4'b1011;\n\t\t\t\t4'b1011: q <= 4'b1100;\n\t\t\t\t4'b1100: q <= 4'b1101;\n\t\t\t\t4'b1101: q <= 4'b1110;\n\t\t\t\t4'b1110: q <= 4'b1111;\n\t\t\t\t4'b1111: q <= 4'b0000;\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n\n    reg [1:0] state;\n    reg [2:0] byte_count;\n    reg [7:0] buffer;\n    reg done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 2'b00;\n            byte_count <= 3'b000;\n            buffer <= 8'b00000000;\n            done_reg <= 1'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (in[3] == 1'b1) begin\n                        state <= 2'b01;\n                        byte_count <= 3'b000;\n                        buffer <= {in, 8'b00000000};\n                    end\n                end\n                2'b01: begin\n                    if (byte_count == 3'b000) begin\n                        buffer <= {in, buffer[7:1]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b001) begin\n                        buffer <= {in, buffer[7:2]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b010) begin\n                        buffer <= {in, buffer[7:3]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b011) begin\n                        buffer <= {in, buffer[7:4]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b100) begin\n                        buffer <= {in, buffer[7:5]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b101) begin\n                        buffer <= {in, buffer[7:6]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b110) begin\n                        buffer <= {in, buffer[7]};\n                        byte_count <= byte_count + 1;\n                    end else if (byte_count == 3'b111) begin\n                        state <= 2'b10;\n                        done_reg <= 1'b1;\n                    end\n                end\n                2'b10: begin\n                    if (in[3] == 1'b1) begin\n                        state <= 2'b00;\n                        byte_count <= 3'b000;\n                        buffer <= {in, 8'b00000000};\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "endmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                3'b000: begin\n                    if (x) state <= 3'b001;\n                    else state <= 3'b000;\n                    z <= 1'b0;\n                end\n                3'b001: begin\n                    if (x) state <= 3'b100;\n                    else state <= 3'b001;\n                    z <= 1'b0;\n                end\n                3'b010: begin\n                    if (x) state <= 3'b001;\n                    else state <= 3'b010;\n                    z <= 1'b0;\n                end\n                3'b011: begin\n                    if (x) state <= 3'b010;\n                    else state <= 3'b011;\n                    z <= 1'b1;\n                end\n                3'b100: begin\n                    if (x) state <= 3'b011;\n                    else state <= 3'b100;\n                    z <= 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) begin\n\t\t\tf <= 0;\n\t\t\tg <= 0;\n\t\t\tstate <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\t0: begin // state A\n\t\t\t\t\tf <= 1;\n\t\t\t\t\tg <= 0;\n\t\t\t\t\tstate <= 1;\n\t\t\t\tend\n\t\t\t\t1: begin // state B\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= 2;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2: begin // state C\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= 3;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t3: begin // state D\n\t\t\t\t\tif (y) begin\n\t\t\t\t\t\tstate <= 4;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t4: begin // state E\n\t\t\t\t\tf <= 0;\n\t\t\t\t\tg <= 1;\n\t\t\t\t\tstate <= 5;\n\t\t\t\tend\n\t\t\t\t5: begin // state F\n\t\t\t\t\tif (y) begin\n\t\t\t\t\t\tstate <= 6;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t6: begin // state G\n\t\t\t\t\tg <= 1;\n\t\t\t\t\tstate <= 7;\n\t\t\t\tend\n\t\t\t\t7: begin // state H\n\t\t\t\t\tif (y) begin\n\t\t\t\t\t\tstate <= 6;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if(reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\nalways @(*) begin\n    case (state)\n        2'b00: begin\n            if (in == 1) begin\n                next_state = 2'b01;\n                out = 1;\n            end else begin\n                next_state = 2'b00;\n                out = 0;\n            end\n        end\n        2'b01: begin\n            if (in == 1) begin\n                next_state = 2'b01;\n                out = 0;\n            end else begin\n                next_state = 2'b10;\n                out = 0;\n            end\n        end\n        2'b10: begin\n            if (in == 1) begin\n                next_state = 2'b01;\n                out = 1;\n            end else begin\n                next_state = 2'b11;\n                out = 0;\n            end\n        end\n        2'b11: begin\n            if (in == 1) begin\n                next_state = 2'b01;\n                out = 1;\n            end else begin\n                next_state = 2'b10;\n                out = 0;\n            end\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    // Delay of 5ns\n    delay_5ns d1(.x(x), .y(y), .z(z1));\n    \n    // Delay of 10ns\n    delay_10ns d2(.x(x), .y(y), .z(z2));\n    \n    // Delay of 15ns\n    delay_15ns d3(.x(x), .y(y), .z(z3));\n    \n    // Delay of 20ns\n    delay_20ns d4(.x(x), .y(y), .z(z4));\n    \n    // Delay of 25ns\n    delay_25ns d5(.x(x), .y(y), .z(z5));\n    \n    // Delay of 30ns\n    delay_30ns d6(.x(x), .y(y), .z(z6));\n    \n    // Delay of 35ns\n    delay_35ns d7(.x(x), .y(y), .z(z7));\n    \n    // Delay of 40ns\n    delay_40ns d8(.x(x), .y(y), .z(z8));\n    \n    // Delay of 45ns\n    delay_45ns d9(.x(x), .y(y), .z(z9));\n    \n    // Delay of 50ns\n    delay_50ns d10(.x(x), .y(y), .z(z10));\n    \n    // Delay of 55ns\n    delay_55ns d11(.x(x), .y(y), .z(z11));\n    \n    // Delay of 60ns\n    delay_60ns d12(.x(x), .y(y), .z(z12));\n    \n    // Delay of 65ns\n    delay_65ns d13(.x(x), .y(y), .z(z13));\n    \n    // Delay of 70ns\n    delay_70ns d14(.x(x), .y(y), .z(z14));\n    \n    // Delay of 75ns\n    delay_75ns d15(.x(x), .y(y), .z(z15));\n    \n    // Delay of 80ns\n    delay_80ns d16(.x(x), .y(y), .z(z16));\n    \n    // Delay of 85ns\n    delay_85ns d17(.x(x), .y(y), .z(z17));\n    \n    // Delay of 90ns\n    delay_90ns d18(.x(x), .y(y), .z(z18));\n    \n    // Delay of 95ns\n    delay_95ns d19(.x(x), .y(y), .z(z19));\n    \n    // Delay of 100ns\n    delay_100ns d20(.x(x), .y(y), .z(z20));\n    \n    // Combine all the delayed signals\n    assign z = z1 & z2 & z3 & z4 & z5 & z6 & z7 & z8 & z9 & z10 & z11 & z12 & z13 & z14 & z15 & z16 & z17 & z18 & z19 & z20;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // State codes\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // State register\n    reg [1:0] state;\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (w) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                B: begin\n                    if (w) begin\n                        state <= C;\n                    end else begin\n                        state <= D;\n                    end\n                end\n                C: begin\n                    if (w) begin\n                        state <= E;\n                    end else begin\n                        state <= D;\n                    end\n                end\n                D: begin\n                    if (w) begin\n                        state <= A;\n                    end else begin\n                        state <= C;\n                    end\n                end\n                E: begin\n                    if (w) begin\n                        state <= E;\n                    end else begin\n                        state <= D;\n                    end\n                end\n                F: begin\n                    if (w) begin\n                        state <= C;\n                    end else begin\n                        state <= D;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output\n    always @(state) begin\n        case (state)\n            A: z = 1'b0;\n            B: z = 1'b1;\n            C: z = 1'b1;\n            D: z = 1'b0;\n            E: z = 1'b1;\n            F: z = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q);\n\n    reg [15:0] q_next;\n\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            q_next <= 16'h0;\n        end else begin\n            if (byteena[1]) begin\n                q_next[15:8] <= d[15:8];\n            end\n            if (byteena[0]) begin\n                q_next[7:0] <= d[7:0];\n            end\n        end\n    end\n\n    assign q = q_next;\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "Do not introduce any new register or wire. Use the signal in itself as much as possible.\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n\talways @(posedge clk) begin\n\t\tpedge <= (in & ~pedge);\n\tend\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    always @(posedge clock) begin\n        if(a) begin\n            q <= 1;\n            p <= 0;\n        end\n        else if(q) begin\n            q <= 0;\n            p <= 0;\n        end\n        else if(p) begin\n            q <= 1;\n            p <= 0;\n        end\n        else begin\n            q <= 1;\n            p <= 1;\n        end\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "endmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "Then, write the Verilog code to compare A and B. Use the if-else statement to set z to 1 if A = B, otherwise set z to 0.\n```verilog\n\tassign z = (A == B) ? 1 : 0;\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module code template below and add the necessary logic to compute the three output vectors: out_both, out_any, out_different.\n\nDo not add any other code that is not relevant to computing these three output vectors. Please use meaningful names for the signals and variables.\n\nDo not repeat the same logic for different output vectors. Use the existing signals to compute the output vectors.\n\nModule top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    wire [99:0] left_neighbour;\n    wire [99:0] right_neighbour;\n\n    assign left_neighbour = {in[99], in[0:98]};\n    assign right_neighbour = {in[1:99], in[0]};\n\n    assign out_both = in & left_neighbour;\n    assign out_any = in | right_neighbour;\n    assign out_different = in ^ left_neighbour;\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n        input d,\n        input ena,\n        output logic q\n    );\n\n    always @ (posedge ena) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "Do not use any comments in the code. Indent your code in a consistent manner. Use meaningful variable and function names.\n\nmodule top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n\twire [3:0] mux_out;\n\n\tassign mux_out[0] = in[3:0];\n\tassign mux_out[1] = in[7:4];\n\tassign mux_out[2] = in[11:8];\n\tassign mux_out[3] = in[15:12];\n\tassign mux_out[4] = in[19:16];\n\tassign mux_out[5] = in[23:20];\n\tassign mux_out[6] = in[27:24];\n\tassign mux_out[7] = in[31:28];\n\tassign mux_out[8] = in[35:32];\n\tassign mux_out[9] = in[39:36];\n\tassign mux_out[10] = in[43:40];\n\tassign mux_out[11] = in[47:44];\n\tassign mux_out[12] = in[51:48];\n\tassign mux_out[13] = in[55:52];\n\tassign mux_out[14] = in[59:56];\n\tassign mux_out[15] = in[63:60];\n\tassign mux_out[16] = in[67:64];\n\tassign mux_out[17] = in[71:68];\n\tassign mux_out[18] = in[75:72];\n\tassign mux_out[19] = in[79:76];\n\tassign mux_out[20] = in[83:80];\n\tassign mux_out[21] = in[87:84];\n\tassign mux_out[22] = in[91:88];\n\tassign mux_out[23] = in[95:92];\n\tassign mux_out[24] = in[99:96];\n\tassign mux_out[25] = in[103:100];\n\tassign mux_out[26] = in[107:104];\n\tassign mux_out[27] = in[111:108];\n\tassign mux_out[28] = in[115:112];\n\tassign mux_out[29] = in[119:116];\n\tassign mux_out[30] = in[123:120];\n\tassign mux_out[31] = in[127:124];\n\tassign mux_out[32] = in[131:128];\n\tassign mux_out[33] = in[135:132];\n\tassign mux_out[34] = in[139:136];\n\tassign mux_out[35] = in[143:140];\n\tassign mux_out[36] = in[147:144];\n\tassign mux_out[37] = in[151:148];\n\tassign mux_out[38] = in[155:152];\n\tassign mux_out[39] = in[159:156];\n\tassign mux_out[40] = in[163:160];\n\tassign mux_out[41] = in[167:164];\n\tassign mux_out[42] = in[171:168];\n\tassign mux_out[43] = in[175:172];\n\tassign mux_out[44] = in[179:176];\n\tassign mux_out[45] = in[18"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "// Verilog code to create a 9-to-1 multiplexer\n// sel=0 chooses a, sel=1 chooses b, etc.\n// For the unused cases (sel=9 to 15), set all output bits to '1'\n\nalways @(*) begin\n\tcase(sel)\n\t\t4'd0: out = a;\n\t\t4'd1: out = b;\n\t\t4'd2: out = c;\n\t\t4'd3: out = d;\n\t\t4'd4: out = e;\n\t\t4'd5: out = f;\n\t\t4'd6: out = g;\n\t\t4'd7: out = h;\n\t\t4'd8: out = i;\n\t\tdefault: out = 16'hffff;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR\n    assign out_or_logical = (a != 0) || (b != 0);\n    \n    // NOT of a and b\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "// State encoding\nparameter A = 4'b0001;\nparameter B = 4'b0010;\nparameter C = 4'b0100;\nparameter D = 4'b1000;\n\n// State transition and output logic\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tnext_state = (in == 1'b0) ? A : B;\n\t\t\tout = 1'b0;\n\t\tend\n\t\tB: begin\n\t\t\tnext_state = (in == 1'b0) ? C : B;\n\t\t\tout = 1'b0;\n\t\tend\n\t\tC: begin\n\t\t\tnext_state = (in == 1'b0) ? A : D;\n\t\t\tout = 1'b0;\n\t\tend\n\t\tD: begin\n\t\t\tnext_state = (in == 1'b0) ? C : B;\n\t\t\tout = 1'b1;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "The Verilog code to find the minimum of four unsigned numbers is given below:\n```verilog\nalways @(*) begin\n\tif (a < b && a < c && a < d)\n\t\tmin = a;\n\telse if (b < a && b < c && b < d)\n\t\tmin = b;\n\telse if (c < a && c < b && c < d)\n\t\tmin = c;\n\telse\n\t\tmin = d;\nend\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "//        ab\n  // cd   00 01 11 10\n  //  00 | 1 | 1 | 0 | 1 |\n  //  01 | 1 | 0 | 0 | 1 |\n  //  11 | 0 | 1 | 1 | 1 |\n  //  10 | 1 | 1 | 0 | 0 |\n  \n  // Implement the circuit\n  // AND gate\n  assign out = (~(a & b & c & d) & ~(a & b & ~c & d) & ~(a & b & c & ~d) & ~(a & b & ~c & ~d) & ~(a & b & c & d) & ~(a & ~b & c & d) & ~(a & b & c & ~d) & ~(a & ~b & ~c & d) & ~(a & ~b & c & ~d) & ~(a & b & ~c & ~d) & ~(a & ~b & c & d) & ~(a & b & ~c & d) & ~(a & ~b & c & ~d) & ~(a & b & c & ~d)) & ~(~a & b & c & d);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tz <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= E;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= F;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tz <= 1;\n\t\t\t\tstate <= B;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nreg [1:0] state;\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\nparameter E = 2'b00;\nparameter F = 2'b01;\n\ninitial begin\n\tstate <= A;\nend\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tz <= 0;\n\t\tstate <= A;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= E;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= F;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tz <= 1;\n\t\t\t\tstate <= B;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[0];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "Do not use unnecessary comments or whitespace. Do not use variable names that are not meaningful. Do not use verbs in variable names.\n\n// Verilog code\n// Priority encoder for 4-bit input\n// If no bits are high, output 0\n// Else output position of first 1 bit\n// 0: none of the bits are high\n// 1: bit[0] is high\n// 2: bit[1] is high\n// 3: bit[2] is high\n// 4: bit[3] is high\n\nalways @(*) begin\n\tcase(in)\n\t\t4'b0000: pos = 2'b00;\n\t\t4'b0001: pos = 2'b01;\n\t\t4'b0010: pos = 2'b01;\n\t\t4'b0011: pos = 2'b02;\n\t\t4'b0100: pos = 2'b02;\n\t\t4'b0101: pos = 2'b03;\n\t\t4'b0110: pos = 2'b03;\n\t\t4'b0111: pos = 2'b04;\n\t\t4'b1000: pos = 2'b04;\n\t\t4'b1001: pos = 2'b05;\n\t\t4'b1010: pos = 2'b05;\n\t\t4'b1011: pos = 2'b06;\n\t\t4'b1100: pos = 2'b06;\n\t\t4'b1101: pos = 2'b07;\n\t\t4'b1110: pos = 2'b07;\n\t\t4'b1111: pos = 2'b08;\n\t\tdefault: pos = 2'b00;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "and end with:\n```verilog\n\treg out_reg;\n\talways_ff @ (posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tout_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t0: begin\n\t\t\t\t\tif (j) begin\n\t\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\t\t\tstate <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t1: begin\n\t\t\t\t\tif (k) begin\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\t\tstate <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\tassign out = out_reg;\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "// This module always drives 0 on the output.\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "endmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    reg d;\n\n    always @(posedge clk) begin\n        d <= in ^ d;\n    end\n\n    assign out = d;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0;\n        end\n        else begin\n            if (load) begin\n                q <= data;\n            end\n            else if (ena) begin\n                q <= {q[2:0], 1'b0};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & ~x2 & ~x1) | (x3 & ~x2 & x1) | (x3 & x2 & ~x1) | (x3 & x2 & x1);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "// Asynchronous reset\n\t\talways @(*) begin\n\t\t\tif (areset == 1) begin\n\t\t\t\tq <= 0;\n\t\t\tend\n\t\tend\n\t\t// D flip-flops\n\t\talways @(posedge clk) begin\n\t\t\tq <= d;\n\t\tend\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module and signal names to make the code self-explanatory.\n\nmodule top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "always @(posedge clk, posedge reset)\n    begin\n        if (reset)\n            state <= 0;\n        else\n            case (state)\n                0: if (j) state <= 1;\n                1: if (k) state <= 0;\n            endcase\n    end"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n\n    // Define the two states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // Define the state register and initialize to B\n    reg [1:0] state = B;\n\n    // Define the output register and initialize to 1\n    reg out_reg = 1'b1;\n\n    // Define the next state and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n            out_reg <= 1'b1;\n        end else begin\n            case (state)\n                A: begin\n                    if (in) begin\n                        state <= A;\n                        out_reg <= 1'b0;\n                    end else begin\n                        state <= B;\n                        out_reg <= 1'b1;\n                    end\n                end\n                B: begin\n                    if (in) begin\n                        state <= B;\n                        out_reg <= 1'b1;\n                    end else begin\n                        state <= A;\n                        out_reg <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Assign the output to the output register\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module in your code. **Do** write the full adder module from scratch.\n\nFollow the Verilog code conventions. Use meaningful names for your signals and modules.\n\nReview the Verilog code carefully and remove any redundant code.\n\nmodule top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    wire x1, x2, x3, x4;\n\n    xor(x1, a, b);\n    xor(sum, x1, cin);\n    and(x2, a, b);\n    and(x3, x1, cin);\n    or(cout, x2, x3);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    wire xnor_out;\n    wire xor_out;\n\n    xnor_2x1 xnor_inst (\n        .a(in1),\n        .b(in2),\n        .y(xnor_out)\n    );\n\n    xor_2x1 xor_inst (\n        .a(xnor_out),\n        .b(in3),\n        .y(xor_out)\n    );\n\n    assign out = xor_out;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    wire [1:0] a, b;\n    assign a = {d, c};\n    assign b = {c, ~d};\n\n    // 4-to-1 mux\n    wire [3:0] mux_4to1_out;\n    assign mux_4to1_out = {4'b0, 4'b0, 4'b1, 4'b1} & {{2{a[1]}}, 2{a[0]}, 2{b[1]}, 2{b[0]}};\n\n    // 2-to-1 muxes\n    wire [3:0] mux_2to1_0_out;\n    wire [3:0] mux_2to1_1_out;\n    wire [3:0] mux_2to1_2_out;\n    wire [3:0] mux_2to1_3_out;\n\n    assign mux_2to1_0_out = {2'b0, 2'b1} & {{1'b0}, a[1], a[0], 1'b0} |\n                             {2'b1, 2'b0} & {{1'b1}, a[1], a[0], 1'b0};\n    assign mux_2to1_1_out = {2'b0, 2'b1} & {{1'b0}, a[1], b[0], 1'b0} |\n                             {2'b1, 2'b0} & {{1'b1}, a[1], b[0], 1'b0};\n    assign mux_2to1_2_out = {2'b0, 2'b1} & {{1'b0}, b[1], a[0], 1'b0} |\n                             {2'b1, 2'b0} & {{1'b1}, b[1], a[0], 1'b0};\n    assign mux_2to1_3_out = {2'b0, 2'b1} & {{1'b0}, b[1], b[0], 1'b0} |\n                             {2'b1, 2'b0} & {{1'b1}, b[1], b[0], 1'b0};\n\n    // 2-to-1 muxes output to mux_in\n    assign mux_in = mux_2to1_3_out & mux_4to1_out |\n                     mux_2to1_2_out & mux_4to1_out |\n                     mux_2to1_1_out & mux_4to1_out |\n                     mux_2to1_0_out & mux_4to1_out;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // States\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // State register\n    reg [1:0] state;\n\n    // Next state logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (x == 1'b0) begin\n                        state <= A;\n                    end else begin\n                        state <= B;\n                    end\n                end\n                B: begin\n                    if (x == 1'b0) begin\n                        state <= B;\n                    end else begin\n                        state <= B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    always @ (state or x) begin\n        case (state)\n            A: begin\n                if (x == 1'b0) begin\n                    z <= 1'b0;\n                end else begin\n                    z <= 1'b1;\n                end\n            end\n            B: begin\n                if (x == 1'b0) begin\n                    z <= 1'b1;\n                end else begin\n                    z <= 1'b0;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg q;\n    reg [1:0] state;\n\n    always @(posedge clk) begin\n        case (state)\n            2'b00: begin\n                if (a) state <= 2'b01;\n                else state <= 2'b10;\n            end\n            2'b01: begin\n                if (b) state <= 2'b11;\n                else state <= 2'b00;\n            end\n            2'b10: begin\n                if (b) state <= 2'b11;\n                else state <= 2'b00;\n            end\n            2'b11: begin\n                if (a) state <= 2'b01;\n                else state <= 2'b10;\n            end\n        endcase\n        q <= state[0];\n    end\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "// Karnaugh map for function f\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\n\n// Verilog implementation of function f\nalways @ (*)\nbegin\n\tcase (x)\n\t\t4'b0000: f = 1'b1;\n\t\t4'b0001: f = 1'b0;\n\t\t4'b0010: f = 1'b0;\n\t\t4'b0011: f = 1'b0;\n\t\t4'b0100: f = 1'b1;\n\t\t4'b0101: f = 1'b1;\n\t\t4'b0110: f = 1'b1;\n\t\t4'b0111: f = 1'b0;\n\t\t4'b1000: f = 1'b1;\n\t\t4'b1001: f = 1'b1;\n\t\t4'b1010: f = 1'b1;\n\t\t4'b1011: f = 1'b0;\n\t\t4'b1100: f = 1'b0;\n\t\t4'b1101: f = 1'b0;\n\t\t4'b1110: f = 1'b1;\n\t\t4'b1111: f = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "// Moore-type FSM with 4 states\n// State 0: Start state\n// State 1: Look for 6 consecutive 1s\n// State 2: Look for 7 consecutive 1s\n// State 3: Look for 0 after 5 consecutive 1s\n// State 4: Error condition\n\n// State encoding\nparameter STATE_0 = 2'b00;\nparameter STATE_1 = 2'b01;\nparameter STATE_2 = 2'b10;\nparameter STATE_3 = 2'b11;\nparameter STATE_4 = 2'b100;\n\n// FSM output signals\nreg [1:0] state;\nreg [5:0] input_buffer;\nreg disc_out;\nreg flag_out;\nreg err_out;\n\n// FSM state transition and output logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= STATE_0;\n\t\tinput_buffer <= 6'b000000;\n\t\tdisc_out <= 1'b0;\n\t\tflag_out <= 1'b0;\n\t\terr_out <= 1'b0;\n\tend else begin\n\t\tcase (state)\n\t\t\tSTATE_0: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= STATE_1;\n\t\t\t\t\tinput_buffer <= {input_buffer[4:0], in};\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= STATE_0;\n\t\t\t\t\tinput_buffer <= 6'b000000;\n\t\t\t\tend\n\t\t\t\tdisc_out <= 1'b0;\n\t\t\t\tflag_out <= 1'b0;\n\t\t\t\terr_out <= 1'b0;\n\t\t\tend\n\t\t\tSTATE_1: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= STATE_1;\n\t\t\t\t\tinput_buffer <= {input_buffer[4:0], in};\n\t\t\t\tend else if (input_buffer == 6'b011111) begin\n\t\t\t\t\tstate <= STATE_2;\n\t\t\t\t\tinput_buffer <= 6'b000000;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= STATE_1;\n\t\t\t\t\tinput_buffer <= {input_buffer[4:0], in};\n\t\t\t\tend\n\t\t\t\tdisc_out <= 1'b0;\n\t\t\t\tflag_out <= 1'b0;\n\t\t\t\terr_out <= 1'b0;\n\t\t\tend\n\t\t\tSTATE_2: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= STATE_1;\n\t\t\t\t\tinput_buffer <= {input_buffer[4:0], in};\n\t\t\t\tend else if (input_buffer == 6'b0111111) begin\n\t\t\t\t\tstate <= STATE_3;\n\t\t\t\t\tinput_buffer <= 6'b000000;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= STATE_2;\n\t\t\t\t\tinput_buffer <= {input_buffer[4:0], in};\n\t\t\t\tend\n\t\t\t\tdisc_out <= 1'b0;\n\t\t\t\tflag_out <= 1'b0;\n\t\t\t\terr_out <= 1'b0;\n\t\t\tend\n\t\t\tSTATE_3: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= STATE_4;\n\t\t\t\t\tinput_buffer <= 6'b000000;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= STATE_3;\n\t\t\t\t\tinput_buffer <= {input_buffer[4:0], in};\n\t\t\t\tend\n\t\t\t\tdisc_out <= 1'b1;\n\t\t\t\tflag_out"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "always @(*)\nbegin\n    next_state = state;\n    case (state)\n        ST_IDLE:\n            begin\n                if (data == 4'b1101)\n                    next_state = ST_START;\n            end\n        ST_START:\n            begin\n                delay <= delay_in;\n                next_state = ST_DELAY;\n            end\n        ST_DELAY:\n            begin\n                if (counter == (delay + 1) * 1000)\n                    next_state = ST_COUNT;\n            end\n        ST_COUNT:\n            begin\n                if (counter == 0)\n                    next_state = ST_DONE;\n            end\n        ST_DONE:\n            begin\n                if (ack == 1)\n                    next_state = ST_IDLE;\n            end\n        default:\n            begin\n                next_state = ST_IDLE;\n            end\n    endcase\nend"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// State definitions\n\tparameter IDLE = 2'b00;\n\tparameter HIGH = 2'b01;\n\tparameter MID = 2'b10;\n\tparameter LOW = 2'b11;\n\n\t// State and next state registers\n\treg [1:0] state, next_state;\n\n\t// Water level and previous level registers\n\treg [2:0] water_level, prev_level;\n\n\t// Flow rate registers\n\treg [1:0] fr_reg;\n\n\t// Reset logic\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\twater_level <= 3'b000;\n\t\t\tprev_level <= 3'b000;\n\t\t\tfr_reg <= 2'b00;\n\t\t\tfr3 <= 0;\n\t\t\tfr2 <= 0;\n\t\t\tfr1 <= 0;\n\t\t\tdfr <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\t\twater_level <= prev_level;\n\t\t\tprev_level <= water_level;\n\t\t\tfr_reg <= fr3 ? 2'b11 : fr2 ? 2'b10 : fr1 ? 2'b01 : 2'b00;\n\t\tend\n\tend\n\n\t// State machine\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (s[1] && s[2] && s[3]) next_state = HIGH;\n\t\t\t\telse if (s[1] && s[2]) next_state = MID;\n\t\t\t\telse if (s[1]) next_state = LOW;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tHIGH: begin\n\t\t\t\tif (!s[1] && !s[2] && s[3]) next_state = HIGH;\n\t\t\t\telse if (!s[1] && s[2] && !s[3]) next_state = MID;\n\t\t\t\telse if (!s[1] && s[2] && s[3]) next_state = LOW;\n\t\t\t\telse next_state = HIGH;\n\t\t\tend\n\t\t\tMID: begin\n\t\t\t\tif (!s[1] && s[2] && !s[3]) next_state = LOW;\n\t\t\t\telse if (s[1] && !s[2]) next_state = HIGH;\n\t\t\t\telse next_state = MID;\n\t\t\tend\n\t\t\tLOW: begin\n\t\t\t\tif (s[1]) next_state = HIGH;\n\t\t\t\telse next_state = LOW;\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (fr_reg)\n\t\t\t2'b11: begin\n\t\t\t\tfr3 <= 1;\n\t\t\t\tfr2 <= 0;\n\t\t\t\tfr1 <= 0;\n\t\t\t\tdfr <= 0;\n\t\t\tend\n\t\t\t2'b10: begin\n\t\t\t\tfr3 <= 0;\n\t\t\t\tfr2 <= 1;\n\t\t\t\tfr1 <= 0;\n\t\t\t\tdfr <= 0;\n\t\t\tend\n\t\t\t2'b01: begin\n\t\t\t\tfr3 <= 0;\n\t\t\t\tfr2 <= 0;\n\t\t\t\tfr1 <= 1;\n\t\t\t\tdfr <= 0;\n\t\t\tend\n\t\t\t2'b00: begin\n\t\t\t\tfr3 <= 0;\n\t\t\t\tfr2 <= 0;\n\t\t\t\tfr1 <= 0;\n\t\t\t\tdfr <= 1;\n\t\t\tend"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    // define state encoding\n    parameter IDLE = 2'b00;\n    parameter START = 2'b01;\n    parameter DATA = 2'b10;\n    parameter STOP = 2'b11;\n\n    // define state register\n    reg [1:0] state = IDLE;\n\n    // define data register\n    reg [7:0] data = 8'b00000000;\n\n    // define start and stop bits\n    reg start_bit = 1'b0;\n    reg stop_bit = 1'b0;\n\n    // define counter for data bits\n    reg [2:0] count = 3'b000;\n\n    // define done signal\n    reg done_reg = 1'b0;\n\n    // reset the FSM\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            data <= 8'b00000000;\n            start_bit <= 1'b0;\n            stop_bit <= 1'b0;\n            count <= 3'b000;\n            done_reg <= 1'b0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (in == 1'b0) begin\n                        start_bit <= 1'b1;\n                        count <= 3'b000;\n                        state <= START;\n                    end\n                end\n                START: begin\n                    if (in == 1'b1) begin\n                        start_bit <= 1'b0;\n                        state <= DATA;\n                    end\n                end\n                DATA: begin\n                    if (count < 3'b111) begin\n                        data[count] <= in;\n                        count <= count + 1;\n                    end\n                    else begin\n                        stop_bit <= in;\n                        count <= 3'b000;\n                        state <= STOP;\n                    end\n                end\n                STOP: begin\n                    if (in == 1'b1) begin\n                        done_reg <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // assign done signal\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "// state encoding\nparameter IDLE = 2'b00;\nparameter START_BIT = 2'b01;\nparameter DATA_BITS = 2'b10;\nparameter STOP_BIT = 2'b11;\n\n// state transitions\nparameter IDLE_TO_START_BIT = 1'b1;\nparameter START_BIT_TO_DATA_BITS = 1'b1;\nparameter DATA_BITS_TO_STOP_BIT = 1'b1;\nparameter STOP_BIT_TO_IDLE = 1'b1;"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n\treg [6:0] pc_r;\n\treg [6:0] train_pc_r;\n\treg [6:0] history_r;\n\treg [6:0] train_history_r;\n\treg [6:0] pht_index;\n\treg [1:0] pht_state;\n\n\twire [1:0] pht_next_state;\n\twire [6:0] pht_state_out;\n\twire pht_taken;\n\n\t// Prediction\n\tassign predict_taken = pht_taken;\n\tassign predict_history = pht_state_out;\n\n\t// PHT\n\txor_xor_xor32_1_xor_xor_xor32_1_xor_xor_xor32_1 pht_xor0(\n\t\t.a(history_r),\n\t\t.b(pc_r),\n\t\t.c(pht_index),\n\t\t.s(pht_state)\n\t);\n\txor_xor_xor32_1_xor_xor_xor32_1_xor_xor32_1_xor_xor32_1 pht_xor1(\n\t\t.a(pht_state),\n\t\t.b(train_history_r),\n\t\t.c(pht_index),\n\t\t.s(pht_state_out)\n\t);\n\txor_xor_xor32_1_xor_xor32_1_xor_xor32_1_xor_xor32_1_xor_xor32_1 pht_xor2(\n\t\t.a(pht_state),\n\t\t.b(train_pc_r),\n\t\t.c(pht_index),\n\t\t.s(pht_taken)\n\t);\n\n\t// State update\n\talways @(posedge clk) begin\n\t\tif (areset) begin\n\t\t\tpc_r <= 7'b0;\n\t\t\thistory_r <= 7'b0;\n\t\t\ttrain_pc_r <= 7'b0;\n\t\t\ttrain_history_r <= 7'b0;\n\t\t\tpht_index <= 7'b0;\n\t\t\tpht_state <= 2'b00;\n\t\tend else begin\n\t\t\tif (predict_valid) begin\n\t\t\t\tpc_r <= predict_pc;\n\t\t\t\thistory_r <= predict_history;\n\t\t\tend else if (train_valid) begin\n\t\t\t\tif (train_mispredicted) begin\n\t\t\t\t\ttrain_history_r <= train_history;\n\t\t\t\tend\n\t\t\t\ttrain_pc_r <= train_pc;\n\t\t\tend\n\t\tend\n\tend\n\n\t// PHT next state\n\txor_xor32_1_xor_xor32_1_xor32_1_xor_xor32_1_xor_xor32_1_xor_xor32_1 pht_xor3(\n\t\t.a(pht_state),\n\t\t.b(pht_state_out),\n\t\t.c(pht_index),\n\t\t.s(pht_next_state)\n\t);\n\txor_xor32_1_xor_xor32_1_xor32_1_xor_xor32_1_xor_xor32_1_xor_xor32_1_xor_xor32_1 pht_xor4(\n\t\t.a(pht_next_state"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter falling_state = 2'b10;\n\tparameter digging_state = 2'b11;\n\n\t// Define the outputs\n\treg walk_left_out;\n\treg walk_right_out;\n\treg aaah_out;\n\treg digging_out;\n\n\t// Define the state and next state registers\n\treg [1:0] state_reg;\n\treg [1:0] next_state_reg;\n\n\t// Define the fall counter\n\treg [3:0] fall_count_reg;\n\n\t// Define the dig counter\n\treg [2:0] dig_count_reg;\n\n\t// Define the constants\n\tlocalparam MAX_FALL_COUNT = 4'd20;\n\tlocalparam MAX_DIG_COUNT = 3'd3;\n\n\t// Define the state machine\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate_reg <= walk_left_state;\n\t\t\twalk_left_out <= 1'b1;\n\t\t\twalk_right_out <= 1'b0;\n\t\t\taaah_out <= 1'b0;\n\t\t\tdigging_out <= 1'b0;\n\t\t\tfall_count_reg <= 4'd0;\n\t\t\tdig_count_reg <= 3'd0;\n\t\tend else begin\n\t\t\tstate_reg <= next_state_reg;\n\t\t\tcase (state_reg)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\twalk_left_out <= 1'b1;\n\t\t\t\t\twalk_right_out <= 1'b0;\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tnext_state_reg <= walk_right_state;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tnext_state_reg <= digging_state;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tnext_state_reg <= falling_state;\n\t\t\t\t\t\tfall_count_reg <= 4'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\twalk_left_out <= 1'b0;\n\t\t\t\t\twalk_right_out <= 1'b1;\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tnext_state_reg <= digging_state;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tnext_state_reg <= falling_state;\n\t\t\t\t\t\tfall_count_reg <= 4'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state_reg <= walk_right_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfalling_state: begin\n\t\t\t\t\twalk_left_out <= 1'b0;\n\t\t\t\t\twalk_right_out <= 1'b0;\n\t\t\t\t\taaah_out <= 1'b1;\n\t\t\t\t\tif (ground) begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;\n\t\t\t\t\t\tfall_count_reg <= 4'd0;\n\t\t\t\t\tend else if (fall_count_reg == MAX_FALL_COUNT) begin\n\t\t\t\t\t\tnext_state_reg <= 2"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "+---+\nPATTERN --shift_ena--+   |   | IDLE\n                          +---+\n                           /  \\\n                          /    \\\n                         /      \\\n                        /        \\\n                       /          \\\n                      /            \\\n                     /              \\\n                    /                \\\n                   /                  \\\n                  COUNTER_START--counting-->COUNTER\n                                             \\\n                                              \\--done--+\n                                                |       | ACK\n                                                |       |\n                                                +---+    +---+"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "// Internal wires\n  wire [3:0] n1, n2, n3, n4;\n  wire [15:0] n_row, n_col;\n  wire [15:0] q_row, q_col;\n  wire [15:0] q_next;\n\n  // Load initial state\n  assign q_row = data[15:0];\n  assign q_col = data[31:16];\n  assign n_row = {q_row[14], q_row[15], q_row[15], q_row[14]};\n  assign n_col = {q_col[14], q_col[15], q_col[15], q_col[14]};\n  assign n1 = {n_row[3], n_col[3]};\n  assign n2 = {n_row[2], n_col[2]};\n  assign n3 = {n_row[1], n_col[1]};\n  assign n4 = {n_row[0], n_col[0]};\n\n  // Next state calculation\n  assign q_next[0] = q_row[0] ^ n1[0] ^ n1[1] ^ n1[2] ^ n1[3];\n  assign q_next[1] = q_row[1] ^ n1[0] ^ n1[1] ^ n1[2] ^ n1[3];\n  assign q_next[2] = q_row[2] ^ n1[0] ^ n1[1] ^ n1[2] ^ n1[3];\n  assign q_next[3] = q_row[3] ^ n1[0] ^ n1[1] ^ n1[2] ^ n1[3];\n  assign q_next[4] = q_col[0] ^ n2[0] ^ n2[1] ^ n2[2] ^ n2[3];\n  assign q_next[5] = q_col[1] ^ n2[0] ^ n2[1] ^ n2[2] ^ n2[3];\n  assign q_next[6] = q_col[2] ^ n2[0] ^ n2[1] ^ n2[2] ^ n2[3];\n  assign q_next[7] = q_col[3] ^ n2[0] ^ n2[1] ^ n2[2] ^ n2[3];\n  assign q_next[8] = q_row[4] ^ n3[0] ^ n3[1] ^ n3[2] ^ n3[3];\n  assign q_next[9] = q_row[5] ^ n3[0] ^ n3[1] ^ n3[2] ^ n3[3];\n  assign q_next[10] = q_row[6] ^ n3[0] ^ n3[1] ^ n3[2] ^ n3[3];\n  assign q_next[11] = q_row[7] ^ n3[0] ^ n3[1] ^ n3[2] ^ n3[3];\n  assign q_next[12] = q_col[4] ^ n4[0] ^ n4[1] ^ n4[2] ^ n4[3];\n  assign q_next[13] = q_col[5] ^ n4[0] ^ n4[1] ^ n4[2] ^ n4[3];\n  assign q_next[14] = q_col[6] ^ n4[0] ^ n4[1] ^ n4[2] ^ n4[3];\n  assign q_next[15] = q_col[7] ^ n4[0] ^ n4[1] ^ n4[2] ^ n4[3];\n\n  // Load initial state\n  always @(posedge clk) begin\n    if (load) begin\n      q <= q_next;\n    end\n  end\n\n  // Update state\n  always @(posedge clk) begin\n    q <= q_next;\n  end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // Define the states\n    parameter STATE_WALK_LEFT = 2'b00;\n    parameter STATE_WALK_RIGHT = 2'b01;\n    parameter STATE_FALLING = 2'b10;\n    parameter STATE_DIGGING = 2'b11;\n\n    // Define the outputs\n    assign walk_left = (state == STATE_WALK_LEFT);\n    assign walk_right = (state == STATE_WALK_RIGHT);\n    assign aaah = (state == STATE_FALLING);\n    assign digging = (state == STATE_DIGGING);\n\n    // Define the state register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= STATE_WALK_LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Define the next state logic\n    always @(*) begin\n        case (state)\n            STATE_WALK_LEFT: begin\n                if (bump_left) begin\n                    next_state = STATE_WALK_RIGHT;\n                end\n                else if (dig && ground) begin\n                    next_state = STATE_DIGGING;\n                end\n                else begin\n                    next_state = STATE_WALK_LEFT;\n                end\n            end\n            STATE_WALK_RIGHT: begin\n                if (bump_right) begin\n                    next_state = STATE_WALK_LEFT;\n                end\n                else if (dig && ground) begin\n                    next_state = STATE_DIGGING;\n                end\n                else begin\n                    next_state = STATE_WALK_RIGHT;\n                end\n            end\n            STATE_FALLING: begin\n                if (ground) begin\n                    next_state = (dig) ? STATE_DIGGING : STATE_WALK_LEFT;\n                end\n                else begin\n                    next_state = STATE_FALLING;\n                end\n            end\n            STATE_DIGGING: begin\n                if (ground) begin\n                    next_state = (dig) ? STATE_DIGGING : STATE_WALK_LEFT;\n                end\n                else begin\n                    next_state = STATE_FALLING;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "Do not add any additional module or global declarations.\n\nComplete the Verilog code for the 12-hour clock counters and the AM/PM indicator.\n\nFollow the Verilog coding standard and conventions for readability and maintainability.\n\nmodule top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n\treg [3:0] h;\n\treg [3:0] m;\n\treg [3:0] s;\n\treg [1:0] period;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\th <= 4'b0001;\n\t\t\tm <= 4'b0000;\n\t\t\ts <= 4'b0000;\n\t\t\tperiod <= 2'b00;\n\t\t\tpm <= 1'b0;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tcase (period)\n\t\t\t\t2'b00: begin\n\t\t\t\t\tif (s == 4'b1011) begin\n\t\t\t\t\t\ts <= 4'b0000;\n\t\t\t\t\t\tif (m == 4'b1111) begin\n\t\t\t\t\t\t\tm <= 4'b0000;\n\t\t\t\t\t\t\tif (h == 4'b1111) begin\n\t\t\t\t\t\t\t\th <= 4'b0001;\n\t\t\t\t\t\t\t\tif (h[3] == 1) begin\n\t\t\t\t\t\t\t\t\tpm <= 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t\tpm <= 1'b0;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\th <= h + 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tm <= m + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\ts <= s + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\tif (s == 4'b1011) begin\n\t\t\t\t\t\ts <= 4'b0000;\n\t\t\t\t\t\tif (m == 4'b1111) begin\n\t\t\t\t\t\t\tm <= 4'b0000;\n\t\t\t\t\t\t\tif (h == 4'b1111) begin\n\t\t\t\t\t\t\t\th <= 4'b0001;\n\t\t\t\t\t\t\t\tif (h[3] == 1) begin\n\t\t\t\t\t\t\t\t\tpm <= 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\t\tpm <= 1'b0;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\th <= h + 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tm <= m + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\ts <= s + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b10: begin\n\t\t\t\t\tif (s == 4'b1011) begin\n\t\t\t\t\t\ts <= 4'b0000;\n\t\t\t\t\t\tif (m == 4"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "reg [1:0] state;\n\treg [1:0] next_state;\n\t\n\tparameter walk_left_val = 2'b00;\n\tparameter walk_right_val = 2'b01;\n\tparameter aaah_val = 2'b10;\n\t\n\tassign walk_left = (state == walk_left_val);\n\tassign walk_right = (state == walk_right_val);\n\tassign aaah = (state == aaah_val);\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left_val;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\twalk_left_val: begin\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tnext_state = walk_right_val;\n\t\t\t\tend\n\t\t\t\telse if (!ground) begin\n\t\t\t\t\tnext_state = aaah_val;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = walk_left_val;\n\t\t\t\tend\n\t\t\tend\n\t\t\twalk_right_val: begin\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = walk_left_val;\n\t\t\t\tend\n\t\t\t\telse if (!ground) begin\n\t\t\t\t\tnext_state = aaah_val;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = walk_right_val;\n\t\t\t\tend\n\t\t\tend\n\t\t\taaah_val: begin\n\t\t\t\tif (ground) begin\n\t\t\t\t\tnext_state = walk_left_val;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = aaah_val;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "endmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "Follow the Verilog coding standard to write the code.\n\n  - 80-character line limit\n  - 100-character function limit\n  - 10-character tab limit\n  - Use comments to explain the code\n  - Use meaningful names for variables and functions\n  - Use blank lines to separate logical blocks\n  - Use indentation to improve readability\n  - Use uppercase for constants\n  - Use lowercase for variables\n  - Use camelCase for functions and modules\n  - Use braces for control structures\n  - Use spaces around operators\n  - Use spaces between keywords and arguments\n  - Use semicolons to end statements\n  - Use parentheses to group statements\n  - Use commas to separate arguments\n  - Use a blank line between functions\n  - Use a blank line between modules\n  - Use a blank line between logical blocks\n  - Use a blank line between comments\n  - Use a blank line between code and comments\n  - Use a blank line between code and module headers\n  - Use a blank line between module headers\n  - Use a blank line between module instances\n  - Use a blank line between module ports\n  - Use a blank line between module headers and ports\n  - Use a blank line between module instances and ports\n  - 4-space tab stop\n  - 2-space indent\n  - 1-space for operators and assignments\n  - 1-space for keywords\n  - 1-space for arguments\n  - 1-space for brackets\n  - 1-space for commas\n  - 1-space for colons\n  - 1-space for semicolons\n  - 1-space for parentheses\n  - 1-space for braces\n  - 1-space for else\n  - 1-space for if\n  - 1-space for case\n  - 1-space for default\n  - 1-space for switch\n  - 1-space for guard\n  - 1-space for begin\n  - 1-space for end\n  - 1-space for while\n  - 1-space for do\n  - 1-space for for\n  - 1-space for continue\n  - 1-space for break\n  - 1-space for return\n  - 1-space for module headers\n  - 1-space for module ports\n  - 1-space for module instances\n  - 1-space for module signals\n  - 1-space for Verilog comments\n  - 1-space for Verilog keywords\n  - 1-space for Verilog operators\n  - 1-space for Verilog assignments\n  - 1-space for Verilog code\n  - 1-space for Verilog module names\n  - 1-space for Verilog module signals\n  - 1-space for Verilog module instances\n  - 1-space for Verilog module ports\n  - 1-space for Verilog module headers\n  - 1-space for Verilog code\n  - 1-space for Verilog comments\n  // 1-space for Verilog code\n  // 1-space for Verilog code ends\n  // 1-space for module instances ends\n  // 1-space for module ports ends\n  // 1-space for module signals ends\n  // 1-space for module names ends\n  // 1-space for else ends\n  // 1-space for if ends\n  // 1-space for case ends\n  // 1-space for default ends\n  // 1-space for switch ends\n  // 1-space for guard ends\n  // 1-space for begin ends\n  // 1-space for end ends\n  // 1-space for while ends\n  // 1-space for do ends\n  // 1-space for for ends\n  // 1-space for continue ends\n  // 1-space for break ends\n  // 1-space for return ends\n  // 1-space for Verilog code ends\n  // 1-space for Verilog code starts\n  // 1-space for Verilog code starts\n  // 1-space for Verilog assignments ends\n  // 1-space for Verilog code ends\n  // 1-space for Verilog code starts\n  // 1-space for Verilog comments ends\n  // 80-character line limit\n  // 100-character function"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "always @ (w, y) begin\n\t\t\tcase (y)\n\t\t\t\t3'b000: Y2 <= 1'b0;\n\t\t\t\t3'b001: Y2 <= 1'b1;\n\t\t\t\t3'b010: Y2 <= 1'b0;\n\t\t\t\t3'b011: Y2 <= 1'b1;\n\t\t\t\t3'b100: Y2 <= 1'b0;\n\t\t\t\t3'b101: Y2 <= 1'b1;\n\t\t\t\t3'b110: Y2 <= 1'b0;\n\t\t\t\t3'b111: Y2 <= 1'b1;\n\t\t\tendcase\n\t\tend\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If vibrate_mode is high, turn on the motor. Otherwise, turn on the ringer.\n    assign motor = vibrate_mode;\n    assign ringer = ~vibrate_mode & ring;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "endmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "endmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "// Sequential circuit with feedback\n\n// a -> q in 5ns\n// q -> q in 15ns\n// q -> q in 20ns\n// q -> q in 25ns\n// q -> q in 30ns\n// q -> q in 35ns\n// q -> q in 40ns\n// q -> q in 45ns\n// q -> q in 50ns\n// q -> q in 55ns\n// q -> q in 60ns\n// q -> q in 65ns\n// q -> q in 70ns\n// q -> q in 75ns\n// q -> q in 80ns\n// q -> q in 85ns\n// q -> q in 90ns\n\nalways @(posedge clk) begin\n\tif (a) begin\n\t\tq <= 1'b1;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (!q) begin\n\t\tq <= q;\n\tend\n\tif (q) begin\n\t\tq <= q;\n\tend\nend\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// Module ports\n\t\tinput clk, areset, x;\n\t\toutput z;\n\n\t\t// Local signals\n\t\twire [1:0] state;\n\t\twire [1:0] next_state;\n\t\twire [1:0] prev_state;\n\t\twire [1:0] x_reg;\n\t\twire [1:0] x_next;\n\t\twire [1:0] x_prev;\n\t\twire [1:0] z_reg;\n\t\twire [1:0] z_next;\n\t\twire [1:0] z_prev;\n\n\t\t// State machine\n\t\tlocalparam IDLE = 2'b00;\n\t\tlocalparam ACCEPT = 2'b01;\n\t\tlocalparam CONVERT = 2'b10;\n\t\treg [1:0] state_reg, next_state_reg;\n\t\talways @(posedge clk or posedge areset) begin\n\t\t\tif (areset) begin\n\t\t\t\tstate_reg <= IDLE;\n\t\t\tend else begin\n\t\t\t\tstate_reg <= next_state_reg;\n\t\t\tend\n\t\tend\n\t\talways @(*) begin\n\t\t\tnext_state_reg = state_reg;\n\t\t\tcase (state_reg)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (x == 1'b0) begin\n\t\t\t\t\t\tnext_state_reg = CONVERT;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tACCEPT: begin\n\t\t\t\t\tif (x == 1'b0) begin\n\t\t\t\t\t\tnext_state_reg = CONVERT;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state_reg = ACCEPT;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCONVERT: begin\n\t\t\t\t\tif (x == 1'b0) begin\n\t\t\t\t\t\tnext_state_reg = IDLE;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state_reg = CONVERT;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\n\t\t// State registers\n\t\talways @(posedge clk or posedge areset) begin\n\t\t\tif (areset) begin\n\t\t\t\tx_reg <= 2'b00;\n\t\t\t\tz_reg <= 2'b00;\n\t\t\tend else begin\n\t\t\t\tx_reg <= x_next;\n\t\t\t\tz_reg <= z_next;\n\t\t\tend\n\t\tend\n\t\talways @(*) begin\n\t\t\tx_next = x_reg;\n\t\t\tz_next = z_reg;\n\t\t\tcase (state_reg)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tx_next = x_reg;\n\t\t\t\t\tz_next = z_reg;\n\t\t\t\tend\n\t\t\t\tACCEPT: begin\n\t\t\t\t\tx_next = x_reg;\n\t\t\t\t\tz_next = z_reg;\n\t\t\t\tend\n\t\t\t\tCONVERT: begin\n\t\t\t\t\tx_next = {x_reg[0], x_reg[1]};\n\t\t\t\t\tz_next = {z_reg[1], ~x_reg[0]};\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\n\t\t// Output\n\t\tassign z = z_reg[1];\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore state machine with one input, one output, and four states\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n// Asynchronous reset that resets the FSM to state A\n// Positive edge triggered reset that resets the FSM to state A\n\n// state encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// state register\nreg [1:0] state, next_state;\n\n// output register\nreg out;\n\n// state transition logic\nalways @(posedge clk, posedge areset) begin\n\tif (areset) begin\n\t\tstate <= A;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// next state logic\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tout = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\t\tout = 1'b1;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tout = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout = 1'b1;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "followed by the implementation of the D flip flop with synchronous reset.\n```verilog\nreg q;\n\nalways @(posedge clk) begin\n\tif (r) begin\n\t\tq <= 1'b0;\n\tend else begin\n\t\tq <= d;\n\tend\nend\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x^y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "// Shifter\nreg [63:0] shift_reg;\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tshift_reg <= data;\n\tend else if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00: shift_reg <= {shift_reg[62:0], shift_reg[63]};\n\t\t\t2'b01: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};\n\t\t\t2'b10: shift_reg <= {shift_reg[5:0], shift_reg[63:6]};\n\t\t\t2'b11: shift_reg <= {shift_reg[55:0], shift_reg[63:56]};\n\t\tendcase\n\tend\nend\n\n// Output\nassign q = shift_reg;\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "// Asynchronous negative edge triggered reset\n\talways @(negedge aresetn) begin\n\t\tif (~aresetn) begin\n\t\t\tz <= 0;\n\t\t\tstate <= IDLE;\n\t\tend\n\tend\n\t\n\t// State machine\n\treg [1:0] state;\n\tparameter IDLE = 2'b00;\n\tparameter WAIT_1 = 2'b01;\n\tparameter WAIT_0 = 2'b10;\n\t\n\talways @(posedge clk) begin\n\t\tif (~aresetn) begin\n\t\t\tz <= 0;\n\t\t\tstate <= IDLE;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= WAIT_1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tWAIT_1: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= WAIT_0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tWAIT_0: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tz <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= WAIT_1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n    parameter E = 2'b100;\n    parameter F = 2'b101;\n\n    // Define the state register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Define the output register and output logic\n    reg output_reg;\n    always @(state) begin\n        case (state)\n            A: begin\n                if (w == 0) begin\n                    next_state = B;\n                end else begin\n                    next_state = A;\n                end\n                output_reg = 0;\n            end\n            B: begin\n                if (w == 0) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n                output_reg = 0;\n            end\n            C: begin\n                if (w == 0) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n                output_reg = 0;\n            end\n            D: begin\n                if (w == 0) begin\n                    next_state = F;\n                end else begin\n                    next_state = A;\n                end\n                output_reg = 1;\n            end\n            E: begin\n                if (w == 0) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n                output_reg = 1;\n            end\n            F: begin\n                if (w == 1) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n                output_reg = 1;\n            end\n        endcase\n    end\n\n    // Assign the output\n    assign z = output_reg;\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "```verilog\nreg [2:0] state;\nreg [7:0] byte_reg;\nreg [23:0] out_reg;\nreg done_reg;\n\nassign out_bytes = out_reg;\nassign done = done_reg;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 0;\n\t\tbyte_reg <= 0;\n\t\tout_reg <= 0;\n\t\tdone_reg <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\t0: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate <= 1;\n\t\t\t\t\tbyte_reg <= in;\n\t\t\t\tend\n\t\t\tend\n\t\t\t1: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tbyte_reg <= {byte_reg[6:0], in};\n\t\t\t\t\tif (state == 2) begin\n\t\t\t\t\t\tout_reg <= {byte_reg[15:8], byte_reg[23:16], byte_reg[7:0]};\n\t\t\t\t\t\tdone_reg <= 1;\n\t\t\t\t\t\tstate <= 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= state + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "reg [5:0] y_next;\n\nalways @ (posedge Y1 or posedge Y3) begin\n    if (Y1) begin\n        y_next <= {y[0], y[1], y[2], y[3], y[4], y[5]} >> 1;\n    end else if (Y3) begin\n        y_next <= {y[2], y[3], y[4], y[5], y[0], y[1]} >> 1;\n    end\nend\n\nalways @ (posedge Y1 or posedge Y3) begin\n    y <= y_next;\nend"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module and the functionality of each block of code.\n* Use Verilog keywords and syntax to ensure your code is readable and maintainable.\n* Break your code into logical modules and functions to make it easier to understand and modify.\n* Use blank lines to separate different sections of code.\n\n**DON'T**\n* Use nested if-else statements or for-loops to make your code difficult to read.\n* Repeat yourself. Use functions or modules to break your code into logical parts.\n* Use global variables. They can be difficult to debug and maintain.\n* Write overly complex code. Keep your functions and modules simple and easy to understand.\n* Use magic numbers. Assign meaningful names to constants and parameters.\n\n**Note:** Verilog is a hardware description language, so it's important to write code that is easy to understand and maintain. Avoid using tricks or hacks that make your code difficult to follow. Be consistent with your naming conventions and formatting.\nmodule top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\n\nalways @ (a or b or c or d) begin\n\tcase ({a,b,c,d})\n\t\t4'b0000: out = 1'b0;\n\t\t4'b0001: out = 1'b1;\n\t\t4'b0010: out = 1'b0;\n\t\t4'b0011: out = 1'b1;\n\t\t4'b0100: out = 1'b1;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0110: out = 1'b1;\n\t\t4'b0111: out = 1'b0;\n\t\t4'b1000: out = 1'b0;\n\t\t4'b1001: out = 1'b1;\n\t\t4'b1010: out = 1'b1;\n\t\t4'b1011: out = 1'b0;\n\t\t4'b1100: out = 1'b1;\n\t\t4'b1101: out = 1'b0;\n\t\t4'b1110: out = 1'b0;\n\t\t4'b1111: out = 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "Use the `NOR` gate primitive to implement the NOR gate.\n```verilog\n\tNOR gate (out, a, b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "// Output is assigned directly\nassign out_assign = a ^ b;\n\n// Output is computed in a combinational always block\nalways @(*) begin\n\tout_always_comb = a ^ b;\nend\n\n// Output is computed in a clocked always block\nreg a_reg;\nreg b_reg;\nreg out_always_ff_reg;\n\nalways @(posedge clk) begin\n\ta_reg <= a;\n\tb_reg <= b;\n\tout_always_ff_reg <= a_reg ^ b_reg;\nend\n\nassign out_always_ff = out_always_ff_reg;\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "```verilog\nmodule top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n\t// Derive the logic equations for Y2 and Y4 by inspection\n\t// Y2: y[2] = 0 implies y[4] = 0 and y[6] = 1\n\t// Y4: y[4] = 0 implies y[2] = 0 and y[6] = 1\n\t// y[6] = 1 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 1 implies y[4] = 1 and y[6] = 0\n\t// y[4] = 1 implies y[2] = 1 and y[6] = 0\n\t// y[6] = 0 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 0 implies y[4] = 0 and y[6] = 1\n\t// y[4] = 0 implies y[2] = 0 and y[6] = 1\n\t// y[6] = 1 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 1 implies y[4] = 1 and y[6] = 0\n\t// y[4] = 1 implies y[2] = 1 and y[6] = 0\n\t// y[6] = 0 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 0 implies y[4] = 0 and y[6] = 1\n\t// y[4] = 0 implies y[2] = 0 and y[6] = 1\n\t// y[6] = 1 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 1 implies y[4] = 1 and y[6] = 0\n\t// y[4] = 1 implies y[2] = 1 and y[6] = 0\n\t// y[6] = 0 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 0 implies y[4] = 0 and y[6] = 1\n\t// y[4] = 0 implies y[2] = 0 and y[6] = 1\n\t// y[6] = 1 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 1 implies y[4] = 1 and y[6] = 0\n\t// y[4] = 1 implies y[2] = 1 and y[6] = 0\n\t// y[6] = 0 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 0 implies y[4] = 0 and y[6] = 1\n\t// y[4] = 0 implies y[2] = 0 and y[6] = 1\n\t// y[6] = 1 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 1 implies y[4] = 1 and y[6] = 0\n\t// y[4] = 1 implies y[2] = 1 and y[6] = 0\n\t// y[6] = 0 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 0 implies y[4] = 0 and y[6] = 1\n\t// y[4] = 0 implies y[2] = 0 and y[6] = 1\n\t// y[6] = 1 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 1 implies y[4] = 1 and y[6] = 0\n\t// y[4] = 1 implies y[2] = 1 and y[6] = 0\n\t// y[6] = 0 implies y[2] = 0 and y[4] = 0\n\t// y[2] = 0 implies y[4] = 0 and y[6] ="}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "The Verilog code for the 1-bit wide 256-to-1 multiplexer is:\n```verilog\nwire [255:0] sel_inv;\nassign sel_inv = ~sel;\n\nwire [255:0] sel_shifted;\nassign sel_shifted = sel_inv << sel;\n\nwire [255:0] in_sel_shifted;\nassign in_sel_shifted = in & sel_shifted;\n\nwire [255:0] in_sel_inv_shifted;\nassign in_sel_inv_shifted = in & sel_inv >> sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv;\nassign in_sel_inv_shifted_sel_inv = in_sel_inv_shifted_sel_inv_shifted & sel_inv;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel;\nassign in_sel_inv_shifted_sel_inv_shifted_sel = in_sel_inv_shifted_sel_inv_shifted_sel_shifted & sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel;\nassign in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel = in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_shifted & sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel;\nassign in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel = in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_shifted & sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel;\nassign in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel = in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_shifted & sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel;\nassign in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel = in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_shifted & sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel;\nassign in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel = in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_shifted & sel;\n\nwire [255:0] in_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv_shifted_sel_inv"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk) begin\n\tif (L) begin\n\t\tQ <= w;\n\tend else if (E) begin\n\t\tQ <= Q;\n\tend else begin\n\t\tQ <= R;\n\tend\nend\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module d_ff (\n    input clk,\n    input d,\n    output q\n);\n    reg q_reg;\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n    assign q = q_reg;\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & ~b & ~c & d;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "endmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register\nreg [1:0] state;\n\n// Next state logic\nalways @ (posedge clk, posedge reset)\nbegin\n\tif (reset)\n\t\tstate <= A;\n\telse\n\t\tcase (state)\n\t\t\tA: if (in)\n\t\t\t\tstate <= B;\n\t\t\t\telse\n\t\t\t\tstate <= A;\n\t\t\tB: if (in)\n\t\t\t\tstate <= B;\n\t\t\t\telse\n\t\t\t\tstate <= C;\n\t\t\tC: if (in)\n\t\t\t\tstate <= D;\n\t\t\t\telse\n\t\t\t\tstate <= A;\n\t\t\tD: if (in)\n\t\t\t\tstate <= C;\n\t\t\t\telse\n\t\t\t\tstate <= B;\n\t\tendcase\nend\n\n// Output logic\nalways @ (state)\nbegin\n\tcase (state)\n\t\tA: out <= 0;\n\t\tB: out <= 0;\n\t\tC: out <= 0;\n\t\tD: out <= 1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "```verilog\n\talways @ (a, b, c, d, e)\n\tbegin\n\t\tcase ({a,b,c,d,e})\n\t\t\t5'b0xxxx: q = 4'bxxxx;\n\t\t\t5'b1xxxx: q = 4'bxxxx;\n\t\t\t5'bxxxx1: q = 4'bxxxx;\n\t\t\t5'bxxxxx2: q = 4'bxxxx;\n\t\t\t5'bxxxxx3: q = 4'bxxxx;\n\t\t\t5'bxxxxx4: q = 4'bxxxx;\n\t\t\t5'bxxxxx5: q = 4'bxxxx;\n\t\t\t5'bxxxxx6: q = 4'bxxxx;\n\t\t\t5'bxxxxx7: q = 4'bxxxx;\n\t\t\t5'bxxxxx8: q = 4'bxxxx;\n\t\t\t5'bxxxxx9: q = 4'bxxxx;\n\t\t\t5'bxxxxxA: q = 4'bxxxx;\n\t\t\t5'bxxxxxB: q = 4'bxxxx;\n\t\t\t5'bxxxxxC: q = 4'bxxxx;\n\t\t\t5'bxxxxxD: q = 4'bxxxx;\n\t\t\t5'bxxxxxE: q = 4'bxxxx;\n\t\t\t5'bxxxxx0: q = 4'bxxxx;\n\t\t\t5'bxxxxx1: q = 4'bxxxx;\n\t\t\t5'bxxxxx2: q = 4'bxxxx;\n\t\t\t5'bxxxxx3: q = 4'bxxxx;\n\t\t\t5'bxxxxx4: q = 4'bxxxx;\n\t\t\t5'bxxxxx5: q = 4'bxxxx;\n\t\t\t5'bxxxxx6: q = 4'bxxxx;\n\t\t\t5'bxxxxx7: q = 4'bxxxx;\n\t\t\t5'bxxxxx8: q = 4'bxxxx;\n\t\t\t5'bxxxxx9: q = 4'bxxxx;\n\t\t\t5'bxxxxxA: q = 4'bxxxx;\n\t\t\t5'bxxxxxB: q = 4'bxxxx;\n\t\t\t5'bxxxxxC: q = 4'bxxxx;\n\t\t\t5'bxxxxxD: q = 4'bxxxx;\n\t\t\t5'bxxxxxE: q = 4'bxxxx;\n\t\t\t5'bxxxxx0: q = 4'bxxxx;\n\t\t\t5'bxxxxxF: q = 4'bxxxx;\n\t\t\t5'bxxxxxA: q = 4'bxxxx;\n\t\t\t5'bxxxxxB: q = 4'bxxxx;\n\t\t\t5'bxxxxxC: q = 4'bxxxx;\n\t\t\t5'bxxxxxD: q = 4'bxxxx;\n\t\t\t5'bxxxxxE: q = 4'bxxxx;\n\t\t\t5'bxxxxx10: q = 4'b0000;\n\t\t\t5'bxxxxx11: q = 4'b0000;\n\t\t\t5'bxxxxx12: q = 4'b0000;\n\t\t\t5'bxxxxx13: q = 4'b0000;\n\t\t\t5'bxxxxx14: q = 4'b0000;\n\t\t\t5'bxxxxx15: q = 4'b1000;\n\t\t\t5'bxxxxx16: q = 4'b0100;\n\t\t\t5'bxxxxx17: q = 4'b0010;\n\t\t\t5'bxxxxx18: q = 4'b0001;\n\t\t\t5'bxxxxx19: q = 4'"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "Do not add any extra code or comments.\n\nComplete the mux implementation as follows:\n```verilog\nalways @(*)\nbegin\n\tif(sel == 1'b1)\n\t\tout = b;\n\telse\n\t\tout = a;\nend\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module three times\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\nwire q0, q1, q2;\n\nflipflop_mux mux0(.clk(clk), .L(L), .q_in(q_in), .r_in(r_in), .q(q0));\nflipflop_mux mux1(.clk(clk), .L(L), .q_in(q0), .r_in(q_in), .q(q1));\nflipflop_mux mux2(.clk(clk), .L(L), .q_in(q1), .r_in(q_in), .q(q2));\n\nassign Q = q2;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module code as follows:\n```verilog\nreg [31:0] prev_in;\nreg [31:0] curr_in;\nreg [31:0] diff;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 0;\n        prev_in <= 0;\n        curr_in <= 0;\n        diff <= 0;\n    end\n    else begin\n        prev_in <= curr_in;\n        curr_in <= in;\n        diff <= curr_in - prev_in;\n        out <= diff[31];\n    end\nend\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] sum;\n    wire carry_out;\n    wire sign_a;\n    wire sign_b;\n    wire sign_sum;\n\n    assign sign_a = (a[7] == 1);\n    assign sign_b = (b[7] == 1);\n    assign sign_sum = (sum[8] == 1);\n\n    assign overflow = sign_a ^ sign_b ^ sign_sum;\n\n    assign {carry_out, sum} = a + b;\n\n    assign s = sum[7:0];\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n// State encoding\nparameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b1000000000;\nparameter Wait = 10'b0100000000;\n\n// Next-state logic\nreg [9:0] next_state;\nalways @ (posedge d or posedge done_counting or posedge ack)\nbegin\n    case (state)\n        S: next_state = S;\n        S1: next_state = S1;\n        S11: next_state = S11;\n        S110: next_state = S110;\n        B0: next_state = B0;\n        B1: next_state = B1;\n        B2: next_state = B2;\n        B3: next_state = B3;\n        Count: next_state = (done_counting) ? Wait : Count;\n        Wait: next_state = (ack) ? S : Wait;\n        default: next_state = S;\n    endcase\nend\n\n// Output logic\nassign B3_next = (next_state == B3);\nassign S_next = (next_state == S);\nassign S1_next = (next_state == S1);\nassign Count_next = (next_state == Count);\nassign Wait_next = (next_state == Wait);\nassign done = (next_state == S);\nassign counting = (next_state == Count);\nassign shift_ena = (next_state == B3);\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module names.\n\n// State encoding\nparameter [1:0] not_taken = 2'b00;\nparameter [1:0] weakly_not_taken = 2'b01;\nparameter [1:0] taken = 2'b10;\n\n// State register\nreg [1:0] state_reg;\n\n// State update logic\nalways @(posedge clk, posedge areset) begin\n    if (areset) begin\n        state_reg <= weakly_not_taken;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state_reg == 2'b11) begin\n                state_reg <= 2'b11;\n            end else begin\n                state_reg <= state_reg + 1;\n            end\n        end else begin\n            if (state_reg == 2'b00) begin\n                state_reg <= 2'b00;\n            end else begin\n                state_reg <= state_reg - 1;\n            end\n        end\n    end\nend\n\n// Output logic\nassign state = state_reg;\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        pos = 0;\n        for (int i = 0; i < 8; i = i + 1) begin\n            if (in[i] == 1) begin\n                pos = i;\n                break;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        case (scancode)\n            16'he06b: begin\n                left = 1;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n            16'he072: begin\n                left = 0;\n                down = 1;\n                right = 0;\n                up = 0;\n            end\n            16'he074: begin\n                left = 0;\n                down = 0;\n                right = 1;\n                up = 0;\n            end\n            16'he075: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 1;\n            end\n            default: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "// Full Adder\n// a - input a\n// b - input b\n// cin - carry in\n// sum - output sum\n// cout - carry out\n//\n// The carry out (cout) is the sum of the carry in (cin) and the bitwise xor (^) of a and b\n//\n// The sum (sum) is the bitwise xor (^) of a and b, and the carry out (cout)\n//\n// The carry out (cout) is the carry out (cout) of the previous full adder\n//\n// The carry in (cin) is the carry out (cout) of the previous full adder\n//\n// The full adder is implemented by the following equation\n//\n//   cout = cin | (a & b)\n//   sum = a ^ b ^ cin\n//\n// Full Adder\n//\n// The four-bit adder is implemented by four full adders. The carry out of the first full adder is the carry in of the second full adder\n// The carry out of the second full adder is the carry in of the third full adder\n// The carry out of the third full adder is the carry in of the fourth full adder\n// The carry out of the fourth full adder is the carry out (overflow) of the four-bit adder\n//\n// The four-bit adder is implemented by the following equation\n//\n//   sum = {cout, sum[3:0]}\n//\n// where cout is the carry out of the fourth full adder\n//\n// The overflow is the carry out (cout) of the fourth full adder\n//\n// The sum is the output sum of the four-bit adder\n//\n// 4-bit Adder\n//\n// The four-bit adder is implemented by four full adders\n//\n// The four-bit adder is implemented by the following equation\n//\n//   sum = {cout, sum[3:0]}\n//\n// where cout is the carry out of the fourth full adder\n//\n// The overflow is the carry out (cout) of the fourth full adder\n//\n// The sum is the output sum of the four-bit adder\n//\n// Full Adder\n//\n// The four full adders are implemented by the following equations\n//\n//   FA0: cout0 = 0 | (x[0] & y[0]) , sum0 = x[0] ^ y[0] ^ 0\n//   FA1: cout1 = cout0 | (x[1] & y[1]) , sum1 = x[1] ^ y[1] ^ cout0\n//   FA2: cout2 = cout1 | (x[2] & y[2]) , sum2 = x[2] ^ y[2] ^ cout1\n//   FA3: cout3 = cout2 | (x[3] & y[3]) , sum3 = x[3] ^ y[3] ^ cout2\n//\n// Full Adder\n//\n// The four full adders are implemented by the following equations\n//\n//   FA0: cout0 = 0 , sum0 = x[0] ^ y[0]\n//   FA1: cout1 = cout0 , sum1 = x[1] ^ y[1] ^ cout0\n//   FA2: cout2 = cout1 , sum2 = x[2] ^ y[2] ^ cout1\n//   FA3: cout3 = cout2 , sum3 = x[3] ^ y[3] ^ cout2\n//\n// Four-bit Adder\n//\n// The four full adders are implemented by the following equations\n//\n//   sum = {cout3, sum3, sum2, sum1, sum0}\n//\n// Overflow\n//\n// The overflow is the carry out (cout) of the fourth full adder\n//\n// Sum\n//\n// The sum is the output sum of the four-bit adder\n//\n//   sum = {cout3, sum3, sum2, sum1, sum0}\n//\n// 4-bit Adder\n//\n// The four-bit adder is implemented by the following equations\n//\n//   sum = {cout3, sum3, sum2, sum1, sum0}\n//\n// Overflow\n//\n// The overflow is the carry out (cout) of the fourth full adder\n//\n//   overflow = cout3\n//\n// Sum\n//\n// The sum is the output sum of the four-bit adder\n//\n//   sum = {"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    logic [31:0] history_reg;\n    logic [31:0] misprediction_history;\n    logic [31:0] branch_history;\n    logic [31:0] train_history;\n    logic [31:0] predict_history_reg;\n    logic [31:0] predict_history_next;\n    logic [31:0] misprediction_history_reg;\n    \n    // Reset the history counter to zero\n    always @(posedge areset) begin\n        history_reg <= 0;\n        misprediction_history_reg <= 0;\n        predict_history_reg <= 0;\n    end\n    \n    // Update the branch history register based on the predict_valid and train_mispredicted signals\n    always @(posedge clk) begin\n        if (predict_valid) begin\n            // Shift in the predict_taken value to update the branch history for the predicted branch\n            branch_history <= {branch_history[30:0], predict_taken};\n        end\n        else if (train_mispredicted) begin\n            // Load the branch history register with the history after the completion of the mispredicted branch\n            misprediction_history_reg <= {train_history, train_taken};\n        end\n    end\n    \n    // Compute the next value of the predict_history_reg based on the predict_valid and train_mispredicted signals\n    always @(posedge clk) begin\n        if (predict_valid) begin\n            // Update the predict_history_reg with the shifted branch history\n            predict_history_next <= {branch_history[30:0], predict_taken};\n        end\n        else if (train_mispredicted) begin\n            // Update the predict_history_reg with the misprediction history\n            predict_history_next <= misprediction_history_reg;\n        end\n    end\n    \n    // Write the predict_history_reg to the output port\n    always @(posedge clk) begin\n        predict_history_reg <= predict_history_next;\n        predict_history <= predict_history_reg;\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// Notice that the inverted output 'out_n' is really the output of the NOT gate.\n\n// In Verilog, we use the '=' operator to connect the output of a gate to an intermediate wire. We can use this intermediate wire as many times as we want.\n\n// Also, we use the '!' operator to invert the output of a gate.\n\n// Finally, we can use the '&' and '|' operators to implement AND and OR gates, respectively.\n\n// Do not use the 'and' and 'or' keywords in Verilog. They are not valid operators.\n\n// Do not use the 'not' keyword in Verilog.\n\n\twire and1_out;\n\twire and2_out;\n\twire or_out;\n\n\tand gate1 (and1_out, a, b);\n\tand gate2 (and2_out, c, d);\n\tor gate3 (or_out, and1_out, and2_out);\n\tnot gate4 (out_n, or_out);\n\tassign out = ~out_n;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "endmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "Do not use any other Verilog modules or functions in your code.\n\nModule top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\n\tassign heater = (mode == 1) && (too_cold == 1) ? 1 : 0;\n\tassign aircon = (mode == 0) && (too_hot == 1) ? 1 : 0;\n\tassign fan = (heater == 1 || aircon == 1) || fan_on ? 1 : 0;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    wire a_bar = ~a;\n    wire b_bar = ~b;\n    wire c_bar = ~c;\n    wire d_bar = ~d;\n\n    wire a_and_b = a & b;\n    wire a_and_b_bar = a & b_bar;\n    wire a_bar_and_b = a_bar & b;\n    wire a_bar_and_b_bar = a_bar & b_bar;\n    wire a_and_c = a & c;\n    wire a_and_c_bar = a & c_bar;\n    wire a_bar_and_c = a_bar & c;\n    wire a_bar_and_c_bar = a_bar & c_bar;\n    wire a_and_d = a & d;\n    wire a_and_d_bar = a & d_bar;\n    wire a_bar_and_d = a_bar & d;\n    wire a_bar_and_d_bar = a_bar & d_bar;\n\n    wire b_and_c = b & c;\n    wire b_and_c_bar = b & c_bar;\n    wire b_bar_and_c = b_bar & c;\n    wire b_bar_and_c_bar = b_bar & c_bar;\n    wire b_and_d = b & d;\n    wire b_and_d_bar = b & d_bar;\n    wire b_bar_and_d = b_bar & d;\n    wire b_bar_and_d_bar = b_bar & d_bar;\n\n    wire c_and_d = c & d;\n    wire c_and_d_bar = c & d_bar;\n    wire c_bar_and_d = c_bar & d;\n    wire c_bar_and_d_bar = c_bar & d_bar;\n\n    wire out_sop_wire = (a_and_b_bar & b_and_c & c_and_d) | (a_and_b_bar & b_and_c_bar & c_bar_and_d_bar) | (a_and_b_bar & b_bar_and_c & c_and_d_bar) | (a_and_b_bar & b_bar_and_c_bar & c_bar_and_d);\n    wire out_pos_wire = (a_and_b & b_and_c & c_and_d_bar) & (a_and_b & b_and_c_bar & c_bar_and_d) & (a_and_b_bar & b_and_c & c_and_d) & (a_and_b_bar & b_and_c_bar & c_bar_and_d_bar) & (a_and_b_bar & b_bar_and_c & c_and_d_bar) & (a_and_b_bar & b_bar_and_c_bar & c_bar_and_d);\n\n    assign out_sop = out_sop_wire;\n    assign out_pos = out_pos_wire;\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "Do not include a testbench or other unnecessary code. 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1:\n\n```verilog\n\treg [31:0] lfsr;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 32'h1;\n\t\t\tq <= 32'h1;\n\t\tend\n\t\telse begin\n\t\t\tlfsr[31] <= lfsr[31] ^ lfsr[30];\n\t\t\tlfsr[30] <= lfsr[29] ^ lfsr[28];\n\t\t\tlfsr[29] <= lfsr[28] ^ lfsr[27];\n\t\t\tlfsr[28] <= lfsr[27] ^ lfsr[26];\n\t\t\tlfsr[27] <= lfsr[26] ^ lfsr[25];\n\t\t\tlfsr[26] <= lfsr[25] ^ lfsr[24];\n\t\t\tlfsr[25] <= lfsr[24] ^ lfsr[23];\n\t\t\tlfsr[24] <= lfsr[23] ^ lfsr[22];\n\t\t\tlfsr[23] <= lfsr[22] ^ lfsr[21];\n\t\t\tlfsr[22] <= lfsr[21] ^ lfsr[20];\n\t\t\tlfsr[21] <= lfsr[20] ^ lfsr[19];\n\t\t\tlfsr[20] <= lfsr[19] ^ lfsr[18];\n\t\t\tlfsr[19] <= lfsr[18] ^ lfsr[17];\n\t\t\tlfsr[18] <= lfsr[17] ^ lfsr[16];\n\t\t\tlfsr[17] <= lfsr[16] ^ lfsr[15];\n\t\t\tlfsr[16] <= lfsr[15] ^ lfsr[14];\n\t\t\tlfsr[15] <= lfsr[14] ^ lfsr[13];\n\t\t\tlfsr[14] <= lfsr[13] ^ lfsr[12];\n\t\t\tlfsr[13] <= lfsr[12] ^ lfsr[11];\n\t\t\tlfsr[12] <= lfsr[11] ^ lfsr[10];\n\t\t\tlfsr[11] <= lfsr[10] ^ lfsr[9];\n\t\t\tlfsr[10] <= lfsr[9] ^ lfsr[8];\n\t\t\tlfsr[9] <= lfsr[8] ^ lfsr[7];\n\t\t\tlfsr[8] <= lfsr[7] ^ lfsr[6];\n\t\t\tlfsr[7] <= lfsr[6] ^ lfsr[5];\n\t\t\tlfsr[6] <= lfsr[5] ^ lfsr[4];\n\t\t\tlfsr[5] <= lfsr[4] ^ lfsr[3];\n\t\t\tlfsr[4] <= lfsr[3] ^ lfsr[2];\n\t\t\tlfsr[3] <= lfsr[2] ^ lfsr[1];\n\t\t\tlfsr[2] <= lfsr[1] ^ lfsr[0];\n\t\t\tlfsr[1] <= lfsr[0] ^ 1'b1;\n\t\t\tlfsr[0] <= 1'b0;\n\t\t\tq <= lfsr;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & b & c & d | a & b & c | a & b & d | a & c & d | b & c & d;\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// First NAND gate\n\t\twire nand1_out;\n\t\tassign nand1_out = ~(p1a & p1b & p1c & p1d);\n\t\t\n\t\t// Second NAND gate\n\t\twire nand2_out;\n\t\tassign nand2_out = ~(p2a & p2b & p2c & p2d);\n\t\t\n\t\t// Output assignments\n\t\tassign p1y = nand1_out;\n\t\tassign p2y = nand2_out;\n\t\t\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        out = 8'b0;\n        for (int i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "```verilog\n\tassign out_both[0] = in[0] & in[1];\n\tassign out_both[1] = in[1] & in[2];\n\tassign out_both[2] = in[2] & in[3];\n\tassign out_both[3] = 1'b0;\n\n\tassign out_any[0] = in[1] | in[0];\n\tassign out_any[1] = in[2] | in[1];\n\tassign out_any[2] = in[3] | in[2];\n\tassign out_any[3] = 1'b0;\n\n\tassign out_different[0] = (in[0] != in[3]) ? 1'b1 : 1'b0;\n\tassign out_different[1] = (in[1] != in[0]) ? 1'b1 : 1'b0;\n\tassign out_different[2] = (in[2] != in[1]) ? 1'b1 : 1'b0;\n\tassign out_different[3] = (in[3] != in[2]) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'b1232;\n            3'b001: q = 16'bAEE0;\n            3'b010: q = 16'b27D4;\n            3'b011: q = 16'b5A0E;\n            3'b100: q = 16'b2066;\n            3'b101: q = 16'b64CE;\n            3'b110: q = 16'bC526;\n            3'b111: q = 16'b2F19;\n            default: q = 16'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// State encoding: 4 bits to encode 10 states.\n// 0000 for state 0, 0001 for state 1, ... 1001 for state 9.\nreg [3:0] state = 4'b0000;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 4'b0000;\n\tend else if (slowena) begin\n\t\tstate <= state + 1;\n\tend\nend\n\nalways @(state) begin\n\tcase (state)\n\t\t4'b0000: q <= 4'b0000;\n\t\t4'b0001: q <= 4'b0001;\n\t\t4'b0010: q <= 4'b0010;\n\t\t4'b0011: q <= 4'b0011;\n\t\t4'b0100: q <= 4'b0100;\n\t\t4'b0101: q <= 4'b0101;\n\t\t4'b0110: q <= 4'b0110;\n\t\t4'b0111: q <= 4'b0111;\n\t\t4'b1000: q <= 4'b1000;\n\t\t4'b1001: q <= 4'b0000;\n\t\tdefault: q <= 4'bxxxx;\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    and gate (out, in1, in2);\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "endmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// State register\nreg [1:0] state, next_state;\n\n// Output register\nreg out_reg;\n\n// Moore machine implementation\nalways @ (posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= B;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// Next state logic\nalways @ (*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (in) begin\n\t\t\t\tnext_state = A;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (in) begin\n\t\t\t\tnext_state = B;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Output logic\nalways @ (*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tout_reg = 1'b0;\n\t\tend\n\t\tB: begin\n\t\t\tout_reg = in;\n\t\tend\n\tendcase\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    reg q_prev;\n\n    always @(posedge clk) begin\n        q_prev <= q;\n        q <= d;\n    end\n\n    always @(negedge clk) begin\n        q <= q_prev;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    wire xnor_out;\n    xnor_gate xnor_inst(\n        .a(a),\n        .b(b),\n        .out(xnor_out)\n    );\n\n    assign out = xnor_out;\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module that implements the boolean function z = (x & y) | (~x & y) | (x & ~y) | (~x & ~y).\nmodule B(\n    input x,\n    input y,\n    output z);\n    \n    assign z = (x & y) | (~x & y) | (x & ~y) | (~x & ~y);\n    \nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tcase (ena)\n\t\t\t\t2'b01: q <= {q[0], q[99:1]};\n\t\t\t\t2'b10: q <= {q[98:0], q[99]};\n\t\t\t\tdefault: q <= q;\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;\n        end else if (q == 999) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "Module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n\t// State transition logic\n\talways @ (state or in) begin\n\t\tcase (state)\n\t\t\t10'b0000000001: next_state = 10'b0000000010;\n\t\t\t10'b0000000010: next_state = 10'b0000000001;\n\t\t\t10'b0000000011: next_state = 10'b0000000100;\n\t\t\t10'b0000000100: next_state = 10'b0000000001;\n\t\t\t10'b0000000101: next_state = 10'b0000001000;\n\t\t\t10'b0000001000: next_state = 10'b0000000001;\n\t\t\t10'b0000001001: next_state = 10'b0000010000;\n\t\t\t10'b0000010000: next_state = 10'b0000000001;\n\t\t\t10'b0000010001: next_state = 10'b0000100000;\n\t\t\t10'b0000100000: next_state = 10'b0000000001;\n\t\t\t10'b0000100001: next_state = 10'b0000110000;\n\t\t\t10'b0000110000: next_state = 10'b0000000001;\n\t\t\t10'b0000110001: next_state = 10'b0001000000;\n\t\t\t10'b0001000000: next_state = 10'b0000000001;\n\t\t\t10'b0001000001: next_state = 10'b0001010000;\n\t\t\t10'b0001010000: next_state = 10'b0000000001;\n\t\t\t10'b0001010001: next_state = 10'b0001010100;\n\t\t\t10'b0001010100: next_state = 10'b0000000001;\n\t\t\t10'b0001010101: next_state = 10'b0001011100;\n\t\t\t10'b0001011100: next_state = 10'b0000000001;\n\t\t\t10'b0001011101: next_state = 10'b0001100000;\n\t\t\t10'b0001100000: next_state = 10'b0000000001;\n\t\t\t10'b0001100001: next_state = 10'b0001110000;\n\t\t\t10'b0001110000: next_state = 10'b0000000001;\n\t\t\t10'b0001110001"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    Q <= ~j & Q | j & ~Q | k & Q | ~k & ~Q;\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "The following Verilog code is a population count circuit for a 3-bit input vector.\n```verilog\n\twire [1:0] count;\n\n\tassign count[0] = in[0] ^ in[1];\n\tassign count[1] = count[0] ^ in[2];\n\n\tassign out = count;\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "Then, continue with the following code:\n```verilog\n\tassign out[24] = ~a ^ a;\n\tassign out[23] = ~a ^ b;\n\tassign out[22] = ~a ^ c;\n\tassign out[21] = ~b ^ a;\n\tassign out[20] = ~b ^ b;\n\tassign out[19] = ~b ^ c;\n\tassign out[18] = ~c ^ a;\n\tassign out[17] = ~c ^ b;\n\tassign out[16] = ~c ^ c;\n\tassign out[15] = ~d ^ a;\n\tassign out[14] = ~d ^ b;\n\tassign out[13] = ~d ^ c;\n\tassign out[12] = ~e ^ a;\n\tassign out[11] = ~e ^ b;\n\tassign out[10] = ~e ^ c;\n\tassign out[ 9] = ~e ^ d;\n\tassign out[ 8] = ~e ^ e;\n\tassign out[ 7] = ~a ^ d;\n\tassign out[ 6] = ~a ^ e;\n\tassign out[ 5] = ~b ^ d;\n\tassign out[ 4] = ~b ^ e;\n\tassign out[ 3] = ~c ^ d;\n\tassign out[ 2] = ~c ^ e;\n\tassign out[ 1] = ~d ^ e;\n\tassign out[ 0] = ~e ^ e;\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "Then, add the following code:\n```verilog\n\treg [1:0] state;\n\treg walk_left_int;\n\treg walk_right_int;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= 2'b00;\n\t\t\twalk_left_int <= 1'b1;\n\t\t\twalk_right_int <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: begin\n\t\t\t\t\twalk_left_int <= 1'b1;\n\t\t\t\t\twalk_right_int <= 1'b0;\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\twalk_left_int <= 1'b0;\n\t\t\t\t\twalk_right_int <= 1'b1;\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign walk_left = walk_left_int;\n\tassign walk_right = walk_right_int;\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module (\n//    input a, \n//    input b, \n//    output q\n//);\n//\n//    wire a_xor_b = a ^ b;\n//    wire a_and_b = a & b;\n//    wire q_temp = (a_xor_b & ~a_and_b) | (a_and_b & ~a_xor_b);\n//\n//    assign q = (a & b) ? 0 : q_temp;\n//\n//endmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// The four AND gates:\nwire and1 = p1a & p1b;\nwire and2 = p1c & p1d;\nwire and3 = p1e & p1f;\nwire and4 = p2a & p2b;\n\n// The two OR gates:\nwire or1 = and1 | and2;\nwire or2 = and3 | and4;\n\n// Drive the output wires:\nassign p1y = or1;\nassign p2y = or2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\n    always @(posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= {2'b00, y[2]};\n                z <= 0;\n            end\n            3'b001: begin\n                Y0 <= {2'b01, y[1]};\n                z <= 0;\n            end\n            3'b010: begin\n                Y0 <= {2'b00, y[2]};\n                z <= 0;\n            end\n            3'b011: begin\n                Y0 <= {2'b01, y[1]};\n                z <= 1;\n            end\n            3'b100: begin\n                Y0 <= {2'b01, y[1]};\n                z <= 1;\n            end\n            default: begin\n                Y0 <= 3'b0;\n                z <= 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "Make sure to use the logic keyword for the output.\n```verilog\n\tassign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n    reg q_reg;\n\n    always @(posedge clk or negedge ar) begin\n        if (~ar) begin\n            q_reg <= 1'b0;\n        end else begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "assign tc = (cnt == 0);\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "The FSM should be designed to check for the sequence 1101 in the input bit stream. When the sequence is found, it should set start_shifting to 1. Otherwise, it should set start_shifting to 0.\n\n\tmodule top_module(\n\t\tinput clk,\n\t\tinput reset,\n\t\tinput data,\n\t\toutput start_shifting\n\t);\n\n\t\t// Define the states\n\t\tparameter IDLE = 2'b00;\n\t\tparameter FOUND_1 = 2'b01;\n\t\tparameter FOUND_11 = 2'b10;\n\t\tparameter FOUND_110 = 2'b11;\n\t\tparameter FOUND_1101 = 2'b00;\n\n\t\t// Define the state register and initialize it to IDLE\n\t\treg [1:0] state = IDLE;\n\t\treg [3:0] shift_reg = 4'b0000;\n\n\t\t// Define the start_shifting output\n\t\tassign start_shifting = (state == FOUND_1101);\n\n\t\t// Define the next state logic\n\t\talways @(posedge clk) begin\n\t\t\tif (reset) begin\n\t\t\t\tstate <= IDLE;\n\t\t\t\tshift_reg <= 4'b0000;\n\t\t\tend else begin\n\t\t\t\tcase (state)\n\t\t\t\t\tIDLE: begin\n\t\t\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\t\tstate <= FOUND_1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tFOUND_1: begin\n\t\t\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend else if (data == 1'b1) begin\n\t\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\t\tstate <= FOUND_11;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tFOUND_11: begin\n\t\t\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\t\tstate <= FOUND_110;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tFOUND_110: begin\n\t\t\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend else if (data == 1'b1) begin\n\t\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\t\tstate <= FOUND_1101;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tFOUND_1101: begin\n\t\t\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\t\t\tshift_reg <= 4'b0000;\n\t\t\t\t\t\t\tstate <= IDLE;"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "// Verilog code for D flip-flops with synchronous reset\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b0;\n\t\tend\n\t\telse begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "endmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "always @(posedge clk, posedge reset) begin\n    if(reset) begin\n        q <= 4'b0001;\n    end else begin\n        if(q == 4'b1010) begin\n            q <= 4'b0001;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        case ({clk,a})\n            5'b00000: q <= 3'b000;\n            5'b00001: q <= 3'b001;\n            5'b00010: q <= 3'b010;\n            5'b00011: q <= 3'b011;\n            5'b00100: q <= 3'b100;\n            5'b00101: q <= 3'b101;\n            5'b00110: q <= 3'b110;\n            5'b00111: q <= 3'b111;\n            5'b01000: q <= 3'b000;\n            5'b01001: q <= 3'b001;\n            5'b01010: q <= 3'b010;\n            5'b01011: q <= 3'b011;\n            5'b01100: q <= 3'b100;\n            5'b01101: q <= 3'b101;\n            5'b01110: q <= 3'b110;\n            5'b01111: q <= 3'b111;\n            5'b10000: q <= 3'b000;\n            5'b10001: q <= 3'b001;\n            5'b10010: q <= 3'b010;\n            5'b10011: q <= 3'b011;\n            5'b10100: q <= 3'b100;\n            5'b10101: q <= 3'b101;\n            5'b10110: q <= 3'b110;\n            5'b10111: q <= 3'b111;\n            5'b11000: q <= 3'b000;\n            5'b11001: q <= 3'b001;\n            5'b11010: q <= 3'b010;\n            5'b11011: q <= 3'b011;\n            5'b11100: q <= 3'b100;\n            5'b11101: q <= 3'b101;\n            5'b11110: q <= 3'b110;\n            5'b11111: q <= 3'b111;\n        endcase\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b1;\n    end else begin\n        q <= {q[4] ^ q[2], q[4:1]};\n    end\nend"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );\n\n//     always @(*) begin\n//         if (do_sub) begin\n//             out = a - b;\n//             if (out == 0)\n//                 result_is_zero = 1;\n//         end else begin\n//             out = a + b;\n//             if (out == 0)\n//                 result_is_zero = 1;\n//         end\n//     end\n\n// endmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "Consider the following Verilog code that implements the function f shown in the Karnaugh map:\n```verilog\nalways_comb begin\n\tcase(x)\n\t\t5'b00000: f = 1'b0;\n\t\t5'b00001: f = 1'b1;\n\t\t5'b00010: f = 1'b1;\n\t\t5'b00011: f = 1'b1;\n\t\t5'b00100: f = 1'b1;\n\t\t5'b00101: f = 1'b0;\n\t\t5'b00110: f = 1'b1;\n\t\t5'b00111: f = 1'b1;\n\t\t5'b01000: f = 1'b1;\n\t\t5'b01001: f = 1'b0;\n\t\t5'b01010: f = 1'b1;\n\t\t5'b01011: f = 1'b1;\n\t\t5'b01100: f = 1'b1;\n\t\t5'b01101: f = 1'b0;\n\t\t5'b01110: f = 1'b1;\n\t\t5'b01111: f = 1'b1;\n\t\t5'b10000: f = 1'b0;\n\t\t5'b10001: f = 1'b1;\n\t\t5'b10010: f = 1'b1;\n\t\t5'b10011: f = 1'b1;\n\t\t5'b10100: f = 1'b1;\n\t\t5'b10101: f = 1'b0;\n\t\t5'b10110: f = 1'b1;\n\t\t5'b10111: f = 1'b1;\n\t\t5'b11000: f = 1'b1;\n\t\t5'b11001: f = 1'b0;\n\t\t5'b11010: f = 1'b1;\n\t\t5'b11011: f = 1'b1;\n\t\t5'b11100: f = 1'b1;\n\t\t5'b11101: f = 1'b0;\n\t\t5'b11110: f = 1'b1;\n\t\t5'b11111: f = 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "and end with:\n```verilog\n\talways @*\n\tbegin\n\t\tcase (code)\n\t\t\t8'h45: begin out = 4'd0; valid = 1'b1; end\n\t\t\t8'h16: begin out = 4'd1; valid = 1'b1; end\n\t\t\t8'h1e: begin out = 4'd2; valid = 1'b1; end\n\t\t\t8'h26: begin out = 4'd3; valid = 1'b1; end\n\t\t\t8'h25: begin out = 4'd4; valid = 1'b1; end\n\t\t\t8'h2e: begin out = 4'd5; valid = 1'b1; end\n\t\t\t8'h36: begin out = 4'd6; valid = 1'b1; end\n\t\t\t8'h3d: begin out = 4'd7; valid = 1'b1; end\n\t\t\t8'h3e: begin out = 4'd8; valid = 1'b1; end\n\t\t\t8'h46: begin out = 4'd9; valid = 1'b1; end\n\t\t\tdefault: begin out = 4'd0; valid = 1'b0; end\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*)\n    begin\n        case ({a,b,c,d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b1;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b0;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b0;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n            default: out = 1'bx;\n        endcase\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if(count_ena) begin\n            q <= q - 1;\n        end\n        if(shift_ena) begin\n            q <= {q[2:0], data};\n        end\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "// State encoding\nparameter IDLE = 2'b00;\nparameter PRE = 2'b01;\nparameter ASSERT = 2'b10;\nparameter RELEASE = 2'b11;\n\n// State register\nreg [1:0] state_reg, state_next;\n\n// State logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate_reg <= IDLE;\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tIDLE: begin\n\t\t\tif (shift_ena) begin\n\t\t\t\tstate_next = PRE;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = IDLE;\n\t\t\tend\n\t\tend\n\t\tPRE: begin\n\t\t\tif (shift_ena) begin\n\t\t\t\tstate_next = ASSERT;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = IDLE;\n\t\t\tend\n\t\tend\n\t\tASSERT: begin\n\t\t\tstate_next = RELEASE;\n\t\tend\n\t\tRELEASE: begin\n\t\t\tif (~shift_ena) begin\n\t\t\t\tstate_next = IDLE;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = RELEASE;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Output logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tshift_ena <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state_reg)\n\t\t\tIDLE: begin\n\t\t\t\tif (shift_ena) begin\n\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tPRE: begin\n\t\t\t\tshift_ena <= 1'b1;\n\t\t\tend\n\t\t\tASSERT: begin\n\t\t\t\tshift_ena <= 1'b1;\n\t\t\tend\n\t\t\tRELEASE: begin\n\t\t\t\tshift_ena <= 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// Reset the counter to 0 when reset is high\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 4'b0000;\n\tend else begin\n\t\t// Increment the counter\n\t\tq <= q + 1;\n\tend\nend\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2) begin\n            out_always = b;\n        end\n        else begin\n            out_always = a;\n        end\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (a & b & c) | (~a & b & c) | (a & ~b & c) | (~a & ~b & c);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output [3:1] g\n);\n\n    // State codes\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // State register\n    reg [1:0] state;\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (r[1]) begin\n                        state <= B;\n                    end else if (r[2]) begin\n                        state <= C;\n                    end else if (r[3]) begin\n                        state <= D;\n                    end\n                end\n                B: begin\n                    if (r[1]) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                C: begin\n                    if (r[2]) begin\n                        state <= C;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                D: begin\n                    if (r[3]) begin\n                        state <= D;\n                    end else begin\n                        state <= A;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) begin\n                    g[1] = 1;\n                    g[2] = 0;\n                    g[3] = 0;\n                end else if (r[2]) begin\n                    g[1] = 0;\n                    g[2] = 1;\n                    g[3] = 0;\n                end else if (r[3]) begin\n                    g[1] = 0;\n                    g[2] = 0;\n                    g[3] = 1;\n                end else begin\n                    g[1] = 0;\n                    g[2] = 0;\n                    g[3] = 0;\n                end\n            end\n            B: begin\n                g[1] = 1;\n                g[2] = 0;\n                g[3] = 0;\n            end\n            C: begin\n                g[1] = 0;\n                g[2] = 1;\n                g[3] = 0;\n            end\n            D: begin\n                g[1] = 0;\n                g[2] = 0;\n                g[3] = 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n            if (q == 4'b1001) begin\n                q <= 4'b0000;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "// Define states\n\tparameter IDLE = 2'b00;\n\tparameter FIRST_BYTE = 2'b01;\n\tparameter SECOND_BYTE = 2'b10;\n\tparameter THIRD_BYTE = 2'b11;\n\t\n\t// Define variables\n\treg [1:0] state;\n\treg [7:0] byte_count;\n\treg done_reg;\n\t\n\t// Define the FSM\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbyte_count <= 0;\n\t\t\tdone_reg <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\t\tstate <= FIRST_BYTE;\n\t\t\t\t\t\tbyte_count <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tFIRST_BYTE: begin\n\t\t\t\t\tif (in[3] == 0) begin\n\t\t\t\t\t\tstate <= SECOND_BYTE;\n\t\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= FIRST_BYTE;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSECOND_BYTE: begin\n\t\t\t\t\tif (in[3] == 0) begin\n\t\t\t\t\t\tstate <= THIRD_BYTE;\n\t\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= SECOND_BYTE;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tTHIRD_BYTE: begin\n\t\t\t\t\tif (in[3] == 0) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tdone_reg <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= THIRD_BYTE;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Assign done\n\tassign done = done_reg;\n\t\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "// state-assign table\nreg [2:0] y;\nparameter [2:0] s0 = 3'b000;\nparameter [2:0] s1 = 3'b001;\nparameter [2:0] s2 = 3'b010;\nparameter [2:0] s3 = 3'b011;\nparameter [2:0] s4 = 3'b100;\n\n// state register\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\ty <= s0;\n\tend else begin\n\t\tcase (y)\n\t\t\ts0: begin\n\t\t\t\tif (x) y <= s1;\n\t\t\t\telse y <= s0;\n\t\t\tend\n\t\t\ts1: begin\n\t\t\t\tif (x) y <= s2;\n\t\t\t\telse y <= s0;\n\t\t\tend\n\t\t\ts2: begin\n\t\t\t\tif (x) y <= s3;\n\t\t\t\telse y <= s0;\n\t\t\tend\n\t\t\ts3: begin\n\t\t\t\tif (x) y <= s4;\n\t\t\t\telse y <= s0;\n\t\t\tend\n\t\t\ts4: begin\n\t\t\t\tif (x) y <= s3;\n\t\t\t\telse y <= s0;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// output register\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tz <= 0;\n\tend else begin\n\t\tcase (y)\n\t\t\ts0: z <= 0;\n\t\t\ts1: z <= 0;\n\t\t\ts2: z <= 0;\n\t\t\ts3: z <= 1;\n\t\t\ts4: z <= 1;\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "endmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "Do not use comments to explain the Verilog code.\n\nModules and functions should be avoided.\n\nDo not use intermediate variables.\n\nFollow the Verilog coding standards.\n\n83..94 columns should be a single line.\n\nUse short and descriptive names.\n\nDo not use long lines.\n\nDo not use tabs.\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'h34;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 0) ? 2'b00 : 2'b01;\n            2'b01: next_state = (in == 0) ? 2'b01 : 2'b10;\n            2'b10: next_state = (in == 0) ? 2'b00 : 2'b11;\n            2'b11: next_state = (in == 0) ? 2'b11 : 2'b01;\n        endcase\n        \n        case (state)\n            2'b00: out = 1'b0;\n            2'b01: out = 1'b0;\n            2'b10: out = 1'b0;\n            2'b11: out = (in == 0) ? 1'b0 : 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x & y) | (x & ~y) | (~x & y);\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// Define the state codes. You can use any unique code.\n// For example, I am using 4-bit binary codes for the states.\nparameter A = 4'b0000;\nparameter B = 4'b0001;\nparameter C = 4'b0010;\nparameter D = 4'b0011;\nparameter E = 4'b0100;\nparameter F = 4'b0101;\n\n// Define the state register and output register\nreg [3:0] state_reg;\nreg [3:0] next_state_reg;\nreg z_reg;\n\n// Define the state table\nalways @(*) begin\n\tcase (state_reg)\n\t\tA: next_state_reg = w ? B : A;\n\t\tB: next_state_reg = w ? C : D;\n\t\tC: next_state_reg = w ? E : D;\n\t\tD: next_state_reg = w ? F : A;\n\t\tE: next_state_reg = w ? E : D;\n\t\tF: next_state_reg = w ? C : D;\n\tendcase\nend\n\n// Define the state flip-flop\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate_reg <= A;\n\t\tz_reg <= 1'b0;\n\tend\n\telse begin\n\t\tstate_reg <= next_state_reg;\n\t\tcase (state_reg)\n\t\t\tA: z_reg <= 1'b0;\n\t\t\tB: z_reg <= 1'b1;\n\t\t\tC: z_reg <= 1'b0;\n\t\t\tD: z_reg <= 1'b1;\n\t\t\tE: z_reg <= 1'b0;\n\t\t\tF: z_reg <= 1'b1;\n\t\tendcase\n\tend\nend\n\n// Assign the output\nassign z = z_reg;\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "endmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "in = 0\n                           |\n                           v\n                    0: clk    1: posedge\n     -------------------- ---- -------------------\n     |                  |   |                    |\n0: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n1: 0 0 0 0 0 0 0 0   0 0 0 | 1 1 1 1 1 1 1 1     |\n     |                  |   |                    |\n     |                  |   |                    |\n2: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n3: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n4: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n5: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n                          in = 1\n                          |\n                          v\n                    0: clk    1: posedge\n     -------------------- ---- -------------------\n     |                  |   |                    |\n0: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n1: 0 0 0 0 0 0 0 0   0 0 0 | 1 1 1 1 1 1 1 1     |\n     |                  |   |                    |\n     |                  |   |                    |\n2: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n3: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n4: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |\n     |                  |   |                    |\n     |                  |   |                    |\n5: 0 0 0 0 0 0 0 0   0 0 0 | 0 0 0 0 0 0 0 0     |"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg a_reg;\n    reg a_reg_next;\n    reg p_reg;\n    reg q_reg;\n    reg q_reg_next;\n\n    always @(posedge clock) begin\n        a_reg <= a;\n        p_reg <= a_reg;\n        q_reg <= q_reg_next;\n    end\n\n    always @* begin\n        a_reg_next = a_reg;\n        q_reg_next = q_reg;\n\n        case (a_reg)\n            0: begin\n                q_reg_next = 0;\n            end\n            1: begin\n                q_reg_next = 0;\n            end\n            2: begin\n                q_reg_next = 0;\n            end\n            3: begin\n                q_reg_next = 0;\n            end\n            4: begin\n                q_reg_next = 0;\n            end\n            5: begin\n                q_reg_next = 1;\n            end\n            6: begin\n                q_reg_next = 1;\n            end\n            7: begin\n                q_reg_next = 1;\n            end\n            8: begin\n                q_reg_next = 1;\n            end\n            9: begin\n                q_reg_next = 1;\n            end\n            10: begin\n                q_reg_next = 1;\n            end\n            11: begin\n                q_reg_next = 0;\n            end\n            12: begin\n                q_reg_next = 0;\n            end\n            13: begin\n                q_reg_next = 0;\n            end\n            14: begin\n                q_reg_next = 0;\n            end\n            15: begin\n                q_reg_next = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Clock domain\nreg [511:0] q_next;\nalways @(posedge clk) begin\n\tq <= q_next;\nend\n\n// State transition logic\nalways @(*) begin\n\tq_next[0] = 0;\n\tq_next[511] = 0;\n\tfor (i = 1; i < 511; i = i + 1) begin\n\t\tq_next[i] = q[i-1] ^ q[i] ^ q[i+1];\n\tend\nend\n\n// Load data\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\nend\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "assign z = (A == B) ? 1 : 0;\n\t\t// equivalent to:\n\t\t// always @(*)\n\t\t// begin\n\t\t// \tif (A == B)\n\t\t// \t\tz = 1;\n\t\t// \telse\n\t\t// \t\tz = 0;\n\t\t// end\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "// (1) out_both\nassign out_both[0] = 0;\nassign out_both[1:98] = in[0:98] & in[1:99];\n\n// (2) out_any\nassign out_any[0] = 0;\nassign out_any[1:99] = in[0:98] | in[1:99];\n\n// (3) out_different\nassign out_different[0] = 0;\nassign out_different[1:99] = in[0:99] ^ in[1:99];\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge ena) begin\n        if (ena) begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "Follow the Verilog coding standard and use descriptive names for the signals and modules.\n\n// 9-to-1 multiplexer\nalways @ (sel or a or b or c or d or e or f or g or h)\nbegin\n\tcase (sel)\n\t\t4'd0: out = a;\n\t\t4'd1: out = b;\n\t\t4'd2: out = c;\n\t\t4'd3: out = d;\n\t\t4'd4: out = e;\n\t\t4'd5: out = f;\n\t\t4'd6: out = g;\n\t\t4'd7: out = h;\n\t\tdefault: out = 16'hffff;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = (a != 0) || (b != 0);\n\n    // NOT of b\n    assign out_not[5:3] = ~b;\n\n    // NOT of a\n    assign out_not[2:0] = ~a;\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n\nalways @(*) begin\n\tcase (state)\n\t\t4'b0001: begin // A\n\t\t\tnext_state = (in == 1) ? 4'b0010 : 4'b0001; // B or A\n\t\t\tout = 1'b0;\n\t\tend\n\t\t4'b0010: begin // B\n\t\t\tnext_state = (in == 1) ? 4'b1000 : 4'b0010; // D or B\n\t\t\tout = 1'b0;\n\t\tend\n\t\t4'b0100: begin // C\n\t\t\tnext_state = (in == 1) ? 4'b1000 : 4'b0100; // D or C\n\t\t\tout = 1'b0;\n\t\tend\n\t\t4'b1000: begin // D\n\t\t\tnext_state = (in == 1) ? 4'b0100 : 4'b1000; // C or B\n\t\t\tout = 1'b1;\n\t\tend\n\t\tdefault: begin // Invalid state\n\t\t\tnext_state = 4'b0000;\n\t\t\tout = 1'b0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "and end with:\n```verilog\nalways @ (*) begin\n\tif (a < b && a < c && a < d) begin\n\t\tmin = a;\n\tend else if (b < a && b < c && b < d) begin\n\t\tmin = b;\n\tend else if (c < a && c < b && c < d) begin\n\t\tmin = c;\n\tend else begin\n\t\tmin = d;\n\tend\nend\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "Do not add any extra comments or whitespace. Your code should be easy to read and understand.\n\n// Karnaugh map\n// a b c d | out\n// 0 0 0 0 | 1\n// 0 0 1 0 | 1\n// 0 1 0 0 | 0\n// 0 1 1 0 | 1\n// 1 0 0 0 | 1\n// 1 0 1 0 | 0\n// 1 1 0 0 | 1\n// 1 1 1 0 | 1\n\n// Verilog code\n// Implement the circuit described by the Karnaugh map\n// using Verilog's logical operators (&&, ||, ~, !)\n// and if-else statements\n\n// out = a & b | c & d | a & c | b & d\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & c) | (b & d)\n\n// out = (a & b) | (c & d) | (a & d) | (b & c)\n\n  // Verilog code\n  // Implement the circuit described by the Karnaugh map\n  // using Verilog's logical operators (&&"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "// State encoding\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\t\t\n\t// State register and next state logic\n\treg [1:0] state, next_state;\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\t\n\t// Output logic\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tz <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tif (s) begin\n\t\t\t\t\t\tnext_state <= B;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= A;\n\t\t\t\t\tend\n\t\t\t\t\tz <= 0;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tnext_state <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= B;\n\t\t\t\t\tend\n\t\t\t\t\tz <= 0;\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tnext_state <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= C;\n\t\t\t\t\tend\n\t\t\t\t\tz <= 0;\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tnext_state <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= B;\n\t\t\t\t\tend\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tz <= 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tz <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "// Sign-extend an 8-bit number to 32 bits\nassign out = {24{in[7]}, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module names.\n* Be consistent in your code formatting.\n* Use braces for multi-line statements.\n* Indent the code appropriately.\n* Avoid code duplication.\n* Use comments to explain the code if needed.\n\n```verilog\nmodule top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n    reg out_reg;\n\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn) begin\n            shift_reg <= 4'b0;\n            out_reg <= 1'b0;\n        end else begin\n            shift_reg <= {in, shift_reg[3:1]};\n            out_reg <= shift_reg[0];\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "always @(*)\nbegin\n    if (in[3] == 1)\n        pos = 2'd3;\n    else if (in[2] == 1)\n        pos = 2'd2;\n    else if (in[1] == 1)\n        pos = 2'd1;\n    else if (in[0] == 1)\n        pos = 2'd0;\n    else\n        pos = 2'd0;\nend"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n// areset is an active-high asynchronous reset to state OFF\n\nreg [1:0] state;\nreg out_reg;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= 2'b00;\n\t\tout_reg <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\t2'b00: begin // OFF\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b01: begin // ON\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b10: begin // OFF\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nassign out = out_reg;\n\nalways @(state) begin\n\tcase (state)\n\t\t2'b00: out_reg <= 1'b0;\n\t\t2'b01: out_reg <= 1'b1;\n\t\t2'b10: out_reg <= 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "endmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one);\n\n    assign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "// Reverse the bit ordering\nreg [99:0] reversed;\ninteger i;\nalways @(*) begin\n\tfor (i = 0; i < 100; i = i + 1) begin\n\t\treversed[i] = in[99 - i];\n\tend\n\tout = reversed;\nend\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    reg d;\n\n    always @(posedge clk) begin\n        d <= in ^ d;\n    end\n\n    assign out = d;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "// (1) areset: Resets shift register to zero. \nalways @(posedge areset) begin\n\tq <= 4'b0;\nend\n\n// (2) load: Loads shift register with data[3:0] instead of shifting. \nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\n\telse if (ena) begin\n\t\tq <= {q[2:0], 1'b0};\n\tend\nend\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & ~x2 & ~x1) | (x3 & x2 & x1);\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "Inside the always block, use a loop to reset all the DFFs to 0 and then set the output to the value of d.\n\n```verilog\n\talways @(posedge clk) begin\n\t\tif (areset) begin\n\t\t\tq <= 8'b0;\n\t\t\tfor (i = 0; i < 8; i = i + 1) begin\n\t\t\t\tq[i] <= 1'b0;\n\t\t\tend\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    // Half Adder\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// State register\nreg [1:0] state;\n\n// Next state logic\nalways @ (posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= OFF;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nalways @ (state) begin\n\tcase (state)\n\t\tOFF: out = 1'b0;\n\t\tON: out = 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    wire [29:0] input_concatenated;\n    wire [29:0] input_concatenated_plus_1_bit;\n\n    assign input_concatenated = {a, b, c, d, e, f};\n    assign input_concatenated_plus_1_bit = {input_concatenated, 2'b11};\n\n    assign w = input_concatenated_plus_1_bit[29:22];\n    assign x = input_concatenated_plus_1_bit[21:14];\n    assign y = input_concatenated_plus_1_bit[13:8];\n    assign z = input_concatenated_plus_1_bit[7:0];\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    wire e, f, g, h, i, j;\n\n    // XOR gate implementation\n    xor x1(e, a, b);\n    xor x2(f, c, d);\n    xor x3(g, e, f);\n    xor x4(h, g, i);\n    xor x5(j, h, i);\n\n    // Assign output\n    assign q = j;\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "then add the and gate implementation:\n```verilog\n\tassign out = a & b;\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// States\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// State register and next state logic\nreg [1:0] state, next_state;\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= B;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// Output logic\nalways @(state, in) begin\n\tcase (state)\n\t\tA: out <= 0;\n\t\tB: out <= in;\n\tendcase\nend\n\n// Next state logic\nalways @(state, in) begin\n\tcase (state)\n\t\tA: next_state = (in) ? A : B;\n\t\tB: next_state = (in) ? B : A;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "where a, b, cin are inputs and sum, cout are outputs.\n\n// Full adder implementation\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module\n\n// XNOR gate implementation\nmodule xnor (\n    input a,\n    input b,\n    output logic y\n);\n    assign y = ~(a ^ b);\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "and end with the following 2-to-1 and 4-to-1 muxes:\n```verilog\n\twire w1, w2, w3, w4, w5, w6, w7, w8;\n\n\t// 2-to-1 muxes\n\tmux2to1 #(.D1(1'b1), .D2(1'b0)) mux1 (.I(c), .S(d), .O(w1));\n\tmux2to1 #(.D1(1'b0), .D2(1'b1)) mux2 (.I(c), .S(d), .O(w2));\n\tmux2to1 #(.D1(1'b1), .D2(1'b0)) mux3 (.I(c), .S(d), .O(w3));\n\tmux2to1 #(.D1(1'b0), .D2(1'b1)) mux4 (.I(c), .S(d), .O(w4));\n\tmux2to1 #(.D1(1'b1), .D2(1'b1)) mux5 (.I(c), .S(d), .O(w5));\n\tmux2to1 #(.D1(1'b1), .D2(1'b0)) mux6 (.I(c), .S(d), .O(w6));\n\tmux2to1 #(.D1(1'b0), .D2(1'b1)) mux7 (.I(c), .S(d), .O(w7));\n\tmux2to1 #(.D1(1'b1), .D2(1'b0)) mux8 (.I(c), .S(d), .O(w8));\n\n\t// 4-to-1 mux\n\tmux4to1 mux (.I0(w1), .I1(w2), .I2(w3), .I3(w4), .S0(a), .S1(b), .O(mux_in[0]));\n\tmux4to1 mux (.I0(w5), .I1(w6), .I2(w7), .I3(w8), .S0(a), .S1(b), .O(mux_in[1]));\n\tmux4to1 mux (.I0(w1), .I1(w2), .I2(w3), .I3(w4), .S0(a), .S1(b), .O(mux_in[2]));\n\tmux4to1 mux (.I0(w5), .I1(w6), .I2(w7), .I3(w8), .S0(a), .S1(b), .O(mux_in[3]));\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // States\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Output register\n    reg z_reg;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n            z_reg <= 1'b0;\n        end else begin\n            state <= next_state;\n            z_reg <= z;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (x) ? B : A;\n            B: next_state = (x) ? B : A;\n        endcase\n    end\n\n    // Output logic\n    assign z = z_reg;\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg q_reg;\n    wire q_wire;\n    reg [1:0] state_reg;\n    wire [1:0] state_wire;\n\n    assign state_wire = {q_reg, state_reg[1]};\n    assign q = q_wire;\n\n    always @(posedge clk) begin\n        state_reg <= {b, a};\n        q_reg <= state_reg[1];\n    end\n\n    assign state = state_wire;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module (\n    input [4:1] x,\n    output logic f\n);\n\nalways @(*) begin\n    case(x)\n        4'b0000: f = 1'b0;\n        4'b0001: f = 1'b1;\n        4'b0010: f = 1'b0;\n        4'b0011: f = 1'b1;\n        4'b0100: f = 1'b1;\n        4'b0101: f = 1'b0;\n        4'b0110: f = 1'b1;\n        4'b0111: f = 1'b1;\n        4'b1000: f = 1'b1;\n        4'b1001: f = 1'b1;\n        4'b1010: f = 1'b0;\n        4'b1011: f = 1'b1;\n        4'b1100: f = 1'b1;\n        4'b1101: f = 1'b1;\n        4'b1110: f = 1'b1;\n        4'b1111: f = 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output disc,\n    output flag,\n    output err);\n\n    // Define the states\n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n    parameter S3 = 2'b11;\n\n    // Define the state register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Define the output registers and next state logic\n    reg disc_reg, flag_reg, err_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            disc_reg <= 1'b0;\n            flag_reg <= 1'b0;\n            err_reg <= 1'b0;\n        end else begin\n            disc_reg <= (state == S1);\n            flag_reg <= (state == S2);\n            err_reg <= (state == S3);\n        end\n    end\n\n    // Define the next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = (in == 1'b0) ? S0 : (in == 1'b1) ? S1 : S3;\n            S1: next_state = (in == 1'b0) ? S0 : (in == 1'b1) ? S1 : S3;\n            S2: next_state = (in == 1'b0) ? S0 : (in == 1'b1) ? S1 : S3;\n            S3: next_state = (in == 1'b0) ? S0 : (in == 1'b1) ? S1 : S3;\n        endcase\n    end\n\n    // Assign the outputs\n    assign disc = disc_reg;\n    assign flag = flag_reg;\n    assign err = err_reg;\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "// State encoding for the state machine\nparameter IDLE = 2'd0;\nparameter START = 2'd1;\nparameter DELAY_SETUP = 2'd2;\nparameter COUNTING = 2'd3;\n\n// State register and next state logic\nreg [1:0] state, next_state;\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// State output logic\nalways @ (*) begin\n\tcase (state)\n\t\tIDLE: next_state = (data == 4'b1101) ? DELAY_SETUP : IDLE;\n\t\tDELAY_SETUP: next_state = (counting) ? COUNTING : DELAY_SETUP;\n\t\tCOUNTING: next_state = (count == 4'b0000) ? IDLE : COUNTING;\n\t\tdefault: next_state = IDLE;\n\tendcase\nend\n\n// Count register and next count logic\nreg [3:0] count_reg, count_next;\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tcount_reg <= 4'b0000;\n\tend else begin\n\t\tcount_reg <= count_next;\n\tend\nend\n\n// Count output logic\nalways @ (*) begin\n\tcase (state)\n\t\tIDLE: count_next = 4'b0000;\n\t\tDELAY_SETUP: count_next = count_reg;\n\t\tCOUNTING: count_next = count_reg - 4'b0001;\n\t\tdefault: count_next = 4'b0000;\n\tendcase\nend\n\n// Counting output logic\nassign counting = (state == COUNTING);\n\n// Done output logic\nassign done = (count_reg == 4'b0000);\n\n// Acknowledge output logic\nassign ack = (done && ack);\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // Define state machine states\n    localparam IDLE = 2'b00;\n    localparam HIGH_LEVEL = 2'b01;\n    localparam LOW_LEVEL = 2'b10;\n\n    // Define state machine signals\n    reg [1:0] state = IDLE;\n    reg [1:0] next_state = IDLE;\n    reg [1:0] prev_state = IDLE;\n    reg [1:0] sensor_prev = 2'b00;\n    reg [1:0] sensor = 2'b00;\n    reg [1:0] sensor_next = 2'b00;\n\n    // Define output signals\n    reg [1:0] flow_rate = 2'b00;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            sensor_prev <= 2'b00;\n            sensor <= 2'b00;\n            sensor_next <= 2'b00;\n            flow_rate <= 2'b00;\n            fr3 <= 0;\n            fr2 <= 0;\n            fr1 <= 0;\n            dfr <= 0;\n        end else begin\n            state <= next_state;\n            sensor_prev <= sensor;\n            sensor <= sensor_next;\n            flow_rate <= {fr3, fr2, fr1};\n            case (state)\n                IDLE: begin\n                    if (s[1] || s[2] || s[3]) begin\n                        next_state = HIGH_LEVEL;\n                        sensor_next = {s[2], s[1]};\n                        fr3 = 1;\n                    end\n                end\n                HIGH_LEVEL: begin\n                    if (!s[3]) begin\n                        next_state = LOW_LEVEL;\n                        sensor_next = {s[2], s[1]};\n                        fr3 = 0;\n                    end\n                end\n                LOW_LEVEL: begin\n                    if (s[1] || s[2] || s[3]) begin\n                        next_state = HIGH_LEVEL;\n                        sensor_next = {s[2], s[1]};\n                        fr3 = 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            fr2 <= 0;\n            fr1 <= 0;\n            dfr <= 0;\n        end else begin\n            if (sensor_prev < sensor) begin\n                if (flow_rate == 2'b00) begin\n                    flow_rate <= {2'b00, 1'b1};\n                    dfr <= 1;\n                end else begin\n                    flow_rate <= flow_rate + 1;\n                    dfr <= 1;\n                end\n            end else begin\n                if (flow_rate != 2'b00) begin\n                    flow_rate <= flow_rate - 1;\n                    dfr <= 0;\n                end else begin\n                    dfr <= 0;\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module code, such as test benches or other FSMs. Your code should only focus on the FSM for the serial protocol.\nmodule top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    // Define the states\n    parameter IDLE = 2'b00;\n    parameter START = 2'b01;\n    parameter DATA = 2'b10;\n    parameter STOP = 2'b11;\n\n    // Define the data register\n    reg [7:0] data_reg;\n\n    // Define the state register\n    reg [1:0] state_reg;\n\n    // Define the reset signal\n    reg reset_reg;\n\n    // Define the start, data, and stop signals\n    reg start_reg;\n    reg data_reg;\n    reg stop_reg;\n\n    // Define the done signal\n    reg done_reg;\n\n    // State machine\n    always @(posedge clk) begin\n        if (reset_reg) begin\n            state_reg <= IDLE;\n            data_reg <= 0;\n            start_reg <= 0;\n            data_reg <= 0;\n            stop_reg <= 0;\n            done_reg <= 0;\n        end\n        else begin\n            case (state_reg)\n                IDLE: begin\n                    if (in == 0) begin\n                        state_reg <= START;\n                    end\n                end\n                START: begin\n                    if (in == 1) begin\n                        state_reg <= DATA;\n                    end\n                    else begin\n                        state_reg <= IDLE;\n                    end\n                end\n                DATA: begin\n                    if (in == 1) begin\n                        state_reg <= STOP;\n                        data_reg <= {data_reg[6:0], in};\n                    end\n                    else begin\n                        state_reg <= DATA;\n                        data_reg <= {data_reg[6:0], in};\n                    end\n                end\n                STOP: begin\n                    if (in == 1) begin\n                        state_reg <= IDLE;\n                        done_reg <= 1;\n                    end\n                    else begin\n                        state_reg <= STOP;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Assign the output signals\n    assign done = done_reg;\n    assign data_reg = {data_reg[6:0], in};\n    assign start_reg = in;\n    assign stop_reg = in;\n\n    // Assign the reset signal\n    always @(posedge clk) begin\n        if (reset_reg) begin\n            state_reg <= IDLE;\n            data_reg <= 0;\n            start_reg <= 0;\n            data_reg <= 0;\n            stop_reg <= 0;\n            done_reg <= 0;\n        end\n    end\n\n    // Assign the reset signal to the input\n    assign reset_reg = reset;\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "Follow the Verilog code style guide to improve readability.\n\nmodule top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n\n\t// Define states\n\tlocalparam IDLE = 2'b00;\n\tlocalparam START_BIT = 2'b01;\n\tlocalparam DATA_BITS = 2'b10;\n\tlocalparam STOP_BIT = 2'b11;\n\n\t// Define registers\n\treg [1:0] state;\n\treg [7:0] shift_reg;\n\treg [2:0] bit_count;\n\treg done_reg;\n\n\t// Define outputs\n\tassign out_byte = shift_reg;\n\tassign done = done_reg;\n\n\t// Define combinational logic\n\talways @ (posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tshift_reg <= 8'b0;\n\t\t\tbit_count <= 3'b0;\n\t\t\tdone_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= START_BIT;\n\t\t\t\t\t\tbit_count <= 3'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTART_BIT: begin\n\t\t\t\t\tif (bit_count == 3'b0) begin\n\t\t\t\t\t\tshift_reg[0] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b1) begin\n\t\t\t\t\t\tshift_reg[1] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b2) begin\n\t\t\t\t\t\tshift_reg[2] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b3) begin\n\t\t\t\t\t\tshift_reg[3] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b4) begin\n\t\t\t\t\t\tshift_reg[4] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b5) begin\n\t\t\t\t\t\tshift_reg[5] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b6) begin\n\t\t\t\t\t\tshift_reg[6] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3'b7) begin\n\t\t\t\t\t\tshift_reg[7] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\t\tif (bit_count == 3'b8) begin\n\t\t\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\t\t\tstate <= STOP_BIT;\n\t\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\t\tbit_count <= 3'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tDATA_BITS: begin\n\t\t\t\t\tif (bit_count == 3'b0) begin\n\t\t\t\t\t\tshift_reg[0] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend else if (bit_count == 3"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Verilog code goes here\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // Define the states\n    localparam IDLE = 2'b00;\n    localparam WALK_LEFT = 2'b01;\n    localparam WALK_RIGHT = 2'b10;\n    localparam DIG = 2'b11;\n\n    // Define the outputs\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIG);\n\n    // Define the state register and next state logic\n    reg [1:0] state, next_state;\n    always @ (posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Define the state transition logic\n    always @ (*) begin\n        case (state)\n            IDLE: begin\n                if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else if (dig) begin\n                    next_state = DIG;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WALK_LEFT: begin\n                if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else if (dig) begin\n                    next_state = DIG;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end else if (dig) begin\n                    next_state = DIG;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            DIG: begin\n                if (ground == 0) begin\n                    next_state = FALLING;\n                end else begin\n                    next_state = DIG;\n                end\n            end\n            FALLING: begin\n                if (ground == 1) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n        endcase\n    end\n\n    // Define the output logic\n    always @ (*) begin\n        if (state == FALLING) begin\n            aaah = 1;\n            digging = 0;\n        end else begin\n            aaah = 0;\n            digging = (state == DIG);\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n\n\treg [3:0] nb;\n\treg [255:0] q_next;\n\treg [255:0] q_load;\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq_load <= data;\n\t\tend else begin\n\t\t\tq_load <= q_next;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnb = 4'b0000;\n\t\tfor (int i = -1; i <= 1; i = i + 1) begin\n\t\t\tfor (int j = -1; j <= 1; j = j + 1) begin\n\t\t\t\tif (i == 0 && j == 0) begin\n\t\t\t\t\tcontinue;\n\t\t\t\tend\n\t\t\t\tif (i == 0 && j == 1) begin\n\t\t\t\t\tnb = nb | q[15 + j + (i - 1) * 16];\n\t\t\t\tend\n\t\t\t\tif (i == 1 && j == 0) begin\n\t\t\t\t\tnb = nb | q[(i - 1) * 16 + j];\n\t\t\t\tend\n\t\t\t\tif (i == 1 && j == 1) begin\n\t\t\t\t\tnb = nb | q[(i - 1) * 16 + j];\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif (nb == 4'b1110) begin\n\t\t\tq_next[0] = 1'b0;\n\t\tend else if (nb == 4'b1101) begin\n\t\t\tq_next[0] = q[0];\n\t\tend else if (nb == 4'b1011) begin\n\t\t\tq_next[0] = 1'b1;\n\t\tend else if (nb >= 4'b0111) begin\n\t\t\tq_next[0] = 1'b0;\n\t\tend\n\t\tfor (int i = 1; i < 16; i = i + 1) begin\n\t\t\tif (i == 1 && j == 0) begin\n\t\t\t\tnb = nb | q[(i - 1) * 16 + j + 1];\n\t\t\tend\n\t\t\tif (i == 1 && j == 1) begin\n\t\t\t\tnb = nb | q[(i - 1) * 16 + j - 1];\n\t\t\tend\n\t\t\tif (i == 1 && j == 15) begin\n\t\t\t\tnb = nb | q[(i - 1) * 16 + j + 1];\n\t\t\tend\n\t\t\tif (i == 15 && j == 0) begin\n\t\t\t\tnb = nb | q[i * 16 + j + 1];\n\t\t\tend\n\t\t\tif (i == 15 && j == 15) begin\n\t\t\t\tnb = nb | q[i * 16 + j - 1];\n\t\t\tend\n\t\t\tif (i == 1 && j == 0) begin\n\t\t\t\tq_next[i] = q_load[i - 1];\n\t\t\tend else if (i == 1 && j == 15) begin\n\t\t\t\tq_next[i] = q_load[i + 1];\n\t\t\tend else if (i == 0) begin\n\t\t\t\tq_next[i] = q_load[15];\n\t\t\tend else if (i == 15) begin\n\t\t\t\tq_next[i] = q_load[0];\n\t\t\tend else begin\n\t\t\t\tq_next[i] = q_load[i - 1];\n\t\t\tend\n\t\t\tif (nb == 4'b1110) begin\n\t\t\t\tq_next[i] = 1'b0;"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "// State encoding:\n// 0: walk left\n// 1: walk right\n// 2: falling\n// 3: digging\n// State transition and output logic:\n// The output signals are defined in terms of the current state.\n// The state transition logic is based on the current state and the external inputs.\n// Since the state encoding is relatively simple, we can write the state transition logic and the output logic in the same module.\n// We can also use an enumerated type for the state encoding, to make the code clearer.\n// Since we don't care about the exact value of the state (only its encoding), we can use a wire to connect the state outputs to the inputs.\n// State 0: walk left\n// ------------------\n// If we are in state 0 and the ground is 0, we fall and say \"aaah!\".\n// If we are in state 0 and the dig input is 1, we start digging.\n// If we are in state 0 and we get bumped, we switch directions.\n// If we are in state 0 and areset is asserted, we reset to state 0.\n// \n// State 1: walk right\n// -------------------\n// If we are in state 1 and the ground is 0, we fall and say \"aaah!\".\n// If we are in state 1 and the dig input is 1, we start digging.\n// If we are in state 1 and we get bumped, we switch directions.\n// If we are in state 1 and areset is asserted, we reset to state 0.\n// \n// State 2: falling\n// -----------------\n// If we are in state 2 and the ground is 1, we resume walking in the original direction (walk_left or walk_right).\n// If we are in state 2 and areset is asserted, we reset to state 0.\n// \n// State 3: digging\n// -----------------\n// If we are in state 3 and the ground is 0, we fall and say \"aaah!\".\n// If we are in state 3 and the dig input is 0, we stop digging and resume walking in the original direction.\n// If we are in state 3 and areset is asserted, we reset to state 0.\n// \n// State transitions:\n// -------------------\n// State 0 -> 2: ground=0\n// State 1 -> 2: ground=0\n// State 2 -> 0: ground=1\n// State 2 -> 3: dig=1\n// State 3 -> 0: ground=1\n// \n// State transitions with areset:\n// State 0 -> 0: areset\n// State 1 -> 0: areset\n// State 2 -> 0: areset\n// State 3 -> 0: areset\n// \n// State transitions with bump:\n// State 0 -> 1: bump_left\n// State 1 -> 0: bump_right\n// \n// Output signals:\n// walk_left: 1 if we are in state 0\n// walk_right: 1 if we are in state 1\n// aaah: 1 if we are in state 2\n// digging: 1 if we are in state 3\n// \n// State encoding and output logic:\n// We encode the states using an enumerated type, since it is relatively simple.\n// We use a wire to connect the state outputs to the inputs.\n// We use a case statement to generate the output signals.\n// \n// Falling and digging:\n// If we are in state 2 (falling) or state 3 (digging), we say \"aaah!\" and start digging, and we don't switch directions.\n// \n// Walking:\n// If we are in state 0 (walk left) or state 1 (walk right), we switch directions when bumped, and we don't say \"aaah!\" or start digging.\n// \n// Digging and falling:\n// If we are in state 0 or state 1 and we start digging, we switch to state 3 (digging) and continue walking in the original direction.\n// If we are in state 0 or state 1 and we fall, we switch to state 2 (falling) and continue walking in the original direction.\n// \n// State machine:\n// We use a Moore state machine, with the current state and the external inputs determining the next state and the output signals.\n// \n// State"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    reg [3:0] count;\n    reg [3:0] next_count;\n    reg [3:0] next_next_count;\n    reg [3:0] prev_count;\n    reg [3:0] prev_next_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n            next_count <= 4'b0000;\n            next_next_count <= 4'b0000;\n            prev_count <= 4'b0000;\n            prev_next_count <= 4'b0000;\n            pm <= 1'b0;\n            hh <= 8'b00000001;\n            mm <= 8'b00000000;\n            ss <= 8'b00000000;\n        end else if (ena) begin\n            if (count == 4'b1110) begin\n                count <= 4'b0000;\n                pm <= ~pm;\n            end else begin\n                count <= count + 1;\n            end\n        end\n\n        if (count == 4'b1110 && pm == 1'b0) begin\n            next_count <= 4'b0001;\n            next_next_count <= 4'b1111;\n        end else if (count == 4'b0000 && pm == 1'b1) begin\n            next_count <= 4'b0001;\n            next_next_count <= 4'b1111;\n        end else if (count == 4'b1110 && pm == 1'b1) begin\n            next_count <= 4'b0000;\n            next_next_count <= 4'b0001;\n        end else if (count == 4'b0000 && pm == 1'b0) begin\n            next_count <= 4'b0001;\n            next_next_count <= 4'b1111;\n        end else if (count == 4'b1110 && pm == 1'b0) begin\n            next_count <= 4'b0000;\n            next_next_count <= 4'b0001;\n        end else begin\n            next_count <= count;\n            next_next_count <= prev_next_count;\n        end\n\n        prev_count <= count;\n        prev_next_count <= next_next_count;\n        hh <= {hh[6:0], next_count[0]};\n        mm <= {mm[6:0], next_count[1]};\n        ss <= {ss[6:0], next_count[2]};\n    end\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    parameter walk_left_0 = 2'b00;\n    parameter walk_right_0 = 2'b01;\n    parameter falling_0 = 2'b10;\n\n    reg [1:0] state = walk_left_0;\n    reg [1:0] next_state = walk_left_0;\n    reg aaah_reg = 0;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= walk_left_0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            walk_left_0: begin\n                if (bump_left) begin\n                    next_state = walk_right_0;\n                end\n                else if (ground == 0) begin\n                    next_state = falling_0;\n                    aaah_reg = 1;\n                end\n                else begin\n                    next_state = walk_left_0;\n                    aaah_reg = 0;\n                end\n            end\n            walk_right_0: begin\n                if (bump_right) begin\n                    next_state = walk_left_0;\n                end\n                else if (ground == 0) begin\n                    next_state = falling_0;\n                    aaah_reg = 1;\n                end\n                else begin\n                    next_state = walk_right_0;\n                    aaah_reg = 0;\n                end\n            end\n            falling_0: begin\n                if (ground == 1) begin\n                    next_state = walk_left_0;\n                    aaah_reg = 0;\n                end\n                else begin\n                    next_state = falling_0;\n                    aaah_reg = 1;\n                end\n            end\n        endcase\n    end\n\n    assign walk_left = (state == walk_left_0);\n    assign walk_right = (state == walk_right_0);\n    assign aaah = aaah_reg;\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "Complete the Verilog code with the following:\n```verilog\n\treg [1:0] digit;\n\treg [3:0] ones;\n\treg [3:0] tens;\n\treg [3:0] hundreds;\n\treg [3:0] thousands;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'b0;\n\t\t\tdigit <= 2'b00;\n\t\t\tones <= 4'b0;\n\t\t\ttens <= 4'b0;\n\t\t\thundreds <= 4'b0;\n\t\t\tthousands <= 4'b0;\n\t\t\tena <= 3'b0;\n\t\tend else begin\n\t\t\tcase (digit)\n\t\t\t\t2'b00: begin\n\t\t\t\t\tif (ones == 4'b1001) begin\n\t\t\t\t\t\tdigit <= 2'b01;\n\t\t\t\t\t\tones <= 4'b0000;\n\t\t\t\t\t\ttens <= tens + 1;\n\t\t\t\t\t\tif (tens == 4'b1001) begin\n\t\t\t\t\t\t\ttens <= 4'b0000;\n\t\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\t\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\t\t\t\t\thundreds <= 4'b0000;\n\t\t\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\t\t\t\tif (thousands == 4'b1001) begin\n\t\t\t\t\t\t\t\t\tthousands <= 4'b0000;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tones <= ones + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\tif (tens == 4'b1001) begin\n\t\t\t\t\t\tdigit <= 2'b10;\n\t\t\t\t\t\ttens <= 4'b0000;\n\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\t\t\t\thundreds <= 4'b0000;\n\t\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\t\t\tif (thousands == 4'b1001) begin\n\t\t\t\t\t\t\t\tthousands <= 4'b0000;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\ttens <= tens + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b10: begin\n\t\t\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\t\t\tdigit <= 2'b00;\n\t\t\t\t\t\thundreds <= 4'b0000;\n\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\t\tif (thousands == 4'b1001) begin\n\t\t\t\t\t\t\tthousands <= 4'b0000;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b11: begin\n\t\t\t\t\tif (thousands == 4'b1001) begin\n\t\t\t\t\t\tdigit <= 2'b00;\n\t\t\t\t\t\tthousands <= 4'b0000;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tthousands <="}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "// Next-state logic for y[2]\nalways @ (posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tY2 <= 0;\n\tend else begin\n\t\tcase (y)\n\t\t\t3'b000: Y2 <= w;\n\t\t\t3'b001: Y2 <= w;\n\t\t\t3'b010: Y2 <= 0;\n\t\t\t3'b011: Y2 <= 1;\n\t\t\t3'b100: Y2 <= 0;\n\t\t\t3'b101: Y2 <= 1;\n\t\t\t3'b110: Y2 <= 1;\n\t\t\t3'b111: Y2 <= 1;\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "and end with:\n```verilog\n\talways @(*)\n\t\tout_alwaysblock = a & b;\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "Use the assign keyword to assign the output to 0.\n```verilog\n\tassign zero = 0;\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\nreg [1:0] state;\n\nalways @(posedge clk) begin\n    case(state)\n        2'b00: begin\n            if (a) begin\n                state <= 2'b01;\n            end\n        end\n        2'b01: begin\n            if (a) begin\n                state <= 2'b10;\n            end else begin\n                state <= 2'b00;\n            end\n        end\n        2'b10: begin\n            if (a) begin\n                state <= 2'b11;\n            end else begin\n                state <= 2'b00;\n            end\n        end\n        2'b11: begin\n            if (a) begin\n                state <= 2'b00;\n            end else begin\n                state <= 2'b11;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    case(state)\n        2'b00: q <= 1'b0;\n        2'b01: q <= 1'b1;\n        2'b10: q <= 1'b1;\n        2'b11: q <= 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "endmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output out\n);\n\n    // states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // state register\n    reg [1:0] state;\n\n    // next state logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (in == 1) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                B: begin\n                    if (in == 1) begin\n                        state <= D;\n                    end else begin\n                        state <= C;\n                    end\n                end\n                C: begin\n                    if (in == 1) begin\n                        state <= D;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                D: begin\n                    if (in == 1) begin\n                        state <= C;\n                    end else begin\n                        state <= B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // output logic\n    always @(state) begin\n        case (state)\n            A: out <= 1'b0;\n            B: out <= 1'b0;\n            C: out <= 1'b0;\n            D: out <= 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "Use the assign statement to reverse the byte order.\n\n```verilog\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module name.\n  * 120 characters per line.\n  * 80 characters per parameter or input/output/inout.\n  * 100 characters per function body.\n  * 80 characters per else if or else.\n  * 80 characters per indentation level.\n  * 80 characters per function.\n  * 80 characters per module.\n  * 80 characters per variable name.\n  * 80 characters per line.\n  * 80 characters per parameter or input/output/inout.\n  * 80 characters per statement.\n  * 120 characters per function.\n  * 80 characters per variable name..\n  * 80 characters per if or else.\n  * 80 characters per module..\n  * 80 characters per statement..\n  * 120 characters per else.\n  * 80 characters per loop.\n  * 80 characters per parameter or input/output/inout.\n  * 80 characters per condition.\n  * 80 characters per while or for or repeat or begin.\n  * 80 characters per continue or break.\n  * 80 characters per block.\n  * 80 characters per do.\n  * 80 characters per label.\n  * 80 characters per case or default.\n  * 100 characters per switch.\n  * 80 characters per assign.\n  * 80 characters per selection.\n  * 80 characters per return.\n  * 80 characters per parameter or input/output/inout.\n  * 80 characters per comment..\n  * 80 characters per module.\n  * 80 characters per else.\n  * 80 characters per loop.\n  * 80 characters per module..\n  * 80 characters per endif.\n  * 80 characters per module name.\n  * 80 characters per endmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x^y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "// Shift left by 1 bit\nassign q[0] = (amount == 2'b00) ? ((ena) ? q[7:0] : q[63:1]) : 1'b0;\n// Shift left by 8 bits\nassign q[63:8] = (amount == 2'b01) ? q[63:0] : 64'b0;\n// Shift right by 1 bit\nassign q[63] = (amount == 2'b10) ? ((ena) ? q[62:0] : q[7:0]) : 1'b0;\n// Shift right by 8 bits\nassign q[7:0] = (amount == 2'b11) ? q[63:8] : 8'b0;\n\n// Load\nalways @ (posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\nend\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "// FSM states\n\t\tparameter S0 = 2'b00;\n\t\tparameter S1 = 2'b01;\n\t\tparameter S2 = 2'b10;\n\t\tparameter S3 = 2'b11;\n\t\t\n\t\t// FSM outputs\n\t\tparameter O0 = 1'b0;\n\t\tparameter O1 = 1'b1;\n\t\t\n\t\t// FSM registers\n\t\treg [1:0] state;\n\t\treg [1:0] next_state;\n\t\t\n\t\t// FSM outputs registers\n\t\treg output_reg;\n\t\t\n\t\t// FSM combinational logic\n\t\talways @ (posedge clk or negedge aresetn) begin\n\t\t\tif (~aresetn) begin\n\t\t\t\tstate <= S0;\n\t\t\t\tnext_state <= S0;\n\t\t\t\toutput_reg <= O0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate <= next_state;\n\t\t\t\t\n\t\t\t\tcase (state)\n\t\t\t\t\tS0: begin\n\t\t\t\t\t\tif (x == 1'b1) begin\n\t\t\t\t\t\t\tnext_state = S1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\toutput_reg = O0;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tS1: begin\n\t\t\t\t\t\tif (x == 1'b0) begin\n\t\t\t\t\t\t\tnext_state = S2;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tnext_state = S1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\toutput_reg = O0;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tS2: begin\n\t\t\t\t\t\tif (x == 1'b1) begin\n\t\t\t\t\t\t\tnext_state = S3;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tnext_state = S1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\toutput_reg = O1;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tS3: begin\n\t\t\t\t\t\tif (x == 1'b0) begin\n\t\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tnext_state = S3;\n\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\toutput_reg = O0;\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\t\t\n\t\t// FSM output register\n\t\talways @ (posedge clk or negedge aresetn) begin\n\t\t\tif (~aresetn) begin\n\t\t\t\tz <= O0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tz <= output_reg;\n\t\t\tend\n\t\tend\n\t\t\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg [1:0] output_reg;\n\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A;\n            output_reg <= 2'b00;\n        end\n        else begin\n            state <= next_state;\n            output_reg <= 2'b00;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w) begin\n                    next_state = A;\n                    output_reg = 2'b00;\n                end\n                else begin\n                    next_state = B;\n                    output_reg = 2'b00;\n                end\n            end\n            B: begin\n                if (w) begin\n                    next_state = B;\n                    output_reg = 2'b00;\n                end\n                else begin\n                    next_state = A;\n                    output_reg = 2'b00;\n                end\n            end\n            C: begin\n                if (w) begin\n                    next_state = D;\n                    output_reg = 2'b00;\n                end\n                else begin\n                    next_state = D;\n                    output_reg = 2'b00;\n                end\n            end\n            D: begin\n                if (w) begin\n                    next_state = D;\n                    output_reg = 2'b00;\n                end\n                else begin\n                    next_state = A;\n                    output_reg = 2'b00;\n                end\n            end\n            E: begin\n                if (w) begin\n                    next_state = E;\n                    output_reg = 2'b01;\n                end\n                else begin\n                    next_state = D;\n                    output_reg = 2'b01;\n                end\n            end\n            F: begin\n                if (w) begin\n                    next_state = C;\n                    output_reg = 2'b01;\n                end\n                else begin\n                    next_state = D;\n                    output_reg = 2'b01;\n                end\n            end\n        endcase\n    end\n\n    assign z = output_reg[1];\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n    reg [7:0] state_reg;\n    reg [7:0] next_state;\n    reg [23:0] byte_reg;\n    reg [2:0] byte_count;\n    reg done_reg;\n\n    parameter IDLE = 8'h00;\n    parameter FOUND_START = 8'h01;\n    parameter WAITING_FOR_SECOND_BYTE = 8'h02;\n    parameter WAITING_FOR_THIRD_BYTE = 8'h03;\n    parameter DONE = 8'h04;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state_reg <= IDLE;\n            next_state <= IDLE;\n            byte_reg <= 0;\n            byte_count <= 0;\n            done_reg <= 0;\n            out_bytes <= 0;\n        end else begin\n            state_reg <= next_state;\n            case (state_reg)\n                IDLE: begin\n                    if (in[3] == 1) begin\n                        next_state <= FOUND_START;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n                FOUND_START: begin\n                    next_state <= WAITING_FOR_SECOND_BYTE;\n                    byte_reg <= in;\n                    byte_count <= 1;\n                end\n                WAITING_FOR_SECOND_BYTE: begin\n                    if (in[3] == 1) begin\n                        next_state <= WAITING_FOR_THIRD_BYTE;\n                        byte_reg <= in;\n                        byte_count <= 2;\n                    end else begin\n                        next_state <= WAITING_FOR_SECOND_BYTE;\n                    end\n                end\n                WAITING_FOR_THIRD_BYTE: begin\n                    if (in[3] == 1) begin\n                        next_state <= DONE;\n                        done_reg <= 1;\n                        out_bytes <= {byte_reg[23:16], byte_reg[15:8], byte_reg[7:0]};\n                    end else begin\n                        next_state <= WAITING_FOR_THIRD_BYTE;\n                    end\n                end\n                DONE: begin\n                    next_state <= IDLE;\n                    done_reg <= 0;\n                    out_bytes <= 0;\n                end\n            endcase\n        end\n    end\n\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n  );\n\n    wire [5:0] y_next;\n    wire [5:0] y_next_w;\n\n    // State transition logic\n    assign y_next[0] = w ? y[3] : y[1];\n    assign y_next[1] = w ? y[4] : y[0];\n    assign y_next[2] = w ? y[5] : y[2];\n    assign y_next[3] = w ? y[0] : y[4];\n    assign y_next[4] = w ? y[1] : y[5];\n    assign y_next[5] = w ? y[2] : y[3];\n\n    // Output logic\n    assign Y1 = y[0];\n    assign Y3 = y[2];\n\n    // State flip-flop\n    reg [5:0] y_reg;\n    always @ (posedge w) begin\n        y_reg <= y_next;\n    end\n\n    // Output logic\n    assign Y1 = y_reg[1];\n    assign Y3 = y_reg[3];\n\n  endmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "// Verilog code for Karnaugh map\n\n\talways @(*)\n\tbegin\n\t\tcase ({a,b})\n\t\t\t2'b00: out = c & d;\n\t\t\t2'b01: out = c | d;\n\t\t\t2'b10: out = ~c;\n\t\t\t2'b11: out = c;\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    assign out_assign = a ^ b;\n\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    always @(posedge clk) begin\n        out_always_ff = a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "x[0] = w & y[1] & ~y[2] & ~y[4] & ~y[6];\nx[1] = w & y[2] & ~y[1] & ~y[4] & ~y[6];"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "Make sure your Verilog code is synthesizable and adheres to the Verilog guidelines. Use the Verilog syntax correctly and avoid any ambiguity.\n\n 3-6 bits: sel = 3-6'b000000\n 7-10 bits: sel = 4-10'b0000000000\n 11-15 bits: sel = 5-15'b00000000000000\n 16-20 bits: sel = 5-20'b0000000000000000\n 21-25 bits: sel = 5-25'b000000000000000000\n 26-30 bits: sel = 6-30'b0000000000000000000000\n 31-35 bits: sel = 6-35'b000000000000000000000000000000\n 36-40 bits: sel = 7-40'b0000000000000000000000000000000000\n 41-45 bits: sel = 7-45'b00000000000000000000000000000000000000\n 46-50 bits: sel = 8-50'b00000000000000000000000000000000000000\n 51-55 bits: sel = 9-55'b00000000000000000000000000000000000000\n 56-60 bits: sel = 10-60'b00000000000000000000000000000000000000\n 61-65 bits: sel = 11-65'b00000000000000000000000000000000000000\n 66-70 bits: sel = 12-70'b00000000000000000000000000000000000000\n 71-75 bits: sel = 13-75'b00000000000000000000000000000000000000\n 76-80 bits: sel = 14-80'b00000000000000000000000000000000000000\n 81-85 bits: sel = 15-85'b00000000000000000000000000000000000000\n 86-90 bits: sel = 16-90'b00000000000000000000000000000000000000\n 91-95 bits: sel = 17-95'b00000000000000000000000000000000000000\n 96-100 bits: sel = 18-100'b00000000000000000000000000000000000000\n 101-105 bits: sel ="}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module shift_register_stage (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    input [n-1:0] data,\n    output reg [n-1:0] Q\n);\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// The three D flip-flops.\nreg d1, d2, d3;\n\n// The three gates.\nwire g1, g2, g3;\n\n// The three-input XNOR gate.\nwire xnor_out;\nxnor(xnor_out, g3, g2, g1);\n\n// The XOR gate.\nxor(g1, d1, x);\n\n// The AND gate.\nand(g2, d2, ~d1);\n\n// The OR gate.\nor(g3, d3, d1, d2);\n\n// The D flip-flops.\nalways @(posedge clk) begin\n\td1 <= x;\n\td2 <= d1;\n\td3 <= d2;\nend\n\n// The output.\nassign z = xnor_out;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & ~b & c) | (~a & b & ~c) | (a & b & c) | (~a & ~b & d) | (a & ~b & d) | (~a & b & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Rule 110 cellular automaton\n\nreg [511:0] q_next;\n\nalways @ (posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else begin\n\t\tq <= q_next;\n\tend\nend\n\nalways @ (*) begin\n\tq_next[0] = 0;\n\tq_next[511] = 0;\n\tfor (i = 1; i < 511; i = i + 1) begin\n\t\tif (q[i-1] && q[i] && q[i+1]) begin\n\t\t\tq_next[i] = 0;\n\t\tend else if (q[i-1] && q[i] && !q[i+1]) begin\n\t\t\tq_next[i] = 1;\n\t\tend else if (!q[i-1] && q[i] && q[i+1]) begin\n\t\t\tq_next[i] = 1;\n\t\tend else if (!q[i-1] && q[i] && !q[i+1]) begin\n\t\t\tq_next[i] = 1;\n\t\tend else if (q[i-1] && !q[i] && q[i+1]) begin\n\t\t\tq_next[i] = 1;\n\t\tend else if (q[i-1] && !q[i] && !q[i+1]) begin\n\t\t\tq_next[i] = 0;\n\t\tend else begin\n\t\t\tq_next[i] = q[i];\n\t\tend\n\tend\nend\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // Define the state register and initialize to state A\n    reg [1:0] state = A;\n\n    // Define the output register and initialize to 0\n    reg out_reg = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            out_reg <= 0;\n        end\n        else begin\n            case (state)\n                A: begin\n                    if (in) begin\n                        state <= B;\n                    end\n                    else begin\n                        state <= C;\n                    end\n                    out_reg <= 0;\n                end\n                B: begin\n                    if (in) begin\n                        state <= B;\n                    end\n                    else begin\n                        state <= C;\n                    end\n                    out_reg <= 0;\n                end\n                C: begin\n                    if (in) begin\n                        state <= D;\n                    end\n                    else begin\n                        state <= A;\n                    end\n                    out_reg <= 0;\n                end\n                D: begin\n                    if (in) begin\n                        state <= B;\n                    end\n                    else begin\n                        state <= C;\n                    end\n                    out_reg <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Assign the output to the output register\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\nalways @(*) begin\n    case({a,b,c,d,e})\n        5'bxxxxx: q = 4'bxxxx; // time 5ns\n        5'bxxxxxx: q = 4'bxxxx; // time 10ns\n        5'bxxxxx0: q = 4'bxxxx; // time 15ns\n        5'bxxxxx1: q = 4'bxxxx; // time 20ns\n        5'bxxxxx2: q = 4'bxxxx; // time 25ns\n        5'bxxxxx3: q = 4'bxxxx; // time 30ns\n        5'bxxxxx4: q = 4'bxxxx; // time 35ns\n        5'bxxxxx5: q = 4'bxxxx; // time 40ns\n        5'bxxxxx6: q = 4'bxxxx; // time 45ns\n        5'bxxxxx7: q = 4'bxxxx; // time 50ns\n        5'bxxxxx8: q = 4'bxxxx; // time 55ns\n        5'bxxxxx9: q = 4'bxxxx; // time 60ns\n        5'bxxxxxa: q = 4'bxxxx; // time 65ns\n        5'bxxxxxb: q = 4'bxxxx; // time 70ns\n        5'bxxxxxc: q = 4'bxxxx; // time 75ns\n        5'bxxxxxdd: q = 4'bxxxx; // time 80ns\n        5'bxxxxxee: q = 4'bxxxx; // time 85ns\n        5'bxxxxxff: q = 4'bxxxx; // time 90ns\n        default: q = 4'bxxxx; // unknown input\n    endcase\nend\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "always @ (sel, a, b) begin\n    if (sel) begin\n        out = b;\n    end\n    else begin\n        out = a;\n    end\nend"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module three times\nwire [2:0] q1;\nwire [2:0] q2;\nwire [2:0] q3;\n\nflipflop_mux ff1(.clk(clk), .L(L), .r(r), .q_in(q_in), .q(q1));\nflipflop_mux ff2(.clk(clk), .L(L), .r(r), .q_in(q_in), .q(q2));\nflipflop_mux ff3(.clk(clk), .L(L), .r(r), .q_in(q_in), .q(q3));\n\n// Assign the output of the submodules to the output of the full module\nassign Q = q3;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module\n\nmodule top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 0;\n            prev_in <= 0;\n        end else begin\n            if (in != prev_in) begin\n                out <= in;\n            end\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "always @(posedge clk) begin\n    q <= d;\nend"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] temp_s;\n    wire carry;\n\n    assign temp_s = {1'b0, a} + {1'b0, b};\n    assign s = temp_s[7:0];\n    assign carry = temp_s[8];\n\n    assign overflow = (a[7] == b[7] && s[7] != a[7]) || (a[7] != b[7] && s[7] == carry);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "Module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n    // Define state encoding\n    parameter S = 10'b0000000001;\n    parameter S1 = 10'b0000000010;\n    parameter S11 = 10'b0000000100;\n    parameter S110 = 10'b0000001000;\n    parameter B0 = 10'b0000010000;\n    parameter B1 = 10'b0000100000;\n    parameter B2 = 10'b0001000000;\n    parameter B3 = 10'b0010000000;\n    parameter Count = 10'b0100000000;\n    parameter Wait = 10'b1000000000;\n\n    // Define state register\n    reg [9:0] current_state;\n\n    // Define next state logic\n    always @ (current_state or d) begin\n        case (current_state)\n            S: begin\n                if (d) begin\n                    B3_next = 1'b1;\n                    S1_next = 1'b0;\n                    S_next = 1'b0;\n                end else begin\n                    B3_next = 1'b0;\n                    S1_next = 1'b1;\n                    S_next = 1'b0;\n                end\n            end\n            S1: begin\n                if (d) begin\n                    S11_next = 1'b1;\n                    S_next = 1'b0;\n                end else begin\n                    S11_next = 1'b0;\n                    S_next = 1'b1;\n                end\n            end\n            S11: begin\n                if (d) begin\n                    S110_next = 1'b1;\n                    S_next = 1'b0;\n                end else begin\n                    S110_next = 1'b0;\n                    S_next = 1'b1;\n                end\n            end\n            S110: begin\n                if (d) begin\n                    B0_next = 1'b1;\n                    S_next = 1'b0;\n                end else begin\n                    B0_next = 1'b0;\n                    S_next = 1'b1;\n                end\n            end\n            B0: begin\n                B1_next = 1'b1;\n                B2_next = 1'b0;\n                B3_next = 1'b0;\n                S_next = 1'b0;\n            end\n            B1: begin\n                B2_next = 1'b1;\n                B3_next = 1'b0;\n                S_next = 1'b0;\n            end\n            B2: begin\n                B3_next = 1'b1;\n                S_next = 1'b0;\n            end\n            B3: begin\n                Count_next = 1'b1;\n                S_next = 1'b0;\n            end\n            Count: begin\n                if (done_counting) begin\n                    Wait_next = 1'b1;\n                end else begin\n                    Count_next = 1'b1;\n                end\n                S_next = 1'b0;\n            end\n            Wait: begin\n                if (ack) begin\n                    S_next = 1'b1;\n                end else begin"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n  );\n\n    reg [1:0] counter;\n\n    always @(posedge clk or posedge areset) begin\n      if (areset) begin\n        counter <= 2'b01;\n      end else if (train_valid) begin\n        if (train_taken) begin\n          counter <= (counter == 2'b11) ? 2'b11 : counter + 1;\n        end else begin\n          counter <= (counter == 2'b00) ? 2'b00 : counter - 1;\n        end\n      end\n    end\n\n    assign state = counter;\n\n  endmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @(*) begin\n        case (scancode)\n            16'he06b: begin\n                left = 1;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n            16'he072: begin\n                left = 0;\n                down = 1;\n                right = 0;\n                up = 0;\n            end\n            16'he074: begin\n                left = 0;\n                down = 0;\n                right = 1;\n                up = 0;\n            end\n            16'he075: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 1;\n            end\n            default: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    reg [31:0] history_reg;\n    reg [31:0] mispredicted_history;\n    reg [31:0] mispredicted_history_reg;\n    reg [1:0] history_counter;\n    reg [1:0] mispredicted_history_counter;\n    \n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            history_reg <= 0;\n            mispredicted_history_reg <= 0;\n            history_counter <= 0;\n            mispredicted_history_counter <= 0;\n        end else begin\n            if (predict_valid && predict_taken) begin\n                history_reg <= {history_reg[30:0], predict_taken};\n                history_counter <= history_counter + 1;\n            end else if (train_mispredicted) begin\n                mispredicted_history_reg <= {train_history, train_taken};\n                mispredicted_history_counter <= history_counter;\n                history_reg <= mispredicted_history_reg;\n            end\n        end\n    end\n    \n    assign predict_history = history_reg;\n    \nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module instantiation (M1 ()) where necessary.\n// Use the internal signals (wire) where necessary.\n// Use the output ports (out) where necessary.\n// Use the inout ports (out_n) where necessary.\n// Use the parentheses where necessary.\n// Use the semicolons where necessary.\n// Use the braces where necessary.\n    wire and1_out;\n    wire and2_out;\n    wire or_out;\n\n    and and1 (and1_out, a, b);\n    and and2 (and2_out, c, d);\n    or or1 (or_out, and1_out, and2_out);\n    not not1 (out_n, or_out);\n    assign out = ~out_n;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module port.\n\nDo not add any Verilog module parameter.\n\nDo not add any Verilog module IO.\n\nDo not add any Verilog module architecture.\n\nDo not add any Verilog module generator.\n\nDo not add any Verilog module block.\n\nDo not add any Verilog module design_principle.\n\nDo not add any Verilog module design_precept.\n\nDo not add any Verilog module design_pattern.\n\nDo not add any Verilog module testbench.\n\nDo not add any Verilog module checklist.\n\n 8 lines of code maximum.\n```verilog\nmodule top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n    always @(posedge clk) begin\n        if(enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Mode selection\n    reg mode_sel;\n    always @ (mode) begin\n        if (mode == 1) begin\n            mode_sel <= 1;\n        end else begin\n            mode_sel <= 0;\n        end\n    end\n\n    // Heater logic\n    assign heater = (mode_sel == 1) & too_cold;\n\n    // Air conditioner logic\n    assign aircon = (mode_sel == 0) & too_hot;\n\n    // Fan logic\n    assign fan = fan_on | (heater | aircon);\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n\n    assign w1 = ~(a & b);\n    assign w2 = ~(a & c);\n    assign w3 = ~(a & d);\n    assign w4 = ~(b & c);\n    assign w5 = ~(b & d);\n    assign w6 = ~(c & d);\n    assign w7 = ~(a & b & c);\n    assign w8 = ~(a & b & d);\n    assign w9 = ~(a & c & d);\n    assign w10 = ~(b & c & d);\n    assign w11 = ~(a & b & c & d);\n    assign w12 = ~(a | b | c | d);\n    assign w13 = ~(a | b | c | d | 1'b0);\n    assign w14 = ~(a | b | c | d | 1'b1);\n    assign w15 = ~(a | b | c | d);\n\n    assign out_sop = w1 | w2 | w3 | w4 | w5 | w6 | w7 | w8 | w9 | w10 | w11 | w12 | w13 | w14 | w15;\n    assign out_pos = ~(w1 & w2 & w3 & w4 & w5 & w6 & w7 & w8 & w9 & w10 & w11 & w12 & w13 & w14 & w15);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 32'h1;\n\t\tend else begin\n\t\t\tq <= {q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31], q[31]^q[31], q[31]^q[22], q[31]^q[2], q[31]^q[1]};\n\t\tend\n\tend\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    // Compute the population count of the input vector\n    always @* begin\n        out = 0;\n        for (int i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "endmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    wire and_output;\n\n    and gate (\n        .in1(in1),\n        .in2(in2),\n        .out(and_output)\n    );\n\n    assign out = and_output;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n    \n    assign out = in;\n    \nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// State register\nreg [1:0] state_reg, state_next;\n\n// Output register\nreg out_reg;\n\n// State transitions\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= B;\n\tend else begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tA: begin\n\t\t\tif (in) begin\n\t\t\t\tstate_next = A;\n\t\t\tend else begin\n\t\t\t\tstate_next = B;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (in) begin\n\t\t\t\tstate_next = B;\n\t\t\tend else begin\n\t\t\t\tstate_next = A;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Output logic\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tout_reg <= 0;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tA: begin\n\t\t\t\tout_reg <= 1'b0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tout_reg <= 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Assign output to output register\nassign out = out_reg;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    reg q_prev;\n\n    always @(posedge clk) begin\n        q_prev <= q;\n        q <= d;\n    end\n\n    always @(negedge clk) begin\n        q <= q_prev;\n    end\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "END OF CHANGES\n---------------\n\n```verilog\n\tassign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n    wire or_out;\n    wire and_out;\n    \n    A a1(.x(x), .y(y), .z(or_out));\n    A a2(.x(x), .y(y), .z(and_out));\n    B b1(.x(x), .y(y), .z(or_out));\n    B b2(.x(x), .y(y), .z(and_out));\n    \n    XOR xor_gate(.a(or_out), .b(and_out), .z(z));\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena == 2'b01) begin\n            q <= {q[0], q[99:1]};\n        end else if (ena == 2'b10) begin\n            q <= {q[98:0], q[99]};\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "always @(posedge clk) begin\n\t\t\tif (reset) begin\n\t\t\t\tq <= 0;\n\t\t\tend else begin\n\t\t\t\tif (q == 999) begin\n\t\t\t\t\tq <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tq <= q + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "Follow the Verilog coding convention and use meaningful names for the signals and modules.\nDo not use abbreviations and avoid single-letter names.\n\nComment your code and explain the design and the key points.\n\nModule top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n\t// State transition logic\n\tassign next_state[0] = (state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[1] = (state[0] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[2] = (state[0] || state[1] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[3] = (state[0] || state[1] || state[2] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[4] = (state[0] || state[1] || state[2] || state[3] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[5] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[6] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[7] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[8] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[9]) ? 0 : 1;\n\tassign next_state[9] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8]) ? 0 : 1;\n\n\t// Output logic\n\tassign out1 = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign out2 = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[0] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[1] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[2] = (state[0] || state[1] || state[2] || state[3] || state[4] || state[5] || state[6] || state[7] || state[8] || state[9]) ? 0 : 1;\n\tassign next_state[3] = (state[0] || state["}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (j && k)\n            Q <= ~Q;\n        else if (j)\n            Q <= 0;\n        else if (k)\n            Q <= 1;\n        else\n            Q <= Q;\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "// Compute the population count for a 3-bit input vector\n// The population count is the number of 1's in the input vector\n// We can compute the population count by iteratively adding the input vector to itself,\n// but shifting the input vector to the right by one bit each time\n// The number of 1's in the final result is the population count\n// For example, if the input vector is [1 0 0], the population count is 1\n// If the input vector is [0 1 0], the population count is 2\n// If the input vector is [0 0 1], the population count is 1\n// If the input vector is [1 1 1], the population count is 3\n// If the input vector is [1 1 0], the population count is 2\n// If the input vector is [1 0 1], the population count is 2\n// If the input vector is [0 1 1], the population count is 2\n// If the input vector is [0 0 0], the population count is 0\n// If the input vector is [0 0 1], the population count is 1\n// If the input vector is [0 1 0], the population count is 1\n// If the input vector is [1 0 0], the population count is 1\n// If the input vector is [1 1 0], the population count is 2\n// If the input vector is [1 0 1], the population count is 2\n// If the input vector is [0 1 1], the population count is 2\n// If the input vector is [0 0 0], the population count is 0\n// If the input vector is [0 0 1], the population count is 1\n// If the input vector is [0 1 0], the population count is 1\n// If the input vector is [1 0 0], the population count is 1\n// If the input vector is [1 1 1], the population count is 3\n// If the input vector is [1 1 0], the population count is 2\n// If the input vector is [1 0 1], the population count is 2\n// If the input vector is [0 1 1], the population count is 2\n// If the input vector is [0 0 0], the population count is 0\n// If the input vector is [0 0 1], the population count is 1\n// If the input vector is [0 1 0], the population count is 1\n// If the input vector is [1 0 0], the population count is 1\n// If the input vector is [1 1 0], the population count is 2\n// If the input vector is [1 0 1], the population count is 2\n// If the input vector is [0 1 1], the population count is 2\n// If the input vector is [0 0 0], the population count is 0\n // If the input vector is [0 0 1], the population count is 1\n // If the input vector is [0 1 0], the population count is 1\n // If the input vector is [1 0 0], the population count is 1\n // If the input vector is [1 1 1], the population count is 3\n // If the input vector is [1 1 0], the population count is 2\n // If the input vector is [1 0 1], the population count is 2\n // If the input vector is [0 1 1], the population count is 2\n // If the input vector is [0 0 1], the population count is 1\n // If the input vector is [0 1 0], the population count is 1\n // If the input vector is [1 0 1], the population count is 2\n // If the input vector is [0 0 0], the population count is 0\n // If the input vector is [1 0 0], the population count is 1\n // If the input vector is [1 1 1], the population count is 3\n // If the input vector is [1 1 0], the population count is 2\n // If the input vector is [1 0 0], the population count is 1\n // If the input vector is [1 0 1], the population count is 2\n // If the input vector is [0 1 1], the population count is"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    assign out[19] = ~b ^ c;\n    assign out[18] = ~b ^ d;\n    assign out[17] = ~b ^ e;\n    assign out[16] = ~c ^ d;\n    assign out[15] = ~c ^ e;\n    assign out[14] = ~d ^ e;\n    assign out[13] = ~a ^ b;\n    assign out[12] = ~a ^ c;\n    assign out[11] = ~a ^ d;\n    assign out[10] = ~a ^ e;\n    assign out[ 9] = ~b ^ c;\n    assign out[ 8] = ~b ^ d;\n    assign out[ 7] = ~b ^ e;\n    assign out[ 6] = ~c ^ d;\n    assign out[ 5] = ~c ^ e;\n    assign out[ 4] = ~d ^ e;\n    assign out[ 3] = ~a ^ b;\n    assign out[ 2] = ~a ^ c;\n    assign out[ 1] = ~a ^ d;\n    assign out[ 0] = ~a ^ e;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= 1'b0;\n\t\twalk_left <= 1'b1;\n\t\twalk_right <= 1'b0;\n\tend else begin\n\t\tcase (state)\n\t\t\t1'b0: begin\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tstate <= 1'b1;\n\t\t\t\t\twalk_left <= 1'b0;\n\t\t\t\t\twalk_right <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t1'b1: begin\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tstate <= 1'b0;\n\t\t\t\t\twalk_left <= 1'b1;\n\t\t\t\t\twalk_right <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = (a & ~b) | (~a & b) | (a & b);\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// The four internal wires that will be used to drive the output signals.\nwire and1_out;\nwire and2_out;\nwire and3_out;\nwire and4_out;\n\n// The two AND gates that make up the first OR gate (p1y)\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\n\n// The two AND gates that make up the second OR gate (p2y)\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\n\n// The two OR gates that make up the final output signals\nassign p1y = and1_out | and2_out;\nassign p2y = and3_out | and4_out;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "// Verilog code\n\n```verilog\nalways @ (posedge clk) begin\n\tcase (y)\n\t\t3'b000: begin\n\t\t\tif (x == 0)\n\t\t\t\tY0 <= 0;\n\t\t\telse\n\t\t\t\tY0 <= 1;\n\t\t\tz <= 0;\n\t\tend\n\t\t3'b001: begin\n\t\t\tif (x == 0)\n\t\t\t\tY0 <= 0;\n\t\t\telse\n\t\t\t\tY0 <= 1;\n\t\t\tz <= 0;\n\t\tend\n\t\t3'b010: begin\n\t\t\tif (x == 0)\n\t\t\t\tY0 <= 0;\n\t\t\telse\n\t\t\t\tY0 <= 1;\n\t\t\tz <= 0;\n\t\tend\n\t\t3'b011: begin\n\t\t\tif (x == 0)\n\t\t\t\tY0 <= 0;\n\t\t\telse\n\t\t\t\tY0 <= 1;\n\t\t\tz <= 1;\n\t\tend\n\t\t3'b100: begin\n\t\t\tif (x == 0)\n\t\t\t\tY0 <= 0;\n\t\t\telse\n\t\t\t\tY0 <= 1;\n\t\t\tz <= 1;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    reg q;\n\n    always @(posedge clk or negedge ar) begin\n        if (ar == 0) begin\n            q <= 1'b0;\n        end\n        else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        0: out = data0;\n        1: out = data1;\n        2: out = data2;\n        3: out = data3;\n        4: out = data4;\n        5: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\nreg [9:0] counter;\nreg tc_reg;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n        tc_reg <= 0;\n    end\n    else begin\n        if (counter == 0) begin\n            tc_reg <= 1;\n        end\n        else begin\n            tc_reg <= 0;\n            counter <= counter - 1;\n        end\n    end\nend\n\nassign tc = tc_reg;\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "endmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module or function. Your code should be as concise as possible.\n\nmodule top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if(reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "// Registers to store the previous input value\nreg [7:0] prev_in;\n\n// Detect any edge from 0 to 1\nalways @(posedge clk) begin\n\tanyedge <= 0;\n\tfor (int i = 0; i < 8; i = i + 1) begin\n\t\tif (in[i] && !prev_in[i]) begin\n\t\t\tanyedge[i] <= 1;\n\t\tend\n\tend\n\tprev_in <= in;\nend\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "always @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'd1;\n\t\tend\n\t\telse begin\n\t\t\tif (q == 4'd10) begin\n\t\t\t\tq <= 4'd1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 1;\n\t\t\tend\n\t\tend\n\t  end\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    reg [2:0] q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= {q_reg[1:0], a};\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "// LFSR state\nreg [4:0] state;\n\n// Tap positions\nparameter TAP_POSITIONS = 2'b11;\n\n// Next state logic\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 5'b10001;\n\t\tq <= 1'b1;\n\tend\n\telse begin\n\t\tstate <= {state[4], state[4:1] ^ state[TAP_POSITIONS]};\n\t\tq <= state[0];\n\tend\nend\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n    always @(*) begin\n        if (do_sub == 0) begin\n            out = a + b;\n        end else begin\n            out = a - b;\n        end\n        if (out == 0) begin\n            result_is_zero = 1;\n        end\n    end\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "// 00 x[3] = 0, x[4] = 0\n// 01 x[3] = 0, x[4] = 1\n// 11 x[3] = 1, x[4] = 1\n// 10 x[3] = 1, x[4] = 0\n\n// x[3] is an input, so we can't decide its value\n// x[4] is an input, so we can't decide its value\n\n// x[1] and x[2] are don't cares, so we can decide their values\n\nalways @(*) begin\n\tcase (x)\n\t\t// 00\n\t\t4'b0000: f = 1'b0;\n\t\t// 01\n\t\t4'b0001: f = 1'b0;\n\t\t4'b0011: f = 1'b1;\n\t\t// 11\n\t\t4'b0100: f = 1'b1;\n\t\t4'b0101: f = 1'b1;\n\t\t4'b0111: f = 1'b1;\n\t\t// 10\n\t\t4'b1000: f = 1'b1;\n\t\t4'b1001: f = 1'b1;\n\t\t4'b1011: f = 1'b1;\n\t\t// default\n\t\tdefault: f = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "// Verilog code for the 8-bit to 4-bit keycode translation circuit\n\nalways @(*) begin\n\tcase (code)\n\t\t8'h45: begin\n\t\t\tout = 4'b0000;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h16: begin\n\t\t\tout = 4'b0001;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h1e: begin\n\t\t\tout = 4'b0010;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h26: begin\n\t\t\tout = 4'b0011;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h25: begin\n\t\t\tout = 4'b0100;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h2e: begin\n\t\t\tout = 4'b0101;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h36: begin\n\t\t\tout = 4'b0110;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h3d: begin\n\t\t\tout = 4'b0111;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h3e: begin\n\t\t\tout = 4'b1000;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\t8'h46: begin\n\t\t\tout = 4'b1001;\n\t\t\tvalid = 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tout = 4'b0000;\n\t\t\tvalid = 1'b0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "assign out = {in[0], in[7], in[1], in[6], in[2], in[5], in[3], in[4]};"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\n\nalways @(*) begin\n\tcase({a,b,c,d})\n\t\t4'b0000: out = 1'b1;\n\t\t4'b0001: out = 1'b0;\n\t\t4'b0010: out = 1'b1;\n\t\t4'b0011: out = 1'b0;\n\t\t4'b0100: out = 1'b0;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0110: out = 1'b1;\n\t\t4'b0111: out = 1'b1;\n\t\t4'b1000: out = 1'b0;\n\t\t4'b1001: out = 1'b0;\n\t\t4'b1010: out = 1'b1;\n\t\t4'b1011: out = 1'b1;\n\t\t4'b1100: out = 1'b0;\n\t\t4'b1101: out = 1'b0;\n\t\t4'b1110: out = 1'b1;\n\t\t4'b1111: out = 1'b1;\n\t\tdefault: out = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "endmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "reg [1:0] state;\n\tparameter IDLE = 2'b00;\n\tparameter COUNTING = 2'b01;\n\tparameter SHIFTING = 2'b10;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tshift_ena <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (count == 4'b0001) begin\n\t\t\t\t\t\tstate <= COUNTING;\n\t\t\t\t\t\tcount <= 4'b0000;\n\t\t\t\t\t\tshift_ena <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tcount <= count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tCOUNTING: begin\n\t\t\t\t\tif (count == 4'b0010) begin\n\t\t\t\t\t\tstate <= SHIFTING;\n\t\t\t\t\t\tshift_ena <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tcount <= count + 1;\n\t\t\t\t\t\tshift_ena <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSHIFTING: begin\n\t\t\t\t\tif (count == 4'b0100) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tcount <= 4'b0000;\n\t\t\t\t\t\tshift_ena <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tcount <= count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module should have a 4-bit output (q) and two input signals (clk and reset). The output (q) should be the current value of the counter. The counter should increment by one every time the clock ticks. Use the always block to update the counter.\n\nFollow the Verilog coding guidelines and conventions to make your code easy to read and maintain.\n\nModule top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "// Using assign statement\n\t\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\t\t\n\t\t// Using procedural if statement\n\t\talways @(*) begin\n\t\t\tif(sel_b1 & sel_b2)\n\t\t\t\tout_always = b;\n\t\t\telse\n\t\t\t\tout_always = a;\n\t\tend\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "// Verilog code for the circuit described by the Karnaugh map\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nassign out = ((~a & b & c) | (a & b & ~c) | (a & ~b & c) | (~a & ~b & ~c));\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "// State encoding\nparameter [3:1] A = 3'b000;\nparameter [3:1] B = 3'b001;\nparameter [3:1] C = 3'b010;\nparameter [3:1] D = 3'b011;\n\n// State variables\nreg [3:1] current_state;\nreg [3:1] next_state;\n\n// Output variables\nreg g1;\nreg g2;\nreg g3;\n\n// State table\nalways @(posedge clk, negedge resetn) begin\n\tif (~resetn) begin\n\t\tcurrent_state <= A;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tcase (current_state)\n\t\tA: begin\n\t\t\tif (r[1]) begin\n\t\t\t\tnext_state = B;\n\t\t\t\tg1 = 1;\n\t\t\tend else if (r[2]) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tg2 = 1;\n\t\t\tend else if (r[3]) begin\n\t\t\t\tnext_state = D;\n\t\t\t\tg3 = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (r[1]) begin\n\t\t\t\tnext_state = B;\n\t\t\t\tg1 = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\t\tg1 = 0;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (r[2]) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tg2 = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\t\tg2 = 0;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (r[3]) begin\n\t\t\t\tnext_state = D;\n\t\t\t\tg3 = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// State flip-flops\nalways @(posedge clk, negedge resetn) begin\n\tif (~resetn) begin\n\t\tcurrent_state <= A;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\tend\nend\n\n// Output flip-flops\nalways @(posedge clk, negedge resetn) begin\n\tif (~resetn) begin\n\t\tg1 <= 0;\n\t\tg2 <= 0;\n\t\tg3 <= 0;\n\tend else begin\n\t\tg1 <= (current_state == B) ? 1 : 0;\n\t\tg2 <= (current_state == C) ? 1 : 0;\n\t\tg3 <= (current_state == D) ? 1 : 0;\n\tend\nend\n\n// Assign outputs\nassign g = {g3, g2, g1};\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "endmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "assign out_and = in[0] & in[1] & in[2] & in[3];"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // State-assigned table\n    localparam [2:0] S_0 = 3'b000;\n    localparam [2:0] S_1 = 3'b001;\n    localparam [2:0] S_2 = 3'b010;\n    localparam [2:0] S_3 = 3'b011;\n    localparam [2:0] S_4 = 3'b100;\n\n    // State register\n    reg [2:0] state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= S_0;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                S_0: begin\n                    if (x) next_state = S_1;\n                    else next_state = S_0;\n                    z = 1'b0;\n                end\n                S_1: begin\n                    if (x) next_state = S_2;\n                    else next_state = S_1;\n                    z = 1'b0;\n                end\n                S_2: begin\n                    if (x) next_state = S_3;\n                    else next_state = S_1;\n                    z = 1'b0;\n                end\n                S_3: begin\n                    if (x) next_state = S_4;\n                    else next_state = S_1;\n                    z = 1'b1;\n                end\n                S_4: begin\n                    if (x) next_state = S_3;\n                    else next_state = S_1;\n                    z = 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "endmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "In Verilog, the default value for a register is 0. So if you reset to 0, the flip-flops will go to 0. Use the initial value to set the flip-flops to 0x34.\nFollow the Verilog coding guidelines to make your code more readable and understandable.\n```verilog\n\tinitial begin\n\t\tq <= 8'h34;\n\tend\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'h34;\n\t\tend\n\t\telse begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    always @(*) begin\n        case(state)\n            2'b00: begin // A\n                if(in == 1'b0) begin\n                    next_state = 2'b00;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end\n            end\n            2'b01: begin // B\n                if(in == 1'b0) begin\n                    next_state = 2'b10;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end\n            end\n            2'b10: begin // C\n                if(in == 1'b0) begin\n                    next_state = 2'b00;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b11;\n                    out = 1'b1;\n                end\n            end\n            2'b11: begin // D\n                if(in == 1'b0) begin\n                    next_state = 2'b10;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b01;\n                    out = 1'b1;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    wire x_wire, y_wire, z_wire;\n\n    // First stage\n    assign x_wire = x;\n    assign y_wire = y;\n    assign z_wire = 1;\n    \n    // Second stage\n    assign z_wire = (x_wire & y_wire) | (x_wire & z_wire) | (y_wire & z_wire);\n    \n    // Third stage\n    assign z = z_wire;\n    \nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// Write the state table. Use a 3-bit state code (A, B, C, D, E, F) and a 2-bit input code (00, 01, 10, 11).\n\n// Write the state flip-flops. Use 3 bits for the state register (S) and 2 bits for the input register (I).\n\n// Write the state output. Use z to represent the output of the FSM.\n\n// Write the FSM logic. Use a case statement to determine the next state based on the current state and input.\n\n// Write the reset logic. Reset the FSM to state A.\n\n// Write the output logic. Output the value of the state register (S).\n\n// Write the state table\n\n```verilog\n\treg [2:0] S;\n\treg [1:0] I;\n\n\talways @(posedge clk)\n\tbegin\n\t\tif (reset)\n\t\t\tS <= 3'b000;\n\t\telse\n\t\t\tS <= next_state;\n\tend\n\n\talways @(S or I)\n\tbegin\n\t\tcase (S)\n\t\t\t3'b000: // state A\n\t\t\t\tif (I == 2'b00)\n\t\t\t\t\tnext_state = 3'b000;\n\t\t\t\telse\n\t\t\t\t\tnext_state = 3'b001;\n\t\t\t3'b001: // state B\n\t\t\t\tif (I == 2'b01)\n\t\t\t\t\tnext_state = 3'b010;\n\t\t\t\telse\n\t\t\t\t\tnext_state = 3'b011;\n\t\t\t3'b010: // state C\n\t\t\t\tif (I == 2'b01)\n\t\t\t\t\tnext_state = 3'b100;\n\t\t\t\telse\n\t\t\t\t\tnext_state = 3'b101;\n\t\t\t3'b011: // state D\n\t\t\t\tif (I == 2'b01)\n\t\t\t\t\tnext_state = 3'b110;\n\t\t\t\telse\n\t\t\t\t\tnext_state = 3'b000;\n\t\t\t3'b100: // state E\n\t\t\t\tif (I == 2'b01)\n\t\t\t\t\tnext_state = 3'b100;\n\t\t\t\telse\n\t\t\t\t\tnext_state = 3'b101;\n\t\t\t3'b101: // state F\n\t\t\t\tif (I == 2'b01)\n\t\t\t\t\tnext_state = 3'b010;\n\t\t\t\telse\n\t\t\t\t\tnext_state = 3'b101;\n\t\t\tdefault:\n\t\t\t\tnext_state = 3'b000;\n\t\tendcase\n\tend\n\n\talways @(S)\n\tbegin\n\t\tcase (S)\n\t\t\t3'b000: z = 1'b0;\n\t\t\t3'b001: z = 1'b1;\n\t\t\t3'b010: z = 1'b0;\n\t\t\t3'b011: z = 1'b1;\n\t\t\t3'b100: z = 1'b0;\n\t\t\t3'b101: z = 1'b1;\n\t\t\t3'b110: z = 1'b0;\n\t\t\t3'b111: z = 1'b1;\n\t\t\tdefault: z = 1'b0;\n\t\tendcase\n\tend\n\n\talways @(posedge clk)\n\tbegin\n\t\tif (reset)\n\t\t\tI <= 2'b00;\n\t\telse\n\t\t\tI <= w;\n\tend\n\n\talways @(S)\n\tbegin\n\t\tcase (S)\n\t\t\t3'b000: z = 1'b0;\n\t\t\t3'b001: z ="}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) begin\n\t\t\tq <= 16'b0;\n\t\tend else begin\n\t\t\tif (byteena[1]) begin\n\t\t\t\tq[15:8] <= d[15:8];\n\t\t\tend\n\t\t\tif (byteena[0]) begin\n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\tend\n\t\tend\n\tend\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "followed by the Verilog code for the edge detect module.\n\nDo not use any Verilog language features that are not needed.\n\nFollow Verilog coding conventions, such as indentation and spacing.\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\n\treg [7:0] prev_in;\n\n\talways @(posedge clk) begin\n\t\tif (in != prev_in) begin\n\t\t\tpedge <= in;\n\t\tend\n\t\tprev_in <= in;\n\tend\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg a_reg;\n    reg p_reg;\n    reg q_reg;\n\n    always @ (posedge clock) begin\n        a_reg <= a;\n    end\n\n    always @ (posedge clock) begin\n        if (a_reg == 0) begin\n            p_reg <= 1'bx;\n        end else if (a_reg == 1) begin\n            p_reg <= 1'b0;\n        end else if (a_reg == 2) begin\n            p_reg <= 1'b1;\n        end\n    end\n\n    always @ (posedge clock) begin\n        if (a_reg == 0) begin\n            q_reg <= 1'bx;\n        end else if (a_reg == 1) begin\n            q_reg <= 1'b0;\n        end else if (a_reg == 2) begin\n            q_reg <= 1'b1;\n        end\n    end\n\n    assign p = p_reg;\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n    wire [511:0] q_prev;\n\n    // Rule 90 module instances\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : rule90_insts\n            rule90 rule90_inst (\n                .a(q[i-1]),\n                .b(q[i]),\n                .c(next_q[i])\n            );\n        end\n    endgenerate\n\n    // Load initial state\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q <= next_q;\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "assign z = (A == B) ? 1 : 0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // Compute out_both\n    assign out_both[98:0] = {in[99], in[99:1]} & {in[99], in[99:1]};\n\n    // Compute out_any\n    assign out_any[99] = in[99];\n    assign out_any[98:0] = {in[99], in[99:1]} | {in[0], in[99:1]};\n\n    // Compute out_different\n    assign out_different[99:1] = in[99:1] ^ in[0];\n    assign out_different[0] = in[0];\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "followed by the Verilog code to implement the 256-to-1 multiplexer.\n\n```verilog\nreg [3:0] out_reg;\n\nalways @(*) begin\n\tcase (sel)\n\t\t8'h00: out_reg = in[3:0];\n\t\t8'h01: out_reg = in[7:4];\n\t\t8'h02: out_reg = in[11:8];\n\t\t8'h03: out_reg = in[15:12];\n\t\t8'h04: out_reg = in[19:16];\n\t\t8'h05: out_reg = in[23:20];\n\t\t8'h06: out_reg = in[27:24];\n\t\t8'h07: out_reg = in[31:28];\n\t\t8'h08: out_reg = in[35:32];\n\t\t8'h09: out_reg = in[39:36];\n\t\t8'h0A: out_reg = in[43:40];\n\t\t8'h0B: out_reg = in[47:44];\n\t\t8'h0C: out_reg = in[51:48];\n\t\t8'h0D: out_reg = in[55:52];\n\t\t8'h0E: out_reg = in[59:56];\n\t\t8'h0F: out_reg = in[63:60];\n\t\t8'h10: out_reg = in[67:64];\n\t\t8'h11: out_reg = in[71:68];\n\t\t8'h12: out_reg = in[75:72];\n\t\t8'h13: out_reg = in[79:76];\n\t\t8'h14: out_reg = in[83:80];\n\t\t8'h15: out_reg = in[87:84];\n\t\t8'h16: out_reg = in[91:88];\n\t\t8'h17: out_reg = in[95:92];\n\t\t8'h18: out_reg = in[99:96];\n\t\t8'h19: out_reg = in[103:100];\n\t\t8'h1A: out_reg = in[107:104];\n\t\t8'h1B: out_reg = in[111:108];\n\t\t8'h1C: out_reg = in[115:112];\n\t\t8'h1D: out_reg = in[119:116];\n\t\t8'h1E: out_reg = in[123:120];\n\t\t8'h1F: out_reg = in[127:124];\n\t\t8'h20: out_reg = in[131:128];\n\t\t8'h21: out_reg = in[135:132];\n\t\t8'h22: out_reg = in[139:136];\n\t\t8'h23: out_reg = in[143:140];\n\t\t8'h24: out_reg = in[147:144];\n\t\t8'h25: out_reg = in[151:148];\n\t\t8'h26: out_reg = in[155:152];\n\t\t8'h27: out_reg = in[159:156];\n\t\t8'h28: out_reg = in[163:160];\n\t\t8'h29: out_reg = in[167:164];\n\t\t8'h2A: out_reg = in[171:168];\n\t\t8'h2B: out_reg = in[175:172];\n\t\t8'h2C: out_"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "// 9-to-1 multiplexer\nalways @(*) begin\n\tcase (sel)\n\t\t4'h0: out = a;\n\t\t4'h1: out = b;\n\t\t4'h2: out = c;\n\t\t4'h3: out = d;\n\t\t4'h4: out = e;\n\t\t4'h5: out = f;\n\t\t4'h6: out = g;\n\t\t4'h7: out = h;\n\t\t4'h8: out = i;\n\t\tdefault: out = 16'hFFFF;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise-OR of the two vectors\n    assign out_or_bitwise = a | b;\n    \n    // Logical-OR of the two vectors\n    assign out_or_logical = (a != 0) || (b != 0);\n    \n    // Inverse of both vectors\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n    \nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        if(a < b && a < c && a < d)\n            min = a;\n        else if(b < a && b < c && b < d)\n            min = b;\n        else if(c < a && c < b && c < d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    wire abcd;\n    \n    assign abcd = {a, b, c, d};\n    \n    assign out = (abcd == 4'b0001) ? 1'b1 :\n                (abcd == 4'b0010) ? 1'b1 :\n                (abcd == 4'b0100) ? 1'b1 :\n                (abcd == 4'b1000) ? 1'b1 :\n                (abcd == 4'b0110) ? 1'b0 :\n                (abcd == 4'b1010) ? 1'b0 :\n                (abcd == 4'b1100) ? 1'b0 :\n                (abcd == 4'b1110) ? 1'b0 :\n                (abcd == 4'b1001) ? 1'b1 :\n                (abcd == 4'b0111) ? 1'b0 :\n                (abcd == 4'b1111) ? 1'b1 :\n                1'b0;\n    \nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "endmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n    reg [3:0] next_shift_reg;\n\n    always @(posedge clk) begin\n        if (~resetn) begin\n            shift_reg <= 4'b0000;\n        end\n        else begin\n            shift_reg <= next_shift_reg;\n        end\n    end\n\n    always @(*) begin\n        next_shift_reg[0] = in;\n        next_shift_reg[1:3] = shift_reg[0:2];\n    end\n\n    assign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "and end with:\n```verilog\n\talways @*\n\tbegin\n\t\tcase (in)\n\t\t\t4'b0000: pos = 2'd0;\n\t\t\t4'b0001: pos = 2'd1;\n\t\t\t4'b0010: pos = 2'd2;\n\t\t\t4'b0011: pos = 2'd3;\n\t\t\t4'b0100: pos = 2'd4;\n\t\t\t4'b0101: pos = 2'd5;\n\t\t\t4'b0110: pos = 2'd6;\n\t\t\t4'b0111: pos = 2'd7;\n\t\t\t4'b1000: pos = 2'd8;\n\t\t\t4'b1001: pos = 2'd9;\n\t\t\t4'b1010: pos = 2'd10;\n\t\t\t4'b1011: pos = 2'd11;\n\t\t\t4'b1100: pos = 2'd12;\n\t\t\t4'b1101: pos = 2'd13;\n\t\t\t4'b1110: pos = 2'd14;\n\t\t\t4'b1111: pos = 2'd15;\n\t\t\tdefault: pos = 2'd0;\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Define states\n  parameter OFF = 2'b00;\n  parameter ON = 2'b01;\n\n  // Define outputs\n  parameter out_OFF = 1'b0;\n  parameter out_ON = 1'b1;\n\n  // Define state register and output register\n  reg [1:0] state;\n  reg out_reg;\n\n  // Define next state logic\n  always @ (posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= OFF;\n      out_reg <= out_OFF;\n    end else begin\n      case (state)\n        OFF: begin\n          if (j) begin\n            state <= ON;\n          end else begin\n            state <= OFF;\n          end\n        end\n        ON: begin\n          if (k) begin\n            state <= OFF;\n          end else begin\n            state <= ON;\n          end\n        end\n      endcase\n    end\n  end\n\n  // Define output logic\n  always @ (state) begin\n    case (state)\n      OFF: out_reg <= out_OFF;\n      ON: out_reg <= out_ON;\n    endcase\n  end\n\n  // Assign output\n  assign out = out_reg;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "Then, inside the module, assign the output to 0:\n```verilog\n\tassign out = 1'b0;\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "Make sure to use meaningful names for your signals and variables. Your Verilog code should be easy to read and understand.\n\n  Indent your code properly. Use tabs to align the code and make it visually appealing.\n\n  Use comments to explain the purpose of each block of code. This will help the readers of your code understand the logic behind your design.\n\n  Do not repeat yourself. Use the Verilog constructs to the fullest to write concise and readable code.\n\n  Do not leave unused signals or variables in your code. Remove them to avoid any confusion.\n\n  Do not use magic numbers in your code. Use constants to represent them.\n\n  Module top_module(\n\toutput one);\n\n\tassign one = 1'b1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "The Verilog code for the D flip-flop with XOR input should be:\n```verilog\nreg d;\nalways @(posedge clk) begin\n\td <= in ^ d;\nend\nassign out = d;\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "// (1) areset: Resets shift register to zero.\nalways @(posedge areset)\n\tq <= 4'b0000;\n\n// (2) load: Loads shift register with data[3:0] instead of shifting.\nalways @(posedge clk)\n\tif (load)\n\t\tq <= data;\n\n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).\nalways @(posedge clk)\n\tif (ena)\n\t\tq <= {q[2:0], 1'b0};\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (x3 & x2 & x1) ? 1'b1 :\n        (x3 & x2 & ~x1) ? 1'b0 :\n        (x3 & ~x2 & x1) ? 1'b1 :\n        (x3 & ~x2 & ~x1) ? 1'b0 :\n        (~x3 & x2 & x1) ? 1'b1 :\n        (~x3 & x2 & ~x1) ? 1'b1 :\n        (~x3 & ~x2 & x1) ? 1'b0 :\n        (~x3 & ~x2 & ~x1) ? 1'b0 :\n        1'bz;\n\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "Do not add any comments in the Verilog code.\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk or negedge areset) begin\n\t\tif(!areset) begin\n\t\t\tq <= 8'b0;\n\t\tend\n\t\telse begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "The Verilog code for a half adder is as follows:\n```verilog\n\txor #(.N(1)) xor1(sum, a, b);\n\tand #(.N(1)) and1(cout, a, b);\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module\n\nmodule top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// MOORE state machine\n// 2 states\n// 2 inputs\n// 1 output\n// reset is active-high synchronous reset to state OFF\n\n// states\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// outputs\nparameter out_OFF = 1'b0;\nparameter out_ON = 1'b1;\n\n// state register\nreg [1:0] state;\n\n// output register\nreg out_reg;\n\n// state transition logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= OFF;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// output logic\nalways @(state) begin\n\tcase (state)\n\t\tOFF: out_reg <= out_OFF;\n\t\tON: out_reg <= out_ON;\n\tendcase\nend\n\n// assign output\nassign out = out_reg;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    wire e;\n    wire f;\n    wire g;\n    wire h;\n    wire i;\n    wire j;\n    wire k;\n\n    assign e = a & b;\n    assign f = c | d;\n    assign g = e & f;\n    assign h = a | b;\n    assign i = c & d;\n    assign j = h & i;\n    assign k = j & g;\n    assign q = k;\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // Define the state register and initialize to B\n    reg [1:0] state = B;\n\n    // Define the output register and initialize to 0\n    reg out_reg = 0;\n\n    always @(posedge clk) begin\n        // Reset logic\n        if (reset) begin\n            state <= B;\n            out_reg <= 0;\n        end\n        else begin\n            // State transition logic\n            case (state)\n                A: begin\n                    if (in) begin\n                        state <= A;\n                    end\n                    else begin\n                        state <= B;\n                    end\n                end\n                B: begin\n                    if (in) begin\n                        state <= B;\n                    end\n                    else begin\n                        state <= A;\n                    end\n                end\n            endcase\n            // Output logic\n            case (state)\n                A: begin\n                    out_reg <= 0;\n                end\n                B: begin\n                    out_reg <= 1;\n                end\n            endcase\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "endianness: little\n\n```verilog\nwire w1, w2, w3;\n\nassign w1 = a ^ b;\nassign w2 = a & b;\nassign w3 = w1 ^ cin;\n\nassign sum = w1 ^ cin;\nassign cout = w2 | (w1 & cin);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module should be named top_module and it should have three inputs (in1, in2, in3) and one output (out). Do not use the deprecated logic data type. out should be an XOR of the output of the XNOR (in1, in2) and in3.\n\nFollow the Verilog syntax and coding standards. Do not introduce any new errors. \n\nmodule top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    wire xnor_out;\n\n    xnor_gate xnor1 (\n        .in1(in1),\n        .in2(in2),\n        .out(xnor_out)\n    );\n\n    xor_gate xor1 (\n        .in1(xnor_out),\n        .in2(in3),\n        .out(out)\n    );\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "assign mux_in[0] = (c & ~d) | (~c & d);\nassign mux_in[1] = (c & d) | (~c & ~d);\nassign mux_in[2] = (c & d) | (~c & ~d);\nassign mux_in[3] = (c & ~d) | (~c & d);"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// One-hot encoding for states\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// State register\nreg [1:0] state;\n\n// Output register\nreg z_reg;\n\n// Next state logic\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= A;\n\t\tz_reg <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\tz_reg <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= A;\n\t\t\t\t\tz_reg <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\tz_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= A;\n\t\t\t\t\tz_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output assignment\nassign z = z_reg;\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg [1:0] q_reg;\n    reg state_reg;\n\n    always @(posedge clk) begin\n        if (a && b) begin\n            q_reg <= 2'b00;\n            state_reg <= 1'b1;\n        end else if (a) begin\n            q_reg <= 2'b01;\n            state_reg <= 1'b0;\n        end else if (b) begin\n            q_reg <= 2'b10;\n            state_reg <= 1'b0;\n        end else begin\n            q_reg <= 2'b11;\n            state_reg <= 1'b0;\n        end\n    end\n\n    assign q = q_reg[1];\n    assign state = state_reg;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n    assign f = (x[3] == 1'b0) ? (x[1] == 1'b1) : ((x[1] == 1'b0) || (x[2] == 1'b1));\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "Do not add any additional code outside the FSM. Each state should be identified by a unique name and the next state is determined by the current state and the input. The output signals should be asserted based on the current state. Do not include the output signals in the state transition logic. The output signals should be asserted outside the state transition logic. If an error occurs, the state should be reset to the initial state. Include the state transition logic, state encoding, and output signals. Use the Verilog keyword `always` to define the state transition logic.\n```verilog\n\treg [2:0] state;\n\tparameter S0 = 3'd0;\n\tparameter S1 = 3'd1;\n\tparameter S2 = 3'd2;\n\tparameter S3 = 3'd3;\n\tparameter S4 = 3'd4;\n\tparameter S5 = 3'd5;\n\tparameter S6 = 3'd6;\n\treg [3:0] count;\n\treg [2:0] next_state;\n\treg [2:0] prev_state;\n\treg [2:0] error_count;\n\treg [2:0] flag_count;\n\treg [2:0] disc_count;\n\treg [2:0] error_flag;\n\treg [2:0] flag_disc;\n\treg [2:0] disc_count_error;\n\treg [2:0] flag_error;\n\treg [2:0] flag_disc_error;\n\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tcount <= 4'd0;\n\t\t\tnext_state <= S0;\n\t\t\tprev_state <= S0;\n\t\t\terror_count <= 3'd0;\n\t\t\tflag_count <= 3'd0;\n\t\t\tdisc_count <= 3'd0;\n\t\t\terror_flag <= 3'd0;\n\t\t\tflag_disc <= 3'd0;\n\t\t\tdisc_count_error <= 3'd0;\n\t\t\tflag_error <= 3'd0;\n\t\t\tflag_disc_error <= 3'd0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tnext_state <= S0;\n\t\t\t\t\t\tcount <= 4'd0;\n\t\t\t\t\t\tdisc_count <= 3'd0;\n\t\t\t\t\t\tflag_count <= 3'd0;\n\t\t\t\t\t\terror_flag <= 3'd0;\n\t\t\t\t\t\tflag_disc <= 3'd0;\n\t\t\t\t\t\tdisc_count_error <= 3'd0;\n\t\t\t\t\t\tflag_error <= 3'd0;\n\t\t\t\t\t\tflag_disc_error <= 3'd0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= S1;\n\t\t\t\t\t\tcount <= 4'd1;\n\t\t\t\t\t\tdisc_count <= 3'd0;\n\t\t\t\t\t\tflag_count <= 3'd0;\n\t\t\t\t\t\terror_flag <= 3'd0;\n\t\t\t\t\t\tflag_disc <= 3'd0;\n\t\t\t\t\t\tdisc_count_error <= 3'd0;\n\t\t\t\t\t\tflag_error <= 3'd0;\n\t\t\t\t\t\tflag_disc_error <= 3'd0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (count == 4'd5) begin\n\t\t\t\t\t\tnext_state <= S2;\n\t\t\t\t\t\tcount <= 4'd0;\n\t\t\t\t\t\tdisc_count <= 3'd1;\n\t\t\t\t\t\tflag_count <= 3'd0;\n\t\t\t\t\t\terror_flag <= 3'd0;"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module shift_register_4bit(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] data_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], data};\n    end\nend\n\nassign data_out = shift_reg;\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "// Verilog code\nmodule top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// State machine states\n\tparameter IDLE = 2'b00;\n\tparameter NOMINAL = 2'b01;\n\tparameter SUPPLEMENTAL = 2'b10;\n\n\t// State machine signals\n\treg [1:0] state;\n\treg [1:0] prev_state;\n\treg [1:0] next_state;\n\n\t// Water level to flow rate mapping\n\tparameter [1:0] WL_LEVEL = 2'b01;\n\tparameter [1:0] WL_LOWER_LEVEL = 2'b10;\n\tparameter [1:0] WL_HIGHER_LEVEL = 2'b11;\n\treg [1:0] wl_level;\n\treg [1:0] wl_previous;\n\treg [1:0] wl_current;\n\treg [1:0] flow_rate;\n\treg [1:0] nominal_flow_rate;\n\treg [1:0] supplemental_flow_rate;\n\n\t// Initialize signals\n\tinitial begin\n\t\tstate = IDLE;\n\t\tprev_state = IDLE;\n\t\tnext_state = IDLE;\n\t\twl_level = IDLE;\n\t\twl_previous = IDLE;\n\t\twl_current = IDLE;\n\t\tflow_rate = IDLE;\n\t\tnominal_flow_rate = IDLE;\n\t\tsupplemental_flow_rate = IDLE;\n\t\tfr3 = IDLE;\n\t\tfr2 = IDLE;\n\t\tfr1 = IDLE;\n\t\tdfr = IDLE;\n\tend\n\n\t// State machine\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tprev_state <= IDLE;\n\t\t\tnext_state <= IDLE;\n\t\t\twl_level <= IDLE;\n\t\t\twl_previous <= IDLE;\n\t\t\twl_current <= IDLE;\n\t\t\tflow_rate <= IDLE;\n\t\t\tnominal_flow_rate <= IDLE;\n\t\t\tsupplemental_flow_rate <= IDLE;\n\t\t\tfr3 <= IDLE;\n\t\t\tfr2 <= IDLE;\n\t\t\tfr1 <= IDLE;\n\t\t\tdfr <= IDLE;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tprev_state <= state;\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (s[1]) begin\n\t\t\t\t\t\tnext_state = NOMINAL;\n\t\t\t\t\t\twl_level = WL_LEVEL;\n\t\t\t\t\t\tnominal_flow_rate = 2'b01;\n\t\t\t\t\t\tflow_rate = nominal_flow_rate;\n\t\t\t\t\t\tfr3 = 1'b0;\n\t\t\t\t\t\tfr2 = 1'b0;\n\t\t\t\t\t\tfr1 = 1'b1;\n\t\t\t\t\t\tdfr = 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = SUPPLEMENTAL;\n\t\t\t\t\t\twl_level = WL_LOWER_LEVEL;\n\t\t\t\t\t\tnominal_flow_rate = 2'b00;\n\t\t\t\t\t\tflow_rate = nominal_flow_rate;\n\t\t\t\t\t\tfr3 = 1'b0;\n\t\t\t\t\t\tfr2 = 1'b1;\n\t\t\t\t\t\tfr1 = 1'b1;\n\t\t\t\t\t\tdfr = 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tNOMINAL: begin\n\t\t\t\t\tif (s[1] && !s[2]) begin\n\t\t\t\t\t\tnext_state = SUPPLEMENTAL;"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "Modules:\n```verilog\n// FSM states\nparameter IDLE = 2'b00;\nparameter START_BIT = 2'b01;\nparameter DATA_BITS = 2'b10;\nparameter STOP_BIT = 2'b11;\n\n// FSM signals\nreg [1:0] state;\nreg [7:0] data_reg;\nreg done_reg;\n\n// State machine\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\t\tdata_reg <= 8'b0;\n\t\tdone_reg <= 1'b0;\n\tend else begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= START_BIT;\n\t\t\t\t\tdata_reg <= 8'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART_BIT: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= DATA_BITS;\n\t\t\t\t\tdata_reg <= {data_reg[6:0], in};\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tdata_reg <= 8'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tDATA_BITS: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= STOP_BIT;\n\t\t\t\t\tdata_reg <= {data_reg[6:0], in};\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tdata_reg <= 8'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP_BIT: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tdata_reg <= 8'b0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Assign done output\nassign done = done_reg;\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output [7:0] out_byte,\n    output done\n);\n\n    reg [3:0] state;\n    reg [7:0] data;\n    reg done_reg;\n    wire start_bit = ~in;\n    wire stop_bit = in;\n    wire data_bit = in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 4'b0000;\n            data <= 8'b0;\n            done_reg <= 1'b0;\n        end\n        else begin\n            case (state)\n                4'b0000: begin\n                    if (start_bit) begin\n                        state <= 4'b0001;\n                    end\n                end\n                4'b0001: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0010;\n                    end\n                end\n                4'b0010: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0011;\n                    end\n                end\n                4'b0011: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0100;\n                    end\n                end\n                4'b0100: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0101;\n                    end\n                end\n                4'b0101: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0110;\n                    end\n                end\n                4'b0110: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0111;\n                    end\n                end\n                4'b0111: begin\n                    data <= {data_bit, data};\n                    if (data_bit) begin\n                        state <= 4'b0000;\n                        done_reg <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out_byte = data;\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // verilator lint_off UNUSED\n    reg [6:0] bhr;\n\n    wire [6:0] pht_index = predict_pc ^ bhr;\n    wire [1:0] pht_out;\n    wire [1:0] pht_out_next;\n\n    // PHT is 128 entries of 2-bit counters, indexed by xor of pc and global history\n    // The PHT is used to make branch direction predictions\n    // The PHT is also used to count the number of times a branch is predicted to be taken or not\n    // The PHT is used to recover the global history register to the state immediately after the mispredicting branch completes execution\n    // The PHT is used to train the branch predictor to predict this branch more accurately next time\n    // The PHT is not used to store the actual branch direction outcomes, that is done by the branch history register\n\n    // PHT is a saturating counter, so when it reaches 3, it can only increment or decrement by 1\n    // This is done to prevent the PHT from overflowing and corrupting the history register\n    // The PHT is also used to recover the global history register to the state immediately after the mispredicting branch completes execution\n    // The PHT is also used to train the branch predictor to predict this branch more accurately next time\n    // The PHT is incremented (by 1) for predicted taken branches, and decremented (by 1) for predicted not-taken branches\n    // The PHT is incremented (by 1) for mispredicted taken branches and decremented (by 1) for mispredicted not-taken branches\n    // The PHT is only incremented or decremented at the next positive clock edge after the branch outcome is known\n    // The PHT is also used to make branch direction predictions\n    // The PHT is indexed by the xor of the pc and global history register\n\n    assign pht_out = {2{1'b0}}; // initialize PHT to 0\n    assign pht_out_next = {2{1'b0}}; // initialize PHT next to 0\n    assign pht_out[0] = pht_out[1] ? 1'b1 : pht_out[0]; // saturating counter\n    assign pht_out[1] = pht_out[0] ? 1'b1 : pht_out[1]; // saturating counter\n\n    // PHT training\n    always @(posedge clk) begin\n        if (train_valid) begin\n            if (train_taken) begin\n                pht_out_next[0] <= pht_out_next[0] + 1;\n                pht_out_next[1] <= pht_out_next[1] + 1;\n            end\n            else begin\n                pht_out_next[0] <= pht_out_next[0] - 1;\n                pht_out_next[1] <= pht_out_next[1] - 1;\n            end\n        end\n    end\n\n    // PHT prediction\n    assign predict_taken = (pht_out_next[1] > pht_out_next[0]);\n    assign predict_history = bhr;\n\n    // PHT recovery\n    always @(posedge clk) begin\n        if (train_valid && train_mispredicted) begin\n            bhr <= train_history;\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    parameter initial_state = 2'b00;\n    parameter walk_left_state = 2'b01;\n    parameter walk_right_state = 2'b10;\n\n    reg [1:0] state;\n    reg [4:0] count;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= initial_state;\n            count <= 0;\n        end else begin\n            case (state)\n                initial_state: begin\n                    if (bump_left) begin\n                        state <= walk_right_state;\n                    end else if (bump_right) begin\n                        state <= walk_left_state;\n                    end\n                end\n                walk_left_state: begin\n                    if (bump_left) begin\n                        state <= walk_right_state;\n                    end else if (bump_right) begin\n                        state <= walk_left_state;\n                    end else if (dig) begin\n                        state <= digging_state;\n                    end\n                end\n                walk_right_state: begin\n                    if (bump_left) begin\n                        state <= walk_left_state;\n                    end else if (bump_right) begin\n                        state <= walk_right_state;\n                    end else if (dig) begin\n                        state <= digging_state;\n                    end\n                end\n                digging_state: begin\n                    if (count == 20) begin\n                        state <= walk_left_state;\n                    end else if (bump_left) begin\n                        state <= walk_right_state;\n                    end else if (bump_right) begin\n                        state <= walk_left_state;\n                    end\n                end\n            endcase\n            if (ground) begin\n                count <= 0;\n                aaah <= 0;\n            end else begin\n                count <= count + 1;\n                if (count == 20) begin\n                    aaah <= 1;\n                end\n            end\n            if (dig) begin\n                walk_left <= 0;\n                walk_right <= 0;\n                digging <= 1;\n            end else begin\n                walk_left <= (state == walk_left_state);\n                walk_right <= (state == walk_right_state);\n                digging <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "// Define states\nlocalparam IDLE = 2'd0;\nlocalparam START_SEQ = 2'd1;\nlocalparam COUNTING = 2'd2;\nlocalparam DONE = 2'd3;\n\n// Define state register and next state logic\nreg [1:0] state, next_state;\nalways @(posedge clk)\nbegin\n    if (reset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// Define output logic\nalways @(*)\nbegin\n    case (state)\n        IDLE: begin\n            shift_ena = 0;\n            counting = 0;\n            done = 0;\n            if (data == 1'b1)\n                next_state = START_SEQ;\n            else\n                next_state = IDLE;\n        end\n        START_SEQ: begin\n            shift_ena = 1;\n            counting = 0;\n            done = 0;\n            if (data == 1'b1)\n                next_state = START_SEQ;\n            else if (data == 1'b0)\n                next_state = COUNTING;\n            else\n                next_state = IDLE;\n        end\n        COUNTING: begin\n            shift_ena = 0;\n            counting = 1;\n            done = 0;\n            if (done_counting)\n                next_state = DONE;\n            else\n                next_state = COUNTING;\n        end\n        DONE: begin\n            shift_ena = 0;\n            counting = 0;\n            done = 1;\n            if (ack)\n                next_state = IDLE;\n            else\n                next_state = DONE;\n        end\n    endcase\nend\n\n// Define output register for shift_ena\nreg shift_ena_reg;\nalways @(posedge clk)\nbegin\n    if (reset)\n        shift_ena_reg <= 0;\n    else\n        shift_ena_reg <= shift_ena;\nend\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    // Local signals\n    wire [15:0] q_row [15:0];\n    wire [15:0] q_next;\n    wire [15:0] q_wrap;\n\n    // Assign the data to the q_row signals\n    assign q_row[0] = data[15:0];\n    assign q_row[1] = data[31:16];\n    assign q_row[2] = data[47:32];\n    assign q_row[3] = data[63:48];\n    assign q_row[4] = data[79:64];\n    assign q_row[5] = data[95:80];\n    assign q_row[6] = data[111:96];\n    assign q_row[7] = data[127:112];\n    assign q_row[8] = data[143:128];\n    assign q_row[9] = data[159:144];\n    assign q_row[10] = data[175:160];\n    assign q_row[11] = data[191:176];\n    assign q_row[12] = data[207:192];\n    assign q_row[13] = data[223:208];\n    assign q_row[14] = data[239:224];\n    assign q_row[15] = data[255:240];\n\n    // Wrap the q_row signals around the torus\n    assign q_wrap = {q_row[15], q_row[14], q_row[13], q_row[12], q_row[11], q_row[10], q_row[9], q_row[8], q_row[7], q_row[6], q_row[5], q_row[4], q_row[3], q_row[2], q_row[1], q_row[0], q_row[15], q_row[14], q_row[13], q_row[12], q_row[11], q_row[10], q_row[9], q_row[8], q_row[7], q_row[6], q_row[5], q_row[4], q_row[3], q_row[2], q_row[1], q_row[0]};\n\n    // Compute the next state of the game\n    assign q_next = {1'b0, q_wrap[15:1], q_wrap[15:2], q_wrap[15:3], q_wrap[15:4], q_wrap[15:5], q_wrap[15:6], q_wrap[15:7], q_wrap[15:8], q_wrap[15:9], q_wrap[15:10], q_wrap[15:11], q_wrap[15:12], q_wrap[15:13], q_wrap[15:14], q_wrap[15:15]};\n\n    // Load data into q at the next clock edge\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= 2'b00;\n\t\twalk_left <= 1'b1;\n\t\twalk_right <= 1'b0;\n\t\taaah <= 1'b0;\n\t\tdigging <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\t2'b00: begin // Walk left\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\twalk_left <= 1'b1;\n\t\t\t\t\twalk_right <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (dig) begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\twalk_left <= 1'b1;\n\t\t\t\t\twalk_right <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b01: begin // Walk right\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\twalk_left <= 1'b1;\n\t\t\t\t\twalk_right <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (dig) begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\twalk_left <= 1'b0;\n\t\t\t\t\twalk_right <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b10: begin // Digging\n\t\t\t\tif (ground == 1'b0) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\twalk_left <= 1'b0;\n\t\t\t\t\twalk_right <= 1'b1;\n\t\t\t\t\taaah <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse if (bump_left || bump_right) begin\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\twalk_left <= 1'b1;\n\t\t\t\t\twalk_right <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (dig == 1'b0) begin\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\twalk_left <= 1'b1;\n\t\t\t\t\twalk_right <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tdigging <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\t2'b00: begin // Walk left\n\t\t\t\tdigging <= 1'b0;\n\t\t\tend\n\t\t\t2'b01: begin // Walk right\n\t\t\t\tdigging <= 1'b0;\n\t\t\tend\n\t\t\t2'b10: begin // Digging\n\t\t\t\tdigging <= 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\taaah <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\t2'b00: begin // Walk left\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\taaah <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\taaah <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b01: begin // Walk right\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\taaah <= 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\taaah <= 1'b0;"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "// Parameters\n  parameter W = 3; // Width of the 2D world\n  parameter H = 3; // Height of the 2D world\n\n  // States\n  parameter WALK_LEFT = 2'b00;\n  parameter WALK_RIGHT = 2'b01;\n  parameter FALL = 2'b10;\n\n  // State register\n  reg [1:0] state_reg, state_next;\n\n  // Output registers\n  reg walk_left_reg, walk_right_reg, aaah_reg;\n\n  // Combinational logic\n  assign walk_left = walk_left_reg;\n  assign walk_right = walk_right_reg;\n  assign aaah = aaah_reg;\n\n  // State transition and output logic\n  always @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state_reg <= WALK_LEFT;\n      walk_left_reg <= 1'b1;\n      walk_right_reg <= 1'b0;\n      aaah_reg <= 1'b0;\n    end else begin\n      state_reg <= state_next;\n      case (state_reg)\n        WALK_LEFT: begin\n          walk_left_reg <= 1'b1;\n          walk_right_reg <= 1'b0;\n          if (bump_left) begin\n            state_next <= WALK_RIGHT;\n          end else if (ground == 1) begin\n            state_next <= WALK_LEFT;\n          end else begin\n            state_next <= FALL;\n            aaah_reg <= 1'b1;\n          end\n        end\n        WALK_RIGHT: begin\n          walk_left_reg <= 1'b0;\n          walk_right_reg <= 1'b1;\n          if (bump_right) begin\n            state_next <= WALK_LEFT;\n          end else if (ground == 1) begin\n            state_next <= WALK_RIGHT;\n          end else begin\n            state_next <= FALL;\n            aaah_reg <= 1'b1;\n          end\n        end\n        FALL: begin\n          walk_left_reg <= walk_right_reg;\n          if (ground == 1) begin\n            state_next <= state_reg;\n            aaah_reg <= 1'b0;\n          end else begin\n            state_next <= FALL;\n            aaah_reg <= 1'b1;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'b0;\n\t\t\tena <= 3'b0;\n\t\tend else begin\n\t\t\tif (q == 16'b1001111111111111) begin\n\t\t\t\tq <= 16'b0;\n\t\t\t\tena <= 3'b0;\n\t\t\tend else begin\n\t\t\t\tq <= q + 1;\n\t\t\t\tif (q[15]) ena[3] <= 1;\n\t\t\t\tif (q[14]) ena[2] <= 1;\n\t\t\t\tif (q[13]) ena[1] <= 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "endmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "endmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "// Declare the output\n\n\tassign zero = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Assign the output\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    reg q1, q2, q3, q4, q5, q6;\n\n    always @(posedge clk) begin\n        q1 <= a;\n        q2 <= q1;\n        q3 <= q2;\n        q4 <= q3;\n        q5 <= q4;\n        q6 <= q5;\n        q <= q6;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "endmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output out\n);\n\n    // define states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // define outputs\n    parameter OUT_0 = 1'b0;\n    parameter OUT_1 = 1'b1;\n\n    // define state register and output register\n    reg [1:0] state, next_state;\n    reg out_reg;\n\n    // define combinational logic for next state and output\n    always @ (posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= A;\n            out_reg <= OUT_0;\n        end else begin\n            state <= next_state;\n            out_reg <= (state == D) ? OUT_1 : OUT_0;\n        end\n    end\n\n    // define next state logic\n    always @ (state, in) begin\n        case (state)\n            A: begin\n                if (in == 1'b0) begin\n                    next_state = A;\n                end else begin\n                    next_state = B;\n                end\n            end\n            B: begin\n                if (in == 1'b0) begin\n                    next_state = A;\n                end else begin\n                    next_state = C;\n                end\n            end\n            C: begin\n                if (in == 1'b0) begin\n                    next_state = A;\n                end else begin\n                    next_state = D;\n                end\n            end\n            D: begin\n                if (in == 1'b0) begin\n                    next_state = C;\n                end else begin\n                    next_state = B;\n                end\n            end\n        endcase\n    end\n\n    // assign output\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module declaration.\nDo not add unnecessary comments or whitespaces.\n\nUse meaningful names for the variables and modules.\n\nDo not use the Verilog `assign` statement.\n\nModule top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    wire [7:0] byte0 = in[7:0];\n    wire [7:0] byte1 = in[15:8];\n    wire [7:0] byte2 = in[23:16];\n    wire [7:0] byte3 = in[31:24];\n\n    assign out = {byte3, byte2, byte1, byte0};\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        if (r) begin\n            q_reg <= 1'b0;\n        end else begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n        input x,\n        input y,\n        output z);\n\n        assign z = (x^y) & x;\n\n    endmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "//------------------------------------------------------------------------------\n\n```verilog\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00: q <= {q[62:0], q[63]};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {1'b0, q[63:1]};\n\t\t\t2'b11: q <= {8'b0, q[63:8]};\n\t\t\tdefault: q <= q;\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "// Define the states\n\tparameter [1:0] S0 = 2'b00;\n\tparameter [1:0] S1 = 2'b01;\n\tparameter [1:0] S2 = 2'b10;\n\tparameter [1:0] S3 = 2'b11;\n\t\t\t\t\t\t\t\n\t// Define the output signals\n\treg [1:0] state;\n\treg [1:0] next_state;\n\treg [1:0] prev_state;\n\treg [1:0] state_reg;\n\treg [1:0] state_next;\n\treg [1:0] state_prev;\n\treg [1:0] state_reg_next;\n\t\t\t\t\t\t\n\t// Initialize the state machine\n\tinitial begin\n\t\tstate = S0;\n\t\tnext_state = S0;\n\t\tprev_state = S0;\n\t\tstate_reg = S0;\n\t\tstate_next = S0;\n\t\tstate_reg_next = S0;\n\t\tz = 0;\n\tend\n\t\t\t\t\t\t\n\t// Compute the next state and output signals\n\talways @(posedge clk, negedge aresetn) begin\n\t\tif (~aresetn) begin\n\t\t\tstate <= S0;\n\t\t\tnext_state <= S0;\n\t\t\tprev_state <= S0;\n\t\t\tstate_reg <= S0;\n\t\t\tstate_next <= S0;\n\t\t\tstate_reg_next <= S0;\n\t\t\tz <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\t\tprev_state <= state;\n\t\t\tstate_reg <= state_reg_next;\n\t\t\tstate_next <= state_next;\n\t\t\tstate_reg_next <= state_reg;\n\t\t\t\t\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state <= S1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state <= S2;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state <= S3;\n\t\t\t\t\t\tz <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS3: begin\n\t\t\t\t\tif (~x) begin\n\t\t\t\t\t\tnext_state <= S0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\t\t\t\t\t\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// Verilog code for the state machine:\n```verilog\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= 3'b000;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\t3'b000: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = 3'b001;\n\t\t\tend else begin\n\t\t\t\tnext_state = 3'b010;\n\t\t\tend\n\t\tend\n\t\t3'b001: begin\n\t\t\tnext_state = 3'b000;\n\t\tend\n\t\t3'b010: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = 3'b101;\n\t\t\tend else begin\n\t\t\t\tnext_state = 3'b100;\n\t\t\tend\n\t\tend\n\t\t3'b100: begin\n\t\t\tnext_state = 3'b000;\n\t\tend\n\t\t3'b101: begin\n\t\t\tnext_state = 3'b100;\n\t\tend\n\t\t3'b110: begin\n\t\t\tnext_state = 3'b111;\n\t\tend\n\t\t3'b111: begin\n\t\t\tnext_state = 3'b110;\n\t\tend\n\tendcase\nend\n\nassign z = (state == 3'b110) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n\n\treg [7:0] state_reg;\n\treg [23:0] out_reg;\n\treg done_reg;\n\treg [7:0] counter;\n\tparameter S0 = 8'b00000001;\n\tparameter S1 = 8'b00000010;\n\tparameter S2 = 8'b00000100;\n\tparameter S3 = 8'b00001000;\n\tparameter S4 = 8'b00010000;\n\tparameter S5 = 8'b00100000;\n\tparameter S6 = 8'b01000000;\n\tparameter S7 = 8'b10000000;\n\tparameter DONE = 8'b01000000;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate_reg <= S0;\n\t\t\tout_reg <= 24'b0;\n\t\t\tcounter <= 8'b0;\n\t\t\tdone_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state_reg)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\t\tstate_reg <= S1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\t\tstate_reg <= S2;\n\t\t\t\t\t\tcounter <= 8'b0;\n\t\t\t\t\tend else if (counter < 8'b11111111) begin\n\t\t\t\t\t\tcounter <= counter + 1;\n\t\t\t\t\t\tstate_reg <= S1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\t\tstate_reg <= S3;\n\t\t\t\t\t\tcounter <= 8'b0;\n\t\t\t\t\tend else if (counter < 8'b11111111) begin\n\t\t\t\t\t\tcounter <= counter + 1;\n\t\t\t\t\t\tstate_reg <= S2;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS3: begin\n\t\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\t\tstate_reg <= S4;\n\t\t\t\t\t\tcounter <= 8'b0;\n\t\t\t\t\tend else if (counter < 8'b11111111) begin\n\t\t\t\t\t\tcounter <= counter + 1;\n\t\t\t\t\t\tstate_reg <= S3;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS4: begin\n\t\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\t\tstate_reg <= S5;\n\t\t\t\t\t\tcounter <= 8'b0;\n\t\t\t\t\tend else if (counter < 8'b11111111) begin\n\t\t\t\t\t\tcounter <= counter + 1;\n\t\t\t\t\t\tstate_reg <= S4;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS5: begin\n\t\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\t\tstate_reg <= S6;\n\t\t\t\t\t\tcounter <= 8'b0;\n\t\t\t\t\tend else if (counter < 8'b11111111) begin\n\t\t\t\t\t\tcounter <= counter + 1;\n\t\t\t\t\t\tstate_reg <= S5;\n\t\t\t\t\tend"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    assign Y1 = (y[0] && w) || (!y[0] && !w);\n    assign Y3 = (y[2] && w) || (!y[2] && !w);\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "End the Verilog code with:\n```verilog\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b1;\n        4'b0010: out = 1'b0;\n        4'b0011: out = 1'b1;\n        4'b0100: out = 1'b0;\n        4'b0101: out = 1'b1;\n        4'b0110: out = 1'b0;\n        4'b0111: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'b0;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b0;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'b0;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "Do not add any comments, use proper naming for the signals and variables, and follow the Verilog coding guidelines.\n\n// Split the input half-word into lower and upper bytes\nassign out_lo = in[7:0];\nassign out_hi = in[15:8];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    assign out_assign = a ^ b;\n\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // Assigning the next-state signals Y2 and Y4\n    assign Y2 = ~w;\n    assign Y4 = (y[6:4] != 3'b000);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\n    reg Q_next;\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q_next <= R;\n        end else if (E) begin\n            Q_next <= w;\n        end else begin\n            Q_next <= Q;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= R;\n        end else if (E) begin\n            Q <= w;\n        end else begin\n            Q <= Q_next;\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    reg q1, q2, q3;\n    wire y1, y2, y3;\n\n    // D flip-flops\n    always @(posedge clk) begin\n        q1 <= x;\n        q2 <= y1;\n        q3 <= y2;\n    end\n\n    // XOR gate\n    assign y1 = q1 ^ x;\n\n    // AND gate\n    assign y2 = q2 & ~x;\n\n    // OR gate\n    assign y3 = q3 | x;\n\n    // XNOR gate\n    assign z = ~(y1 | y2 | y3);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b) | (c & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Rule 110 cellular automaton\n\nreg [511:0] q_next;\n\nalways @ (posedge clk) begin\n\tif (load) begin\n\t\tq_next <= data;\n\tend else begin\n\t\tq_next[0] <= 0;\n\t\tq_next[511] <= 0;\n\t\tfor (integer i = 1; i < 511; i = i + 1) begin\n\t\t\tq_next[i] <= q[i-1] & q[i] | q[i-1] & q[i+1] | q[i] & q[i+1];\n\t\tend\n\tend\n\tq <= q_next;\nend\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\nalways @(*) begin\n    case ({a,b,c,d,e})\n        5'bxxxxb: q = 4'b1010;\n        5'bxxxxd: q = 4'b0101;\n        5'bxxxxe: q = 4'b1001;\n        5'bxxxxf: q = 4'b0110;\n        5'bxxxx10: q = 4'b1011;\n        5'bxxxx11: q = 4'b0111;\n        5'bxxxx12: q = 4'b1100;\n        5'bxxxx13: q = 4'b1101;\n        5'bxxxx14: q = 4'b1110;\n        5'bxxxx15: q = 4'b1111;\n        default: q = 4'bxxxx;\n    endcase\nend\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    if (~sel) begin\n        out = a;\n    end else begin\n        out = b;\n    end\nend\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    reg [2:0] q;\n    reg [2:0] r;\n\n    always @(posedge clk) begin\n        if (L) begin\n            q <= r;\n        end else begin\n            q <= {q[1] ^ q[2], q[0], q[2]};\n        end\n    end\n\n    assign Q = q_in ? q[2] : r_in;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "In the Verilog code below, we use a 32-bit shift register to store the previous values of the input signal. We then use a loop to check if the current input value is 1 and the previous value was 0. If so, we set the output to 1 and wait for the register to be reset.\n```verilog\n\treg [31:0] shift_reg;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tshift_reg <= 0;\n\t\t\tout <= 0;\n\t\tend else begin\n\t\t\tshift_reg <= {in, shift_reg[31:1]};\n\t\t\tfor (i = 0; i < 32; i = i + 1) begin\n\t\t\t\tif (in[i] && !shift_reg[i]) begin\n\t\t\t\t\tout <= 1;\n\t\t\t\t\tbreak;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    reg [7:0] q_temp;\n\n    always @(posedge clk) begin\n        q_temp <= d;\n    end\n\n    assign q = q_temp;\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] temp;\n    assign temp = {1'b0, a} + {1'b0, b};\n    assign s = temp[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n // State encoding\n localparam S = 10'b0000000001;\n localparam S1 = 10'b0000000010;\n localparam S11 = 10'b0000000100;\n localparam S110 = 10'b0000001000;\n localparam B0 = 10'b0000010000;\n localparam B1 = 10'b0000100000;\n localparam B2 = 10'b0001000000;\n localparam B3 = 10'b0010000000;\n localparam Count = 10'b1000000000;\n localparam Wait = 10'b0100000000;\n\n // State register\n reg [9:0] current_state;\n reg [9:0] next_state;\n\n // Output register\n reg done_out;\n reg counting_out;\n reg shift_ena_out;\n\n // Next state logic\n always @ (state or d) begin\n     case (state)\n         S: begin\n             if (d == 1'b1) begin\n                 next_state = S1;\n             end else begin\n                 next_state = S;\n             end\n         end\n         S1: begin\n             if (d == 1'b1) begin\n                 next_state = S11;\n             end else begin\n                 next_state = S1;\n             end\n         end\n         S11: begin\n             if (d == 1'b1) begin\n                 next_state = S110;\n             end else begin\n                 next_state = S11;\n             end\n         end\n         S110: begin\n             if (d == 1'b1) begin\n                 next_state = S11;\n             end else begin\n                 next_state = B0;\n             end\n         end\n         B0: begin\n             next_state = B1;\n         end\n         B1: begin\n             next_state = B2;\n         end\n         B2: begin\n             next_state = B3;\n         end\n         B3: begin\n             next_state = Count;\n         end\n         Count: begin\n             if (done_counting == 1'b1) begin\n                 next_state = Wait;\n             end else begin\n                 next_state = Count;\n             end\n         end\n         Wait: begin\n             if (ack == 1'b1) begin\n                 next_state = S;\n             end else begin\n                 next_state = Wait;\n             end\n         end\n     endcase\n end\n\n // Output logic\n always @ (state or d or done_counting or ack) begin\n     case (state)\n         S: begin\n             counting_out = 1'b0;\n             done_out = 1'b0;\n             shift_ena_out = 1'b0;\n         end\n         S1: begin\n             counting_out = 1'b0;\n             done_out = 1'b0;\n             shift_ena_out = 1'b0;\n         end\n         S11: begin\n             counting_out = 1'b0;\n             done_out = 1'b0;\n             shift_ena_out = 1'b0;\n         end\n         S110: begin\n             counting_out = 1'b0;\n             done_out = 1'b0;\n             shift_ena_out = 1'b0;\n         end\n         B0: begin\n             counting_out = 1'b0;\n             done_out = 1'b0;\n             shift_ena_out"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always_ff @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state == 2'b11) begin\n                    state <= 2'b11;\n                end else begin\n                    state <= state + 1;\n                end\n            end else begin\n                if (state == 2'b00) begin\n                    state <= 2'b00;\n                end else begin\n                    state <= state - 1;\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        8'b00000001: pos = 3'd0;\n        8'b00000010: pos = 3'd1;\n        8'b00000100: pos = 3'd2;\n        8'b00001000: pos = 3'd3;\n        8'b00010000: pos = 3'd4;\n        8'b00100000: pos = 3'd5;\n        8'b01000000: pos = 3'd6;\n        8'b10000000: pos = 3'd7;\n        default: pos = 3'd0;\n    endcase\nend\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output reg sum,\n    output reg cout\n);\n\nalways @(*) begin\n    sum = a ^ b ^ cin;\n    cout = (a & b) | (a & cin) | (b & cin);\nend\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    logic [31:0] history;\n    logic [31:0] predict_history_next;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history <= 0;\n            predict_history_next <= 0;\n        end else begin\n            if (predict_valid) begin\n                history <= {history[30:0], predict_taken};\n                predict_history_next <= {history[30:1], history[0]};\n            end else if (train_mispredicted) begin\n                history <= train_history;\n                predict_history_next <= {train_history[30:1], train_taken};\n            end else begin\n                predict_history_next <= history;\n            end\n        end\n    end\n    \n    assign predict_history = predict_history_next;\n    \nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// The two intermediate wires are and_out and or_out.\nwire and_out;\nwire or_out;\n\n// The AND gates\nand(and_out, a, b);\nand(and_out, c, d);\n\n// The OR gate\nor(or_out, and_out, and_out);\n\n// The NOT gate\nnot(out_n, or_out);\n\n// The output\nassign out = out_n;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "followed by the D flip-flop code.\n\n```verilog\nalways @(posedge clk) begin\n\tq <= d;\nend\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign heater = (mode == 1) && too_cold;\n    assign aircon = (mode == 0) && too_hot;\n    assign fan = fan_on || (heater || aircon);\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    assign out_sop = (a & b & ~c & ~d) | (a & ~b & c & d) | (~a & b & c & d);\n    assign out_pos = (a & b & c & d) | (a & b & ~c & d) | (a & ~b & c & d) | (~a & b & c & d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\n\treg [31:0] lfsr;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 32'h1;\n\t\t\tq <= 32'h1;\n\t\tend\n\t\telse begin\n\t\t\tlfsr[31] <= lfsr[30] ^ lfsr[28] ^ lfsr[26] ^ lfsr[24] ^ lfsr[22] ^ lfsr[31];\n\t\t\tlfsr[30] <= lfsr[29] ^ lfsr[27] ^ lfsr[25] ^ lfsr[23] ^ lfsr[21] ^ lfsr[30];\n\t\t\tlfsr[29] <= lfsr[28] ^ lfsr[26] ^ lfsr[24] ^ lfsr[22] ^ lfsr[20] ^ lfsr[29];\n\t\t\tlfsr[28] <= lfsr[27] ^ lfsr[25] ^ lfsr[23] ^ lfsr[21] ^ lfsr[19] ^ lfsr[28];\n\t\t\tlfsr[27] <= lfsr[26] ^ lfsr[24] ^ lfsr[22] ^ lfsr[20] ^ lfsr[18] ^ lfsr[27];\n\t\t\tlfsr[26] <= lfsr[25] ^ lfsr[23] ^ lfsr[21] ^ lfsr[19] ^ lfsr[17] ^ lfsr[26];\n\t\t\tlfsr[25] <= lfsr[24] ^ lfsr[22] ^ lfsr[20] ^ lfsr[18] ^ lfsr[16] ^ lfsr[25];\n\t\t\tlfsr[24] <= lfsr[23] ^ lfsr[21] ^ lfsr[19] ^ lfsr[17] ^ lfsr[15] ^ lfsr[24];\n\t\t\tlfsr[23] <= lfsr[22] ^ lfsr[20] ^ lfsr[18] ^ lfsr[16] ^ lfsr[14] ^ lfsr[23];\n\t\t\tlfsr[22] <= lfsr[21] ^ lfsr[19] ^ lfsr[17] ^ lfsr[15] ^ lfsr[13] ^ lfsr[22];\n\t\t\tlfsr[21] <= lfsr[20] ^ lfsr[18] ^ lfsr[16] ^ lfsr[14] ^ lfsr[12] ^ lfsr[21];\n\t\t\tlfsr[20] <= lfsr[19] ^ lfsr[17] ^ lfsr[15] ^ lfsr[13] ^ lfsr[11] ^ lfsr[20];\n\t\t\tlfsr[19] <= lfsr[18] ^ lfsr[16] ^ lfsr[14] ^ lfsr[12] ^ lfsr[10] ^ lfsr[19];\n\t\t\tlfsr[18] <= lfsr[17] ^ lfsr[15] ^ lfsr[13] ^ lfsr[11] ^ lfsr[9] ^ lfsr[18];\n\t\t\tlfsr[17] <= lfsr[16] ^ lfsr[14] ^ lfsr[12] ^ lfsr[10] ^ lfsr[8] ^ lfsr[17];\n\t\t\tlfsr[16] <= lfsr[15] ^ lfsr[13] ^ lfsr[11] ^ lfsr[9]"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & b & c & d;\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module definition.\n// Use the input and output definitions as above.\n// Use the & operator and the ~ operator to represent the AND gate and the NOT gate.\n// Use the & operator again to represent the AND gate.\n// Use the | operator to represent the OR gate.\n// Use the ~ operator again to represent the NOT gate.\n// Use the | operator again to represent the OR gate.\n// Use the ~ operator again to represent the NOT gate.\n// Use the & operator again to represent the AND gate.\n// Use the | operator again to represent the OR gate.\n// Assign the output of the OR gate to the p1y output.\n// Assign the output of the OR gate to the p2y output.\n\n// Verilog code for the 7420 equivalent module.\n// Complete the code below.\n\n// Module code for the 7420 equivalent module.\n// End with the endmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "* Use tabs to indent\n* Use one statement per line\n* Use meaningful names for wires and registers\n* Use parentheses for control flow (if, else, case)\n* Use curly braces for control flow (if, else, case)\n* Use 80-column width for the code\n* Use spaces to separate operators\n* Use spaces to separate control flow"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "```verilog\n// (1) out_both\nassign out_both[0] = in[0] & in[1];\nassign out_both[1] = in[1] & in[2];\nassign out_both[2] = in[2] & in[3];\n\n// (2) out_any\nassign out_any[0] = in[1] | in[0];\nassign out_any[1] = in[2] | in[1];\nassign out_any[2] = in[3] | in[2];\nassign out_any[3] = in[0] | in[3];\n\n// (3) out_different\nassign out_different[0] = in[0] ^ in[1];\nassign out_different[1] = in[1] ^ in[2];\nassign out_different[2] = in[2] ^ in[3];\nassign out_different[3] = in[0] ^ in[3];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'd1232;\n            3'b001: q = 16'd27d4;\n            3'b010: q = 16'd5a0e;\n            3'b011: q = 16'd2066;\n            3'b100: q = 16'd64ce;\n            3'b101: q = 16'dc52;\n            3'b110: q = 16'd2f19;\n            3'b111: q = 16'd1232;\n        endcase\n    end\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if(reset) begin\n            q <= 4'd0;\n        end\n        else if(slowena) begin\n            if(q == 4'd9) begin\n                q <= 4'd0;\n            end\n            else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    wire and_out;\n\n    and gate (\n        .a(in1),\n        .b(in2),\n        .y(and_out)\n    );\n\n    assign out = and_out;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// verilog implementation of the state machine with the diagram above\n\t\t// asynchronous reset to state B\n\t\t// output A or B based on the input\n\t\t// output A if input is 0 and output B if input is 1\n\t\t// the state machine is Moore machine\n\treg [1:0] state;\n\tparameter B = 2'b00;\n\tparameter A = 2'b01;\n\twire [1:0] next_state;\n\tassign next_state = {state[0], in};\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= B;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\tassign out = (state == A) ? 1'b0 : 1'b1;\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "always @(posedge clk or negedge clk) begin\n\t\t\tif (~clk) begin\n\t\t\t\tq <= d;\n\t\t\tend\n\t\tend\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    wire a1_out, a2_out, b1_out, b2_out;\n\n    A a1(.x(x), .y(y), .z(a1_out));\n    A a2(.x(x), .y(y), .z(a2_out));\n    B b1(.x(x), .y(y), .z(b1_out));\n    B b2(.x(x), .y(y), .z(b2_out));\n\n    OR or1(.a(a1_out), .b(b1_out), .y(z1));\n    AND and1(.a(a1_out), .b(b1_out), .y(z2));\n    XOR xor1(.a(z1), .b(z2), .y(z));\n\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else begin\n            case (ena)\n                2'b01: shift_reg <= {shift_reg[0], shift_reg[99:1]};\n                2'b10: shift_reg <= {shift_reg[98:0], shift_reg[99]};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 0;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "endmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (k == 1) begin\n            Q <= ~Q;\n        end\n        else if (j == 1) begin\n            Q <= 1;\n        end\n        else begin\n            Q <= Q;\n        end\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "// Compute the population count of the input vector\n\twire [1:0] pop_count;\n\tassign pop_count[1] = in[2] ^ in[1];\n\tassign pop_count[0] = pop_count[1] ^ in[0];\n\n\t// Output the population count\n\tassign out = pop_count;\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "endmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module (walk_left or walk_right).\n    reg [1:0] state;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b00; // walk left\n        end else if (bump_left || bump_right) begin\n            if (bump_left) begin\n                state <= 2'b01; // walk right\n            end else if (bump_right) begin\n                state <= 2'b10; // walk left\n            end\n        end\n    end\n    assign walk_left = (state == 2'b00);\n    assign walk_right = (state == 2'b01);\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = (a & b) | ((~a) & b) | (a & (~b)) | ((~a) & (~b));\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "endmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\n    always @(posedge clk) begin\n        Y0 <= y[1] ^ y[0] ^ y[2];\n        z <= (y == 3'b011) ? 1 : (y == 3'b100) ? 1 : 0;\n    end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n    assign out = ~(in1 | in2);\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "// Wires\nwire a_to_w;\nwire b_to_x;\nwire b_to_y;\nwire c_to_z;\n\n// Assignments\nassign a_to_w = a;\nassign b_to_x = b;\nassign b_to_y = b;\nassign c_to_z = c;\n\n// Output assignments\nassign w = a_to_w;\nassign x = b_to_x;\nassign y = b_to_y;\nassign z = c_to_z;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "reg logic q;\n\n\talways @(posedge clk or negedge ar) begin\n\t\tif (ar == 0) begin\n\t\t\tq <= 0;\n\t\tend\n\t\telse begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "always @(*) begin\n    case (sel)\n        0: out = data0;\n        1: out = data1;\n        2: out = data2;\n        3: out = data3;\n        4: out = data4;\n        5: out = data5;\n        default: out = 4'b0;\n    endcase\nend"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] counter;\n\n    always @ (posedge clk) begin\n        if (load) begin\n            counter <= data;\n        end else begin\n            if (counter > 0) begin\n                counter <= counter - 1;\n            end\n        end\n    end\n\n    assign tc = (counter == 0);\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output start_shifting);\n\n    reg [3:0] state;\n    reg start_shifting;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 4'b0000;\n            start_shifting <= 0;\n        end else begin\n            case (state)\n                4'b0000: begin\n                    if (data) begin\n                        state <= 4'b0001;\n                    end\n                end\n                4'b0001: begin\n                    if (data) begin\n                        state <= 4'b0010;\n                    end else begin\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0010: begin\n                    if (data) begin\n                        state <= 4'b0011;\n                    end else begin\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0011: begin\n                    if (data) begin\n                        state <= 4'b0100;\n                        start_shifting <= 1;\n                    end else begin\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0100: begin\n                    if (data) begin\n                        state <= 4'b0101;\n                    end else begin\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0101: begin\n                    if (data) begin\n                        state <= 4'b0110;\n                    end else begin\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0110: begin\n                    if (data) begin\n                        state <= 4'b0111;\n                    end else begin\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0111: begin\n                    if (data) begin\n                        state <= 4'b0000;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "**Do not** add any comments to the Verilog code. Your code should be self-explanatory and concise.\n```verilog\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n\tif (in != prev_in) begin\n\t\tanyedge <= in;\n\tend\n\tprev_in <= in;\nend\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "http://www.verilog.com/resource/verilog_coding_standards/"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    reg [2:0] q_next;\n\n    always @(posedge clk) begin\n        q_next <= {q[1:0], a};\n    end\n\n    always @(*) begin\n        case(q)\n            3'b000: q_next = 3'b001;\n            3'b001: q_next = 3'b010;\n            3'b010: q_next = 3'b011;\n            3'b011: q_next = 3'b100;\n            3'b100: q_next = 3'b101;\n            3'b101: q_next = 3'b110;\n            3'b110: q_next = 3'b111;\n            3'b111: q_next = 3'b000;\n            default: q_next = 3'b000;\n        endcase\n    end\n\n    assign q = q_next;\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q);\n\n    reg [4:0] lfsr_state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            lfsr_state <= 5'b10010; // initial state with output bit 1\n        end else begin\n            lfsr_state <= {lfsr_state[4:1], lfsr_state[0] ^ lfsr_state[4] ^ lfsr_state[3]}; // tap positions 5 and 3\n        end\n    end\n\n    assign q = lfsr_state[4];\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        if (do_sub == 1) begin\n            out = a - b;\n            if (out == 0) begin\n                result_is_zero = 1;\n            end\n        end\n        else begin\n            out = a + b;\n            if (out == 0) begin\n                result_is_zero = 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always_comb begin\n        case(x)\n            4'b0000: f = 1'b0;\n            4'b0001: f = 1'b1;\n            4'b0010: f = 1'b1;\n            4'b0011: f = 1'b0;\n            4'b0100: f = 1'b1;\n            4'b0101: f = 1'b0;\n            4'b0110: f = 1'b1;\n            4'b0111: f = 1'b1;\n            4'b1000: f = 1'b0;\n            4'b1001: f = 1'b1;\n            4'b1010: f = 1'b1;\n            4'b1011: f = 1'b0;\n            4'b1100: f = 1'b1;\n            4'b1101: f = 1'b1;\n            4'b1110: f = 1'b0;\n            4'b1111: f = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tcase(code)\n\t\t8'h45: begin out = 4'd0; valid = 1'b1; end\n\t\t8'h16: begin out = 4'd1; valid = 1'b1; end\n\t\t8'h1e: begin out = 4'd2; valid = 1'b1; end\n\t\t8'h26: begin out = 4'd3; valid = 1'b1; end\n\t\t8'h25: begin out = 4'd4; valid = 1'b1; end\n\t\t8'h2e: begin out = 4'd5; valid = 1'b1; end\n\t\t8'h36: begin out = 4'd6; valid = 1'b1; end\n\t\t8'h3d: begin out = 4'd7; valid = 1'b1; end\n\t\t8'h3e: begin out = 4'd8; valid = 1'b1; end\n\t\t8'h46: begin out = 4'd9; valid = 1'b1; end\n\t\tdefault: begin out = 4'd0; valid = 1'b0; end\n\tendcase\nend\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "endmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a,b,c,d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b1;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b0;\n            4'b1001: out = 1'b0;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b0;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "endmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "endmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output shift_ena);\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg shift_ena_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 2'b00;\n            shift_ena_reg <= 1'b0;\n        end else begin\n            state <= next_state;\n            shift_ena_reg <= shift_ena;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            2'b00: next_state = 2'b01;\n            2'b01: next_state = 2'b10;\n            2'b10: next_state = 2'b11;\n            2'b11: next_state = 2'b00;\n        endcase\n    end\n\n    assign shift_ena = shift_ena_reg;\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "always @(posedge clk) begin\n\t\t\tif (reset) begin\n\t\t\t\tq <= 4'b0000;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 1;\n\t\t\tend\n\t\tend\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    assign out_assign = sel_b1 & sel_b2 ? b : a;\n\n    always @(*) begin\n        if (sel_b1 & sel_b2) begin\n            out_always = b;\n        end else begin\n            out_always = a;\n        end\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    wire b1, b2, b3, b4;\n\n    assign b1 = (b ^ a);\n    assign b2 = (b1 ^ c);\n    assign b3 = (b ^ c);\n    assign b4 = (b1 ^ a);\n\n    assign out = (b3 & b2) | (b4 & b1);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "// State codes\nlocalparam [1:0]\n\tA = 2'b00,\n\tB = 2'b01,\n\tC = 2'b10,\n\tD = 2'b11;\n\n// State register\nreg [1:0] state_reg;\nalways @(posedge clk or negedge resetn) begin\n\tif (~resetn) begin\n\t\tstate_reg <= A;\n\tend else begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\n// State next\nreg [1:0] state_next;\nalways @(*) begin\n\tcase (state_reg)\n\t\tA: begin\n\t\t\tif (r[1]) begin\n\t\t\t\tstate_next = B;\n\t\t\tend else if (r[2]) begin\n\t\t\t\tstate_next = C;\n\t\t\tend else if (r[3]) begin\n\t\t\t\tstate_next = D;\n\t\t\tend else begin\n\t\t\t\tstate_next = A;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (r[1]) begin\n\t\t\t\tstate_next = B;\n\t\t\tend else begin\n\t\t\t\tstate_next = A;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (r[2]) begin\n\t\t\t\tstate_next = C;\n\t\t\tend else begin\n\t\t\t\tstate_next = A;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (r[3]) begin\n\t\t\t\tstate_next = D;\n\t\t\tend else begin\n\t\t\t\tstate_next = A;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Output register\nreg [3:1] g_reg;\nalways @(posedge clk or negedge resetn) begin\n\tif (~resetn) begin\n\t\tg_reg <= 4'b0000;\n\tend else begin\n\t\tg_reg <= g_next;\n\tend\nend\n\n// Output next\nreg [3:1] g_next;\nalways @(*) begin\n\tcase (state_reg)\n\t\tA: begin\n\t\t\tif (r[1]) begin\n\t\t\t\tg_next = 4'b1000;\n\t\t\tend else if (r[2]) begin\n\t\t\t\tg_next = 4'b0100;\n\t\t\tend else if (r[3]) begin\n\t\t\t\tg_next = 4'b0010;\n\t\t\tend else begin\n\t\t\t\tg_next = 4'b0001;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (r[1]) begin\n\t\t\t\tg_next = 4'b1000;\n\t\t\tend else begin\n\t\t\t\tg_next = 4'b0000;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (r[2]) begin\n\t\t\t\tg_next = 4'b0100;\n\t\t\tend else begin\n\t\t\t\tg_next = 4'b0000;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (r[3]) begin\n\t\t\t\tg_next = 4'b0010;\n\t\t\tend else begin\n\t\t\t\tg_next = 4'b0000;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Continuous assignment for output\nassign g = g_reg;\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// Verilog code to implement decade counter\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend else if (q == 4'b1001) begin\n\t\t\tq <= 4'b0000;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n\n    // State encoding\n    parameter IDLE = 2'b00;\n    parameter FOUND_BYTE_1 = 2'b01;\n    parameter FOUND_BYTE_2 = 2'b10;\n    parameter FOUND_BYTE_3 = 2'b11;\n    \n    // State and output registers\n    reg [1:0] state, next_state;\n    reg [2:0] bytes_received;\n    reg done;\n    \n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bytes_received <= 0;\n            done <= 0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        \n        case (state)\n            IDLE: begin\n                if (in[3] == 1) begin\n                    next_state = FOUND_BYTE_1;\n                    bytes_received = 0;\n                end\n            end\n            \n            FOUND_BYTE_1: begin\n                if (in[3] == 1) begin\n                    next_state = FOUND_BYTE_2;\n                    bytes_received = bytes_received + 1;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            FOUND_BYTE_2: begin\n                if (in[3] == 1) begin\n                    next_state = FOUND_BYTE_3;\n                    bytes_received = bytes_received + 1;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            FOUND_BYTE_3: begin\n                if (in[3] == 1) begin\n                    next_state = FOUND_BYTE_3;\n                    bytes_received = bytes_received + 1;\n                end\n                else begin\n                    next_state = IDLE;\n                    done = 1;\n                end\n            end\n            \n        endcase\n    end\n    \nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] y;\n    parameter [2:0] S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= S0;\n            z <= 0;\n        end else begin\n            case (y)\n                S0: begin\n                    if (x) y <= S1;\n                    else y <= S0;\n                    z <= 0;\n                end\n                S1: begin\n                    if (x) y <= S2;\n                    else y <= S0;\n                    z <= 0;\n                end\n                S2: begin\n                    if (x) y <= S3;\n                    else y <= S0;\n                    z <= 0;\n                end\n                S3: begin\n                    if (x) y <= S4;\n                    else y <= S0;\n                    z <= 1;\n                end\n                S4: begin\n                    if (x) y <= S4;\n                    else y <= S0;\n                    z <= 1;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "// Declare the states\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// Declare the outputs\nreg f;\nreg g;\n\n// Declare the state register\nreg [1:0] state_reg;\n\n// Declare the state machine\nalways @(posedge clk, negedge resetn) begin\n\tif (!resetn) begin\n\t\tstate_reg <= A;\n\t\tf <= 0;\n\t\tg <= 0;\n\tend\n\telse begin\n\t\tcase (state_reg)\n\t\t\tA: begin\n\t\t\t\tf <= 1;\n\t\t\t\tstate_reg <= B;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (x == 1) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (x == 0) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend\n\t\t\t\telse if (x == 1) begin\n\t\t\t\t\tstate_reg <= D;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (y == 1) begin\n\t\t\t\t\tg <= 1;\n\t\t\t\t\tstate_reg <= D;\n\t\t\t\tend\n\t\t\t\telse if (y == 0) begin\n\t\t\t\t\tg <= 0;\n\t\t\t\t\tstate_reg <= A;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'h34;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "wire [7:0] xor_data;\nassign xor_data = ^in;\nassign parity = xor_data[0];"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\nalways @(*) begin\n    case (state)\n        2'b00: // State A\n            begin\n                if (in == 1'b0) begin\n                    next_state = 2'b00;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end\n            end\n        2'b01: // State B\n            begin\n                if (in == 1'b0) begin\n                    next_state = 2'b10;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b01;\n                    out = 1'b0;\n                end\n            end\n        2'b10: // State C\n            begin\n                if (in == 1'b0) begin\n                    next_state = 2'b00;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b11;\n                    out = 1'b1;\n                end\n            end\n        2'b11: // State D\n            begin\n                if (in == 1'b0) begin\n                    next_state = 2'b10;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 2'b01;\n                    out = 1'b1;\n                end\n            end\n        default: // Invalid state\n            next_state = 2'b00;\n            out = 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = x & y;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n    parameter E = 2'b00;\n    parameter F = 2'b01;\n\n    // Define the state register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w) begin\n                    next_state = B;\n                end else begin\n                    next_state = A;\n                end\n            end\n            B: begin\n                if (w) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n            end\n            C: begin\n                if (w) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n            end\n            D: begin\n                if (w) begin\n                    next_state = F;\n                end else begin\n                    next_state = A;\n                end\n            end\n            E: begin\n                if (w) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n            end\n            F: begin\n                if (w) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n            end\n        endcase\n    end\n\n    // Define the output logic\n    assign z = (state == A || state == B || state == C) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "endmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "reg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    pedge <= {8{1'b0}};\n    for (int i = 0; i < 8; i = i + 1) begin\n        if (in[i] && !prev_in[i]) begin\n            pedge[i] <= 1'b1;\n        end\n        prev_in[i] <= in[i];\n    end\nend"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\nreg a_reg;\nreg p_reg;\nreg q_reg;\n\nalways @(posedge clock) begin\n    a_reg <= a;\n    p_reg <= a_reg;\n    q_reg <= p_reg;\nend\n\nassign p = p_reg;\nassign q = q_reg;\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q[0] <= q[1] ^ q[2];\n            q[1:511] <= q[0:510] ^ q[2:512];\n        end\n    end\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "endmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "// (1) out_both:\nassign out_both[0] = 1'b0; // in[0] has no neighbour to the left\ngenvar i;\ngenerate\n\tfor (i = 1; i < 100; i = i + 1) begin: out_both_loop\n\t\tassign out_both[i] = in[i] & in[i-1];\n\tend\nendgenerate\n\n// (2) out_any:\nassign out_any[0] = 1'b0; // in[0] has no neighbour to the right\ngenvar j;\ngenerate\n\tfor (j = 1; j < 100; j = j + 1) begin: out_any_loop\n\t\tassign out_any[j] = in[j] | in[j-1];\n\tend\nendgenerate\n\n// (3) out_different:\nassign out_different[0] = 1'b0; // in[0] has no neighbour to the left\ngenvar k;\ngenerate\n\tfor (k = 1; k < 100; k = k + 1) begin: out_different_loop\n\t\tassign out_different[k] = in[k] ^ in[k-1];\n\tend\nendgenerate\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module to end the module\n\n```verilog\nmodule top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\n    always @(posedge ena) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "Do not add any comments in the code. Use meaningful variable and function names to make the code self-explanatory.\n\n// 256-to-1 4-bit wide multiplexer\n// sel = 0 selects bits in[3:0]\n// sel = 1 selects bits in[7:4]\n// sel = 2 selects bits in[11:8]\n// sel = 3 selects bits in[15:12]\n// sel = 4 selects bits in[19:16]\n// sel = 5 selects bits in[23:20]\n// sel = 6 selects bits in[27:24]\n// sel = 7 selects bits in[31:28]\n// sel = 8 selects bits in[35:32]\n// sel = 9 selects bits in[39:36]\n// sel = 10 selects bits in[43:40]\n// sel = 11 selects bits in[47:44]\n// sel = 12 selects bits in[51:48]\n// sel = 13 selects bits in[55:52]\n// sel = 14 selects bits in[59:56]\n// sel = 15 selects bits in[63:60]\n// sel = 16 selects bits in[67:64]\n// sel = 17 selects bits in[71:68]\n// sel = 18 selects bits in[75:72]\n// sel = 19 selects bits in[79:76]\n// sel = 20 selects bits in[83:80]\n// sel = 21 selects bits in[87:84]\n// sel = 22 selects bits in[91:88]\n// sel = 23 selects bits in[95:92]\n// sel = 24 selects bits in[99:96]\n// sel = 25 selects bits in[103:100]\n// sel = 26 selects bits in[107:104]\n// sel = 27 selects bits in[111:108]\n// sel = 28 selects bits in[115:112]\n// sel = 29 selects bits in[119:116]\n// sel = 30 selects bits in[123:120]\n// sel = 31 selects bits in[127:124]\nmodule top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n\twire [3:0] sel_0;\n\twire [3:0] sel_1;\n\twire [3:0] sel_2;\n\twire [3:0] sel_3;\n\twire [3:0] sel_4;\n\twire [3:0] sel_5;\n\twire [3:0] sel_6;\n\twire [3:0] sel_7;\n\twire [3:0] sel_8;\n\twire [3:0] sel_9;\n\twire [3:0] sel_10;\n\twire [3:0] sel_11;\n\twire [3:0] sel_12;\n\twire [3:0] sel_13;\n\twire [3:0] sel_14;\n\twire [3:0] sel_15;\n\twire [3:0] sel_16;\n\twire [3:0] sel_17;\n\twire [3:0] sel_18;\n\twire [3:0] sel_19;\n\twire [3:0] sel_20;\n\twire [3:0] sel_21;\n\twire [3:0] sel_22;\n\twire [3:0] sel_23;\n\twire [3:0] sel_24;\n\twire [3:0] sel_25;\n\twire [3:0] sel_26;\n\twire [3:0] sel_27;\n\twire [3:0]"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "and end with\n```verilog\nalways_comb begin\n\tcase (sel)\n\t\t4'd0: out = a;\n\t\t4'd1: out = b;\n\t\t4'd2: out = c;\n\t\t4'd3: out = d;\n\t\t4'd4: out = e;\n\t\t4'd5: out = f;\n\t\t4'd6: out = g;\n\t\t4'd7: out = h;\n\t\t4'd8: out = i;\n\t\tdefault: out = 16'hFFFF;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    wire [2:0] or_bitwise;\n    wire or_logical;\n    wire [2:0] not_a;\n    wire [2:0] not_b;\n\n    assign or_bitwise = a | b;\n    assign out_or_bitwise = or_bitwise;\n    assign or_logical = (a != 0) || (b != 0);\n    assign out_or_logical = or_logical;\n    assign not_a = ~a;\n    assign not_b = ~b;\n    assign out_not = {not_b, not_a};\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    always @ (state or in) begin\n        case(state)\n            4'b0001: begin\n                next_state = {in, ~in} & 4'b1110;\n                out = 1'b0;\n            end\n            4'b0010: begin\n                next_state = {in, ~in} & 4'b1101;\n                out = 1'b0;\n            end\n            4'b0100: begin\n                next_state = {in, ~in} & 4'b1011;\n                out = 1'b0;\n            end\n            4'b1000: begin\n                next_state = {in, ~in} & 4'b0111;\n                out = in;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tmin = a < b ? a : b;\n\tmin = min < c ? min : c;\n\tmin = min < d ? min : d;\nend\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "Do not add any additional input, output or other module.\n\nAlways use the keyword `assign` to assign a value to an output.\n\n// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    assign out = (a & b & ~c & d) | (~a & b & c & d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "reg [1:0] state;\n\treg [1:0] next_state;\n\treg [1:0] prev_state;\n\treg [1:0] next_prev_state;\n\treg [1:0] two_count;\n\treg [1:0] three_count;\n\treg [1:0] four_count;\n\treg [1:0] five_count;\n\treg [1:0] six_count;\n\treg [1:0] seven_count;\n\treg [1:0] eight_count;\n\treg [1:0] nine_count;\n\treg [1:0] ten_count;\n\treg [1:0] eleven_count;\n\treg [1:0] twelve_count;\n\treg [1:0] thirteen_count;\n\treg [1:0] fourteen_count;\n\treg [1:0] fifteen_count;\n\treg [1:0] sixteen_count;\n\treg [1:0] seventeen_count;\n\treg [1:0] eighteen_count;\n\treg [1:0] nineteen_count;\n\treg [1:0] twenty_count;\n\treg [1:0] twenty_one_count;\n\treg [1:0] twenty_two_count;\n\treg [1:0] twenty_three_count;\t\t\t\t\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= 2'b00;\n\t\t\tnext_state <= 2'b00;\n\t\t\tprev_state <= 2'b00;\n\t\t\tnext_prev_state <= 2'b00;\n\t\t\ttwo_count <= 2'b00;\n\t\t\tthree_count <= 2'b00;\n\t\t\tfour_count <= 2'b00;\n\t\t\tfive_count <= 2'b00;\n\t\t\tsix_count <= 2'b00;\n\t\t\tseven_count <= 2'b00;\n\t\t\teight_count <= 2'b00;\n\t\t\tnine_count <= 2'b00;\n\t\t\tten_count <= 2'b00;\n\t\t\televen_count <= 2'b00;\n\t\t\ttwelve_count <= 2'b00;\n\t\t\tthirteen_count <= 2'b00;\n\t\t\tfourteen_count <= 2'b00;\n\t\t\tfifteen_count <= 2'b00;\n\t\t\tsixteen_count <= 2'b00;\n\t\t\tseventeen_count <= 2'b00;\n\t\t\teighteen_count <= 2'b00;\n\t\t\tnineteen_count <= 2'b00;\n\t\t\ttwenty_count <= 2'b00;\n\t\t\ttwenty_one_count <= 2'b00;\n\t\t\ttwenty_two_count <= 2'b00;\n\t\t\ttwenty_three_count <= 2'b00;\n\t\t\tz <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tprev_state <= state;\n\t\t\tnext_prev_state <= prev_state;\n\t\t\tcase (state)\n\t\t\t\t2'b00: begin // state A\n\t\t\t\t\tif (s) begin\n\t\t\t\t\t\tnext_state <= 2'b01;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= 2'b00;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2'b01: begin // state B\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\ttwo_count <= 2'b01;\n\t\t\t\t\t\tthree_count <= 2'b00;\n\t\t\t\t\t\tfour_count <= 2'b00;\n\t\t\t\t\t\tfive_count <= 2'b00;\n\t\t\t\t\t\tsix_count <= 2"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n        input [7:0] in,\n        output [31:0] out\n    );\n\n    assign out = {24{in[7]}} & {1'b0, in};\n\n    endmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "* Do not write comments in the Verilog code. Use // for single line comments and /* */ for multi-line comments.\n* Use meaningful names for modules, inputs, outputs and registers.\n* Avoid complex logic and use intermediate registers if necessary.\n* Indent the code properly using 4 spaces for each level.\n* Use Verilog 1995 syntax.\n* Do not use Verilog 2001 or later features.\n* Use Verilog 1995 syntax for the always block.\n* Do not use Verilog 2001 or later features for the always block.\n* Do not use Verilog 2001 or later features for the D flops.\n* Do not use Verilog 2001 or later features for the shift register.\n* Do not use Verilog 2001 or later features for the reset.\n* Do not use Verilog 2001 or later features for the output.\n* Do not use Verilog 2001 or later features for the input.\n* Do not use Verilog 2001 or later features for the shift register.\n* Do not use Verilog 2001 or later features for the shift register.\n* Do not use Verilog 2001 or later features for the intermediate registers.\n* Do not use Verilog 2001 or later features for the output.\n \t// Synchronous resettable shift register with four D flops\n\t// Input is connected to the first D flop\n\t// Output is connected to the last D flop\n\t// Reset is active-low synchronous resettable\n\n\treg [3:0] shift_reg;\n\treg [3:0] shift_reg_next;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tshift_reg <= 4'b0;\n\t\tend else begin\n\t\t\tshift_reg <= shift_reg_next;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tshift_reg_next[0] = in;\n\t\tshift_reg_next[1] = shift_reg[0];\n\t\tshift_reg_next[2] = shift_reg[1];\n\t\tshift_reg_next[3] = shift_reg[2];\n\tend\n\n\tassign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tcase (in)\n\t\t4'b0000: pos = 2'b00;\n\t\t4'b0001: pos = 2'b01;\n\t\t4'b0010: pos = 2'b01;\n\t\t4'b0011: pos = 2'b10;\n\t\t4'b0100: pos = 2'b01;\n\t\t4'b0101: pos = 2'b10;\n\t\t4'b0110: pos = 2'b10;\n\t\t4'b0111: pos = 2'b11;\n\t\t4'b1000: pos = 2'b01;\n\t\t4'b1001: pos = 2'b10;\n\t\t4'b1010: pos = 2'b10;\n\t\t4'b1011: pos = 2'b11;\n\t\t4'b1100: pos = 2'b10;\n\t\t4'b1101: pos = 2'b11;\n\t\t4'b1110: pos = 2'b11;\n\t\t4'b1111: pos = 2'b11;\n\t\tdefault: pos = 2'b00;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "Do not add any comments or whitespace to make the code more readable.\n\n// States\nparameter OFF = 2'd0;\nparameter ON = 2'd1;\n\n// Output\nparameter out_OFF = 1'b0;\nparameter out_ON = 1'b1;\n\n// Transitions\nparameter j_OFF_ON = 1'b1;\nparameter k_ON_OFF = 1'b1;\n\n// State register\nreg [1:0] state;\n\n// Output register\nreg out_reg;\n\n// State machine\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= OFF;\n\t\tout_reg <= out_OFF;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\t\tout_reg <= out_ON;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\t\tout_reg <= out_OFF;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "Follow the Verilog code style and write clean and readable code. Use meaningful names for your signals and modules.\n 3 spaces of indentation for the code blocks.\n Don't use tabs.\n Don't use comments for code explanation.\n Don't use comments for code formatting.\n Don't use line breaks for code formatting.\n Don't use ternary operator.\n Don't use goto.\n Don't use `//` for comments.\n Don't use `/* */` for comments.\n Don't use `//` for line breaks.\n Don't use `//` for code formatting.\n Don't use `//` for code explanation.\n Don't use `//` for code documentation.\n Don't use `//` for code layout.\n Don't use `//` for code formatting.\n Don't use `//` for code explanation..\n Don't use `//` for code documentation..\n Don't use `//` for code layout..\n Don't use `//` for code comment.\n Don't use `//` for code documentation..\n Don't use `//` for code layout.\n 2 spaces of indentation for the if-else block.\n 8 spaces of indentation for the for-loop.\n 4 spaces of indentation for the else block.\n 8 spaces of indentation for the while-loop.\n 4 spaces of indentation for the else-if block.\n 2 spaces of indentation for the else block.\n 8 spaces of indentation for the do-while-loop.\n 8 spaces of indentation for the switch-case block.\n 4 spaces of indentation for the default block.\n 2 spaces of indentation for the endif block.\n 8 spaces of indentation for the for-loop.\n 8 spaces of indentation for the while-loop..\n 4 spaces of indentation for the else-if block.\n 2 spaces of indentation for the endfor block.\n 2 spaces of indentation for the endwhile block.\n 2 spaces of indentation for the enddo block.\n 2 spaces of indentation for the endswitch block.\n 2 spaces of indentation for the endif block.\n 2 spaces of indentation for the endmodule block.\n // Don't use `//` for code comment.\n // Don't use `/* */` for code comment..\n // Don't use `/* */` for code documentation.\n // Don't use `/* */` for code formatting.\n // Don't use `/* */` for code explanation.\n // 1 space of indentation for the code block.\n // 1 space of indentation for the if-else block.\n // 1 space of indentation for the for-loop.\n // 1 space of indentation for the else block.\n // 1 space of indentation for the while-loop.\n // 1 space of indentation for the else-if block.\n // 1 space of indentation for the else block.\n // 1 space of indentation for the do-while-loop.\n // 1 space of indentation for the case block.\n // 1 space of indentation for the default block.\n // 1 space of indentation for the endif block.\n // 1 space of indentation for the endfor block.\n // 1 space of indentation for the endswitch block..\n // 1 space of indentation for the enddo block.\n // 1 space of indentation for the endswitch block..\n // 1 space of indentation for the else block.\n // 1 space of indentation for the endcase block.\n // 1 space of indentation for the endwhile block.\n // 1 space of indentation for the endif block..\n // 1 space of indentation for the else-if block.\n // 1 space of indentation for the endif block.\n 140 characters per line.\n 80 characters per line for long lines.\n 2 spaces of indentation for the code block.\n // Don't use `//` for code comment..\n // Don't use `/* */` for code comment.\n // Don't use `/* */` for code documentation.\n // Don't use `/* */` for code formatting..\n // Don't use `/* */` for code explanation..\n // Don't use `/* */` for code layout..\n // 1 space of indentation for the code block.\n // 1"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n    reg [99:0] temp;\n    integer i;\n\n    always @(*) begin\n        temp = 0;\n        for (i = 0; i < 100; i = i + 1) begin\n            temp[99-i] = in[i];\n        end\n        out = temp;\n    end\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "// D flip-flop\nreg d;\nalways @(posedge clk) begin\n\td <= in;\nend\n\n// XOR gate\nassign out = in ^ d;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {q[2:0], 1'b0};\n        end\n    end\n\n endmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "8 D flip-flops with asynchronous reset:\n```verilog\n\treg [7:0] q;\n\talways @(posedge clk or negedge areset) begin\n\t\tif(!areset) begin\n\t\t\tq <= 8'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    wire [7:0] abcd;\n    wire [7:0] abcde;\n    wire [7:0] abcdf;\n\n    assign abcd = {a, b, c, d};\n    assign abcde = {abcd, e};\n    assign abcdf = {abcd, f};\n\n    assign w = {abcdf, 2'b11};\n    assign x = {abcde, 2'b11};\n    assign y = {abcd, 2'b11};\n    assign z = {abcd, 2'b11};\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// State register\nreg [1:0] state_reg, state_next;\n\n// Output register\nreg out_reg;\n\n// Combinational logic\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tstate_reg <= B;\n\t\tout_reg <= 1'b1;\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\t\tout_reg <= (state_reg == A) ? 1'b0 : 1'b1;\n\tend\nend\n\n// State transition logic\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tstate_next <= B;\n\tend\n\telse begin\n\t\tcase (state_reg)\n\t\t\tA: state_next <= (in) ? A : B;\n\t\t\tB: state_next <= (in) ? B : A;\n\t\tendcase\n\tend\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    wire w1, w2, w3;\n    xor x1(sum, a, b);\n    and a1(w1, a, b);\n    and a2(w2, a, cin);\n    and a3(w3, b, cin);\n    or o1(cout, w1, w2, w3);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "https://www.verilog.com/news/verilog-coding-standard-and-style-guide_11866.html"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "endmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // Define the states\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n\n    // Define the output encoding\n    localparam ENC_Z_A = 1'b0;\n    localparam ENC_Z_B = 1'b1;\n\n    // Define the state register and initialize to state A\n    reg [1:0] state_reg = A;\n\n    // Define the next state logic\n    always @ (posedge clk, posedge areset) begin\n        if (areset) begin\n            state_reg <= A;\n        end\n        else begin\n            case (state_reg)\n                A: begin\n                    if (x) begin\n                        state_reg <= B;\n                    end\n                end\n                B: begin\n                    if (!x) begin\n                        state_reg <= B;\n                    end\n                    else begin\n                        state_reg <= A;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the output logic\n    always @ (state_reg, x) begin\n        case (state_reg)\n            A: begin\n                z <= ENC_Z_A;\n            end\n            B: begin\n                z <= ENC_Z_B;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg [1:0] state_reg;\n    wire q_wire;\n\n    assign state = state_reg[1:0];\n    assign q = q_wire;\n\n    always @(posedge clk) begin\n        case ({a,b})\n            2'b00: state_reg <= 2'b00;\n            2'b01: state_reg <= 2'b01;\n            2'b10: state_reg <= 2'b10;\n            2'b11: state_reg <= 2'b11;\n        endcase\n    end\n\n    assign q_wire = state_reg[1];\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "The Verilog code for the function f should be implemented as shown below.\n```verilog\nalways @ (*) begin\n\tcase (x)\n\t\t4'b0000: f = 1'b1;\n\t\t4'b0001: f = 1'b0;\n\t\t4'b0010: f = 1'b0;\n\t\t4'b0011: f = 1'b1;\n\t\t4'b0100: f = 1'b1;\n\t\t4'b0101: f = 1'b1;\n\t\t4'b0110: f = 1'b1;\n\t\t4'b0111: f = 1'b0;\n\t\t4'b1000: f = 1'b1;\n\t\t4'b1001: f = 1'b1;\n\t\t4'b1010: f = 1'b0;\n\t\t4'b1011: f = 1'b1;\n\t\t4'b1100: f = 1'b1;\n\t\t4'b1101: f = 1'b1;\n\t\t4'b1110: f = 1'b1;\n\t\t4'b1111: f = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output disc,\n    output flag,\n    output err);\n\n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n    parameter S3 = 2'b11;\n\n    reg [1:0] state;\n    reg [3:0] input_buffer;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            input_buffer <= 4'b0;\n        end else begin\n            case (state)\n                S0: begin\n                    if (in == 1'b0) begin\n                        state <= S1;\n                        input_buffer <= 4'b0;\n                    end\n                end\n                S1: begin\n                    if (input_buffer == 4'b01111) begin\n                        state <= S2;\n                        input_buffer <= 4'b0;\n                    end else if (input_buffer == 4'b011111) begin\n                        state <= S3;\n                        input_buffer <= 4'b0;\n                    end else begin\n                        input_buffer <= {input_buffer[2:0], in};\n                    end\n                end\n                S2: begin\n                    state <= S1;\n                    input_buffer <= 4'b0;\n                    flag <= 1'b1;\n                end\n                S3: begin\n                    state <= S1;\n                    input_buffer <= 4'b0;\n                    err <= 1'b1;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (state == S2) begin\n            disc <= 1'b1;\n        end else begin\n            disc <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "// (1) detect 1101\n\n// (2) shift in 4 more bits to determine the duration to delay\n\n// (3) wait for the counters to finish counting\n\n// (4) notifies the user and waits for the user to acknowledge the timer\n\n// register to hold the delay value\nreg [3:0] delay;\n\n// state machine\nreg [1:0] state;\nparameter IDLE = 2'b00;\nparameter SEARCH = 2'b01;\nparameter COUNTING = 2'b10;\n\n// delay counter\nreg [9:0] delay_count;\nparameter COUNT_MAX = 1000;\n\n// remaining time counter\nreg [9:0] time_left;\nreg [3:0] time_left_reg;\n\n// start sequence\nreg [3:0] pattern;\n\n// done signal\nreg done_reg;\n\n// set initial values\ninitial begin\n    state <= IDLE;\n    delay <= 4'b0;\n    delay_count <= 10'b0;\n    time_left_reg <= 4'b0;\n    pattern <= 4'b0;\n    done_reg <= 1'b0;\nend\n\n// state machine\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        delay_count <= 10'b0;\n        time_left_reg <= 4'b0;\n        pattern <= 4'b0;\n        done_reg <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (data == 1'b1) begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= SEARCH;\n                    end\n                end\n            end\n            SEARCH: begin\n                if (data == 1'b1) begin\n                    pattern <= {pattern[2:0], data};\n                    if (pattern == 4'b1101) begin\n                        state <= COUNTING;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            COUNTING: begin\n                if (delay_count == COUNT_MAX) begin\n                    done_reg <= 1'b1;\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\n// shift in delay bits\nalways @(posedge clk) begin\n    if (state == SEARCH) begin\n        delay <= {delay[2:0], data};\n    end\nend\n\n// delay counter\nalways @(posedge clk) begin\n    if (state == COUNTING) begin\n        if (delay_count == COUNT_MAX) begin\n            delay_count <= 10'b0;\n        end else begin\n            delay_count <= delay_count + 1;\n        end\n    end\nend\n\n// remaining time counter\nalways @(posedge clk) begin\n    if (state == COUNTING) begin\n        if (time_left_reg == 4'b0) begin\n            time_left_reg <= delay;\n        end else begin\n            time_left_reg <= time_left_reg - 1;\n        end\n    end\nend\n\n// counting output\nalways @(posedge clk) begin\n    if (state == COUNTING) begin\n        counting <= 1'b1;\n    end else begin\n        counting <= 1'b0;\n    end\nend\n\n// done signal\nalways @(posedge clk) begin\n    if (state == COUNTING) begin\n        if (done_reg) begin\n            done <= 1'b1;\n        end else begin\n            done <= 1'b0;\n        end\n    end\nend\n\n// ack input\nalways @(posedge clk) begin\n    if (ack) begin\n        done_reg <= 1'b0;\n    end\nend\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// Define states\n\tparameter IDLE = 2'b00;\n\tparameter LOW = 2'b01;\n\tparameter MID = 2'b10;\n\tparameter HIGH = 2'b11;\n\n\t// Define constants\n\tlocalparam FR1_LEVEL = 4'b0001;\n\tlocalparam FR2_LEVEL = 4'b0010;\n\tlocalparam FR3_LEVEL = 4'b0100;\n\tlocalparam FR1_MAX_LEVEL = 4'b1000;\n\tlocalparam FR2_MAX_LEVEL = 4'b0100;\n\tlocalparam FR3_MAX_LEVEL = 4'b0010;\n\n\t// Define state and next_state registers\n\treg [1:0] state, next_state;\n\n\t// Define level and prev_level registers\n\treg [3:0] level, prev_level;\n\n\t// Define flow rate registers\n\treg [3:0] fr_reg;\n\n\t// Define flow rate logic\n\talways @ (posedge clk) begin\n\t\tif (reset) begin\n\t\t\tfr_reg <= 4'b0000;\n\t\t\tfr3 <= 0;\n\t\t\tfr2 <= 0;\n\t\t\tfr1 <= 0;\n\t\t\tdfr <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (level >= FR1_MAX_LEVEL) begin\n\t\t\t\t\t\tfr_reg <= FR3_LEVEL;\n\t\t\t\t\t\tfr3 <= 1;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\t\tdfr <= 0;\n\t\t\t\t\tend else if (level >= FR2_MAX_LEVEL) begin\n\t\t\t\t\t\tfr_reg <= FR2_LEVEL;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\t\tdfr <= 0;\n\t\t\t\t\tend else if (level >= FR1_LEVEL) begin\n\t\t\t\t\t\tfr_reg <= FR1_LEVEL;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tfr_reg <= 4'b0000;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tLOW: begin\n\t\t\t\t\tif (level >= FR1_MAX_LEVEL) begin\n\t\t\t\t\t\tfr_reg <= FR1_LEVEL;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 0;\n\t\t\t\t\tend else if (level >= FR2_MAX_LEVEL) begin\n\t\t\t\t\t\tfr_reg <= FR2_LEVEL;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\t\tdfr <= 0;\n\t\t\t\t\tend else if (level >= FR1_LEVEL) begin\n\t\t\t\t\t\tfr_reg <= FR1_LEVEL;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 1;"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    reg [3:0] state;\n    reg [7:0] data;\n    reg start_bit;\n    reg stop_bit;\n    reg done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 4'b0000;\n            data <= 8'b00000000;\n            start_bit <= 1'b0;\n            stop_bit <= 1'b0;\n            done_reg <= 1'b0;\n        end else begin\n            case (state)\n                4'b0000: begin // Idle state\n                    if (in == 1'b0) begin\n                        start_bit <= 1'b1;\n                        state <= 4'b0001;\n                    end\n                end\n                4'b0001: begin // Wait for start bit\n                    if (in == 1'b1) begin\n                        state <= 4'b0010;\n                    end\n                end\n                4'b0010: begin // Read data bits\n                    data <= {data[6:0], in};\n                    if (in == 1'b1) begin\n                        state <= 4'b0100;\n                    end\n                end\n                4'b0100: begin // Wait for stop bit\n                    if (in == 1'b0) begin\n                        stop_bit <= 1'b1;\n                        state <= 4'b0000;\n                        done_reg <= 1'b1;\n                    end else begin\n                        stop_bit <= 1'b0;\n                        state <= 4'b0010;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "endmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n\treg [6:0] history;\n\treg [6:0] pht_history;\n\treg [6:0] pht_index;\n\treg [1:0] pht_table [0:127];\n\twire [1:0] pht_table_output [0:127];\n\twire [6:0] pht_table_index;\n\twire [1:0] pht_table_input;\n\twire [1:0] pht_table_training;\n\twire pht_table_training_valid;\n\twire pht_table_training_taken;\n\twire pht_table_training_mispredicted;\n\twire pht_table_training_history;\n\n\tassign pht_table_training = {pht_table_training_taken, pht_table_training_mispredicted};\n\n\tassign pht_table_index = history ^ predict_pc;\n\n\tassign pht_table_training_valid = train_valid & (pht_table_index == train_pc);\n\tassign pht_table_training_taken = train_taken;\n\tassign pht_table_training_mispredicted = train_mispredicted;\n\tassign pht_table_training_history = train_history;\n\n\tassign predict_taken = pht_table_output[pht_table_index][1];\n\tassign predict_history = pht_table_output[pht_table_index][0];\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\thistory <= 7'b0;\n\t\t\tpht_history <= 7'b0;\n\t\t\tpht_index <= 7'b0;\n\t\tend else begin\n\t\t\tif (predict_valid) begin\n\t\t\t\tpht_history <= history;\n\t\t\t\tpht_index <= history ^ predict_pc;\n\t\t\tend\n\t\t\tif (pht_table_training_valid) begin\n\t\t\t\tpht_history <= pht_table_training_history;\n\t\t\t\tpht_index <= pht_table_index;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign pht_table_output[0] = pht_table[0];\n\tassign pht_table_output[1] = pht_table[1];\n\tassign pht_table_output[2] = pht_table[2];\n\tassign pht_table_output[3] = pht_table[3];\n\tassign pht_table_output[4] = pht_table[4];\n\tassign pht_table_output[5] = pht_table[5];\n\tassign pht_table_output[6] = pht_table[6];\n\tassign pht_table_output[7] = pht_table[7];\n\tassign pht_table_output[8] = pht_table[8];\n\tassign pht_table_output[9] = pht_table[9];\n\tassign pht_table_output[10] = pht_table[10];\n\tassign pht_table_output[11] = pht_table[11];\n\tassign pht_table_output[12] = pht_table[12];\n\tassign pht_table_output[13] = pht_table[13];\n\tassign pht_table_output[14] = pht_table[14];\n\tassign pht_table_output[15] = pht_table[15];\n\tassign pht_table_output[16] = pht_table[16];\n\tassign pht_table_output[17] = pht_table"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "Module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tlocalparam [1:0] STATE_WALK_LEFT = 2'b00;\n\tlocalparam [1:0] STATE_WALK_RIGHT = 2'b01;\n\tlocalparam [1:0] STATE_DIGGING = 2'b10;\n\tlocalparam [1:0] STATE_FALLING = 2'b11;\n\treg [1:0] current_state, next_state;\n\n\t// Define the output signals\n\treg walk_left_out, walk_right_out, aaah_out, digging_out;\n\tassign walk_left = walk_left_out;\n\tassign walk_right = walk_right_out;\n\tassign aaah = aaah_out;\n\tassign digging = digging_out;\n\n\t// Define the state transition and output logic\n\talways @ (posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= STATE_WALK_LEFT;\n\t\t\twalk_left_out <= 1;\n\t\t\twalk_right_out <= 0;\n\t\t\taaah_out <= 0;\n\t\t\tdigging_out <= 0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tcase (current_state)\n\t\t\t\tSTATE_WALK_LEFT: begin\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\t\t\twalk_left_out = 0;\n\t\t\t\t\t\twalk_right_out = 1;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tnext_state = STATE_DIGGING;\n\t\t\t\t\t\twalk_left_out = 0;\n\t\t\t\t\t\twalk_right_out = 0;\n\t\t\t\t\t\tdigging_out = 1;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tnext_state = STATE_FALLING;\n\t\t\t\t\t\twalk_left_out = 0;\n\t\t\t\t\t\twalk_right_out = 0;\n\t\t\t\t\t\taaah_out = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\t\t\twalk_left_out = 1;\n\t\t\t\t\t\twalk_right_out = 0;\n\t\t\t\t\t\taaah_out = 0;\n\t\t\t\t\t\tdigging_out = 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTATE_WALK_RIGHT: begin\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\t\t\twalk_left_out = 1;\n\t\t\t\t\t\twalk_right_out = 0;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tnext_state = STATE_DIGGING;\n\t\t\t\t\t\twalk_left_out = 0;\n\t\t\t\t\t\twalk_right_out = 0;\n\t\t\t\t\t\tdigging_out = 1;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tnext_state = STATE_FALLING;\n\t\t\t\t\t\twalk_left_out = 0;\n\t\t\t\t\t\twalk_right_out = 0;\n\t\t\t\t\t\taaah_out = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\t\t\twalk_left_out = 0;"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // State encoding\n    parameter IDLE = 2'b00;\n    parameter SEARCHING = 2'b01;\n    parameter SHIFTING = 2'b10;\n    parameter COUNTING = 2'b11;\n\n    // State and next state registers\n    reg [1:0] state, next_state;\n\n    // Pattern match register\n    reg match;\n\n    // Counter for shift duration\n    reg [3:0] shift_count;\n\n    // Verilog code for the state machine\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            match <= 0;\n            shift_count <= 0;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            match <= (data == 4'b1101);\n            shift_count <= (match) ? shift_count + 1 : 0;\n            if (shift_count == 4) begin\n                next_state <= SHIFTING;\n                shift_ena <= 1;\n            end else begin\n                shift_ena <= 0;\n            end\n            if (match) begin\n                next_state <= SEARCHING;\n            end\n            if (done_counting) begin\n                next_state <= COUNTING;\n                counting <= 1;\n            end\n            if (ack) begin\n                next_state <= IDLE;\n                done <= 0;\n            end\n        end\n    end\n\n    // Verilog code for the output\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            if (match) begin\n                shift_count <= 0;\n            end\n            if (counting) begin\n                done <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    reg [15:0] q_next; // next state of the game\n    reg [3:0] count; // number of neighbours for each cell\n    reg [15:0] row; // current row of the grid\n    reg [15:0] col; // current column of the grid\n    reg [15:0] nrow; // next row of the grid\n    reg [15:0] ncol; // next column of the grid\n\n    always @(posedge clk) begin\n        if (load) begin\n            q_next <= data;\n            count <= 0;\n            row <= 0;\n            col <= 0;\n            nrow <= 0;\n            ncol <= 0;\n        end else begin\n            // increment time step\n            q_next <= q;\n            count <= 0;\n            row <= 0;\n            col <= 0;\n            nrow <= 0;\n            ncol <= 0;\n            \n            // check each cell and update q_next\n            for (row = 0; row < 16; row = row + 1) begin\n                for (col = 0; col < 16; col = col + 1) begin\n                    count = 0;\n                    nrow = (row == 0) ? 15 : row - 1;\n                    ncol = (col == 0) ? 15 : col - 1;\n                    \n                    if (q_next[col] && q_next[ncol]) count = count + 2;\n                    if (q_next[ncol] && q_next[col+1]) count = count + 2;\n                    if (q_next[nrow] && q_next[col]) count = count + 2;\n                    if (q_next[nrow] && q_next[col+1]) count = count + 2;\n                    \n                    if (count == 2) q_next[col] = q_next[col];\n                    else if (count == 3) q_next[col] = 1'b1;\n                    else q_next[col] = 1'b0;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load) q <= data;\n        else q <= q_next;\n    end\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // State encoding\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n    parameter FALLING = 2'b10;\n    parameter DIGGING = 2'b11;\n\n    // State register\n    reg [1:0] state;\n\n    // Next state logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            case (state)\n                WALK_LEFT: begin\n                    if (bump_left) begin\n                        state <= WALK_RIGHT;\n                    end else if (!ground) begin\n                        state <= FALLING;\n                    end else if (dig) begin\n                        state <= DIGGING;\n                    end\n                end\n                WALK_RIGHT: begin\n                    if (bump_right) begin\n                        state <= WALK_LEFT;\n                    end else if (!ground) begin\n                        state <= FALLING;\n                    end else if (dig) begin\n                        state <= DIGGING;\n                    end\n                end\n                FALLING: begin\n                    if (ground) begin\n                        state <= WALK_LEFT;\n                    end\n                end\n                DIGGING: begin\n                    if (!ground) begin\n                        state <= FALLING;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "// Declare state encoding and parameters\n`define walk_left 2'b00\n`define walk_right 2'b01\n`define bump_left 1'b1\n`define bump_right 1'b1\n`define aaah 1'b1\n`define ground 1'b1\n\n`define state_width 3\n`define state_idle `state_0\n`define state_walk_left `state_1\n`define state_walk_right `state_2\n`define state_fall `state_3\n`define state_bump `state_4\n`define state_bump_fall `state_5\n\nreg [`state_width-1:0] state_reg;\nreg [`state_width-1:0] next_state;\nreg walk_left_reg;\nreg walk_right_reg;\nreg aaah_reg;\n\nassign walk_left = walk_left_reg;\nassign walk_right = walk_right_reg;\nassign aaah = aaah_reg;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= `state_idle;\n\t\twalk_left_reg <= 1'b1;\n\t\twalk_right_reg <= 1'b0;\n\t\taaah_reg <= 1'b0;\n\tend else begin\n\t\tstate_reg <= next_state;\n\t\tcase (state_reg)\n\t\t`state_idle: begin\n\t\t\tif (bump_left) begin\n\t\t\t\tnext_state = `state_bump;\n\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\twalk_right_reg <= 1'b1;\n\t\t\t\taaah_reg <= 1'b0;\n\t\t\tend else if (bump_right) begin\n\t\t\t\tnext_state = `state_bump;\n\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\taaah_reg <= 1'b0;\n\t\t\tend else if (ground == 1'b0) begin\n\t\t\t\tnext_state = `state_fall;\n\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\taaah_reg <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tnext_state = `state_walk_left;\n\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\taaah_reg <= 1'b0;\n\t\t\tend\n\t\tend\n\t\t`state_walk_left: begin\n\t\t\tif (bump_left) begin\n\t\t\t\tnext_state = `state_bump;\n\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\twalk_right_reg <= 1'b1;\n\t\t\t\taaah_reg <= 1'b0;\n\t\t\tend else if (bump_right) begin\n\t\t\t\tnext_state = `state_bump;\n\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\taaah_reg <= 1'b0;\n\t\t\tend else if (ground == 1'b0) begin\n\t\t\t\tnext_state = `state_fall;\n\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\taaah_reg <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tnext_state = `state_walk_left;\n\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\taaah_reg <= 1'b0;\n\t\t\tend\n\t\tend\n\t\t`state_walk_right: begin\n\t\t\tif (b"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "Use the following Verilog code to implement the 4-digit BCD counter:\n```verilog\n\treg [3:0] ones, tens, hundreds, thousands;\n\treg [2:0] ena_reg;\n\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'b0;\n\t\t\tones <= 4'b0;\n\t\t\ttens <= 4'b0;\n\t\t\thundreds <= 4'b0;\n\t\t\tthousands <= 4'b0;\n\t\t\tena_reg <= 3'b0;\n\t\tend else begin\n\t\t\tif (thousands == 4'b1001) begin\n\t\t\t\tthousands <= 4'b0;\n\t\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\t\thundreds <= 4'b0;\n\t\t\t\t\tif (tens == 4'b1001) begin\n\t\t\t\t\t\ttens <= 4'b0;\n\t\t\t\t\t\tif (ones == 4'b1001) begin\n\t\t\t\t\t\t\tones <= 4'b0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tones <= ones + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\ttens <= tens + 1;\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tthousands <= thousands + 1;\n\t\t\tend\n\n\t\t\tif (thousands == 4'b1000) begin\n\t\t\t\tena_reg[2] <= 1;\n\t\t\tend else begin\n\t\t\t\tena_reg[2] <= 0;\n\t\t\tend\n\n\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\tena_reg[1] <= 1;\n\t\t\tend else begin\n\t\t\t\tena_reg[1] <= 0;\n\t\t\tend\n\n\t\t\tif (tens == 4'b1001) begin\n\t\t\t\tena_reg[0] <= 1;\n\t\t\tend else begin\n\t\t\t\tena_reg[0] <= 0;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign ena = ena_reg;\n\tassign q = {thousands, hundreds, tens, ones};\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "input [99:0] a;\n\tinput [99:0] b;\n\tinput sel;\n\toutput [99:0] out;\n\n\tassign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "// Next-state logic for y[2]\nalways @ (w) begin\n\tcase (y[3:1])\n\t\t3'b000: Y2 <= 0;\n\t\t3'b001: Y2 <= 1;\n\t\t3'b010: Y2 <= 0;\n\t\t3'b011: Y2 <= 1;\n\t\t3'b100: Y2 <= 0;\n\t\t3'b101: Y2 <= 1;\n\t\t3'b110: Y2 <= 0;\n\t\t3'b111: Y2 <= 1;\n\tendcase\nend\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "Then, add the logic to control the ringer and the motor based on the ring input and the vibrate_mode input. If the vibrate_mode is 1, turn on the motor, otherwise turn on the ringer. If the ring is 1, turn on the ringer or the motor based on the vibrate_mode.\n```verilog\n\tassign ringer = ring & !vibrate_mode;\n\tassign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "always @(*) begin\n    out_alwaysblock = a & b;\nend"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "endmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    reg [1:0] state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    always @(posedge clk) begin\n        case(state)\n            S0: begin\n                if(a) state <= S1;\n                else state <= S0;\n            end\n            S1: begin\n                state <= S2;\n            end\n            S2: begin\n                state <= S3;\n            end\n            S3: begin\n                state <= S0;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        case(state)\n            S0: q <= 1'b0;\n            S1: q <= 1'b1;\n            S2: q <= 1'b1;\n            S3: q <= 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// Define states\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\t\n\t// Define outputs\n\toutput reg [1:0] state;\n\toutput reg z;\n\t\n\t// Define state register and next state logic\n\treg [1:0] state_reg;\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate_reg <= S0;\n\t\t\tz <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state_reg)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate_reg <= S1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tstate_reg <= S2;\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tstate_reg <= S3;\n\t\t\t\tend\n\t\t\t\tS3: begin\n\t\t\t\t\tstate_reg <= S0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Define output logic\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tz <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state_reg)\n\t\t\t\tS0: begin\n\t\t\t\t\tz <= 1'b0;\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tz <= ~x;\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tz <= z + 1'b1;\n\t\t\t\tend\n\t\t\t\tS3: begin\n\t\t\t\t\tz <= z + 1'b1;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Assign output\n\tassign state = state_reg;\n\t\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n\n// state encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// state register\nreg [1:0] state;\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= A;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\t\tout <= 1'b0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\t\tout <= 1'b0;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\t\tout <= 1'b0;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\t\tout <= 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "// Synchronous reset\nalways @(posedge clk) begin\n\tif (r == 1'b1) begin\n\t\tq <= 1'b0;\n\tend else begin\n\t\tq <= d;\n\tend\nend\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n        input x,\n        input y,\n        output z);\n        assign z = (x ^ y) & x;\n    endmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if(load) begin\n            q <= data;\n        end\n        else if(ena) begin\n            case(amount)\n                2'b00: q <= {q[62:0], q[63]};\n                2'b01: q <= {q[55:0], q[63:56]};\n                2'b10: q <= {q[63], q[62:0]};\n                2'b11: q <= {q[55:0], q[63:56]};\n                default: q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "3 states, 3 transitions\n\n assign initial state = 0\n\n assign z = 0\n\n always @(negedge aresetn or posedge clk) begin\n \tif (~aresetn) begin\n \t\tz <= 0;\n \tend else begin\n \t\tcase (state)\n \t\t\t0: begin\n \t\t\t\tif (x == 1'b1) begin\n \t\t\t\t\tstate <= 1;\n \t\t\t\tend else begin\n \t\t\t\t\tstate <= 0;\n \t\t\t\tend\n \t\t\tend\n \t\t\t1: begin\n \t\t\t\tif (x == 1'b0) begin\n \t\t\t\t\tstate <= 2;\n \t\t\t\tend else if (x == 1'b1) begin\n \t\t\t\t\tstate <= 1;\n \t\t\t\tend else begin\n \t\t\t\t\tstate <= 0;\n \t\t\t\tend\n \t\t\tend\n \t\t\t2: begin\n \t\t\t\tif (x == 1'b1) begin\n \t\t\t\t\tstate <= 0;\n \t\t\t\t\tz <= 1;\n \t\t\t\tend else begin\n \t\t\t\t\tstate <= 1;\n \t\t\t\tend\n \t\t\tend\n \t\tendcase\n \tend\n end\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // Define the state and next_state variables\n    reg [1:0] state, next_state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // Define the output logic\n    assign z = state[1];\n\n    // Define the state transition logic\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Define the next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w) begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            B: begin\n                if (w) begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            C: begin\n                if (w) begin\n                    next_state = D;\n                end\n                else begin\n                    next_state = C;\n                end\n            end\n            D: begin\n                if (w) begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = C;\n                end\n            end\n            E: begin\n                if (w) begin\n                    next_state = E;\n                end\n                else begin\n                    next_state = D;\n                end\n            end\n            F: begin\n                if (w) begin\n                    next_state = C;\n                end\n                else begin\n                    next_state = D;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n    // Define the FSM states\n    // 0: Waiting for byte 1\n    // 1: Waiting for byte 2\n    // 2: Waiting for byte 3\n    // 3: Done\n    // 4: Error\n    // 5: Done\n    reg [1:0] state = 2'b00;\n    reg [7:0] byte1 = 8'b0;\n    reg [7:0] byte2 = 8'b0;\n    reg [7:0] byte3 = 8'b0;\n\n    // Initialize the output\n    assign out_bytes = 24'b0;\n    assign done = 1'b0;\n\n    // Define the FSM\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 2'b00;\n            byte1 <= 8'b0;\n            byte2 <= 8'b0;\n            byte3 <= 8'b0;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (in[3] == 1) begin\n                        byte1 <= in;\n                        state <= 2'b01;\n                    end\n                end\n                2'b01: begin\n                    if (in[3] == 1) begin\n                        byte2 <= in;\n                        state <= 2'b10;\n                    end else begin\n                        state <= 2'b00;\n                    end\n                end\n                2'b10: begin\n                    if (in[3] == 1) begin\n                        byte3 <= in;\n                        out_bytes <= {byte3, byte2, byte1};\n                        done <= 1'b1;\n                        state <= 2'b00;\n                    end\n                end\n                2'b11: begin\n                    state <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // Define state flip-flop signals\n    reg [5:0] y_reg;\n    wire [5:0] y_next;\n    \n    // Define signals for each state\n    wire A = (y_reg == 6'b000001);\n    wire B = (y_reg == 6'b000010);\n    wire C = (y_reg == 6'b000100);\n    wire D = (y_reg == 6'b001000);\n    wire E = (y_reg == 6'b010000);\n    wire F = (y_reg == 6'b100000);\n    \n    // Define signals for the transitions\n    wire Y1_A = ~A;\n    wire Y1_B = A;\n    wire Y1_C = B;\n    wire Y1_D = C;\n    wire Y1_E = D;\n    wire Y1_F = E;\n    \n    wire Y3_A = ~A;\n    wire Y3_B = A;\n    wire Y3_C = B;\n    wire Y3_D = C;\n    wire Y3_E = D;\n    wire Y3_F = E;\n    \n    // Define the next state logic\n    assign y_next = y;\n    always @ (y) begin\n        case (y)\n            6'b000001: y_next = {A, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n            6'b000010: y_next = {B, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n            6'b000100: y_next = {C, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n            6'b001000: y_next = {D, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n            6'b010000: y_next = {E, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n            6'b100000: y_next = {F, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n            default: y_next = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};\n        endcase\n    end\n    \n    // Define the state flip-flop logic\n    always @ (posedge w) begin\n        y_reg <= y_next;\n    end\n    \n    // Define the output signals\n    assign Y1 = (A || Y1_B || Y1_C || Y1_D || Y1_E || Y1_F);\n    assign Y3 = (A || Y3_B || Y3_C || Y3_D || Y3_E || Y3_F);\n    \nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module instances.\n\nDo not use 0-width module imports.\n\nDo not use 0-width module exports.\n\n 3 out ports, same input vector\nmodule top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "and end with:\n```verilog\nalways @(*)\nbegin\n\tcase ({a,b,c,d})\n\t\t4'b0000: out = 1'b0;\n\t\t4'b0001: out = 1'b1;\n\t\t4'b0011: out = 1'b1;\n\t\t4'b0010: out = 1'b0;\n\t\t4'b0100: out = 1'b1;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0111: out = 1'b0;\n\t\t4'b0110: out = 1'b1;\n\t\t4'b1000: out = 1'b0;\n\t\t4'b1001: out = 1'b1;\n\t\t4'b1011: out = 1'b1;\n\t\t4'b1010: out = 1'b0;\n\t\tdefault: out = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n                                input a, \n                                input b,\n                                output out\n                            );\n                            \n                              assign out = ~(a | b); \n                            \n                            endmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "// Derive the logic equations by inspection assuming a one-hot encoding.\n\t// For example, Y2 = 1 for state B (000010) implies that Y2 = 0 for all other states.\n\t// Similarly, Y4 = 1 for state D (001000) implies that Y4 = 0 for all other states.\n\n\t// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4].\n\tassign Y2 = (y[6:1] == 6'b000010) ? 1'b1 : 1'b0;\n\tassign Y4 = (y[6:1] == 6'b001000) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\n    reg q_next;\n    always @(posedge clk) begin\n        if (L) begin\n            q_next <= R;\n        end else if (E) begin\n            q_next <= w;\n        end else begin\n            q_next <= Q;\n        end\n    end\n    assign Q = q_next;\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// D flip-flops\nreg q1, q2, q3;\n\n// XOR gate\nxor(q1, x, q2);\n\n// AND gate\nand(q2, q1, q3);\n\n// OR gate\nor(q3, q2, q1);\n\n// XNOR gate\nxnor(z, q1, q2, q3);\n\n// Clock domain\nalways @(posedge clk) begin\n\tq1 <= x;\n\tq2 <= q1;\n\tq3 <= q2;\nend\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b) | (c & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Rule 110 cellular automaton\n\nreg [511:0] q_next;\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else begin\n\t\tq <= q_next;\n\tend\nend\n\nalways @(*) begin\n\tq_next[0] = q[1] & q[0] & ~q[1];\n\tq_next[1] = q[2] & q[1] & ~q[0];\n\tq_next[2] = q[3] & q[2] & ~q[1];\n\tq_next[3] = q[4] & q[3] & ~q[2];\n\tq_next[4] = q[5] & q[4] & ~q[3];\n\tq_next[5] = q[6] & q[5] & ~q[4];\n\tq_next[6] = q[7] & q[6] & ~q[5];\n\tq_next[7] = q[8] & q[7] & ~q[6];\n\tq_next[8] = q[9] & q[8] & ~q[7];\n\tq_next[9] = q[10] & q[9] & ~q[8];\n\tq_next[10] = q[11] & q[10] & ~q[9];\n\tq_next[11] = q[12] & q[11] & ~q[10];\n\tq_next[12] = q[13] & q[12] & ~q[11];\n\tq_next[13] = q[14] & q[13] & ~q[12];\n\tq_next[14] = q[15] & q[14] & ~q[13];\n\tq_next[15] = q[16] & q[15] & ~q[14];\n\tq_next[16] = q[17] & q[16] & ~q[15];\n\tq_next[17] = q[18] & q[17] & ~q[16];\n\tq_next[18] = q[19] & q[18] & ~q[17];\n\tq_next[19] = q[20] & q[19] & ~q[18];\n\tq_next[20] = q[21] & q[20] & ~q[19];\n\tq_next[21] = q[22] & q[21] & ~q[20];\n\tq_next[22] = q[23] & q[22] & ~q[21];\n\tq_next[23] = q[24] & q[23] & ~q[22];\n\tq_next[24] = q[25] & q[24] & ~q[23];\n\tq_next[25] = q[26] & q[25] & ~q[24];\n\tq_next[26] = q[27] & q[26] & ~q[25];\n\tq_next[27] = q[28] & q[27] & ~q[26];\n\tq_next[28] = q[29] & q[28] & ~q[27];\n\tq_next[29] = q[30] & q[29] & ~q[28];\n\tq_next[30] = q[31] & q[30] & ~q[29];\n\tq_next[31] = q[32] & q[31] & ~q[30];\n\tq_next[32] = q[33] & q[32] & ~q[31];\n\tq_next[33] = q[34] & q[33] & ~q[32];\n\tq_next[34] = q[35] & q[34] & ~q[33];\n\tq_next[35"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Define the states\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\t\n\t// Define the state register\n\treg [1:0] state_reg;\n\t\n\t// Define the output register\n\treg out_reg;\n\t\n\t// Define the next state logic\n\talways @ (posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate_reg <= A;\n\t\tend else begin\n\t\t\tcase (state_reg)\n\t\t\t\tA: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate_reg <= B;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate_reg <= A;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 0;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate_reg <= B;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate_reg <= C;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 0;\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate_reg <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate_reg <= A;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 1;\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tstate_reg <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate_reg <= B;\n\t\t\t\t\tend\n\t\t\t\t\tout_reg <= 1;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Assign the output\n\tassign out = out_reg;\n\t\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\nalways @(*) begin\n    case ({a,b,c,d,e})\n        5'b00000: q = 4'b1111;\n        5'b10000: q = 4'b0000;\n        5'b01000: q = 4'b1010;\n        5'b00100: q = 4'b0101;\n        5'b00010: q = 4'b1000;\n        5'b00001: q = 4'b0111;\n        default: q = 4'bxxxx;\n    endcase\nend\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module\n**Author:** Verilog Expert\n**Date:** 03/18/2023\n**Version:** 1.0.0\n**Comments:** 2-to-1 Mux with 8-bit wide input and output\n\n```verilog\nmodule top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @ (sel or a or b) begin\n        if (sel == 1'b0) begin\n            out = a;\n        end else begin\n            out = b;\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module \"flipflop_mux\"\n\n// 1st instance\nwire mux_out1;\nwire r_out1;\nwire L_out1;\nflipflop_mux ff_mux1 (\n    .clk(clk),\n    .L(L),\n    .r(r_in),\n    .q(Q)\n);\n\n// 2nd instance\nwire mux_out2;\nwire r_out2;\nwire L_out2;\nflipflop_mux ff_mux2 (\n    .clk(clk),\n    .L(L),\n    .r(r_in),\n    .q(Q)\n);\n\n// 3rd instance\nwire mux_out3;\nwire r_out3;\nwire L_out3;\nflipflop_mux ff_mux3 (\n    .clk(clk),\n    .L(L),\n    .r(r_in),\n    .q(Q)\n);\n\n// 2-1 mux\nmux_2_1 mux1 (\n    .a(q_in),\n    .b(mux_out1),\n    .sel(L),\n    .y(mux_out2)\n);\n\n// 2-1 mux\nmux_2_1 mux2 (\n    .a(q_in),\n    .b(mux_out2),\n    .sel(L),\n    .y(mux_out3)\n);\n\n// assign outputs\nassign r_out1 = r_in;\nassign L_out1 = L;\nassign r_out2 = r_in;\nassign L_out2 = L;\nassign r_out3 = r_in;\nassign L_out3 = L;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 0;\n        prev_in <= 0;\n    end else begin\n        out <= (in & ~prev_in);\n        prev_in <= in;\n    end\nend\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "reg [7:0] q_reg;\n\n\t\talways @(posedge clk) begin\n\t\t\tq_reg <= d;\n\t\tend\n\n\t\tassign q = q_reg;\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    reg [8:0] temp;\n    wire [8:0] sum;\n\n    assign sum = a + b;\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7] && sum[7] != a[7]) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n // State encoding\n localparam S = 10'b0000000001;\n localparam S1 = 10'b0000000010;\n localparam S11 = 10'b0000000100;\n localparam S110 = 10'b0000001000;\n localparam B0 = 10'b0000010000;\n localparam B1 = 10'b0000100000;\n localparam B2 = 10'b0001000000;\n localparam B3 = 10'b0010000000;\n localparam Count = 10'b0100000000;\n localparam Wait = 10'b1000000000;\n\n // State transition and output logic\n always @(*) begin\n     case (state)\n         S: begin\n             B3_next = 1'b1;\n             S_next = 1'b0;\n             S1_next = 1'b0;\n             Count_next = 1'b0;\n             Wait_next = 1'b0;\n             done = 1'b0;\n             counting = 1'b0;\n             shift_ena = 1'b0;\n         end\n         S1: begin\n             B3_next = 1'b0;\n             S_next = 1'b1;\n             S1_next = 1'b0;\n             Count_next = 1'b0;\n             Wait_next = 1'b0;\n             done = 1'b0;\n             counting = 1'b0;\n             shift_ena = 1'b0;\n         end\n         S11: begin\n             B3_next = 1'b0;\n             S_next = 1'b0;\n             S1_next = 1'b1;\n             Count_next = 1'b0;\n             Wait_next = 1'b0;\n             done = 1'b0;\n             counting = 1'b0;\n             shift_ena = 1'b0;\n         end\n         S110: begin\n             B3_next = 1'b0;\n             S_next = 1'b0;\n             S1_next = 1'b0;\n             Count_next = 1'b1;\n             Wait_next = 1'b0;\n             done = 1'b0;\n             counting = 1'b1;\n             shift_ena = 1'b0;\n         end\n         B0: begin\n             B3_next = 1'b0;\n             S_next = 1'b0;\n             S1_next = 1'b0;\n             Count_next = 1'b0;\n             Wait_next = 1'b1;\n             done = 1'b0;\n             counting = 1'b0;\n             shift_ena = 1'b1;\n         end\n         B1: begin\n             B3_next = 1'b0;\n             S_next = 1'b0;\n             S1_next = 1'b0;\n             Count_next = 1'b0;\n             Wait_next = 1'b1;\n             done = 1'b0;\n             counting = 1'b0;\n             shift_ena = 1'b1;\n         end\n         B2: begin\n             B3_next = 1'b0;\n             S_next = 1'b0;\n             S1_next = 1'b0;\n             Count_next = 1'b0;"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "Module logic for a two-bit saturating counter that increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1, and decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01).\n```verilog\nreg [1:0] state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state == 2'b11) begin\n                state <= 2'b11;\n            end else begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state == 2'b00) begin\n                state <= 2'b00;\n            end else begin\n                state <= state - 1;\n            end\n        end\n    end\nend\n\nassign state[1] = state[1] & train_valid;\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module\n\nmodule top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @ (scancode) begin\n        case (scancode)\n            16'he06b: begin\n                left = 1;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n            16'he072: begin\n                left = 0;\n                down = 1;\n                right = 0;\n                up = 0;\n            end\n            16'he074: begin\n                left = 0;\n                down = 0;\n                right = 1;\n                up = 0;\n            end\n            16'he075: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 1;\n            end\n            default: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n    wire [3:0] carry;\n    wire [3:0] sum_bit;\n\n    full_adder fa0(x[0], y[0], 1'b0, sum_bit[0], carry[0]);\n    full_adder fa1(x[1], y[1], carry[0], sum_bit[1], carry[1]);\n    full_adder fa2(x[2], y[2], carry[1], sum_bit[2], carry[2]);\n    full_adder fa3(x[3], y[3], carry[2], sum_bit[3], carry[3]);\n\n    assign sum = {carry[3], sum_bit};\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// First layer of gates\n\twire and1_out;\n\twire and2_out;\n\tand and1 (and1_out, a, b);\n\tand and2 (and2_out, c, d);\n\t// Second layer of gates\n\tor or1 (out, and1_out, and2_out);\n\tnot not1 (out_n, out);\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n    reg [2:0] ABC;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (S) begin\n                Q[7:1] <= Q[6:0];\n                Q[0] <= S;\n            end else begin\n                Q <= Q;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (ABC)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "// mode = 1 for heating, 0 for cooling\n// too_cold = 1 when temperature is below setpoint\n// too_hot = 1 when temperature is above setpoint\n// fan_on = 1 when user requests fan to turn on\n// heater = 1 when heater is on\n// aircon = 1 when air conditioner is on\n// fan = 1 when fan is on\n\n// Combinational logic\nassign heater = mode & too_cold;\nassign aircon = mode & too_hot;\nassign fan = fan_on | heater | aircon;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Calculate out_sop in minimum sum-of-products form\n    assign out_sop = ~(a & ~b & ~c & d) & ~(~a & b & ~c & d) & ~(~a & ~b & c & d) & ~(a & b & c & ~d) & ~(~a & b & c & d) & ~(~a & ~b & c & d) & ~(a & ~b & c & d) & ~(~a & b & c & d) & ~(a & b & ~c & d) & ~(~a & b & c & ~d) & ~(a & ~b & c & d) & ~(~a & b & c & d);\n\n    // Calculate out_pos in minimum product-of-sums form\n    assign out_pos = ((~a | b | c | d) & (~a | b | ~c | d) & (~a | b | c | ~d) & (~a | ~b | c | d)) >> 2;\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    reg [31:0] lfsr;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            lfsr <= 32'h1;\n            q <= 32'h1;\n        end else begin\n            lfsr[31] <= lfsr[31] ^ lfsr[0];\n            lfsr[22] <= lfsr[22] ^ lfsr[2];\n            lfsr[2] <= lfsr[2] ^ lfsr[1];\n            lfsr[1] <= lfsr[1] ^ lfsr[0];\n            q <= lfsr;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (d & c & b) | (a & b & d) | (c & b & d) | (a & c & d) | (b & c & d) | (a & d & b) | (a & d & c) | (b & d & c);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Define the 4-input NAND gate.\n// The output is 1'b0 if all inputs are 1'b1.\n// Otherwise, the output is the inverse of the AND of all inputs.\n// This is equivalent to the NAND gate.\n// The NAND gate is often used as a 1-bit NOT gate.\n// This is done by connecting all inputs to 1'b1.\n// The output of the NAND gate is then the inverse of the output, which is 1'b0.\n// This is equivalent to the NOT gate.\n// The NOT gate is often used to invert the polarity of a signal.\n// This is done by connecting the input to 1'b0.\n// The output of the NOT gate is then 1'b1.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the AND gate with the inverse of all inputs.\n// This is equivalent to the NOT gate with all inputs connected to 1'b0.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the AND of all inputs.\n// This is equivalent to the NOT gate with the inverse of the AND of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b0.\n// The NAND gate is equivalent to the NOT gate with the AND of all inputs.\n// This is equivalent to the NOT gate with the inverse of the AND of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b0.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b0.\n// The NAND gate is equivalent to the NOT gate with the AND of all inputs.\n// This is equivalent to the NOT gate with the inverse of the AND of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b0.\n// The NAND gate is equivalent to the NOT gate with the AND of all inputs.\n// This is equivalent to the NOT gate with the inverse of the AND of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b0.\n// The NAND gate is equivalent to the NOT gate with the AND of all inputs.\n// This is equivalent to the NOT gate with the inverse of the AND of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the OR of all inputs.\n// This is equivalent to the NOT gate with the inverse of the OR of all inputs.\n// The NOT gate is equivalent to the NAND gate with all inputs connected to 1'b1.\n// The NAND gate is equivalent to the NOT gate with the AND of all inputs.\n// This is equivalent to the NOT gate"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "Do not add any unnecessary comments or white spaces. Your code should be well structured and easy to understand.\n```verilog\nreg [7:0] count [0:127];\ninteger i, j;\n\nalways @(*) begin\n\tout = 0;\n\tfor (i = 0; i < 128; i = i + 1) begin\n\t\tcount[i] = 0;\n\t\tfor (j = i; j < 255; j = j + 1) begin\n\t\t\tif (in[j] == 1'b1) begin\n\t\t\t\tcount[i] = count[i] + 1;\n\t\t\tend\n\t\tend\n\t\tout = out + count[i];\n\tend\nend\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "// (1) out_both:\n\tassign out_both[0] = in[0] & in[1];\n\tassign out_both[1] = in[1] & in[2];\n\tassign out_both[2] = in[2] & in[3];\n\n\t// (2) out_any:\n\tassign out_any[0] = in[0] | in[1];\n\tassign out_any[1] = in[1] | in[2];\n\tassign out_any[2] = in[2] | in[3];\n\tassign out_any[3] = in[3];\n\n\t// (3) out_different:\n\tassign out_different[0] = in[0] ^ in[3];\n\tassign out_different[1] = in[1] ^ in[0];\n\tassign out_different[2] = in[2] ^ in[1];\n\tassign out_different[3] = in[3] ^ in[2];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @ (a) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'h1232;\n    endcase\nend\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "Do not include any comments in the Verilog code. \n\nModule top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend else if (slowena) begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    wire and_out;\n    and gate(and_out, in1, in2);\n    assign out = and_out;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output out\n);\n\n    reg [1:0] state;\n    parameter B = 2'b00, A = 2'b01;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end\n        else begin\n            case (state)\n                B: begin\n                    if (in) begin\n                        state <= B;\n                    end\n                    else begin\n                        state <= A;\n                    end\n                end\n                A: begin\n                    if (in) begin\n                        state <= A;\n                    end\n                    else begin\n                        state <= B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out = (state == A);\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n    wire a1_out, b1_out, a2_out, b2_out;\n    \n    A a1(.x(x), .y(y), .z(a1_out));\n    B b1(.x(x), .y(y), .z(b1_out));\n    A a2(.x(x), .y(y), .z(a2_out));\n    B b2(.x(x), .y(y), .z(b2_out));\n    \n    assign z = a1_out | b1_out;\n    assign z = a2_out & b2_out;\n    assign z = a2_out ^ b2_out;\n\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n    reg [99:0] shifted_out_bit;\n    \n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n            shifted_out_bit <= 0;\n        end\n        else begin\n            case (ena)\n                2'b01: begin\n                    shifted_out_bit <= shift_reg[0];\n                    shift_reg <= {shift_reg[98:0], shifted_out_bit};\n                end\n                2'b10: begin\n                    shifted_out_bit <= shift_reg[99];\n                    shift_reg <= {shifted_out_bit, shift_reg[98:1]};\n                end\n                default: begin\n                    shifted_out_bit <= 0;\n                end\n            endcase\n        end\n    end\n    \n    assign q = shift_reg;\n    \nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "always @(posedge clk) begin\n\t\t\tif (reset) begin\n\t\t\t\tq <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tif (q == 999) begin\n\t\t\t\t\tq <= 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tq <= q + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    wire [9:0] next_state_wire;\n    wire out1_wire;\n    wire out2_wire;\n\n    // State transition logic\n    assign next_state_wire[0] = in ? 1'b0 : 1'b0;\n    assign next_state_wire[1] = in ? 1'b0 : 1'b1;\n    assign next_state_wire[2] = in ? 1'b0 : 1'b0;\n    assign next_state_wire[3] = in ? 1'b0 : 1'b1;\n    assign next_state_wire[4] = in ? 1'b0 : 1'b0;\n    assign next_state_wire[5] = in ? 1'b0 : 1'b1;\n    assign next_state_wire[6] = in ? 1'b0 : 1'b0;\n    assign next_state_wire[7] = in ? 1'b0 : 1'b1;\n    assign next_state_wire[8] = in ? 1'b1 : 1'b0;\n    assign next_state_wire[9] = in ? 1'b1 : 1'b1;\n\n    // Output logic\n    assign out1_wire = state[0] & state[1] & state[2] & state[3] & state[4] & state[5] & state[6] & state[7] & state[8] & state[9];\n    assign out2_wire = state[0] & state[1] & state[2] & state[3] & state[4] & state[5] & state[6] & state[7] & state[8] & state[9];\n\n    // Output assignments\n    assign out1 = out1_wire;\n    assign out2 = out2_wire;\n\n    // Next state assignments\n    assign next_state = next_state_wire;\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "// JK flip-flop with asynchronous reset\nreg Q_next;\nalways @ (posedge clk, negedge reset) begin\n\tif (!reset) begin\n\t\tQ_next <= 1'b0;\n\tend else begin\n\t\tif (j && k) begin\n\t\t\tQ_next <= ~Q;\n\t\tend else if (j) begin\n\t\t\tQ_next <= 1'b1;\n\t\tend else if (k) begin\n\t\t\tQ_next <= 1'b0;\n\t\tend else begin\n\t\t\tQ_next <= Q;\n\t\tend\n\tend\nend\n\nalways @ (posedge clk) begin\n\tQ <= Q_next;\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "assign pop_count = in[0] ^ in[1] ^ in[2];"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n\n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n\n    assign out[14] = ~c ^ a;\n    assign out[13] = ~c ^ b;\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n\n    assign out[ 9] = ~d ^ a;\n    assign out[ 8] = ~d ^ b;\n    assign out[ 7] = ~d ^ c;\n    assign out[ 6] = ~d ^ d;\n    assign out[ 5] = ~d ^ e;\n\n    assign out[ 4] = ~e ^ a;\n    assign out[ 3] = ~e ^ b;\n    assign out[ 2] = ~e ^ c;\n    assign out[ 1] = ~e ^ d;\n    assign out[ 0] = ~e ^ e;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n\n  // Define the state encoding\n  parameter [1:0] WALK_LEFT = 2'b00;\n  parameter [1:0] WALK_RIGHT = 2'b01;\n\n  // Define the state register\n  reg [1:0] state_reg;\n\n  // Define the outputs\n  assign walk_left = (state_reg == WALK_LEFT);\n  assign walk_right = (state_reg == WALK_RIGHT);\n\n  // Define the next state logic\n  always @ (posedge clk, posedge areset) begin\n    if (areset) begin\n      state_reg <= WALK_LEFT;\n    end else begin\n      case (state_reg)\n        WALK_LEFT: begin\n          if (bump_right) begin\n            state_reg <= WALK_RIGHT;\n          end\n        end\n        WALK_RIGHT: begin\n          if (bump_left) begin\n            state_reg <= WALK_LEFT;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    wire n1, n2, n3, n4, n5, n6, n7, n8;\n\n    assign n1 = a & ~b;\n    assign n2 = ~a & b;\n    assign n3 = a & b;\n    assign n4 = ~a & ~b;\n    assign n5 = a ^ b;\n    assign n6 = a & b;\n    assign n7 = ~a & b;\n    assign n8 = a & ~b;\n\n    assign q = n1 | n2 | n3 | n4 | n5 | n6 | n7 | n8;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// The 7458 chip has four AND gates and two OR gates.\n// The output of the AND gates is the input to the OR gates.\n// The output of the OR gates is the output of the chip.\n// We can replicate this functionality using Verilog.\n// Here, we use intermediate wires to drive the OR gates.\n// The intermediate wires are driven by the output of the AND gates.\n\n// The first AND gate\nwire and1 = p1a & p1b & p1c;\n\n// The second AND gate\nwire and2 = p1d & p1e & p1f;\n\n// The first OR gate\nwire or1 = and1 | and2;\n\n// The second OR gate\nwire or2 = p2a & p2b | p2c & p2d;\n\n// Assign the output wires to the OR gates\nassign p1y = or1;\nassign p2y = or2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "// State-assigned table\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\n// State encoding\nparameter S0 = 3'b000;\nparameter S1 = 3'b001;\nparameter S2 = 3'b010;\nparameter S3 = 3'b011;\nparameter S4 = 3'b100;\n\n// State register\nreg [2:0] state_reg;\nreg [2:0] next_state;\n\n// Output register\nreg Y0_reg;\n\n// State transition logic\nalways @(posedge clk) begin\n\tstate_reg <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tS0: begin\n\t\t\tif (x) next_state = S0;\n\t\t\telse next_state = S1;\n\t\tend\n\t\tS1: begin\n\t\t\tif (x) next_state = S0;\n\t\t\telse next_state = S2;\n\t\tend\n\t\tS2: begin\n\t\t\tif (x) next_state = S1;\n\t\t\telse next_state = S0;\n\t\tend\n\t\tS3: begin\n\t\t\tif (x) next_state = S2;\n\t\t\telse next_state = S1;\n\t\tend\n\t\tS4: begin\n\t\t\tif (x) next_state = S3;\n\t\t\telse next_state = S4;\n\t\tend\n\tendcase\nend\n\n// Output logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tS0: begin\n\t\t\tY0_reg = 1'b0;\n\t\t\tz = 1'b0;\n\t\tend\n\t\tS1: begin\n\t\t\tY0_reg = 1'b0;\n\t\t\tz = 1'b0;\n\t\tend\n\t\tS2: begin\n\t\t\tY0_reg = 1'b0;\n\t\t\tz = 1'b0;\n\t\tend\n\t\tS3: begin\n\t\t\tY0_reg = 1'b1;\n\t\t\tz = 1'b1;\n\t\tend\n\t\tS4: begin\n\t\t\tY0_reg = 1'b1;\n\t\t\tz = 1'b1;\n\t\tend\n\tendcase\nend\n\n// Output register\nalways @(posedge clk) begin\n\tY0 <= Y0_reg;\nend\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "Do not use unnecessary comments or white spaces.\n\nYour Verilog code should be easy to understand and maintain.\n\nAlways use meaningful names for your variables and functions.\n\nDo not use tabs, instead use 4 spaces for indentation.\n\nFollow the Verilog coding standards and conventions.\n\n \tassign w = a;\n \tassign x = b;\n \tassign y = b;\n \tassign z = c;\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    reg q_next;\n\n    always @(posedge clk or negedge ar) begin\n        if (ar == 0) begin\n            q_next <= 0;\n        end else begin\n            q_next <= d;\n        end\n    end\n\n    assign q = q_next;\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] counter;\n    reg [9:0] next_counter;\n    wire tc_wire;\n\n    assign tc = tc_wire;\n\n    always @(posedge clk) begin\n        if (load) begin\n            next_counter <= data;\n        end else begin\n            if (counter == 0) begin\n                next_counter <= data;\n            end else begin\n                next_counter <= counter - 1;\n            end\n        end\n    end\n\n    assign tc_wire = (counter == 0);\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= next_counter;\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "// Declare the state register and the next state logic\n\treg [3:0] state, next_state;\n\t\n\t// Declare the output logic\n\treg start_shifting;\n\t\n\t// Declare the state machine\n\talways @ (posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= 4'b0000;\n\t\t\tstart_shifting <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\t\tstart_shifting <= 1'b0;\n\t\tend\n\tend\n\t\n\t// Declare the next state logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\t4'b0000: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0001;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0001: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0010;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0010: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0011;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0011: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0100;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0100: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0001;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0101: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0100;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0110: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0010;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b0111: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0001;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b1000: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b0101;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\t\t4'b1001: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = 4'b1000;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if(reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        if (in != prev_in) begin\n            anyedge <= in;\n        end\n        prev_in <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "------------------------------------------------------------------------------------------------\n\nModule top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0001;\n\t\tend\n\t\telse begin\n\t\t\tif (q == 4'b1010) begin\n\t\t\t\tq <= 4'b0001;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    reg [2:0] q_next;\n    always @(posedge clk) begin\n        q_next <= {q[1:0], a};\n    end\n    \n    always @(posedge clk) begin\n        if (a) begin\n            q <= q_next;\n        end\n    end\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "Do not introduce any unnecessary variables, functions, or code.\nModule top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n\n\treg [4:0] lfsr_state;\n\tparameter [4:0] taps = 5'b10101;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr_state <= 5'b10001;\n\t\t\tq <= 5'b00001;\n\t\tend\n\t\telse begin\n\t\t\tlfsr_state <= {lfsr_state[4:1], lfsr_state[0] ^ taps[4] ^ taps[3] ^ taps[2] ^ taps[1] ^ taps[0]};\n\t\t\tq <= lfsr_state;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        if (do_sub == 1) begin\n            out = a - b;\n            if (out == 0)\n                result_is_zero = 1;\n        end\n        else begin\n            out = a + b;\n            if (out == 0)\n                result_is_zero = 1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "// Karnaugh map for function f\n// \t  x[1]\tx[2]\n// \t  x[3]\tx[4]\n// \t0\td\t0\n// \t1\t0\t1\n// \t2\t1\t1\n// \t3\t1\t0\n// \t4\t1\t1\n// \t5\td\t0\n// \t6\t0\t0\n// \t7\t1\t1\n\n// Implement function f\nalways @(*) begin\n\tcase (x)\n\t\t// 0000\n\t\t4'b0000: f = 1'b0;\n\t\t// 0001\n\t\t4'b0001: f = 1'b0;\n\t\t// 0010\n\t\t4'b0010: f = 1'b1;\n\t\t// 0011\n\t\t4'b0011: f = 1'b1;\n\t\t// 0100\n\t\t4'b0100: f = 1'b1;\n\t\t// 0101\n\t\t4'b0101: f = 1'b0;\n\t\t// 0110\n\t\t4'b0110: f = 1'b1;\n\t\t// 0111\n\t\t4'b0111: f = 1'b1;\n\t\t// 1000\n\t\t4'b1000: f = 1'b1;\n\t\t// 1001\n\t\t4'b1001: f = 1'b1;\n\t\t// 1010\n\t\t4'b1010: f = 1'b0;\n\t\t// 1011\n\t\t4'b1011: f = 1'b1;\n\t\t// 1100\n\t\t4'b1100: f = 1'b1;\n\t\t// 1101\n\t\t4'b1101: f = 1'b1;\n\t\t// 1110\n\t\t4'b1110: f = 1'b1;\n\t\t// 1111\n\t\t4'b1111: f = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "always @(*) begin\n\t\tcase (code)\n\t\t\t8'h45: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h16: begin\n\t\t\t\tout = 4'b0001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h1e: begin\n\t\t\t\tout = 4'b0010;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h26: begin\n\t\t\t\tout = 4'b0011;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h25: begin\n\t\t\t\tout = 4'b0100;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h2e: begin\n\t\t\t\tout = 4'b0101;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h36: begin\n\t\t\t\tout = 4'b0110;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3d: begin\n\t\t\t\tout = 4'b0111;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3e: begin\n\t\t\t\tout = 4'b1000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h46: begin\n\t\t\t\tout = 4'b1001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "// Reverse the bit ordering of the input vector\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "// Karnaugh map\n//         ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\n\nalways @(*)\nbegin\n\tcase ({a,b})\n\t\t2'b00: out = d;\n\t\t2'b01: out = c;\n\t\t2'b10: out = d;\n\t\t2'b11: out = a;\n\tendcase\nend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "always @(posedge clk) begin\n    if(count_ena) begin\n        q <= q - 1;\n    end else if(shift_ena) begin\n        q <= {q[2:0], data};\n    end\nend"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "// FSM\n\treg [1:0] state;\n\tparameter IDLE = 2'b00;\n\tparameter COUNT1 = 2'b01;\n\tparameter COUNT2 = 2'b10;\n\tparameter COUNT3 = 2'b11;\n\tparameter COUNT4 = 2'b00;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend else if (shift_ena) begin\n\t\t\t\t\t\tstate <= COUNT1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCOUNT1: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend else if (shift_ena) begin\n\t\t\t\t\t\tstate <= COUNT2;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCOUNT2: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend else if (shift_ena) begin\n\t\t\t\t\t\tstate <= COUNT3;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCOUNT3: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend else if (shift_ena) begin\n\t\t\t\t\t\tstate <= COUNT4;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCOUNT4: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend else if (~shift_ena) begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\t\t\t\t\t\n\t// Output\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tshift_ena <= 1'b0;\n\t\tend else if (state == COUNT1) begin\n\t\t\tshift_ena <= 1'b1;\n\t\tend else if (state == COUNT4) begin\n\t\t\tshift_ena <= 1'b0;\n\t\tend\n\tend\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16\n// Reset input is active high synchronous, and should reset the counter to 0\n// q is the output of the counter\n// clk is the input clock\n\n\talways @(posedge clk) begin\n\t\tif(reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "// Assign statements\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// Procedural if statement\nalways @ (sel_b1 or sel_b2 or a or b) begin\n\tif (sel_b1 & sel_b2) begin\n\t\tout_always = b;\n\tend else begin\n\t\tout_always = a;\n\tend\nend\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (~a & ~b & c) | (~a & b & c) | (a & ~b & c) | (a & b & c);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "// State encoding\nlocalparam [1:0] A = 2'b00;\nlocalparam [1:0] B = 2'b01;\nlocalparam [1:0] C = 2'b10;\nlocalparam [1:0] D = 2'b11;\n\n// State table\nreg [1:0] current_state, next_state;\nalways @ (posedge clk, negedge resetn) begin\n\tif (~resetn) begin\n\t\tcurrent_state <= A;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\tend\nend\n\nalways @ (*) begin\n\tcase (current_state)\n\t\tA: begin\n\t\t\tif (r[0] == 1) begin\n\t\t\t\tnext_state = B;\n\t\t\t\tg[0] = 1;\n\t\t\tend else if (r[1] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tg[1] = 1;\n\t\t\tend else if (r[2] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tg[2] = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (r[0] == 1) begin\n\t\t\t\tnext_state = B;\n\t\t\t\tg[0] = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (r[1] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tg[1] = 1;\n\t\t\tend else if (r[2] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tg[2] = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tnext_state = A;\n\t\tend\n\tendcase\nend\n\n// State flip-flops\nalways @ (posedge clk, negedge resetn) begin\n\tif (~resetn) begin\n\t\tcurrent_state <= A;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\tend\nend\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "endmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "Follow the Verilog code style guidelines:\n- Use meaningful names for signals, variables, and parameters.\n- Use comments to document the code.\n- Use consistent indentation and formatting.\n- Use the FSM template to organize the code.\n- Use the Verilog standard for state encoding (4-bit binary, usually 0..n-1).\n- Use the Verilog standard for state names (all uppercase with underscores).\n- Use the Verilog standard for FSM outputs (1-bit signals).\n- Use the Verilog standard for FSM inputs (1-bit signals).\n- Use the Verilog standard for FSM states (4-bit binary, usually 0..n-1).\n- Use the Verilog standard for FSM actions (usually assignments to FSM signals and outputs).\n- Use the Verilog standard for FSM guards (conditional statements).\n- Use the Verilog standard for FSM logic (usually sequential logic).\n- Use the Verilog standard for FSM registers (registers that hold the current state and next state values).\n- Use the Verilog standard for FSM parameters (constants that represent state values).\n- Use the Verilog standard for FSM outputs (outputs that are signals or registers).\n  - Use 1-bit signals for FSM outputs.\n  - Use registers for FSM outputs that are used in the same cycle they were calculated.\n  - Use registers for FSM outputs that are used in the next cycle.\n  Module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput reg done\n);\n\n\t// FSM parameters\n\tparameter IDLE = 2'b00;\n\tparameter FOUND_START = 2'b01;\n\tparameter FOUND_MIDDLE = 2'b10;\n\tparameter FOUND_END = 2'b11;\n\t\n\t// FSM registers\n\treg [1:0] state_reg, state_next;\n\treg [2:0] byte_reg, byte_next;\n\t\n\t// FSM outputs\n\treg done_reg, done_next;\n\t\n\t// FSM logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate_reg <= IDLE;\n\t\t\tbyte_reg <= 3'b000;\n\t\t\tdone_reg <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate_reg <= state_next;\n\t\t\tbyte_reg <= byte_next;\n\t\t\tdone_reg <= done_next;\n\t\tend\n\tend\n\t\n\t// FSM template\n\talways @(*) begin\n\t\tstate_next = state_reg;\n\t\tbyte_next = byte_reg;\n\t\tdone_next = done_reg;\n\t\t\n\t\tcase (state_reg)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate_next = FOUND_START;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tFOUND_START: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate_next = FOUND_MIDDLE;\n\t\t\t\t\tbyte_next = {in, 1'b0};\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tFOUND_MIDDLE: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate_next = FOUND_END;\n\t\t\t\t\tbyte_next = {in, byte_reg[1:0]};\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = FOUND_START;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tFOUND_END: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate_next = IDLE;\n\t\t\t\t\tdone_next = 1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = FOUND_START;"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "assign out_and = in[0] & in[1] & in[2] & in[3];"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // Define the states\n    parameter [2:0] S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // Define the state register and next state logic\n    reg [2:0] state, next_state;\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Define the output logic\n    always @ (*) begin\n        case (state)\n            S0: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1'b0;\n                end else begin\n                    next_state = S0;\n                    z = 1'b1;\n                end\n            end\n            S1: begin\n                next_state = S2;\n                z = 1'b0;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S3;\n                    z = 1'b0;\n                end else begin\n                    next_state = S0;\n                    z = 1'b1;\n                end\n            end\n            S3: begin\n                next_state = S4;\n                z = 1'b1;\n            end\n            S4: begin\n                next_state = S1;\n                z = 1'b0;\n            end\n            default: begin\n                next_state = S0;\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "// Define the states\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\t\n\t// Define the state register and next state logic\n\treg [1:0] state_reg, state_next;\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) begin\n\t\t\tstate_reg <= A;\n\t\tend else begin\n\t\t\tstate_reg <= state_next;\n\t\tend\n\tend\n\t\n\t// Define the output registers and next output logic\n\treg f_reg, g_reg;\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) begin\n\t\t\tf_reg <= 0;\n\t\t\tg_reg <= 0;\n\t\tend else begin\n\t\t\tf_reg <= 0;\n\t\t\tg_reg <= 0;\n\t\t\tcase (state_reg)\n\t\t\t\tA: begin\n\t\t\t\t\tf_reg <= 1;\n\t\t\t\t\tstate_next <= B;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate_next <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate_next <= B;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate_next <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate_next <= C;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (y) begin\n\t\t\t\t\t\tg_reg <= 1;\n\t\t\t\t\t\tstate_next <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tg_reg <= 0;\n\t\t\t\t\t\tstate_next <= A;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Assign the output registers to the output signals\n\tassign f = f_reg;\n\tassign g = g_reg;\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\nalways @(*) begin\n    case (state)\n        2'b00: begin\n            if (in == 1'b0) begin\n                next_state = 2'b00;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b01;\n                out = 1'b0;\n            end\n        end\n        2'b01: begin\n            if (in == 1'b0) begin\n                next_state = 2'b10;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b01;\n                out = 1'b0;\n            end\n        end\n        2'b10: begin\n            if (in == 1'b0) begin\n                next_state = 2'b00;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b11;\n                out = 1'b1;\n            end\n        end\n        2'b11: begin\n            if (in == 1'b0) begin\n                next_state = 2'b10;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b01;\n                out = 1'b0;\n            end\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    reg z_reg;\n\n    always @(*) begin\n        if (x == 0 && y == 0) begin\n            z_reg = 1;\n        end else if (x == 1 && y == 0) begin\n            z_reg = 0;\n        end else if (x == 0 && y == 1) begin\n            z_reg = 0;\n        end else if (x == 1 && y == 1) begin\n            z_reg = 1;\n        end else begin\n            z_reg = 1;\n        end\n    end\n\n    assign z = z_reg;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // State encoding\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // State register\n    reg [1:0] state = A;\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (w) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                B: begin\n                    if (w) begin\n                        state <= C;\n                    end else begin\n                        state <= D;\n                    end\n                end\n                C: begin\n                    if (w) begin\n                        state <= E;\n                    end else begin\n                        state <= D;\n                    end\n                end\n                D: begin\n                    if (w) begin\n                        state <= F;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                E: begin\n                    if (w) begin\n                        state <= E;\n                    end else begin\n                        state <= D;\n                    end\n                end\n                F: begin\n                    if (w) begin\n                        state <= C;\n                    end else begin\n                        state <= D;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: z = 1'b0;\n            B: z = 1'b1;\n            C: z = 1'b1;\n            D: z = 1'b0;\n            E: z = 1'b1;\n            F: z = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "// 16 D flip-flops with byte enable\n// Write only the bytes that should be modified on that cycle\n// resetn is a synchronous, active-low reset\n// clk is the clock input\n// byteena[1] controls the upper byte d[15:8]\n// byteena[0] controls the lower byte d[7:0]\n// d is the input to be written to the flip-flops\n// q is the output of the flip-flops\n\talways @(posedge clk) begin\n\t\tif(!resetn) begin\n\t\t\tq <= 16'b0;\n\t\tend else begin\n\t\t\tif(byteena[1]) begin\n\t\t\t\tq[15:8] <= d[15:8];\n\t\t\tend\n\t\t\tif(byteena[0]) begin\n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\tend\n\t\tend\n\tend\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg a_delay;\n    reg p_delay;\n    reg q_delay;\n\n    always @(posedge clock) begin\n        a_delay <= a;\n        p_delay <= p;\n        q_delay <= q;\n    end\n\n    always @(a_delay or p_delay or q_delay) begin\n        if(a_delay) begin\n            if(p_delay) begin\n                if(q_delay) begin\n                    q <= 0;\n                end else begin\n                    q <= 1;\n                end\n                p <= 0;\n            end else begin\n                if(q_delay) begin\n                    q <= 0;\n                end else begin\n                    q <= 1;\n                end\n                p <= 1;\n            end\n        end else begin\n            if(p_delay) begin\n                if(q_delay) begin\n                    q <= 0;\n                end else begin\n                    q <= 1;\n                end\n                p <= 0;\n            end else begin\n                if(q_delay) begin\n                    q <= 0;\n                end else begin\n                    q <= 1;\n                end\n                p <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module\nmodule rule_90(\n    input [511:0] q,\n    input [511:0] nq,\n    input [511:0] nq2,\n    output reg [511:0] q_next\n);\n\n    always @* begin\n        q_next = nq ^ nq2;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A == B) ? 1 : 0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "Then, implement the logic for each output vector.\n\n```verilog\n// out_both\nassign out_both[0] = 0;\ngenvar i;\ngenerate\n\tfor (i = 1; i < 100; i = i + 1) begin : gen_out_both\n\t\tassign out_both[i] = in[i-1] & in[i];\n\tend\nendgenerate\n\n// out_any\nassign out_any[0] = 0;\ngenerate\n\tfor (i = 1; i < 100; i = i + 1) begin : gen_out_any\n\t\tassign out_any[i] = in[i] | in[i-1];\n\tend\nendgenerate\n\n// out_different\nassign out_different[0] = 0;\ngenerate\n\tfor (i = 1; i < 100; i = i + 1) begin : gen_out_different\n\t\tassign out_different[i] = in[i] ^ in[i-1];\n\tend\nendgenerate\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "endmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        0: out = a;\n        1: out = b;\n        2: out = c;\n        3: out = d;\n        4: out = e;\n        5: out = f;\n        6: out = g;\n        7: out = h;\n        8: out = i;\n        default: out = 16'hffff;\n    endcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR\n    assign out_or_logical = (a != 0) || (b != 0);\n    \n    // NOT\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n    \nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    always @ (state or in) begin\n        case (state)\n            4'b0001: begin\n                if (in == 0) begin\n                    next_state = 4'b0001;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b0010;\n                    out = 1'b0;\n                end\n            end\n            4'b0010: begin\n                if (in == 0) begin\n                    next_state = 4'b0100;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b0010;\n                    out = 1'b0;\n                end\n            end\n            4'b0100: begin\n                if (in == 0) begin\n                    next_state = 4'b0001;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b1000;\n                    out = 1'b1;\n                end\n            end\n            4'b1000: begin\n                if (in == 0) begin\n                    next_state = 4'b0100;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b0010;\n                    out = 1'b0;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module is as follows:\n```verilog\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if(a < b)\n        min = a;\n    else if(b < c)\n        min = b;\n    else if(c < d)\n        min = c;\n    else\n        min = d;\nend\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\n\t\n\t// Implement the circuit using AND and OR gates\n\twire w1, w2, w3, w4, w5, w6, w7;\n\t\n\t// Implement the AND gates\n\tand gate1(w1, a, b, c, d);\n\tand gate2(w2, a, ~b, c, d);\n\tand gate3(w3, ~a, b, c, d);\n\tand gate4(w4, a, b, ~c, d);\n\tand gate5(w5, a, b, c, ~d);\n\tand gate6(w6, ~a, b, c, d);\n\tand gate7(w7, a, ~b, c, d);\n\t\n\t// Implement the OR gates\n\tor gate8(out, w1, w2, w3, w4, w5, w6, w7);\n\t\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "endmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n    wire sign_bit = in[7];\n    assign out = {sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, sign_bit, in};\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @* begin\n        case (in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            default: pos = 2'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output out\n);\n\n    // define states\n    localparam OFF = 2'b00;\n    localparam ON = 2'b01;\n\n    // define outputs\n    localparam out_OFF = 1'b0;\n    localparam out_ON = 1'b1;\n\n    // define registers\n    reg [1:0] state;\n    reg out_reg;\n\n    // define combinational logic\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j) begin\n                    out_reg = ON;\n                end else begin\n                    out_reg = OFF;\n                end\n            end\n            ON: begin\n                if (k) begin\n                    out_reg = OFF;\n                end else begin\n                    out_reg = ON;\n                end\n            end\n        endcase\n    end\n\n    // define state machine\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // assign outputs\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    assign out = 0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "module top_module(\n    output one);\n    \n    assign one = 1'b1;\n    \nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module (\n    input clk,\n    input in,\n    output logic out\n);\n    reg d;\n    always @(posedge clk) begin\n        d <= in ^ out;\n    end\n    assign out = d;\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {q[2:0], 1'b0};\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "// Combinational circuit to implement the truth table\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\n\tassign f = (x3 & x2 & x1) | (x3 & x2 & ~x1) | (x3 & ~x2 & x1) | (x3 & ~x2 & ~x1) | (~x3 & x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & ~x2 & ~x1);\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "// Asynchronous reset\n\talways @(posedge areset)\n\t\tq <= 8'b0;\n\n\t// D flip-flops\n\talways @(posedge clk)\n\t\tq <= d;\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    wire [99:0] and_wire;\n    wire [99:0] or_wire;\n    wire [99:0] xor_wire;\n\n    assign and_wire = &in;\n    assign or_wire = |in;\n    assign xor_wire = ^in;\n\n    assign out_and = and_wire[0];\n    assign out_or = or_wire[0];\n    assign out_xor = xor_wire[0];\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n    wire xor_out;\n    wire and_out;\n\n    xor xor_gate (xor_out, a, b);\n    and and_gate (and_out, a, b);\n\n    assign sum = xor_out;\n    assign cout = and_out;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "Follow the Verilog coding standards and style guide. Use comments where necessary to make the code self-explanatory.\n\n// Verilog code to shut off the computer if it overheats\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n\n// Verilog code to keep driving until we arrive or the gas tank is empty\nalways @(*) begin\n    if (~arrived)\n        keep_driving = ~gas_tank_empty;\nend\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output.\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n\n// States\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// Output\nwire out_wire;\nassign out = out_wire;\n\n// State register\nreg [1:0] state_reg;\n\n// State transition logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate_reg <= OFF;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate_reg <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate_reg <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nalways @(state_reg) begin\n\tcase (state_reg)\n\t\tOFF: begin\n\t\t\tout_wire = 1'b0;\n\t\tend\n\t\tON: begin\n\t\t\tout_wire = 1'b1;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "Your code should end with:\n```verilog\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (~a & ~b & ~c & d) | (~a & b & c & d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, one input, and one output.\n// The reset state is B and reset is active-high synchronous.\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\n\n// States\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// Output assignments\nassign out = (state == B) ? 1 : 0;\n\n// State register\nreg [1:0] state;\n\n// State transition and output logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= B;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    wire w1, w2, w3;\n\n    xor x1(w1, a, b);\n    xor x2(sum, w1, cin);\n    and a1(w2, a, b);\n    and a2(w3, w1, cin);\n    or o1(cout, w2, w3);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "```\n  wire xnor_out;\n  assign xnor_out = ~(in1 ^ in2);\n  assign out = xnor_out ^ in3;\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    wire a = c & d;\n    wire b = ~c & d;\n    wire ab = a | b;\n\n    assign mux_in[0] = ab;\n    assign mux_in[1] = ~a;\n    assign mux_in[2] = b;\n    assign mux_in[3] = ~b;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // State encoding\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // State encoding in one-hot encoding\n    reg [3:0] state;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (x) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                B: begin\n                    if (x) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output encoding\n    always @(state or x) begin\n        case (state)\n            A: begin\n                if (x) begin\n                    z <= 1'b1;\n                end else begin\n                    z <= 1'b0;\n                end\n            end\n            B: begin\n                if (x) begin\n                    z <= 1'b0;\n                end else begin\n                    z <= 1'b1;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg q_reg;\n    wire state_wire;\n\n    assign state = state_wire;\n\n    always @(posedge clk) begin\n        if (a && b) begin\n            q_reg <= 1'b1;\n            state_wire <= 1'b0;\n        end else if (a) begin\n            q_reg <= 1'b0;\n            state_wire <= 1'b1;\n        end else if (b) begin\n            q_reg <= 1'b0;\n            state_wire <= 1'b1;\n        end else begin\n            q_reg <= 1'b1;\n            state_wire <= 1'b0;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module\nmodule top_module (\n    input [4:1] x,\n    output logic f\n);\n\nalways @(*) begin\n    case (x)\n        4'b0000: f = 1'b1;\n        4'b0001: f = 1'b0;\n        4'b0010: f = 1'b1;\n        4'b0011: f = 1'b1;\n        4'b0100: f = 1'b1;\n        4'b0101: f = 1'b0;\n        4'b0110: f = 1'b1;\n        4'b0111: f = 1'b1;\n        4'b1000: f = 1'b1;\n        4'b1001: f = 1'b1;\n        4'b1010: f = 1'b0;\n        4'b1011: f = 1'b0;\n        4'b1100: f = 1'b1;\n        4'b1101: f = 1'b1;\n        4'b1110: f = 1'b1;\n        4'b1111: f = 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "// Verilog code template for synchronous HDLC framing\n// ===================================================\n\n// Define the states\nlocalparam [2:0] S_IDLE = 3'b000;\nlocalparam [2:0] S_DISCARD = 3'b001;\nlocalparam [2:0] S_FLAG = 3'b010;\nlocalparam [2:0] S_ERROR = 3'b011;\n\n// Define the state register and next state logic\nreg [2:0] state, next_state;\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= S_IDLE;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// Define the output register and next value logic\nreg disc_out, flag_out, err_out;\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tdisc_out <= 1'b0;\n\t\tflag_out <= 1'b0;\n\t\terr_out <= 1'b0;\n\tend else begin\n\t\tdisc_out <= state == S_DISCARD;\n\t\tflag_out <= state == S_FLAG;\n\t\terr_out <= state == S_ERROR;\n\tend\nend\n\n// Define the next state and output logic\nalways @(*) begin\n\tcase (state)\n\t\tS_IDLE: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = S_IDLE;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b0;\n\t\t\tend else if (in == 1'b1) begin\n\t\t\t\tnext_state = S_DISCARD;\n\t\t\t\tnext_disc = 1'b1;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = S_ERROR;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b1;\n\t\t\tend\n\t\tend\n\t\tS_DISCARD: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = S_IDLE;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b0;\n\t\t\tend else if (in == 1'b1) begin\n\t\t\t\tnext_state = S_FLAG;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b1;\n\t\t\t\tnext_err = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = S_ERROR;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b1;\n\t\t\tend\n\t\tend\n\t\tS_FLAG: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = S_IDLE;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b0;\n\t\t\tend else if (in == 1'b1) begin\n\t\t\t\tnext_state = S_FLAG;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b0;\n\t\t\t\tnext_err = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = S_ERROR;\n\t\t\t\tnext_disc = 1'b0;\n\t\t\t\tnext_flag = 1'b"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "// (1) start sequence\n  reg [3:0] start_pattern = 4'b1101;\n  reg [3:0] delay;\n  reg [3:0] count_internal;\n  reg [3:0] remaining_cycles;\n  reg [3:0] done_count;\n  reg [3:0] ack_count;\n  reg [3:0] pattern_count;\n  reg [3:0] state;\n  reg [3:0] next_state;\n\n  // (2) shift in delay\n  always @(posedge clk) begin\n    if (reset) begin\n      delay <= 0;\n    end else if (counting) begin\n      // do nothing\n    end else if (state == 0) begin\n      delay <= {data, 4'b0};\n      state <= 1;\n    end\n  end\n\n  // (3) count\n  always @(posedge clk) begin\n    if (reset) begin\n      count_internal <= 0;\n      remaining_cycles <= 0;\n      counting <= 0;\n      done_count <= 0;\n      ack_count <= 0;\n      pattern_count <= 0;\n      state <= 0;\n      next_state <= 0;\n    end else if (counting) begin\n      if (count_internal == remaining_cycles) begin\n        done_count <= done_count + 1;\n        if (done_count == 1) begin\n          done <= 1;\n        end else begin\n          done <= 0;\n        end\n        ack_count <= ack_count + 1;\n        if (ack_count == 1) begin\n          ack <= 1;\n        end else begin\n          ack <= 0;\n        end\n        counting <= 0;\n        state <= 0;\n      end else begin\n        count_internal <= count_internal + 1;\n      end\n    end else if (state == 1) begin\n      pattern_count <= pattern_count + 1;\n      if (pattern_count == 1) begin\n        next_state <= 2;\n      end else if (pattern_count == 2) begin\n        next_state <= 3;\n      end else if (pattern_count == 3) begin\n        next_state <= 4;\n      end else if (pattern_count == 4) begin\n        next_state <= 5;\n      end else if (pattern_count == 5) begin\n        next_state <= 6;\n      end else if (pattern_count == 6) begin\n        next_state <= 7;\n      end else begin\n        next_state <= 0;\n      end\n      pattern_count <= 0;\n    end else if (state == 2) begin\n      next_state <= 3;\n    end else if (state == 3) begin\n      next_state <= 4;\n    end else if (state == 4) begin\n      next_state <= 5;\n    end else if (state == 5) begin\n      next_state <= 6;\n    end else if (state == 6) begin\n      next_state <= 7;\n    end else if (state == 7) begin\n      next_state <= 0;\n    end\n\n    // (4) counting\n    if (next_state == 7) begin\n      remaining_cycles <= delay;\n      counting <= 1;\n      state <= next_state;\n    end else if (counting) begin\n      remaining_cycles <= remaining_cycles - 1;\n    end\n\n    // (5) count output\n    if (counting) begin\n      count <= remaining_cycles;\n    end else begin\n      count <= count_internal;\n    end\n  end\n\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "Module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// Define the states\n\tparameter IDLE = 2'b00;\n\tparameter LOW_WATER = 2'b01;\n\tparameter HIGH_WATER = 2'b10;\n\n\t// Define the nominal flow rates\n\tparameter NOMINAL_LOW_WATER = 2'b00;\n\tparameter NOMINAL_HIGH_WATER = 2'b01;\n\tparameter NOMINAL_BETWEEN_WATER = 2'b10;\n\n\t// Define the state register and initialize it to IDLE\n\treg [1:0] state = IDLE;\n\n\t// Define the nominal flow rate register and initialize it to NOMINAL_LOW_WATER\n\treg [1:0] nominal_flow_rate = NOMINAL_LOW_WATER;\n\n\t// Define the sensor change register and initialize it to 0\n\treg sensor_change = 0;\n\n\t// Define the flow rate register and initialize it to 0\n\treg [1:0] flow_rate = 2'b00;\n\n\t// Define the dfr register and initialize it to 0\n\treg dfr_reg = 0;\n\n\t// Define the reset signal and initialize it to 0\n\treg reset_reg = 0;\n\n\t// State machine\n\talways @(posedge clk) begin\n\t\tif (reset_reg) begin\n\t\t\tstate <= IDLE;\n\t\t\tnominal_flow_rate <= NOMINAL_LOW_WATER;\n\t\t\tsensor_change <= 0;\n\t\t\tflow_rate <= 2'b00;\n\t\t\tdfr_reg <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (sensor_change) begin\n\t\t\t\t\t\tif (s[0] && s[1] && s[2] && s[3]) begin\n\t\t\t\t\t\t\tstate <= HIGH_WATER;\n\t\t\t\t\t\t\tnominal_flow_rate <= NOMINAL_HIGH_WATER;\n\t\t\t\t\t\t\tflow_rate <= 2'b00;\n\t\t\t\t\t\t\tdfr_reg <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (s[1] && s[2] && !s[3]) begin\n\t\t\t\t\t\t\tstate <= LOW_WATER;\n\t\t\t\t\t\t\tnominal_flow_rate <= NOMINAL_LOW_WATER;\n\t\t\t\t\t\t\tflow_rate <= 2'b00;\n\t\t\t\t\t\t\tdfr_reg <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tstate <= HIGH_WATER;\n\t\t\t\t\t\t\tnominal_flow_rate <= NOMINAL_HIGH_WATER;\n\t\t\t\t\t\t\tflow_rate <= 2'b00;\n\t\t\t\t\t\t\tdfr_reg <= 0;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tnominal_flow_rate <= NOMINAL_LOW_WATER;\n\t\t\t\t\t\tflow_rate <= 2'b00;\n\t\t\t\t\t\tdfr_reg <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tLOW_WATER: begin\n\t\t\t\t\tif (sensor_change) begin\n\t\t\t\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\t\t\t\tstate <= HIGH_WATER;\n\t\t\t\t\t\t\tnominal_flow_rate <= NOMINAL_HIGH_WATER;"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "// State encoding:\n// 0: idle\n// 1: wait for start bit\n// 2: wait for stop bit\n// 3: receive data bits\n// 4: verify stop bit\n// 5: done\n\n// State register\nreg [1:0] state;\n\n// Output register\nreg done_reg;\n\n// Input register\nreg in_reg;\n\n// Counter for data bits\nreg [2:0] data_count;\n\n// Counter for start and stop bits\nreg [1:0] bit_count;\n\n// Output assignments\nassign done = done_reg;\n\n// State transition and output logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 2'b00;\n\t\tdone_reg <= 1'b0;\n\t\tin_reg <= 1'b1;\n\t\tdata_count <= 3'b0;\n\t\tbit_count <= 2'b0;\n\tend else begin\n\t\tcase (state)\n\t\t\t2'b00: begin // idle\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tin_reg <= 1'b1;\n\t\t\t\t\tbit_count <= 2'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tin_reg <= in;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b01: begin // wait for start bit\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= 2'b02;\n\t\t\t\t\tbit_count <= 2'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tin_reg <= in;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b02: begin // wait for stop bit\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tin_reg <= in;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b1[0]: begin // receive data bits\n\t\t\t\tif (bit_count == 2'b00) begin\n\t\t\t\t\tdata_count <= 3'b0;\n\t\t\t\t\tin_reg <= in;\n\t\t\t\tend else begin\n\t\t\t\t\tdata_count <= {data_count[1:0], in};\n\t\t\t\t\tin_reg <= in;\n\t\t\t\tend\n\t\t\t\tif (bit_count == 2'b01) begin\n\t\t\t\t\tstate <= 2'b02;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b11: begin // verify stop bit\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tin_reg <= in;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\t\tbit_count <= {bit_count[0], in};\n\t\tif (bit_count == 2'b01) begin\n\t\t\tbit_count <= 2'b00;\n\t\tend\n\tend\nend\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output [7:0] out_byte,\n    output done\n);\n\n    parameter S_IDLE = 2'b00;\n    parameter S_START = 2'b01;\n    parameter S_DATA = 2'b10;\n    parameter S_STOP = 2'b11;\n\n    reg [1:0] state;\n    reg [7:0] data_reg;\n    reg done_reg;\n\n    assign out_byte = data_reg;\n    assign done = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_IDLE;\n            data_reg <= 8'b0;\n            done_reg <= 1'b0;\n        end else begin\n            case (state)\n                S_IDLE: begin\n                    if (in == 1'b0) begin\n                        state <= S_START;\n                    end\n                end\n                S_START: begin\n                    if (in == 1'b1) begin\n                        state <= S_IDLE;\n                    end else begin\n                        state <= S_DATA;\n                    end\n                end\n                S_DATA: begin\n                    if (in == 1'b1) begin\n                        state <= S_STOP;\n                    end else begin\n                        data_reg <= {data_reg[6:0], in};\n                    end\n                end\n                S_STOP: begin\n                    if (in == 1'b0) begin\n                        state <= S_IDLE;\n                        done_reg <= 1'b1;\n                    end else begin\n                        state <= S_DATA;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n\t// 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index\n\t// The index accesses a 128-entry table of two-bit saturating counters\n\t// The branch predictor has a 7-bit global branch history register\n\t// The branch predictor has two sets of interfaces: One for doing predictions and one for doing training\n\t// The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched\n\t// Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes.\n\n\t// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch.\n\t// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n\n\t// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway.\n\t// If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge.\n\t// The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4.\n\t// Reset is asynchronous active-high.\n\n\treg [1:0] pht [0:127];\n\treg [6:0] history_reg;\n\treg [6:0] pc_reg;\n\treg [6:0] index;\n\treg [1:0] taken_reg;\n\treg [1:0] mispredicted_reg;\n\treg [1:0] trained_reg;\n\treg [6:0] history_reg_next;\n\treg [6:0] pc_reg_next;\n\treg [1:0] taken_reg_next;\n\treg [1:0] mispredicted_reg_next;\n\treg [1:0] trained_reg_next;\n\treg [1:0] predict_taken_reg;\n\treg [6:0] predict_history_reg;\n\treg [1:0] predict_taken_next_reg;\n\treg [6:0] predict_history_next_reg;\n\treg [1:0] predict_taken_reg;\n\treg [6:0] predict_history_reg_next;\n\treg [1:0] pht_entry;\n\treg [1:0] pht_entry_next;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\thistory_reg <= 0;\n\t\t\tpc_reg <= 0;\n\t\t\tindex <= 0;\n\t\t\ttaken_reg <= 0;\n\t\t\tmispredicted_reg <= 0;\n\t\t\ttrained_reg <= 0;"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n// Define the states\nparameter walk_left_state = 2'b00;\nparameter walk_right_state = 2'b01;\nparameter fall_state = 2'b10;\nparameter dig_state = 2'b11;\n\n// Define the outputs\nwire walk_left_wire;\nwire walk_right_wire;\nwire aaah_wire;\nwire digging_wire;\n\n// Define the state register and next state logic\nreg [1:0] state_reg, state_next;\nalways @ (posedge clk or posedge areset) begin\n    if (areset) begin\n        state_reg <= walk_left_state;\n    end else begin\n        state_reg <= state_next;\n    end\nend\n\n// Define the output logic\nassign walk_left_wire = (state_reg == walk_left_state);\nassign walk_right_wire = (state_reg == walk_right_state);\nassign aaah_wire = 0;\nassign digging_wire = (state_reg == dig_state);\n\n// Define the next state logic\nalways @ (*) begin\n    case (state_reg)\n        walk_left_state: begin\n            if (bump_right) begin\n                state_next = walk_right_state;\n            end else if (dig) begin\n                state_next = dig_state;\n            end else if (!ground) begin\n                state_next = fall_state;\n            end else begin\n                state_next = walk_left_state;\n            end\n        end\n        walk_right_state: begin\n            if (bump_left) begin\n                state_next = walk_left_state;\n            end else if (dig) begin\n                state_next = dig_state;\n            end else if (!ground) begin\n                state_next = fall_state;\n            end else begin\n                state_next = walk_right_state;\n            end\n        end\n        fall_state: begin\n            if (ground) begin\n                if (dig) begin\n                    state_next = dig_state;\n                end else begin\n                    state_next = walk_left_state;\n                end\n            end else begin\n                state_next = fall_state;\n            end\n        end\n        dig_state: begin\n            if (ground) begin\n                if (!dig) begin\n                    state_next = walk_left_state;\n                end else begin\n                    state_next = dig_state;\n                end\n            end else begin\n                state_next = fall_state;\n            end\n        end\n    endcase\nend\n\n// Define the aaah output logic\nassign aaah_wire = (state_reg == fall_state) && (clock_count >= 20);\n\n// Define the clock counter\nreg [3:0] clock_count;\nalways @ (posedge clk or posedge areset) begin\n    if (areset) begin\n        clock_count <= 0;\n    end else begin\n        clock_count <= clock_count + 1;\n    end\nend\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "// State encoding\n parameter IDLE = 2'b00;\n parameter START_SEQ = 2'b01;\n parameter WAIT_FOR_PATTERN = 2'b10;\n parameter WAIT_FOR_4BIT_PATTERN = 2'b11;\n\n // State register\n reg [1:0] state_reg, state_next;\n\n // Pattern counter\n reg [1:0] pattern_count;\n\n // Output registers\n reg shift_ena_reg, counting_reg;\n\n // Combinational logic\n always @(posedge clk) begin\n     if (reset) begin\n         state_reg <= IDLE;\n         pattern_count <= 2'b00;\n         shift_ena_reg <= 1'b0;\n         counting_reg <= 1'b0;\n         done <= 1'b0;\n     end else begin\n         state_reg <= state_next;\n         pattern_count <= pattern_count + 1;\n         shift_ena_reg <= (state_reg == WAIT_FOR_4BIT_PATTERN);\n         counting_reg <= (state_reg == WAIT_FOR_4BIT_PATTERN);\n         done <= (state_reg == IDLE);\n     end\n end\n\n // State transition and output logic\n always @(posedge clk) begin\n     case (state_reg)\n         IDLE: begin\n             if (data == 1'b1) begin\n                 state_next <= START_SEQ;\n                 pattern_count <= 2'b00;\n             end else begin\n                 state_next <= IDLE;\n             end\n             shift_ena_reg <= 1'b0;\n             counting_reg <= 1'b0;\n         end\n         START_SEQ: begin\n             if (data == 1'b0) begin\n                 state_next <= WAIT_FOR_4BIT_PATTERN;\n                 pattern_count <= 2'b00;\n             end else begin\n                 state_next <= START_SEQ;\n             end\n             shift_ena_reg <= 1'b0;\n             counting_reg <= 1'b0;\n         end\n         WAIT_FOR_PATTERN: begin\n             if (pattern_count == 2'b10) begin\n                 state_next <= WAIT_FOR_4BIT_PATTERN;\n                 pattern_count <= 2'b00;\n             end else begin\n                 state_next <= WAIT_FOR_PATTERN;\n             end\n             shift_ena_reg <= (pattern_count == 2'b01);\n             counting_reg <= 1'b0;\n         end\n         WAIT_FOR_4BIT_PATTERN: begin\n             if (done_counting) begin\n                 state_next <= IDLE;\n             end else begin\n                 state_next <= WAIT_FOR_4BIT_PATTERN;\n             end\n             shift_ena_reg <= 1'b0;\n             counting_reg <= 1'b1;\n         end\n     endcase\n end\n\n // Acknowledge input\n always @(posedge clk) begin\n     if (reset) begin\n         done <= 1'b0;\n     end else if (done_counting && ack) begin\n         done <= 1'b1;\n     end\n end\n\n // Shift enable output\n always @(posedge clk) begin\n     if (reset) begin\n         shift_ena <= 1'b0;\n     end else begin\n         shift_ena <= shift_ena_reg;\n     end\n end\n\n // Counting output\n always @(posedge clk) begin\n     if (reset) begin\n         counting <= 1'b0;\n     end else begin\n         counting <= counting_reg;\n     end\n end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tq <= {q[15:0], q[255:16]};\n\t\tend\n\tend\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "Module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tlocalparam walk_left_state = 2'b00;\n\tlocalparam walk_right_state = 2'b01;\n\tlocalparam digging_state = 2'b10;\n\tlocalparam falling_state = 2'b11;\n\n\t// Define the outputs\n\treg walk_left_out;\n\treg walk_right_out;\n\treg aaah_out;\n\treg digging_out;\n\n\t// Define the state register and next state logic\n\treg [1:0] state, next_state;\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left_state;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Define the output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\twalk_left_state: begin\n\t\t\t\twalk_left_out = 1;\n\t\t\t\twalk_right_out = 0;\n\t\t\t\taaah_out = 0;\n\t\t\t\tdigging_out = 0;\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = walk_right_state;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend else if (!ground) begin\n\t\t\t\t\tnext_state = falling_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\twalk_right_state: begin\n\t\t\t\twalk_left_out = 0;\n\t\t\t\twalk_right_out = 1;\n\t\t\t\taaah_out = 0;\n\t\t\t\tdigging_out = 0;\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend else if (!ground) begin\n\t\t\t\t\tnext_state = falling_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = walk_right_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdigging_state: begin\n\t\t\t\twalk_left_out = 0;\n\t\t\t\twalk_right_out = 0;\n\t\t\t\taaah_out = 0;\n\t\t\t\tdigging_out = 1;\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = falling_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\tfalling_state: begin\n\t\t\t\twalk_left_out = 0;\n\t\t\t\twalk_right_out = 0;\n\t\t\t\taaah_out = 1;\n\t\t\t\tdigging_out = 0;\n\t\t\t\tif (ground) begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = falling_state;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Define the digging logic\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tdigging_out <= 0;\n\t\tend else if (state == digging_state) begin\n\t\t\tif (!ground) begin\n\t\t\t\tdigging_out <= 0;\n\t\t\tend\n\t\tend else if (state == walk_left_state || state == walk_right_state) begin\n\t\t\tif (dig) begin"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "Make sure to use BCD counters and decode them to binary output. You may need to use a state machine to handle the transitions between AM and PM, and incrementing the clock.\n\n```verilog\nalways @(posedge clk, posedge reset)\nbegin\n\tif(reset)\n\tbegin\n\t\thh <= 8'd12;\n\t\tmm <= 8'd00;\n\t\tss <= 8'd00;\n\t\tpm <= 1'b0;\n\tend\n\telse if(ena)\n\tbegin\n\t\tif(hh == 8'd12 && mm == 8'd59)\n\t\tbegin\n\t\t\thh <= 8'd00;\n\t\t\tmm <= 8'd00;\n\t\t\tss <= ss + 1;\n\t\t\tif(ss == 8'd60)\n\t\t\tbegin\n\t\t\t\tss <= 8'd00;\n\t\t\tend\n\t\t\tif(ss == 8'd00 && mm == 8'd00 && hh == 8'd12)\n\t\t\tbegin\n\t\t\t\tpm <= ~pm;\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(hh == 8'd12)\n\t\t\tbegin\n\t\t\t\thh <= 8'd00;\n\t\t\t\tif(pm)\n\t\t\t\tbegin\n\t\t\t\t\thh <= 8'd12;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\thh <= hh + 1;\n\t\t\tend\n\t\t\tif(hh == 8'd13)\n\t\t\tbegin\n\t\t\t\thh <= 8'd01;\n\t\t\tend\n\t\t\tif(mm == 8'd59)\n\t\t\tbegin\n\t\t\t\tmm <= 8'd00;\n\t\t\t\tif(hh == 8'd12)\n\t\t\t\tbegin\n\t\t\t\t\tpm <= ~pm;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tmm <= mm + 1;\n\t\t\tend\n\t\t\tif(mm == 8'd60)\n\t\t\tbegin\n\t\t\t\tmm <= 8'd00;\n\t\t\t\tif(hh == 8'd12)\n\t\t\t\tbegin\n\t\t\t\t\tpm <= ~pm;\n\t\t\t\tend\n\t\t\tend\n\t\t\tif(ss == 8'd59)\n\t\t\tbegin\n\t\t\t\tss <= 8'd00;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tss <= ss + 1;\n\t\t\tend\n\t\t\tif(ss == 8'd60)\n\t\t\tbegin\n\t\t\t\tss <= 8'd00;\n\t\t\tend\n\t\tend\n\tend\nend\n\nalways @(hh, mm, ss)\nbegin\n\tcase(hh)\n\t\t8'd00: hh_digit <= 4'b0000;\n\t\t8'd01: hh_digit <= 4'b0001;\n\t\t8'd02: hh_digit <= 4'b0010;\n\t\t8'd03: hh_digit <= 4'b0011;\n\t\t8'd04: hh_digit <= 4'b0100;\n\t\t8'd05: hh_digit <= 4'b0101;\n\t\t8'd06: hh_digit <= 4'b0110;\n\t\t8'd07: hh_digit <= 4'b0111;\n\t\t8'd08: hh_digit <= 4'b1000;\n\t\t8'd09: hh_digit <= 4'b1001;\n\t\t8'd10: hh_digit <= 4'b1010;"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "// Moore state machine with 2 states (walk_left or walk_right) and 2 outputs (walk_left or walk_right)\n// FSM outputs are only changed when bump or ground changes\n// FSM outputs are only changed when bump or ground changes while Lemming is walking, not while falling\n// FSM outputs are not changed when bump is received while falling\n// FSM outputs are not changed when bump is received while on the ground\n// FSM outputs are only changed when bump is received while walking\n// FSM outputs are not changed when ground disappears while Lemming is falling\n// FSM outputs are not changed when ground reappears while Lemming is falling\n// FSM outputs are not changed when bump is received while falling\n// FSM outputs are not changed when bump is received while on the ground\n// FSM outputs are not changed when ground disappears while Lemming is falling\n// FSM outputs are not changed when ground reappears while Lemming is falling\n// FSM outputs are not changed when bump is received while falling\n// FSM outputs are only changed when bump is received while walking and ground=1\n// FSM outputs are only changed when bump is received while walking and ground=0\n// FSM outputs are not changed when bump is received while falling\n// FSM outputs are not changed when ground reappears while Lemming is falling\n// FSM outputs are not changed when bump is received while on the ground\n// FSM outputs are not changed when bump is received while falling\n// FSM outputs are not changed when bump is received while on the ground\nmodule top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n// FSM states\nparameter STATE_WALK_LEFT = 2'd0;\nparameter STATE_WALK_RIGHT = 2'd1;\n\n// FSM outputs\nreg walk_left_ff;\nreg walk_right_ff;\n\n// FSM outputs for falling\nreg aaah_ff;\nreg walk_left_ff_falling;\nreg walk_right_ff_falling;\n\n// FSM registers\nreg [1:0] state_ff;\nreg [1:0] next_state;\n\n// FSM combinational logic\nalways @(*) begin\n\tcase (state_ff)\n\t\tSTATE_WALK_LEFT: begin\n\t\t\tif (bump_left) begin\n\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\tend else if (ground==0) begin\n\t\t\t\tnext_state = STATE_FALLING;\n\t\t\tend else begin\n\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\tend\n\t\tend\n\t\tSTATE_WALK_RIGHT: begin\n\t\t\tif (bump_right) begin\n\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\tend else if (ground==0) begin\n\t\t\t\tnext_state = STATE_FALLING;\n\t\t\tend else begin\n\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\tend\n\t\tend\n\t\tSTATE_FALLING: begin\n\t\t\tif (ground) begin\n\t\t\t\tnext_state = STATE_WALK_LEFT_FALLING;\n\t\t\tend else begin\n\t\t\t\tnext_state = STATE_FALLING;\n\t\t\tend\n\t\tend\n\t\tSTATE_WALK_LEFT_FALLING: begin\n\t\t\tif (bump_left) begin\n\t\t\t\tnext_state = STATE_WALK_RIGHT_FALLING;\n\t\t\tend else if (ground) begin\n\t\t\t\tnext_state = STATE_WALK_LEFT_FALLING;\n\t\t\tend else begin\n\t\t\t\tnext_state = STATE_FALLING;\n\t\t\tend\n\t\tend\n\t\tSTATE_WALK_RIGHT_FALLING: begin\n\t\t\tif (bump_right) begin\n\t\t\t\tnext_state = STATE_WALK_LEFT_FALLING;\n\t\t\tend else if (ground) begin\n\t\t\t\tnext_state = STATE_WALK_RIGHT"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "Do not introduce any additional input or output signals.\n```verilog\n\treg [3:0] ones;\n\treg [3:0] tens;\n\treg [3:0] hundreds;\n\treg [3:0] thousands;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'd0;\n\t\t\tones <= 4'd0;\n\t\t\ttens <= 4'd0;\n\t\t\thundreds <= 4'd0;\n\t\t\tthousands <= 4'd0;\n\t\tend else begin\n\t\t\tif (ones == 4'd9) begin\n\t\t\t\tones <= 4'd0;\n\t\t\t\tif (tens == 4'd9) begin\n\t\t\t\t\ttens <= 4'd0;\n\t\t\t\t\tif (hundreds == 4'd9) begin\n\t\t\t\t\t\thundreds <= 4'd0;\n\t\t\t\t\t\tif (thousands == 4'd9) begin\n\t\t\t\t\t\t\tthousands <= 4'd0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\ttens <= tens + 1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tones <= ones + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign ena = {0, (thousands != 4'd0), (hundreds != 4'd0), (tens != 4'd0), (ones != 4'd0)};\n\tassign q = {thousands, hundreds, tens, ones};\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 1'b0;\n            3'b001: Y2 = 1'b1;\n            3'b010: Y2 = 1'b0;\n            3'b011: Y2 = 1'b1;\n            3'b100: Y2 = 1'b0;\n            3'b101: Y2 = 1'b1;\n            3'b110: Y2 = 1'b0;\n            3'b111: Y2 = 1'b1;\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    // If vibrate_mode is on, turn on the motor\n    assign motor = vibrate_mode;\n\n    // If ring is on and vibrate_mode is off, turn on the ringer\n    assign ringer = (ring && !vibrate_mode);\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "// AND gate using assign statement\n\tassign out_assign = a & b;\n\t\n\t// AND gate using combinational always block\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "assign zero = 0;"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= a;\n    end\n\n    always @(posedge clk) begin\n        if (q_reg) begin\n            q <= 1;\n        end else begin\n            q <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// State encoding\nparameter S0 = 2'b00;\nparameter S1 = 2'b01;\nparameter S2 = 2'b10;\n\n// State register and next state logic\nreg [1:0] state, next_state;\nalways @ (posedge clk, posedge areset) begin\n\tif (areset) begin\n\t\tstate <= S0;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\tend\nend\n\n// Output register and combinational logic\nreg [31:0] output_reg;\nassign z = output_reg[31];\n\n// State transition and output logic\nalways @ (state, x) begin\n\tcase (state)\n\t\tS0: begin\n\t\t\tnext_state = S1;\n\t\t\toutput_reg = 32'b0;\n\t\tend\n\t\tS1: begin\n\t\t\tnext_state = S2;\n\t\t\toutput_reg[0] = x;\n\t\tend\n\t\tS2: begin\n\t\t\tnext_state = S0;\n\t\t\toutput_reg[1:0] = x;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// state encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// state register\nreg [1:0] state_reg, next_state;\n\n// output register\nreg out_reg;\n\n// next state logic\nalways @ (posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= A;\n\tend else begin\n\t\tstate_reg <= next_state;\n\tend\nend\n\n// next state logic\nalways @ (*) begin\n\tcase (state_reg)\n\t\tA: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = C;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\t\tout_reg = 1'b1;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (in == 1'b0) begin\n\t\t\t\tnext_state = C;\n\t\t\t\tout_reg = 1'b0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tout_reg = 1'b1;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// output logic\nalways @ (posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tout <= 1'b0;\n\tend else begin\n\t\tout <= out_reg;\n\tend\nend\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "Do not use any Verilog constructs that are not required.\n\nUse a single loop to reverse the byte order.\n\nIndent your code properly.\n\nTry to use meaningful variable and function names.\n\n// Reverse byte order\ninteger i;\nassign out = 0;\nfor (i = 0; i < 4; i = i + 1) begin\n\tout = out | (in[31-i*8 +: 8] << (i*8));\nend\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "and end with:\n```verilog\n\tassign q = ~r;\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "endmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "// Register for storing the input data\nreg [63:0] input_data;\n\n// Registers for storing the shift amounts\nreg [1:0] left_amount;\nreg [1:0] right_amount;\n\n// Registers for storing the shift direction\nreg shift_left;\nreg shift_right;\n\n// Register for storing the final result after shifting\nreg [63:0] shifted_data;\n\n// Assign the input data to the input_data register\nassign input_data = data;\n\n// Assign the shift amounts\nalways @(*) begin\n\tcase (amount)\n\t\t2'b00: begin\n\t\t\tleft_amount = 2'b00;\n\t\t\tright_amount = 2'b00;\n\t\tend\n\t\t2'b01: begin\n\t\t\tleft_amount = 2'b01;\n\t\t\tright_amount = 2'b00;\n\t\tend\n\t\t2'b10: begin\n\t\t\tleft_amount = 2'b00;\n\t\t\tright_amount = 2'b01;\n\t\tend\n\t\t2'b11: begin\n\t\t\tleft_amount = 2'b01;\n\t\t\tright_amount = 2'b01;\n\t\tend\n\tendcase\nend\n\n// Assign the shift direction\nalways @(*) begin\n\tif (amount == 2'b00) begin\n\t\tshift_left = 1'b1;\n\t\tshift_right = 1'b0;\n\tend\n\telse if (amount == 2'b01) begin\n\t\tshift_left = 1'b1;\n\t\tshift_right = 1'b0;\n\tend\n\telse if (amount == 2'b10) begin\n\t\tshift_left = 1'b0;\n\t\tshift_right = 1'b1;\n\tend\n\telse begin // amount == 2'b11\n\t\tshift_left = 1'b1;\n\t\tshift_right = 1'b1;\n\tend\nend\n\n// Shift left by 1 bit\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tshifted_data <= input_data;\n\tend\n\telse if (ena && shift_left && left_amount == 2'b00) begin\n\t\tshifted_data <= {shifted_data[62:0], 1'b0};\n\tend\n\telse if (ena && shift_left && left_amount == 2'b01) begin\n\t\tshifted_data <= {shifted_data[55:0], 8'b0};\n\tend\nend\n\n// Shift right by 1 bit\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tshifted_data <= input_data;\n\tend\n\telse if (ena && shift_right && right_amount == 2'b00) begin\n\t\tshifted_data <= {1'b0, shifted_data[63:1]};\n\tend\n\telse if (ena && shift_right && right_amount == 2'b01) begin\n\t\tshifted_data <= {8'b0, shifted_data[63:8]};\n\tend\nend\n\n// Assign the final shifted data to q\nassign q = shifted_data;\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "Do not use excessive comments and always try to complete the code in a single module. Do not break the code into smaller modules.\n  Use meaningful and descriptive names for the states and signals.\n  Be consistent in your coding style and follow the Verilog coding guidelines.\n  Use Verilator directives to specify the tool version and optimization options.\n\n  Do not use Verilog 2001 features like localparam and initial. Use Verilog 1995 features.\n  Do not use Verilog 2001 features like generate, generate_variable, generate_adl, generate_adl_variable, generate_function.\n  Do not use Verilog 2001 features like attribute, attribute_assign, attribute_assign_bit.\n  Do not use Verilog 2001 features like integer, parameter, reg_initial_value.\n\n  Do not use Verilog 2001 features like always_comb, always_ff, always_latch.\n  Do not use Verilog 2001 features like concurrent_select, concurrent_generate.\n  Do not use Verilog 2001 features like assert_onehot.\n  Do not use Verilog 2001 features like synopsys_attribute.\n  Do not use Verilog 2001 features like synopsys_attribute_assign.\n  Do not use Verilog 2001 features like synopsys_attribute_assign_bit.\n  Do not use Verilog 2001 features like synopsys_attribute_value.\n  Do not use Verilog 2001 features like synopsys_map.\n  Do not use Verilog 2001 features like synopsys_map_input.\n  Do not use Verilog 2001 features like synopsys_map_output.\n  Do not use Verilog 2001 features like synopsys_map_reset.\n  Do not use Verilog 2001 features like synopsys_map_update.\n  Do not use Verilog 2001 features like synopsys_map_value.\n  Do not use Verilog 2001 features like synopsys_map_value_bit.\n  Do not use Verilog 2001 features like synopsys_map_value_string.\n  Do not use Verilog 2001 features like synopsys_map_value_string_length.\n  Do not use Verilog 2001 features like synopsys_map_value_string_value.\n  Do not use Verilog 2001 features like synopsys_map_zero_delay.\n module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\n\t// Define the states\n\tlocalparam [1:0] S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n\t// Define the state register and initialize to S0\n\treg [1:0] state = S0;\n\n\t// Define the next state logic\n\talways @(posedge clk, negedge aresetn) begin\n\t\tif (~aresetn) begin\n\t\t\tstate <= S0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= S2;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\t\tz <= 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\t\tz <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register\nreg [1:0] state, next_state;\n\n// Output register\nreg z_reg;\n\n// State transition and output logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= A;\n\t\tz_reg <= 0;\n\tend else begin\n\t\tstate <= next_state;\n\t\tz_reg <= z;\n\tend\nend\n\n// State transition logic\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = A;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = A;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = D;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = A;\n\t\t\tend else begin\n\t\t\t\tnext_state = C;\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state = A;\n\t\tend\n\tendcase\nend\n\n// Output logic\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tz = 0;\n\t\tend\n\t\tB: begin\n\t\t\tz = 1;\n\t\tend\n\t\tC: begin\n\t\t\tz = 0;\n\t\tend\n\t\tD: begin\n\t\t\tz = 1;\n\t\tend\n\t\tE: begin\n\t\t\tz = 0;\n\t\tend\n\t\tF: begin\n\t\t\tz = 1;\n\t\tend\n\t\tdefault: begin\n\t\t\tz = 0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n    // Define the state machine states\n    parameter IDLE = 2'b00;\n    parameter BYTE_1 = 2'b01;\n    parameter BYTE_2 = 2'b10;\n    parameter BYTE_3 = 2'b11;\n\n    // Define the state machine signals\n    reg [1:0] state;\n    reg [7:0] in_reg;\n    reg [23:0] out_reg;\n    reg done_reg;\n\n    // Initialize the state machine\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            in_reg <= 8'b0;\n            out_reg <= 24'b0;\n            done_reg <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in[7] == 1'b1) begin\n                        state <= BYTE_1;\n                        in_reg <= in;\n                    end\n                end\n                BYTE_1: begin\n                    in_reg <= in;\n                    if (in_reg[7] == 1'b1) begin\n                        state <= BYTE_2;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n                BYTE_2: begin\n                    in_reg <= in;\n                    if (in_reg[7] == 1'b1) begin\n                        state <= BYTE_3;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n                BYTE_3: begin\n                    in_reg <= in;\n                    if (in_reg[7] == 1'b1) begin\n                        state <= IDLE;\n                        done_reg <= 1'b1;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output the message when done is asserted\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            out_reg <= 24'b0;\n        end else begin\n            if (done_reg) begin\n                out_reg <= {in_reg[23:16], in_reg[15:8], in_reg[7:0]};\n            end\n        end\n    end\n\n    // Output the message and done signal\n    assign out_bytes = out_reg;\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// Assign the input w to the output Y1 for the state A (0)\nassign Y1 = w & y[5];\n\n// Assign the output Y3 for the state A (0) to the input of the state flip-flop y[3]\nassign Y3 = y[3];\n\n// Assign the output Y3 for the state B (0) to the input of the state flip-flop y[3]\nassign Y3 = y[3] & ~y[1] & w;\n\n// Assign the output Y3 for the state C (0) to the input of the state flip-flop y[3]\nassign Y3 = y[3] & ~y[2] & ~y[1] & w;\n\n// Assign the output Y3 for the state D (0) to the input of the state flip-flop y[3]\nassign Y3 = y[3] & y[1] & ~y[0] & w;\n\n// Assign the output Y3 for the state E (1) to the input of the state flip-flop y[3]\nassign Y3 = y[3] & ~y[2] & ~y[1] & ~y[0] & w;\n\n// Assign the output Y3 for the state F (1) to the input of the state flip-flop y[3]\nassign Y3 = y[3] & y[2] & ~y[1] & ~y[0] & w;\n\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module or signal.\n```verilog\nmodule top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @ (a or b or c or d) begin\n        case ({a,b,c,d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b0;\n            4'b0111: out = 1'b1;\n            4'b1000: out = 1'b0;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b0;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b0;\n            4'b1110: out = 1'b0;\n            4'b1111: out = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "Do not put any additional code outside the module, and do not add comments that are not needed for understanding the code.\n\nAlways use meaningful names for signals and parameters.\n\nAlign the code in a readable way.\n\nUse the assign statement for the assign output.\n\nUse the combinational always block for the combinational output.\n\nUse the clocked always block for the clocked output.\n\nDo not add any verilator or lint commands.\n\nDo not add any design notes or additional information.\n\nDo not add any whitespace between keywords and signals.\n\n// Assign output\nassign out_assign = a ^ b;\n\n// Combinational output\nalways @(*) begin\n\tout_always_comb = a ^ b;\nend\n\n// Clocked output\nalways @(posedge clk) begin\n\tout_always_ff <= a ^ b;\nend\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding.\n\n// The next-state signal y[2] is used for transitions from state A to B and from state C to D.\n\n// The next-state signal y[4] is used for transitions from state B to C and from state D to E.\n\n// Assuming a one-hot encoding, the output signals for Y2 and Y4 are given by:\n\n// Y2 = y[6:3] & (y[2] ^ y[1]) & (y[1] ^ y[0]) & (y[0] ^ w)\n\n// Y4 = y[6:3] & (y[4] ^ y[3]) & (y[3] ^ y[2]) & (y[2] ^ w)\n\n// where y[6:3] is the 4-bit portion of the state encoding.\n\n// Complete the Verilog code below:\n\n// Y2\nassign Y2 = y[6:3] & (y[2] ^ y[1]) & (y[1] ^ y[0]) & (y[0] ^ w);\n\n// Y4\nassign Y4 = y[6:3] & (y[4] ^ y[3]) & (y[3] ^ y[2]) & (y[2] ^ w);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\n    reg mux_out;\n    always @ (posedge clk) begin\n        if (L) begin\n            mux_out <= R;\n        end\n        else if (E) begin\n            mux_out <= w;\n        end\n    end\n\n    always @ (posedge clk) begin\n        if (E) begin\n            Q <= mux_out;\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// D flip-flops\n\treg [2:0] q;\n\n\t// XOR gate\n\twire xor_out;\n\tassign xor_out = q[0] ^ x;\n\n\t// AND gate\n\twire and_out;\n\tassign and_out = q[0] & ~x;\n\n\t// OR gate\n\twire or_out;\n\tassign or_out = q[0] | ~x;\n\n\t// D flip-flops\n\talways @(posedge clk) begin\n\t\tq <= {xor_out, and_out, or_out};\n\tend\n\n\t// XNOR gate\n\twire xnor_out;\n\tassign xnor_out = ~(xor_out | and_out | or_out);\n\n\t// Output\n\tassign z = xnor_out;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d) | (a & b) | (a & c) | (a & d) | (b & c) | (b & d) | (c & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            next_q <= data;\n        end else begin\n            next_q <= q;\n        end\n    end\n\n    always @(*) begin\n        next_q[0] = q[1] & q[0] & ~q[1];\n        next_q[1] = q[2] & q[1] & ~q[0];\n        next_q[2] = q[3] & q[2] & ~q[1];\n        next_q[3] = q[4] & q[3] & ~q[2];\n        next_q[4] = q[5] & q[4] & ~q[3];\n        next_q[5] = q[6] & q[5] & ~q[4];\n        next_q[511] = q[510] & q[511] & ~q[509];\n        q <= next_q;\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with one input, one output, and four states.\n// State A is the reset state.\n// State B is the middle state.\n// State C is the middle state.\n// State D is the final state.\n// State A is the output state for input 0.\n// State C is the output state for input 1.\n// State B and D are the output states for both inputs.\n// Output is 0 for input 0 and 1 for input 1.\n// Transition between states is determined by the current state and input.\n// Output is determined by the current state and input.\n// Synchronous active high reset.\n\n// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register\nreg [1:0] state_reg;\n\n// Next state logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate_reg <= A;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= D;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= A;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= B;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tout <= 0;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tA: begin\n\t\t\t\tout <= 0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tout <= 0;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tout <= 1;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tout <= 1;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case ({a,b})\n            4'b0000: q = 4'bxxxx;\n            4'b0001: q = 4'bxxxx;\n            4'b0010: q = 4'bxxxx;\n            4'b0011: q = 4'bxxxx;\n            4'b0100: q = 4'bxxxx;\n            4'b0101: q = 4'bxxxx;\n            4'b0110: q = 4'bxxxx;\n            4'b0111: q = 4'bxxxx;\n            4'b1000: q = 4'bxxxx;\n            4'b1001: q = 4'bxxxx;\n            4'b1010: q = 4'bxxxx;\n            4'b1011: q = 4'bxxxx;\n            4'b1100: q = 4'bxxxx;\n            4'b1101: q = 4'bxxxx;\n            4'b1110: q = 4'bxxxx;\n            4'b1111: q = 4'bxxxx;\n            default: begin\n                case ({c,d})\n                    4'b0000: q = 4'bxxxx;\n                    4'b0001: q = 4'bxxxx;\n                    4'b0010: q = 4'bxxxx;\n                    4'b0011: q = 4'bxxxx;\n                    4'b0100: q = 4'bxxxx;\n                    4'b0101: q = 4'bxxxx;\n                    4'b0110: q = 4'bxxxx;\n                    4'b0111: q = 4'bxxxx;\n                    4'b1000: q = 4'bxxxx;\n                    4'b1001: q = 4'bxxxx;\n                    4'b1010: q = 4'bxxxx;\n                    4'b1011: q = 4'bxxxx;\n                    4'b1100: q = 4'bxxxx;\n                    4'b1101: q = 4'bxxxx;\n                    4'b1110: q = 4'bxxxx;\n                    4'b1111: q = 4'bxxxx;\n                endcase\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "// 8-bit wide 2-to-1 mux\n// sel: select input\n// a: input A\n// b: input B\n// out: output\n\n// 2-to-1 mux implementation\nalways @ (sel or a or b)\n\tout = (~sel & a) | (sel & b);\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module \"top_module\"\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\nwire [2:0] q_wire;\n\nflipflop_mux ff_inst1(\n    .clk(clk),\n    .L(L),\n    .r(r_in),\n    .q(q_wire)\n);\n\nflipflop_mux ff_inst2(\n    .clk(clk),\n    .L(L),\n    .r(q_wire),\n    .q(q_wire)\n);\n\nassign Q = q_wire[2];\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "endmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module\nmodule top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    // Instantiate 8 D flip-flops\n    dff dff0(.clk(clk), .d(d[0]), .q(q[0]));\n    dff dff1(.clk(clk), .d(d[1]), .q(q[1]));\n    dff dff2(.clk(clk), .d(d[2]), .q(q[2]));\n    dff dff3(.clk(clk), .d(d[3]), .q(q[3]));\n    dff dff4(.clk(clk), .d(d[4]), .q(q[4]));\n    dff dff5(.clk(clk), .d(d[5]), .q(q[5]));\n    dff dff6(.clk(clk), .d(d[6]), .q(q[6]));\n    dff dff7(.clk(clk), .d(d[7]), .q(q[7]));\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] a_ext = {a, 1'b0};\n    wire [8:0] b_ext = {b, 1'b0};\n    wire [8:0] s_ext;\n\n    assign s_ext = a_ext + b_ext;\n    assign overflow = (a[7] == b[7] && s_ext[8] != a[7]) ? 1 : 0;\n\n    assign s = s_ext[7:0];\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "`B3_next`, `S_next`, `S1_next`, `Count_next`, and `Wait_next` are the next-state logic and `done`, `counting`, and `shift_ena` are the output logic for this state machine.\n```verilog\n    // Next-state logic\n    assign B3_next = (state == 10'b0000000001) & d;\n    assign S_next = (state == 10'b0000000001) & ~d;\n    assign S1_next = (state == 10'b0000000010) & d;\n    assign Count_next = (state == 10'b0000000100) & d;\n    assign Wait_next = (state == 10'b0000001000) & ack;\n\n    // Output logic\n    assign done = (state == 10'b1000000000);\n    assign counting = (state == 10'b0000001000);\n    assign shift_ena = (state == 10'b0000000001) | (state == 10'b0000000100) | (state == 10'b0000001000);\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "Follow the Verilog coding guidelines and conventions. Do not use any Verilog constructs that are not necessary. Do not add comments that are not needed. Use meaningful names for the signals.\n\n 1. Do not use `wire` for signals that are not used in multiple places.\n 2. Do not use `reg` for signals that are not used in multiple places.\n 3. Use `logic` for signals that are used in multiple places.\n 4. Use `initial` block for one-time initialization only.\n 5. Use `always` block for sequential logic.\n 6. Use `assign` for combinational logic.\n 7. Use `begin`-`end` for block-structured code.\n 8. Use `if`-`else` for conditional code.\n 9. Use `case`-`endcase` for case statements.\n 10. Use `for`-`endfor` for loop statements.\n 11. Use `function`-`endfunction` for function definitions.\n 12. Use `function_instantiation` for function calls.\n 13. Use `module`-`endmodule` for module definitions.\n 14. Use `parameter` for constants.\n 15. Use `specify`-`endspecify` for safety properties.\n 16. Use `$display` for debugging purposes.\n 17. Use `$finish` for stopping simulation.\n 18. Use `$monitor` for displaying signal values.\n 19. Use `$random` for generating random numbers.\n 20. Use `$stop` for stopping simulation.\n 21. Use `$dumpfile` for generating VCD file.\n 22. Use `$dumpoff` for suppressing VCD file output.\n 23. Use `$dumpvars` for generating VCD file.\n 24. Use `$finish` for stopping simulation.\n 25. Use `$readmemh` for loading initial state.\n 26. Use `$writememh` for storing final state.\n 27. Use `$display` for displaying signal values.\n 28. Use `$display_bus` for displaying bus values.\n 29. Use `$fopen` for opening a file for writing.\n 30. Use `$fdisplay` for displaying signal values to a file.\n 31. Use `$fclose` for closing a file.\n 32. Use `$save_state` for saving state to a file.\n 33. Use `$restore_state` for restoring state from a file.\n 34. Use `$setup_sdf_export` for generating SDF file.\n 35. Use `$finish` for stopping simulation.\n 36. Use `$sdf_annotate` for annotating the SDF file.\n 37. Use `$sdf_export` for exporting the SDF file.\n 38. Use `$sdf_import` for importing the SDF file.\n 39. Use `$sdf_merge` for merging two SDF files.\n 40. Use `$sdf_open` for opening an SDF file for reading.\n 41. Use `$sdf_read_file` for reading an SDF file.\n 42. Use `$sdf_close` for closing an SDF file.\n 43. Use `$sdf_write_file` for writing an SDF file.\n 44. Use `$sdf_export_display` for displaying the SDF file.\n 45. Use `$stop` for stopping simulation.\n 46. Use `$reset` for resetting the simulation.\n 47. Use `$finish` for stopping simulation.\n 48. Use `$random_seed` for setting random seed.\n 49. Use `$show_sdf` for displaying the SDF file.\n 50. Use `$dumpoff` for suppressing VCD file output.\n 51. Use `$dumpvars` for generating VCD file.\n 52. Use `$final` for generating final state.\n 53. Use `$realtime_stats` for displaying simulation statistics.\n 54. Use `$display_stats` for displaying simulation statistics.\n 55. Use `$dumpfile` for generating VCD file."}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    initial begin\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n    end\n\n    always @ (scancode) begin\n        case (scancode)\n            16'he06b: left = 1;\n            16'he072: down = 1;\n            16'he074: right = 1;\n            16'he075: up = 1;\n            default: left = 0;\n                    down = 0;\n                    right = 0;\n                    up = 0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module\n\n// Full Adder\nmodule full_adder (\n    input x,\n    input y,\n    input carry_in,\n    output sum,\n    output carry_out\n);\n\nassign {carry_out, sum} = x + y + carry_in;\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    reg [31:0] history_reg;\n    reg [31:0] mispredicted_history;\n    reg [4:0] history_count;\n    reg [4:0] mispredicted_count;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history_reg <= 0;\n            mispredicted_history <= 0;\n            history_count <= 0;\n            mispredicted_count <= 0;\n        end\n        else begin\n            if (predict_valid && predict_taken) begin\n                history_reg <= {history_reg[30:0], predict_taken};\n                history_count <= history_count + 1;\n            end\n            \n            if (train_mispredicted) begin\n                mispredicted_history <= {train_history, train_taken};\n                mispredicted_count <= mispredicted_count + 1;\n            end\n            \n            if (history_count > mispredicted_count) begin\n                predict_history <= history_reg;\n            end\n            else begin\n                predict_history <= mispredicted_history;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// Create two intermediate wires to connect the AND and OR gates together.\nwire and1_out;\nwire and2_out;\n\n// The first layer: two AND gates\nand and1 (\n\t.out(and1_out),\n\t.a(a),\n\t.b(b)\n);\n\nand and2 (\n\t.out(and2_out),\n\t.a(c),\n\t.b(d)\n);\n\n// The second layer: an OR gate to OR the two AND outputs, connected the output 'out'.\nor or1 (\n\t.out(out),\n\t.a(and1_out),\n\t.b(and2_out)\n);\n\n// The third layer: an inverter to invert the output 'out'\nnot not1 (\n\t.out(out_n),\n\t.a(out)\n);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n    reg [2:0] ABC;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]};\n        end\n    end\n\n    always @(*) begin\n        case (ABC)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "// Mode logic\n  assign heater = mode & too_cold;\n  assign aircon = ~mode & too_hot;\n  assign fan = heater | aircon | fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // SOP (sum of products)\n    assign out_sop = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & d) | (a & ~b & ~c & d) | (a & b & c & ~d) | (a & b & ~c & d) | (a & ~b & c & d) | (~a & b & c & d);\n\n    // POS (product of sums)\n    assign out_pos = (~a & b & ~c & ~d) & (~a & ~b & c & d) & (a & ~b & c & d) & (~a & b & c & d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "// 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1\n\treg [31:0] lfsr;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 32'h1;\n\t\t\tq <= 32'h1;\n\t\tend\n\t\telse begin\n\t\t\tlfsr[31] <= lfsr[30] ^ lfsr[22] ^ lfsr[1];\n\t\t\tlfsr[30] <= lfsr[29] ^ lfsr[22] ^ lfsr[0];\n\t\t\tlfsr[29] <= lfsr[28] ^ lfsr[22] ^ lfsr[2];\n\t\t\tlfsr[28] <= lfsr[27] ^ lfsr[22] ^ lfsr[3];\n\t\t\tlfsr[27] <= lfsr[26] ^ lfsr[22] ^ lfsr[4];\n\t\t\tlfsr[26] <= lfsr[25] ^ lfsr[22] ^ lfsr[5];\n\t\t\tlfsr[25] <= lfsr[24] ^ lfsr[22] ^ lfsr[6];\n\t\t\tlfsr[24] <= lfsr[23] ^ lfsr[22] ^ lfsr[7];\n\t\t\tlfsr[23] <= lfsr[22] ^ lfsr[22] ^ lfsr[8];\n\t\t\tlfsr[22] <= lfsr[21] ^ lfsr[22] ^ lfsr[9];\n\t\t\tlfsr[21] <= lfsr[20] ^ lfsr[22] ^ lfsr[10];\n\t\t\tlfsr[20] <= lfsr[19] ^ lfsr[22] ^ lfsr[11];\n\t\t\tlfsr[19] <= lfsr[18] ^ lfsr[22] ^ lfsr[12];\n\t\t\tlfsr[18] <= lfsr[17] ^ lfsr[22] ^ lfsr[13];\n\t\t\tlfsr[17] <= lfsr[16] ^ lfsr[22] ^ lfsr[14];\n\t\t\tlfsr[16] <= lfsr[15] ^ lfsr[22] ^ lfsr[15];\n\t\t\tlfsr[15] <= lfsr[14] ^ lfsr[22] ^ lfsr[16];\n\t\t\tlfsr[14] <= lfsr[13] ^ lfsr[22] ^ lfsr[17];\n\t\t\tlfsr[13] <= lfsr[12] ^ lfsr[22] ^ lfsr[18];\n\t\t\tlfsr[12] <= lfsr[11] ^ lfsr[22] ^ lfsr[19];\n\t\t\tlfsr[11] <= lfsr[10] ^ lfsr[22] ^ lfsr[20];\n\t\t\tlfsr[10] <= lfsr[9] ^ lfsr[22] ^ lfsr[21];\n\t\t\tlfsr[9] <= lfsr[8] ^ lfsr[22] ^ lfsr[22];\n\t\t\tlfsr[8] <= lfsr[7] ^ lfsr[22] ^ lfsr[23];\n\t\t\tlfsr[7] <= lfsr[6] ^ lfsr[22] ^ lfsr[24];\n\t\t\tlfsr[6] <= lfsr[5] ^ lfsr[22] ^ lfsr[25];\n\t\t\tlfsr[5] <= lfsr[4] ^ lfsr[22] ^ lfsr["}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (~a & ~b & ~c & ~d) | (a & b & c & ~d) | (~a & b & c & d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & ~c & d) | (a & ~b & c & d) | (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & ~b & c & d) | (~a & b & c & d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Two 4-input NAND gates\nwire n1, n2, n3, n4, n5, n6;\nassign n1 = ~(p1a & p1b & p1c & p1d);\nassign n2 = ~(p2a & p2b & p2c & p2d);\nassign n3 = ~(n1 & n2);\nassign n4 = ~(n3 & n3);\nassign n5 = ~(n4 & n4);\nassign n6 = ~(n5 & n5);\nassign p1y = n6;\nassign p2y = n6;\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "and end with:\n```verilog\n\tassign out = {out[7:0], in[0]};\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    assign out_both[0] = (in[0] & in[3]) ? 1 : 0;\n    assign out_both[1] = (in[1] & in[2]) ? 1 : 0;\n    assign out_both[2] = (in[2] & in[1]) ? 1 : 0;\n    assign out_any[0] = (in[0] | in[1]) ? 1 : 0;\n    assign out_any[1] = (in[1] | in[2]) ? 1 : 0;\n    assign out_any[2] = (in[2] | in[3]) ? 1 : 0;\n    assign out_different[0] = (in[0] != in[3]) ? 1 : 0;\n    assign out_different[1] = (in[1] != in[0]) ? 1 : 0;\n    assign out_different[2] = (in[2] != in[1]) ? 1 : 0;\n    assign out_different[3] = (in[3] != in[2]) ? 1 : 0;\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'b1232;\n        3'b001: q = 16'b0aee;\n        3'b010: q = 16'b27d4;\n        3'b011: q = 16'b5a0e;\n        3'b100: q = 16'b2066;\n        3'b101: q = 16'b64ce;\n        3'b110: q = 16'bc526;\n        3'b111: q = 16'b2f19;\n    endcase\nend\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "Follow the Verilog coding conventions and guidelines. Do not use unnecessary comments and avoid code duplication.\n\n// Verilog coding convention:\n// - use of logic type for output signals\n// - use of 1-bit signals (no arrays)\n// - use of logic operators (&&, ||, !) for gate-level design\n// - use of braces for multiple statements in a block\n// - use of CamelCase for signal names\n// - use of descriptive signal names\n// - use of whitespace for readability\n// - use of comments for complex logic\n// - use of Verilog's reserved keywords (e.g. input, output, logic)\n// - use of Verilog's built-in functions (e.g. $display)\n\n// AND gate with a bubble\nand and_gate (\n\t.A(in1),\n\t.B(in2),\n\t.Z(out)\n);\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "Do not use any comment in the Verilog code.\n\nUse simple and clear naming convention for the variables.\n\nAvoid using intermediate variables.\n\nDo not use any Verilog constructs which are not required.\n\nCheck the Verilog syntax and code style.\n\nModule top_module(\n\tinput in,\n\toutput out);\n\n\tassign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter B = 2'b00;\nparameter A = 2'b01;\n\n // State register\nreg [1:0] state_reg, state_next;\n\n // Output register\nreg out_reg;\n\n // Output logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tB: out_reg = 1'b0;\n\t\tA: out_reg = 1'b1;\n\tendcase\nend\n\n // State transition and output logic\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= B;\n\tend else begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\nalways @(*) begin\n\tcase (state_reg)\n\t\tB: state_next = (in) ? B : A;\n\t\tA: state_next = (in) ? A : B;\n\tendcase\nend\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "// Dual-edge triggered flip-flop\n\treg q_next;\n\talways @(posedge clk or negedge clk) begin\n\t\tif (clk == 1'b0) begin\n\t\t\tq_next <= d;\n\t\tend\n\tend\n\talways @(posedge clk or negedge clk) begin\n\t\tif (clk == 1'b1) begin\n\t\t\tq <= q_next;\n\t\tend\n\tend\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n    wire w1, w2, w3;\n    A a1(.x(x), .y(y), .z(w1));\n    A a2(.x(x), .y(y), .z(w2));\n    B b1(.x(x), .y(y), .z(w3));\n    B b2(.x(x), .y(y), .z(w3));\n    assign z = w1 | w2 & w3;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else if (ena == 2'b01) begin\n            q <= {q[0], q[99:1]};\n        end\n        else if (ena == 2'b10) begin\n            q <= {q[98:0], q[99]};\n        end\n    end\n\n endmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module header.\n\nModule top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 0;\n            q <= 0;\n        end else begin\n            counter <= counter + 1;\n            q <= counter;\n        end\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "Do not use comments to explain the code.\n\nFollow the Verilog syntax and semantic rules.\n\nUse meaningful names for the input and output ports.\n\nDo not use macros or functions in the code.\n\nModule top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    // State transition logic\n    assign next_state[0] = (state[1] ^ state[2] ^ state[3] ^ state[4] ^ state[5] ^ state[6] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[1] = (state[0] ^ state[2] ^ state[3] ^ state[4] ^ state[5] ^ state[6] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[2] = (state[0] ^ state[1] ^ state[3] ^ state[4] ^ state[5] ^ state[6] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[3] = (state[0] ^ state[1] ^ state[2] ^ state[4] ^ state[5] ^ state[6] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[4] = (state[0] ^ state[1] ^ state[2] ^ state[3] ^ state[5] ^ state[6] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[5] = (state[0] ^ state[1] ^ state[2] ^ state[3] ^ state[4] ^ state[6] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[6] = (state[0] ^ state[1] ^ state[2] ^ state[3] ^ state[4] ^ state[5] ^ state[7] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[7] = (state[0] ^ state[1] ^ state[2] ^ state[3] ^ state[4] ^ state[5] ^ state[6] ^ state[8] ^ state[9]) ? 1 : 0;\n    assign next_state[8] = (state[0] ^ state[1] ^ state[2] ^ state[3] ^ state[4] ^ state[5] ^ state[6] ^ state[7] ^ state[9]) ? 1 : 0;\n    assign next_state[9] = (state[0] ^ state[1] ^ state[2] ^ state[3] ^ state[4] ^ state[5] ^ state[6] ^ state[7] ^ state[8]) ? 1 : 0;\n\n    // Output logic\n    assign out1 = (state[0] & state[1] & state[2] & state[3] & state[4] & state[5] & state[6] & state[7] & state[8]) ? 1 : 0;\n    assign out2 = (state[0] & state[1] & state[2] & state[3] & state[4] & state[5] & state[6] & state[7] & state[9]) ? 1 : 0;\n\n endmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "// JK flip-flop\nalways @(posedge clk) begin\n\tif (j && k)\n\t\tQ <= ~Q;\n\telse if (j)\n\t\tQ <= 0;\n\telse if (k)\n\t\tQ <= 1;\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out[0] = in[0] ^ in[1] ^ in[2];\n    assign out[1] = in[0] ^ in[1] ^ in[2];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    assign out[19] = ~b ^ d;\n    assign out[18] = ~b ^ e;\n    assign out[17] = ~c ^ d;\n    assign out[16] = ~c ^ e;\n    assign out[15] = ~d ^ e;\n    assign out[14] = ~a ^ b;\n    assign out[13] = ~a ^ c;\n    assign out[12] = ~a ^ d;\n    assign out[11] = ~a ^ e;\n    assign out[10] = ~b ^ c;\n    assign out[ 9] = ~b ^ d;\n    assign out[ 8] = ~b ^ e;\n    assign out[ 7] = ~c ^ d;\n    assign out[ 6] = ~c ^ e;\n    assign out[ 5] = ~d ^ e;\n    assign out[ 4] = ~a ^ b;\n    assign out[ 3] = ~a ^ c;\n    assign out[ 2] = ~a ^ d;\n    assign out[ 1] = ~e ^ d;\n    assign out[ 0] = ~e ^ e;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    reg [1:0] state;\n    reg walk_left;\n    reg walk_right;\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // walk left\n        end else begin\n            case (state)\n                2'b01: // walk left\n                    if (bump_right) begin\n                        state <= 2'b10; // walk right\n                    end\n                2'b10: // walk right\n                    if (bump_left) begin\n                        state <= 2'b01; // walk left\n                    end\n            endcase\n        end\n    end\n\n    assign walk_left = (state == 2'b01);\n    assign walk_right = (state == 2'b10);\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    wire q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\n\n    assign q1 = a & b;\n    assign q2 = a | b;\n    assign q3 = a ^ b;\n    assign q4 = ~a & ~b;\n    assign q5 = ~a | b;\n    assign q6 = a & ~b;\n    assign q7 = ~a & b;\n    assign q8 = a & b;\n    assign q9 = ~a & ~b;\n    assign q10 = a | b;\n    assign q11 = a ^ b;\n    assign q12 = ~a & b;\n    assign q13 = a & ~b;\n    assign q14 = ~a & ~b;\n    assign q15 = ~a ^ b;\n\n    assign q = q1 | q2 | q3 | q4 | q5 | q6 | q7 | q8 | q9 | q10 | q11 | q12 | q13 | q14 | q15;\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\n    always @(posedge clk) begin\n        // State transition logic\n        if (x == 0) begin\n            Y0 <= y[2:0];\n            z <= 0;\n        case (y)\n            3'b000: Y0 <= 3'b000;\n            3'b001: Y0 <= 3'b001;\n            3'b010: Y0 <= 3'b010;\n            3'b011: Y0 <= 3'b001;\n            3'b100: Y0 <= 3'b011;\n            default: Y0 <= 3'b000;\n        endcase\n        end\n        else begin\n            Y0 <= y[2:0];\n            z <= 1;\n        case (y)\n            3'b000: Y0 <= 3'b001;\n            3'b001: Y0 <= 3'b010;\n            3'b010: Y0 <= 3'b001;\n            3'b011: Y0 <= 3'b011;\n            3'b100: Y0 <= 3'b100;\n            default: Y0 <= 3'b000;\n        endcase\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "// 2-input NOR gate\n\tassign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "// Wires\n  wire a_to_w;\n  wire b_to_x;\n  wire b_to_y;\n  wire c_to_z;\n\n  // Assignments\n  assign a_to_w = a;\n  assign b_to_x = b;\n  assign b_to_y = b;\n  assign c_to_z = c;\n\n  // Outputs\n  assign w = a_to_w;\n  assign x = b_to_x;\n  assign y = b_to_y;\n  assign z = c_to_z;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "and end with the following:\n```verilog\n\talways @(posedge clk or negedge ar) begin\n\t\tif (!ar) begin\n\t\t\tq <= 1'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "Also, add a comment to explain the logic of the mux.\n\n```verilog\n// 6-to-1 MUX\nalways @(*) begin\n\tcase(sel)\n\t\t3'b000: out = data0;\n\t\t3'b001: out = data1;\n\t\t3'b010: out = data2;\n\t\t3'b011: out = data3;\n\t\t3'b100: out = data4;\n\t\t3'b101: out = data5;\n\t\tdefault: out = 4'b0000;\n\tendcase\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] counter;\n    reg tc_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;\n            tc_reg <= 0;\n        end\n        else begin\n            if (counter == 0) begin\n                tc_reg <= 1;\n            end\n            else begin\n                tc_reg <= 0;\n                counter <= counter - 1;\n            end\n        end\n    end\n\n    assign tc = tc_reg;\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "// Declare the states\n\treg [1:0] state;\n\tparameter [1:0] S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\t\t\t\t\t\t\n\t// Declare the outputs\n\toutput start_shifting;\n\treg start_shifting;\n\t\t\t\t\t\t\n\t// Declare the registers\n\treg [1:0] shift_reg;\n\treg [1:0] match_reg;\n\t\t\t\t\t\t\n\t// State machine\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], data};\n\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], data};\n\t\t\t\t\t\tstate <= S2;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], 1'b0};\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], 1'b0};\n\t\t\t\t\t\tstate <= S3;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], 1'b0};\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS3: begin\n\t\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], 1'b1};\n\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\t\tstart_shifting <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[0], 1'b0};\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Assign the match register\n\tassign match_reg = {shift_reg[1], shift_reg[0]};\n\t\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge);\n\n    reg [7:0] prev_in;\n    reg [7:0] cur_in;\n\n    always @(posedge clk) begin\n        prev_in <= cur_in;\n        cur_in <= in;\n        anyedge <= (prev_in & ~cur_in);\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0001;\n        end else if (q == 4'b1010) begin\n            q <= 4'b0001;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    reg [2:0] q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= {q_reg[1:0], a};\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q);\n\n    reg [4:0] lfsr;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            lfsr <= 5'b10000;\n            q <= 5'b1;\n        end\n        else begin\n            lfsr <= {lfsr[4:1], lfsr[0] ^ lfsr[4] ^ lfsr[3]};\n            q <= lfsr[4];\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "```verilog\nalways @(*) begin\n    if (do_sub == 0) begin\n        out = a + b;\n    end else begin\n        out = a - b;\n    end\n    \n    if (out == 0) begin\n        result_is_zero = 1;\n    end else begin\n        result_is_zero = 0;\n    end\nend\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always_comb begin\n        case (x)\n            4'b0000: f = 1'b0;\n            4'b0001: f = 1'b0;\n            4'b0011: f = 1'b1;\n            4'b0010: f = 1'b1;\n            4'b0100: f = 1'b1;\n            4'b0101: f = 1'b1;\n            4'b0111: f = 1'b1;\n            4'b0110: f = 1'b0;\n            4'b1000: f = 1'b1;\n            4'b1001: f = 1'b1;\n            4'b1011: f = 1'b1;\n            4'b1010: f = 1'b0;\n            4'b1100: f = 1'b0;\n            4'b1101: f = 1'b0;\n            4'b1111: f = 1'b1;\n            4'b1110: f = 1'b1;\n            default: f = 1'b0; // d is don't-care\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @*\n    begin\n        case(code)\n            8'h45:\n            begin\n                out = 0;\n                valid = 1;\n            end\n            8'h16:\n            begin\n                out = 1;\n                valid = 1;\n            end\n            8'h1e:\n            begin\n                out = 2;\n                valid = 1;\n            end\n            8'h26:\n            begin\n                out = 3;\n                valid = 1;\n            end\n            8'h25:\n            begin\n                out = 4;\n                valid = 1;\n            end\n            8'h2e:\n            begin\n                out = 5;\n                valid = 1;\n            end\n            8'h36:\n            begin\n                out = 6;\n                valid = 1;\n            end\n            8'h3d:\n            begin\n                out = 7;\n                valid = 1;\n            end\n            8'h3e:\n            begin\n                out = 8;\n                valid = 1;\n            end\n            8'h46:\n            begin\n                out = 9;\n                valid = 1;\n            end\n            default:\n            begin\n                out = 0;\n                valid = 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module code should reverse the bit ordering of the input vector.\nYour Verilog code should be concise and focused on the key points.\nAvoid repetitive thoughts and provide the Verilog code design directly.\n\n```verilog\nmodule top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = {in[0], in[7], in[1], in[6], in[2], in[5], in[3], in[4]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "// 00\nalways @(*) begin\n\tif(a == 0 && b == 0 && c == 0)\n\t\tout = 0;\n\tif(a == 0 && b == 0 && c == 1)\n\t\tout = 1;\n\tif(a == 0 && b == 1 && c == 0)\n\t\tout = 1;\n\tif(a == 0 && b == 1 && c == 1)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 0)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 1)\n\t\tout = 0;\n\tif(a == 1 && b == 1 && c == 0)\n\t\tout = 0;\n\tif(a == 1 && b == 1 && c == 1)\n\t\tout = 1;\nend\n\n// 01\nalways @(*) begin\n\tif(a == 0 && b == 0 && c == 0)\n\t\tout = 0;\n\tif(a == 0 && b == 0 && c == 1)\n\t\tout = 0;\n\tif(a == 0 && b == 1 && c == 0)\n\t\tout = d;\n\tif(a == 0 && b == 1 && c == 1)\n\t\tout = 1;\n\tif(a == 1 && b == 0 && c == 0)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 1)\n\t\tout = 0;\n\tif(a == 1 && b == 1 && c == 0)\n\t\tout = 1;\n\tif(a == 1 && b == 1 && c == 1)\n\t\tout = 1;\nend\n\n// 10\nalways @(*) begin\n\tif(a == 0 && b == 0 && c == 0)\n\t\tout = 0;\n\tif(a == 0 && b == 0 && c == 1)\n\t\tout = 1;\n\tif(a == 0 && b == 1 && c == 0)\n\t\tout = 1;\n\tif(a == 0 && b == 1 && c == 1)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 0)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 1)\n\t\tout = 0;\n\tif(a == 1 && b == 1 && c == 0)\n\t\tout = 0;\n\tif(a == 1 && b == 1 && c == 1)\n\t\tout = 1;\nend\n\n// 11\nalways @(*) begin\n\tif(a == 0 && b == 0 && c == 0)\n\t\tout = 0;\n\tif(a == 0 && b == 0 && c == 1)\n\t\tout = 1;\n\tif(a == 0 && b == 1 && c == 0)\n\t\tout = d;\n\tif(a == 0 && b == 1 && c == 1)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 0)\n\t\tout = d;\n\tif(a == 1 && b == 0 && c == 1)\n\t\tout = 0;\n\tif(a == 1 && b == 1 && c == 0)\n\t\tout = 1;\n\tif(a == 1 && b == 1 && c == 1)\n\t\tout = 1;\nend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "endmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "Then, add the FSM states and transitions:\n```verilog\nreg [1:0] state;\nparameter S0 = 2'b00;\nparameter S1 = 2'b01;\nparameter S2 = 2'b10;\nparameter S3 = 2'b11;\n\nalways @(posedge clk) begin\n\tif(reset) begin\n\t\tstate <= S0;\n\t\tshift_ena <= 0;\n\tend else begin\n\t\tcase(state)\n\t\t\tS0: begin\n\t\t\t\tif(reset) begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tshift_ena <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S1;\n\t\t\t\t\tshift_ena <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif(reset) begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tshift_ena <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S2;\n\t\t\t\t\tshift_ena <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif(reset) begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tshift_ena <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S3;\n\t\t\t\t\tshift_ena <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tif(reset) begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tshift_ena <= 0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= S0;\n\t\t\t\t\tshift_ena <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if(reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n    always @(*) begin\n        if (sel_b1 & sel_b2) begin\n            out_always = b;\n        end else begin\n            out_always = a;\n        end\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'b1001) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n\n    reg [1:0] state;\n    reg [7:0] data;\n    reg [7:0] count;\n\n    parameter IDLE = 2'b00;\n    parameter WAIT = 2'b01;\n    parameter DATA = 2'b10;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            count <= 0;\n            data <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in[3] == 1) begin\n                        state <= WAIT;\n                        count <= 0;\n                        data <= in;\n                    end\n                end\n                WAIT: begin\n                    if (count == 2) begin\n                        state <= DATA;\n                        count <= 0;\n                        done <= 1;\n                    end else if (in[3] == 1) begin\n                        data <= in;\n                        count <= count + 1;\n                    end else begin\n                        count <= 0;\n                    end\n                end\n                DATA: begin\n                    if (count == 2) begin\n                        state <= WAIT;\n                        count <= 0;\n                        done <= 0;\n                    end else if (in[3] == 1) begin\n                        data <= in;\n                        count <= count + 1;\n                    end else begin\n                        count <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    reg [2:0] y;\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 0;\n        end else begin\n            case (y)\n                3'b000: if (x) y <= 3'b001; else y <= 3'b000;\n                3'b001: if (x) y <= 3'b100; else y <= 3'b001;\n                3'b010: if (x) y <= 3'b001; else y <= 3'b010;\n                3'b011: if (x) y <= 3'b010; else y <= 3'b011;\n                3'b100: if (x) y <= 3'b100; else y <= 3'b001;\n                default: y <= 3'b000;\n            endcase\n            case (y)\n                3'b000: z <= 0;\n                3'b001: z <= 0;\n                3'b010: z <= 0;\n                3'b011: z <= 1;\n                3'b100: z <= 1;\n                default: z <= 0;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n\n\t// Define states\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\n\t// Define outputs\n\tparameter IDLE = 1'b0;\n\tparameter ACTIVE = 1'b1;\n\n\t// Define signals\n\treg [1:0] state, next_state;\n\treg [1:0] output_reg;\n\treg [1:0] y_reg;\n\treg [1:0] x_reg;\n\treg [1:0] x_reg_next;\n\treg [1:0] y_reg_next;\n\treg [2:0] counter;\n\treg active;\n\n\t// Define constants\n\tparameter MAX_COUNTER_VALUE = 3'b111;\n\tparameter MAX_Y_COUNTER_VALUE = 2'b11;\n\n\t// Define state machine\n\talways @(posedge clk, negedge resetn) begin\n\t\tif (~resetn) begin\n\t\t\tstate <= A;\n\t\t\toutput_reg <= IDLE;\n\t\t\ty_reg <= 2'b00;\n\t\t\tx_reg <= 2'b00;\n\t\t\tx_reg_next <= 2'b00;\n\t\t\ty_reg_next <= 2'b00;\n\t\t\tcounter <= 3'b000;\n\t\t\tactive <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\toutput_reg <= active ? ACTIVE : IDLE;\n\t\t\ty_reg <= y_reg_next;\n\t\t\tx_reg <= x_reg_next;\n\t\t\tcounter <= counter + 1;\n\t\t\tif (counter == MAX_COUNTER_VALUE) begin\n\t\t\t\tcounter <= 3'b000;\n\t\t\tend\n\t\t\tif (y_reg == MAX_Y_COUNTER_VALUE) begin\n\t\t\t\ty_reg <= 2'b00;\n\t\t\tend else begin\n\t\t\t\ty_reg <= y_reg_next;\n\t\t\tend\n\t\tend\n\tend\n\n\t// Define next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tnext_state = B;\n\t\t\t\tf = 1;\n\t\t\t\tg = 0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (x == 1) begin\n\t\t\t\t\tnext_state = C;\n\t\t\t\t\tx_reg_next = 2'b01;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = B;\n\t\t\t\t\tx_reg_next = 2'b00;\n\t\t\t\tend\n\t\t\t\tf = 0;\n\t\t\t\tg = 0;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (x == 0) begin\n\t\t\t\t\tnext_state = D;\n\t\t\t\t\tx_reg_next = 2'b10;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = C;\n\t\t\t\t\tx_reg_next = 2'b01;\n\t\t\t\tend\n\t\t\t\tf = 0;\n\t\t\t\tg = 0;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (y == 1) begin\n\t\t\t\t\tnext_state = D;\n\t\t\t\t\ty_reg_next = 2'b11;\n\t\t\t\t\tactive = 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = D;\n\t\t\t\t\ty_reg_next = 2'b00;\n\t\t\t\t\tactive = 0;\n\t\t\t\tend\n\t\t\t\tf = 0;"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "Do not add comments to the code.\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n\treg [7:0] q_next;\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq_next <= 8'h34;\n\t\tend else begin\n\t\t\tq_next <= d;\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tq <= q_next;\n\tend\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "// Parity bit is just the XOR of all data bits\n  assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State transition logic\nalways @ (state, in) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (in == 1) begin\n\t\t\t\tnext_state = B;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tout = 0;\n\t\tend\n\t\tB: begin\n\t\t\tif (in == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\t\tout = 0;\n\t\tend\n\t\tC: begin\n\t\t\tif (in == 1) begin\n\t\t\t\tnext_state = D;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tout = 0;\n\t\tend\n\t\tD: begin\n\t\t\tif (in == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\t\tout = 1;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x & y) | (~x & ~y);\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // State encoding\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Output register\n    reg z_reg;\n\n    // State table\n    always @(*) begin\n        case(state)\n            A: begin\n                if(w) begin\n                    next_state = B;\n                end else begin\n                    next_state = A;\n                end\n            end\n            B: begin\n                if(w) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n            end\n            C: begin\n                if(w) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n            end\n            D: begin\n                if(w) begin\n                    next_state = F;\n                end else begin\n                    next_state = A;\n                end\n            end\n            E: begin\n                if(w) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n            end\n            F: begin\n                if(w) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n            end\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk) begin\n        if(reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output register update\n    always @(posedge clk) begin\n        if(reset) begin\n            z_reg <= 0;\n        end else begin\n            case(state)\n                A: z_reg <= 0;\n                B: z_reg <= 1;\n                C: z_reg <= 0;\n                D: z_reg <= 1;\n                E: z_reg <= 1;\n                F: z_reg <= 0;\n            endcase\n        end\n    end\n\n    // Output assignment\n    assign z = z_reg;\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\n\treg [15:0] q_temp;\n\t\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tq_temp <= 16'b0;\n\t\tend else begin\n\t\t\tif (byteena[1]) begin\n\t\t\t\tq_temp[15:8] <= d[15:8];\n\t\t\tend\n\t\t\tif (byteena[0]) begin\n\t\t\t\tq_temp[7:0] <= d[7:0];\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign q = q_temp;\n\t\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "// Registers to store the previous value of in\nreg [7:0] prev_in;\n\n// Detect positive edge transitions\nalways @(posedge clk) begin\n\tif (in != prev_in) begin\n\t\tpedge <= {1'b0, in} | {pedge[6:0], 1'b1};\n\tend\n\tprev_in <= in;\nend\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg a_delayed;\n    reg p_delayed;\n    reg q_delayed;\n\n    always @(posedge clock) begin\n        a_delayed <= a;\n        p_delayed <= p;\n        q_delayed <= q;\n    end\n\n    always @(posedge clock) begin\n        if (a_delayed == 1'b0) begin\n            p <= 1'bx;\n            q <= 1'bx;\n        end else if (a_delayed == 1'b1) begin\n            if (p_delayed == 1'b0) begin\n                p <= 1'b0;\n                q <= 1'b1;\n            end else if (q_delayed == 1'b0) begin\n                p <= 1'b1;\n                q <= 1'b0;\n            end else begin\n                p <= 1'b1;\n                q <= 1'b1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (i = 0; i < 512; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A == B) ? 1 : 0;\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both[0] = 0;\n\tassign out_both[1] = in[0] & in[1];\n\tassign out_both[2] = in[1] & in[2];\n\tassign out_both[3] = in[2] & in[3];\n\tassign out_both[4] = in[3] & in[4];\n\tassign out_both[5] = in[4] & in[5];\n\tassign out_both[6] = in[5] & in[6];\n\tassign out_both[7] = in[6] & in[7];\n\tassign out_both[8] = in[7] & in[8];\n\tassign out_both[9] = in[8] & in[9];\n\tassign out_both[10] = in[9] & in[10];\n\tassign out_both[11] = in[10] & in[11];\n\tassign out_both[12] = in[11] & in[12];\n\tassign out_both[13] = in[12] & in[13];\n\tassign out_both[14] = in[13] & in[14];\n\tassign out_both[15] = in[14] & in[15];\n\tassign out_both[16] = in[15] & in[16];\n\tassign out_both[17] = in[16] & in[17];\n\tassign out_both[18] = in[17] & in[18];\n\tassign out_both[19] = in[18] & in[19];\n\tassign out_both[20] = in[19] & in[20];\n\tassign out_both[21] = in[20] & in[21];\n\tassign out_both[22] = in[21] & in[22];\n\tassign out_both[23] = in[22] & in[23];\n\tassign out_both[24] = in[23] & in[24];\n\tassign out_both[25] = in[24] & in[25];\n\tassign out_both[26] = in[25] & in[26];\n\tassign out_both[27] = in[26] & in[27];\n\tassign out_both[28] = in[27] & in[28];\n\tassign out_both[29] = in[28] & in[29];\n\tassign out_both[30] = in[29] & in[30];\n\tassign out_both[31] = in[30] & in[31];\n\tassign out_both[32] = in[31] & in[32];\n\tassign out_both[33] = in[32] & in[33];\n\tassign out_both[34] = in[33] & in[34];\n\tassign out_both[35] = in[34] & in[35];\n\tassign out_both[36] = in[35] & in[36];\n\tassign out_both[37] = in[36] & in[37];\n\tassign out_both[38] = in[37] & in[38];\n\tassign out_both[39] = in[38] & in[39];\n\tassign out_both[40] = in[39] & in[40];\n\tassign out_both[41] = in[40] & in[41];\n\tassign out_both[42] = in[41] & in[42];\n\tassign out_both[43] = in[42] & in[43];\n\tassign out_both[44] = in[43] & in[44];\n\tassign out_both[45] ="}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge ena) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "and end with:\n```verilog\n\tassign out = in[3:0];\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "// 9-to-1 multiplexer\nalways @(*) begin\n\tcase(sel)\n\t\t4'b0000: out = a;\n\t\t4'b0001: out = b;\n\t\t4'b0010: out = c;\n\t\t4'b0011: out = d;\n\t\t4'b0100: out = e;\n\t\t4'b0101: out = f;\n\t\t4'b0110: out = g;\n\t\t4'b0111: out = h;\n\t\t4'b1000: out = i;\n\t\tdefault: out = 16'hffff;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "Then, add the Verilog code for the bitwise-OR, logical-OR, and NOT operations:\n```verilog\nassign out_or_bitwise = a | b;\nassign out_or_logical = (a != 0) || (b != 0);\nassign out_not[2:0] = ~a;\nassign out_not[5:3] = ~b;\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\nalways @ (state or in) begin\n    case (state)\n        4'b0001: begin // state A\n            if (in == 0) begin\n                next_state = 4'b0001;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b0010;\n                out = 1'b0;\n            end\n        end\n        4'b0010: begin // state B\n            if (in == 0) begin\n                next_state = 4'b0001;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b0100;\n                out = 1'b0;\n            end\n        end\n        4'b0100: begin // state C\n            if (in == 0) begin\n                next_state = 4'b0001;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b1000;\n                out = 1'b1;\n            end\n        end\n        4'b1000: begin // state D\n            if (in == 0) begin\n                next_state = 4'b0100;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b0010;\n                out = 1'b1;\n            end\n        end\n        default: begin // default case\n            next_state = 4'bxxxx;\n            out = 1'b0;\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tif (a < b && a < c && a < d)\n\t\tmin = a;\n\telse if (b < a && b < c && b < d)\n\t\tmin = b;\n\telse if (c < a && c < b && c < d)\n\t\tmin = c;\n\telse\n\t\tmin = d;\nend\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "Follow the coding conventions and style guidelines to improve readability and maintainability of the Verilog code.\n\nmodule top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n\twire abcd;\n\n\tassign abcd = {a, b, c, d};\n\n\tassign out = (abcd == 4'b0000) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0001) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0011) ? 1'b0 :\n\t\t\t\t(abcd == 4'b0110) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1110) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1111) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0111) ? 1'b0 :\n\t\t\t\t(abcd == 4'b0100) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0010) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1011) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1000) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1001) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1010) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0011) ? 1'b0 :\n\t\t\t\t(abcd == 4'b0100) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0110) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1111) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1100) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1101) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1110) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0110) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0010) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1010) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0111) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1001) ? 1'b0 :\n\t\t\t\t(abcd == 4'b0010) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0100) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1110) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0111) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1000) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1100) ? 1'b1 :\n\t\t\t\t(abcd == 4'b1101) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1011) ? 1'b0 :\n\t\t\t\t(abcd == 4'b0001) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0011) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1001) ? 1'b0 :\n\t\t\t\t(abcd == 4'b1111) ? 1'b1 :\n\t\t\t\t(abcd == 4'b0010"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "**DO not** use the state encoding approach. Instead, use the transition encoding approach. The main advantage of the transition encoding approach is that it is easier to understand the behavior of the FSM.\n\n```verilog\n// State encoding approach\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\nreg [1:0] state;\nreg [2:0] w_history;\nreg [1:0] w_count;\n\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= A;\n\t\tw_history <= 0;\n\t\tw_count <= 0;\n\t\tz <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (w_history == 2'b10) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else if (w_history == 2'b01) begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (w_count == 2) begin\n\t\t\t\t\tz <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tz <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= B;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (w_count == 2) begin\n\t\t\t\t\tz <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tz <= 0;\n\t\t\t\tend\n\t\t\t\tstate <= B;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tw_history <= 0;\n\t\tw_count <= 0;\n\tend else begin\n\t\tw_history <= {w_history[1:0], w};\n\t\tw_count <= (w_history == 2'b10) ? w_count + 1 : 0;\n\tend\nend\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    wire sign_bit = in[7];\n\n    assign out = {24{sign_bit}} & in;\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] reg_data;\n    wire [3:0] q;\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            reg_data <= 4'b0;\n        end else begin\n            reg_data <= {reg_data[2:0], in};\n        end\n    end\n\n    assign q = reg_data;\n\n    assign out = q[0];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tcase(in)\n\t\t4'b0000: pos = 2'b00;\n\t\t4'b0001: pos = 2'b01;\n\t\t4'b0010: pos = 2'b01;\n\t\t4'b0011: pos = 2'b10;\n\t\t4'b0100: pos = 2'b01;\n\t\t4'b0101: pos = 2'b10;\n\t\t4'b0110: pos = 2'b10;\n\t\t4'b0111: pos = 2'b11;\n\t\t4'b1000: pos = 2'b01;\n\t\t4'b1001: pos = 2'b10;\n\t\t4'b1010: pos = 2'b10;\n\t\t4'b1011: pos = 2'b11;\n\t\t4'b1100: pos = 2'b10;\n\t\t4'b1101: pos = 2'b11;\n\t\t4'b1110: pos = 2'b11;\n\t\t4'b1111: pos = 2'b00;\n\t\tdefault: pos = 2'b00;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "// State encoding\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// State register and next state logic\nreg [1:0] state, next_state;\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= OFF;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// Output logic\nassign out = (state == ON);\n\n// Next state logic\nalways @(*) begin\n\tcase (state)\n\t\tOFF: begin\n\t\t\tif (j) begin\n\t\t\t\tnext_state = ON;\n\t\t\tend else begin\n\t\t\t\tnext_state = OFF;\n\t\t\tend\n\t\tend\n\t\tON: begin\n\t\t\tif (k) begin\n\t\t\t\tnext_state = OFF;\n\t\t\tend else begin\n\t\t\t\tnext_state = ON;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    assign out = 0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "endmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "// Verilog code to implement the circuit\n\n```verilog\nreg d;\n\nalways @(posedge clk) begin\n\td <= in ^ d;\nend\n\nassign out = d;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q);\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            q <= 4'b0;\n        end else begin\n            if (load) begin\n                q <= data;\n            end else if (ena) begin\n                q <= {q[2:0], 1'b0};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "endmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "reg [7:0] q_reg;\n\t\t\n\t\talways @(posedge clk) begin\n\t\t\tif(areset) begin\n\t\t\t\tq_reg <= 8'b0;\n\t\t\tend else begin\n\t\t\t\tq_reg <= d;\n\t\t\tend\n\t\tend\n\t\t\n\t\tassign q = q_reg;\n\t\t\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // 100-input AND gate\n    assign out_and = &in;\n\n    // 100-input OR gate\n    assign out_or = |in;\n\n    // 100-input XOR gate\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    // Declare wires\n    wire w1, w2;\n\n    // XOR gate\n    xor(w1, a, b);\n\n    // AND gate\n    and(w2, a, b);\n\n    // OR gate\n    or(cout, w2, w1);\n\n    // XOR gate\n    xor(sum, w1, 1'b0);\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n//     input cpu_overheated,\n//     output reg shut_off_computer,\n//     input arrived,\n//     input gas_tank_empty,\n//     output reg keep_driving\n// );\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// states\nlocalparam OFF = 2'b00;\nlocalparam ON = 2'b01;\n\n// outputs\nwire out_internal;\n\n// state register\nreg [1:0] state;\n\n// next state logic\nalways @ (posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= OFF;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// output logic\nassign out_internal = (state == ON);\nassign out = out_internal;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    wire [4:0] ab;\n    wire [4:0] cd;\n    wire [4:0] ef;\n    wire [7:0] abcd;\n    wire [7:0] ef;\n\n    assign ab = {a, b};\n    assign cd = {c, d};\n    assign ef = {e, f};\n    assign abcd = {ab, cd};\n    assign x = abcd[7:1];\n    assign y = abcd[7:1];\n    assign z = ef;\n    assign w = {abcd, 2'b1};\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (a & b & c & ~d) | (a & b & ~c & d) | (a & ~b & c & d) | (~a & b & c & d) | (~a & b & ~c & d) | (~a & ~b & c & d) | (~a & ~b & ~c & d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "Do not introduce any unnecessary code, variables, or comments.\n\n// Moore state machine with two states, one input, and one output\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\n\n// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// State register\nreg [1:0] state = B;\n\n// Output register\nreg out_reg = 1'b1;\n\n// State transition logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= B;\n\tend else begin\n\t\tcase (state)\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nalways @(state, in) begin\n\tcase (state)\n\t\tB: begin\n\t\t\tout_reg = 1'b1;\n\t\tend\n\t\tA: begin\n\t\t\tout_reg = 1'b0;\n\t\tend\n\tendcase\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "// XNOR\n\twire xnor_out;\n\txnor xnor_inst (\n\t\t.a(in1),\n\t\t.b(in2),\n\t\t.out(xnor_out)\n\t);\n\t\n\t// XOR\n\twire xor_out;\n\txor xor_inst (\n\t\t.a(xnor_out),\n\t\t.b(in3),\n\t\t.out(xor_out)\n\t);\n\t\n\tassign out = xor_out;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "and end with:\n```verilog\n\tassign mux_in = {c, d, c, d};\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// Mealy machine implementation of 2's complementer\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\n// One-hot encoding\n// A: (0, 1, 0, 0)\n// B: (0, 0, 1, 0)\n// C: (0, 0, 0, 1)\n// D: (0, 0, 0, 0)\n// Reset: (0, 0, 0, 0)\n\n// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register\nreg [1:0] state, next_state;\n\n// Output register\nreg z_reg;\n\n// Combinational logic\nassign z = z_reg;\n\n// State transition and output logic\nalways @(posedge clk, posedge areset) begin\n\tif (areset) begin\n\t\tstate <= A;\n\t\tz_reg <= 1'b0;\n\tend else begin\n\t\tstate <= next_state;\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tnext_state <= B;\n\t\t\t\t\tz_reg <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= A;\n\t\t\t\t\tz_reg <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tnext_state <= B;\n\t\t\t\t\tz_reg <= 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state <= B;\n\t\t\t\t\tz_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg q_reg;\n    reg [1:0] state_reg;\n\n    always @(posedge clk) begin\n        case (state_reg)\n            2'b00: begin\n                q_reg <= a;\n                state_reg <= 2'b01;\n            end\n            2'b01: begin\n                q_reg <= b;\n                state_reg <= 2'b10;\n            end\n            2'b10: begin\n                q_reg <= ~q_reg;\n                state_reg <= 2'b00;\n            end\n            2'b11: begin\n                q_reg <= 1'b0;\n                state_reg <= 2'b00;\n            end\n        endcase\n    end\n\n    assign q = q_reg;\n    assign state = state_reg;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\nalways @(*) begin\n    case (x)\n        4'b0000: f = 1'b0;\n        4'b0001: f = 1'b1;\n        4'b0010: f = 1'b0;\n        4'b0011: f = 1'b1;\n        4'b0100: f = 1'b1;\n        4'b0101: f = 1'b0;\n        4'b0110: f = 1'b1;\n        4'b0111: f = 1'b1;\n        4'b1000: f = 1'b1;\n        4'b1001: f = 1'b1;\n        4'b1010: f = 1'b0;\n        4'b1011: f = 1'b1;\n        4'b1100: f = 1'b1;\n        4'b1101: f = 1'b1;\n        4'b1110: f = 1'b1;\n        4'b1111: f = 1'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "// Define states\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\n\t// Define outputs\n\treg disc;\n\treg flag;\n\treg err;\n\n\t// Define state and next state registers\n\treg [1:0] state_reg, next_state;\n\n\t// Define input register\n\treg in_reg;\n\n\t// Define shift register\n\treg [5:0] shift_reg;\n\n\t// Define state machine\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate_reg <= S0;\n\t\t\tin_reg <= 0;\n\t\t\tshift_reg <= 0;\n\t\t\tdisc <= 0;\n\t\t\tflag <= 0;\n\t\t\terr <= 0;\n\t\tend else begin\n\t\t\tstate_reg <= next_state;\n\t\t\tin_reg <= in;\n\t\t\tshift_reg <= {shift_reg[4:0], in};\n\t\tend\n\tend\n\n\t// Define next state logic\n\talways @(*) begin\n\t\tcase (state_reg)\n\t\t\tS0: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tend else if (in == 1'b1) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S2;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tdisc <= 1;\n\t\t\t\tend else if (in == 1'b1) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S2;\n\t\t\t\t\tflag <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tdisc <= 0;\n\t\t\t\tend else if (in == 1'b1) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S2;\n\t\t\t\t\tflag <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tdisc <= 0;\n\t\t\t\tend else if (in == 1'b1) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S3;\n\t\t\t\t\terr <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "// State encoding:\n// 000: s[1] not asserted, all 4 outputs asserted\n// 001: s[1] asserted, all 4 outputs deasserted\n// 010: s[1], s[2] asserted, fr1 asserted\n// 011: s[1], s[2] asserted, fr1, fr2 asserted\n// 100: s[1], s[2], s[3] asserted, fr1, fr2, fr3 asserted\n// 101: s[1], s[2], s[3] asserted, fr1, fr2, fr3 deasserted\n// 110: s[1], s[2], s[3] asserted, fr1, fr2 deasserted, fr3 asserted\n// 111: s[1], s[2], s[3] asserted, fr1, fr2, fr3 deasserted\n\n// State transition logic:\nreg [3:0] state;\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= 4'b0000;\n\tend else if (s[1] == 1'b0) begin\n\t\tstate <= 4'b0000;\n\tend else if (s[3] == 1'b0) begin\n\t\tstate <= 4'b1000;\n\tend else if (s[2] == 1'b0) begin\n\t\tstate <= 4'b1100;\n\tend else if (s[1] == 1'b1 && s[2] == 1'b1) begin\n\t\tif (s[3] == 1'b1) begin\n\t\t\tstate <= 4'b1000;\n\t\tend else begin\n\t\t\tstate <= 4'b0100;\n\t\tend\n\tend else if (s[1] == 1'b1 && s[2] == 1'b0) begin\n\t\tstate <= 4'b0010;\n\tend else if (s[1] == 1'b0 && s[2] == 1'b1) begin\n\t\tstate <= 4'b1100;\n\tend else begin\n\t\tstate <= 4'b0000;\n\tend\nend\n\n// Output logic:\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr <= 1'b0;\n\tend else begin\n\t\tcase (state)\n\t\t\t4'b0000: begin\n\t\t\t\tfr3 <= 1'b0;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b0;\n\t\t\tend\n\t\t\t4'b0010: begin\n\t\t\t\tfr3 <= 1'b0;\n\t\t\t\tfr2 <= 1'b0;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend\n\t\t\t4'b0100: begin\n\t\t\t\tfr3 <= 1'b0;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend\n\t\t\t4'b1000: begin\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b1;\n\t\t\t\tdfr <= 1'b1;\n\t\t\tend\n\t\t\t4'b1100: begin\n\t\t\t\tfr3 <= 1'b1;\n\t\t\t\tfr2 <= 1'b1;\n\t\t\t\tfr1 <= 1'b0;\n\t\t\t\tdfr <= 1'b1;"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "// State enumeration\n`define IDLE \t\t\t2'b00\n`define START \t\t\t2'b01\n`define DATA \t\t\t2'b10\n`define STOP \t\t\t2'b11\n\n// State register\nreg [1:0] state_reg, state_next;\n\n// Data register\nreg [7:0] data_reg;\n\n// Counter for data bits\nreg [2:0] data_count;\n\n// Start and stop bits\nreg start_bit, stop_bit;\n\n// Done signal\nreg done_reg;\n\n// Assignments\nassign done = done_reg;\n\n// FSM logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate_reg <= `IDLE;\n\t\tdata_count <= 0;\n\t\tdata_reg <= 0;\n\t\tstart_bit <= 0;\n\t\tstop_bit <= 1;\n\t\tdone_reg <= 0;\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\t\tdata_count <= 0;\n\t\tdata_reg <= 0;\n\t\tstart_bit <= 0;\n\t\tstop_bit <= 1;\n\t\tdone_reg <= 0;\n\tend\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (state_reg)\n\t\t`IDLE: begin\n\t\t\tif (in == 0) begin\n\t\t\t\tstate_next = `START;\n\t\t\t\tstart_bit = 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = `IDLE;\n\t\t\tend\n\t\tend\n\t\t`START: begin\n\t\t\tif (in == 1) begin\n\t\t\t\tstate_next = `DATA;\n\t\t\t\tdata_count <= 0;\n\t\t\t\tdata_reg <= 0;\n\t\t\t\tstop_bit <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = `START;\n\t\t\tend\n\t\tend\n\t\t`DATA: begin\n\t\t\tif (data_count == 7) begin\n\t\t\t\tif (in == 1) begin\n\t\t\t\t\tstate_next = `STOP;\n\t\t\t\t\tstop_bit <= 1;\n\t\t\t\t\tdata_reg <= {data_reg[6:0], in};\n\t\t\t\t\tdone_reg <= 1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = `DATA;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tdata_count <= data_count + 1;\n\t\t\t\tdata_reg <= {data_reg[6:0], in};\n\t\t\t\tstate_next = `DATA;\n\t\t\tend\n\t\tend\n\t\t`STOP: begin\n\t\t\tif (in == 1) begin\n\t\t\t\tstate_next = `IDLE;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = `STOP;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module (\n    input clk,\n    input in,\n    input reset,\n    output [7:0] out_byte,\n    output done\n);\n\n    // Define states\n    parameter IDLE = 2'b00;\n    parameter START_BIT = 2'b01;\n    parameter DATA_BITS = 2'b10;\n    parameter STOP_BIT = 2'b11;\n\n    // Define registers\n    reg [1:0] state_reg;\n    reg [7:0] data_reg;\n\n    // Define wires\n    wire start_bit = in & ~reset;\n    wire stop_bit = in & ~start_bit & ~reset;\n\n    // Define combinational logic\n    assign done = state_reg == STOP_BIT;\n    assign out_byte = data_reg;\n\n    // Define sequential logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state_reg <= IDLE;\n            data_reg <= 8'b0;\n        end else begin\n            case (state_reg)\n                IDLE: begin\n                    if (start_bit) begin\n                        state_reg <= START_BIT;\n                        data_reg <= 8'b0;\n                    end\n                end\n                START_BIT: begin\n                    if (in) begin\n                        state_reg <= IDLE;\n                    end else begin\n                        state_reg <= DATA_BITS;\n                        data_reg <= {1'b0, in};\n                    end\n                end\n                DATA_BITS: begin\n                    if (in) begin\n                        state_reg <= IDLE;\n                    end else begin\n                        state_reg <= DATA_BITS;\n                        data_reg <= {data_reg[6:0], in};\n                    end\n                end\n                STOP_BIT: begin\n                    if (stop_bit) begin\n                        state_reg <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "Module code:\n```verilog\nmodule top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n\t// Declare internal signals and registers\n\treg [6:0] history_reg;\n\treg [6:0] pht [0:127];\n\twire [6:0] pht_index;\n\twire [1:0] pht_count;\n\treg [1:0] pht_saturation[0:127];\n\treg [1:0] pht_reset;\n\twire [1:0] pht_output;\n\n\t// Compute the PHT index from the history register\n\tassign pht_index = {history_reg[6], history_reg[5:0]};\n\n\t// Saturate the PHT counters\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tpht_reset <= 2'b00;\n\t\t\tpht_saturation <= 128'b0;\n\t\tend else begin\n\t\t\tif (pht_count[1] == 2'b11) begin\n\t\t\t\tpht_saturation[pht_index] <= 2'b11;\n\t\t\tend else if (pht_count[1] == 2'b10) begin\n\t\t\t\tpht_saturation[pht_index] <= 2'b10;\n\t\t\t\tpht_reset[pht_index] <= 2'b01;\n\t\t\tend else if (pht_count[1] == 2'b01) begin\n\t\t\t\tpht_saturation[pht_index] <= 2'b01;\n\t\t\t\tpht_reset[pht_index] <= 2'b10;\n\t\t\tend else begin\n\t\t\t\tpht_saturation[pht_index] <= 2'b00;\n\t\t\t\tpht_reset[pht_index] <= 2'b11;\n\t\t\tend\n\t\tend\n\tend\n\n\t// Compute the PHT output\n\tassign pht_output = (pht_saturation[pht_index] == 2'b11) ? 2'b11 : (pht_reset[pht_index] == 2'b10) ? 2'b10 : (pht_reset[pht_index] == 2'b01) ? 2'b01 : 2'b00;\n\n\t// Compute the PHT count\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tpht_count <= 2'b00;\n\t\tend else begin\n\t\t\tif (predict_valid) begin\n\t\t\t\tif (predict_taken) begin\n\t\t\t\t\tpht_count <= pht_count + 2'b01;\n\t\t\t\tend else begin\n\t\t\t\t\tpht_count <= pht_count - 2'b01;\n\t\t\t\tend\n\t\t\tend else if (train_valid) begin\n\t\t\t\tif (train_taken) begin\n\t\t\t\t\tpht_count <= pht_count + 2'b01;\n\t\t\t\tend else begin\n\t\t\t\t\tpht_count <= pht_count - 2'b01;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\t// Compute the PHT output for the prediction interface\n\tassign predict_history = {history_reg[5:0], pht_output[1]};\n\tassign predict_taken = (pht_output[1] == 1'b1);\n\n\t// Compute the PHT output for the training interface\n\tassign"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter digging_state = 2'b10;\n\tparameter splatter_state = 2'b11;\n\n\t// Define the outputs\n\treg walk_left;\n\treg walk_right;\n\treg aaah;\n\treg digging;\n\n\t// Define the state and next state variables\n\treg [1:0] state, next_state;\n\n\t// Define the state machine\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left_state;\n\t\t\twalk_left <= 1;\n\t\t\twalk_right <= 0;\n\t\t\taaah <= 0;\n\t\t\tdigging <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\twalk_left <= 1;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tnext_state <= walk_right_state;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tnext_state <= digging_state;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tnext_state <= falling_state;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= walk_left_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 1;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tnext_state <= walk_left_state;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tnext_state <= digging_state;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tnext_state <= falling_state;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= walk_right_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdigging_state: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 1;\n\t\t\t\t\tif (!ground) begin\n\t\t\t\t\t\tnext_state <= falling_state;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= digging_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tsplatter_state: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 1;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\t\tnext_state <= splatter_state;\n\t\t\t\tend\n\t\t\t\tfalling_state: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\t\tif (ground) begin\n\t\t\t\t\t\tnext_state <= state;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state <= falling_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "// The two state variables are the current walking direction and whether the Lemming is falling or not.\n// The two output variables are the walking direction and the aaah! signal.\n// The two input variables are the bump signals.\n// The two control signals are the dig signal and the ground signal.\n// The two state variables and the two control signals are the only inputs to the Moore state machine.\n// The three output variables are the walking direction, the aaah! signal and the digging signal.\n// The state machine is in the form of a Moore machine with the state variable being the current walking direction.\n// The state transitions and the next state are specified by the state_next variable, which is a function of the current state and the input variables.\n// The output of the Moore machine is specified by the output_next variable, which is a function of the current state and the input variables.\n// The initial state is the walking left state.\n// The Moore machine state transition and output are specified by the state_next and output_next functions.\n// The state machine output is the walking direction and the aaah! signal.\n// The output of the Moore machine is the state_next and output_next functions.\n// The output is then combined with the dig and ground signals to generate the final output of the module.\n// The falling signal is an internal signal that is generated in the Moore machine and is not an input or output.\n// The falling signal is used to determine whether the Lemming is falling or not.\n// The dig signal is used to determine whether the Lemming is digging or not.\n// The walking direction is the output of the Moore machine.\n// The aaah! signal is the output of the Moore machine.\n// The digging signal is the output of the Moore machine.\n// The bump signals are used to determine whether the Lemming should switch directions or not.\n// The ground signal is used to determine whether the Lemming is falling or not.\n// The dig signal is used to determine whether the Lemming is digging or not.\n// The state machine does not reset, so the areset signal is not used.\n// The state machine is a Moore machine.\n// The state machine output is the walking direction and the aaah! signal.\n// The input variables are the bump signals, the dig signal and the ground signal.\n// The state machine is a 2-state Moore machine with the two states being walk_left and walk_right.\n// The output of the Moore machine is the walking direction and the aaah! signal.\n// The output of the Moore machine is combined with the dig and ground signals to generate the final output.\n// The falling signal is an internal signal that is used to determine whether the Lemming is falling or not.\n \n// The state machine output is the walking direction and the aaah! signal.\n// The output of the Moore machine is the state_next and output_next functions.\n// The state machine output is then used to generate the final output of the module.\n \n// The state machine output is combined with the dig and ground signals to generate the final output.\n// The final output is the walking direction, the aaah! signal and the digging signal.\n \n// The state machine output is the next state and the output of the Moore machine.\n \n// The state machine output is the next state, the walking direction and the aaah! signal.\n// The state machine output is then used to generate the final output of the module.\n \nmodule top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\treg [1:0] state, next_state;\n\treg falling;\n\twire walk;\n\n\t// State encoding\n\tlocalparam walk_left = 2'b00;\n\tlocalparam walk_right = 2'b01;\n\n\t// State transition and output\n\talways @(posedge clk) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left;\n\t\t\tnext_state <= walk_left;\n\t\t\twalk <= 1'b0;\n\t\t\tfalling <= 1'b0;\n\t\t\taaah <= 1'b0;\n\t\t\tdigging <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\t\twalk <= walk_left;\n\t\t\tfall"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss);\n\n    // BCD counter for hours\n    reg [3:0] hours_bcd;\n    always @(posedge clk) begin\n        if (reset) begin\n            hours_bcd <= 4'b0000;\n        end else if (ena) begin\n            if (hours_bcd == 4'b1111) begin\n                hours_bcd <= 4'b0000;\n            end else if (hours_bcd == 4'b0001) begin\n                hours_bcd <= 4'b0010;\n            end else begin\n                hours_bcd <= hours_bcd + 1;\n            end\n        end\n    end\n\n    // BCD counter for minutes\n    reg [3:0] minutes_bcd;\n    always @(posedge clk) begin\n        if (reset) begin\n            minutes_bcd <= 4'b0000;\n        end else if (ena) begin\n            if (minutes_bcd == 4'b1111) begin\n                minutes_bcd <= 4'b0000;\n            end else if (minutes_bcd == 4'b0001) begin\n                minutes_bcd <= 4'b0010;\n            end else begin\n                minutes_bcd <= minutes_bcd + 1;\n            end\n        end\n    end\n\n    // BCD counter for seconds\n    reg [3:0] seconds_bcd;\n    always @(posedge clk) begin\n        if (reset) begin\n            seconds_bcd <= 4'b0000;\n        end else if (ena) begin\n            if (seconds_bcd == 4'b1111) begin\n                seconds_bcd <= 4'b0000;\n            end else if (seconds_bcd == 4'b0001) begin\n                seconds_bcd <= 4'b0010;\n            end else begin\n                seconds_bcd <= seconds_bcd + 1;\n            end\n        end\n    end\n\n    // PM indicator\n    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 1'b0;\n        end else if (ena) begin\n            if (hours_bcd == 4'b1111) begin\n                if (minutes_bcd[3] == 1'b1) begin\n                    pm <= 1'b1;\n                end else begin\n                    pm <= 1'b0;\n                end\n            end\n        end\n    end\n\n    // Output BCD digits\n    always @(posedge clk) begin\n        if (reset) begin\n            hh <= 8'b00000000;\n            mm <= 8'b00000000;\n            ss <= 8'b00000000;\n        end else if (ena) begin\n            hh <= {1'b0, hours_bcd};\n            mm <= {1'b0, minutes_bcd};\n            ss <= {1'b0, seconds_bcd};\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "Modules:\n```verilog\nmodule top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\n\tparameter [1:0] initial_state = 2'b00;\n\tparameter [1:0] state_walk_left = 2'b01;\n\tparameter [1:0] state_walk_right = 2'b10;\n\tparameter [1:0] state_falling = 2'b11;\n\n\treg [1:0] current_state;\n\treg [1:0] next_state;\n\treg walk_left_internal;\n\treg walk_right_internal;\n\treg aaah_internal;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= initial_state;\n\t\t\twalk_left_internal <= 1'b0;\n\t\t\twalk_right_internal <= 1'b0;\n\t\t\taaah_internal <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcurrent_state <= next_state;\n\t\t\twalk_left_internal <= walk_left;\n\t\t\twalk_right_internal <= walk_right;\n\t\t\taaah_internal <= aaah;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tinitial_state: begin\n\t\t\t\tnext_state = state_walk_left;\n\t\t\t\twalk_left = 1'b1;\n\t\t\t\twalk_right = 1'b0;\n\t\t\t\taaah = 1'b0;\n\t\t\tend\n\t\t\tstate_walk_left: begin\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = state_walk_right;\n\t\t\t\t\twalk_left = 1'b0;\n\t\t\t\t\twalk_right = 1'b1;\n\t\t\t\t\taaah = 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (ground == 1'b0) begin\n\t\t\t\t\tnext_state = state_falling;\n\t\t\t\t\twalk_left = 1'b0;\n\t\t\t\t\twalk_right = 1'b0;\n\t\t\t\t\taaah = 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = state_walk_left;\n\t\t\t\t\twalk_left = 1'b1;\n\t\t\t\t\twalk_right = 1'b0;\n\t\t\t\t\taaah = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tstate_walk_right: begin\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tnext_state = state_walk_left;\n\t\t\t\t\twalk_left = 1'b1;\n\t\t\t\t\twalk_right = 1'b0;\n\t\t\t\t\taaah = 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (ground == 1'b0) begin\n\t\t\t\t\tnext_state = state_falling;\n\t\t\t\t\twalk_left = 1'b0;\n\t\t\t\t\twalk_right = 1'b0;\n\t\t\t\t\taaah = 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = state_walk_right;\n\t\t\t\t\twalk_left = 1'b0;\n\t\t\t\t\twalk_right = 1'b1;\n\t\t\t\t\taaah = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tstate_falling: begin\n\t\t\t\tif (ground == 1'b1) begin\n\t\t\t\t\tnext_state = state_walk_left;\n\t\t\t\t\twalk_left = walk_left_internal;"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    reg [3:0] ones, tens, hundreds, thousands;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;\n            ones <= 0;\n            tens <= 0;\n            hundreds <= 0;\n            thousands <= 0;\n        end\n        else begin\n            if (thousands == 9) begin\n                thousands <= 0;\n                if (hundreds == 9) begin\n                    hundreds <= 0;\n                    if (tens == 9) begin\n                        tens <= 0;\n                        if (ones == 9) begin\n                            ones <= 0;\n                        end\n                        else begin\n                            ones <= ones + 1;\n                        end\n                    end\n                    else begin\n                        tens <= tens + 1;\n                    end\n                end\n                else begin\n                    hundreds <= hundreds + 1;\n                end\n            end\n            else begin\n                thousands <= thousands + 1;\n            end\n        end\n    end\n\n    assign ena = {1'b0, 1'b0, 1'b0, (thousands == 9)};\n    assign q = {thousands, hundreds, tens, ones};\n\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n    assign out = sel ? b : a;\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "// The next-state logic for y[2]\n\talways @ (y, w) begin\n\t\tcase (y)\n\t\t\t3'b000: Y2 <= w ? 1'b1 : 1'b0; // A --> B\n\t\t\t3'b001: Y2 <= 1'b0; // A --> A\n\t\t\t3'b010: Y2 <= w ? 1'b1 : 1'b0; // B --> C\n\t\t\t3'b011: Y2 <= 1'b1; // B --> D\n\t\t\t3'b100: Y2 <= w ? 1'b1 : 1'b0; // C --> E\n\t\t\t3'b101: Y2 <= w ? 1'b1 : 1'b0; // C --> D\n\t\t\t3'b110: Y2 <= 1'b0; // D --> A\n\t\t\t3'b111: Y2 <= 1'b1; // D --> E\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "// AND gate using assign statement\n\tassign out_assign = a & b;\n\t\n\t// AND gate using combinational always block\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero);\n    \n    assign zero = 0;\n    \nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\nreg q1, q2, q3, q4, q5, q6, q7, q8, q9;\n\nalways @(posedge clk) begin\n    q1 <= a;\n    q2 <= q1;\n    q3 <= q2;\n    q4 <= q3;\n    q5 <= q4;\n    q6 <= q5;\n    q7 <= q6;\n    q8 <= q7;\n    q9 <= q8;\n    q <= q9;\nend\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "endmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Define the states\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\t\n\t// Define the state register and initialize to state A\n\treg [1:0] state = A;\n\t\n\t// Define the output register and initialize to 0\n\treg out_reg = 1'b0;\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= A;\n\t\t\tout_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= D;\n\t\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\tassign out = out_reg;\n\t\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "// Reverse byte order of a 32-bit vector\n// Split the input into 4 8-bit chunks\n// Reverse the order of the chunks\n// Concatenate the reversed chunks to form the output\n\n\treg [7:0] chunk [0:3];\n\treg [31:0] reversed;\n\tinteger i;\n\n\talways @(*) begin\n\t\tfor (i = 0; i < 4; i = i + 1) begin\n\t\t\tchunk[i] = in[i*8 +: 8];\n\t\tend\n\t\tfor (i = 0; i < 4; i = i + 1) begin\n\t\t\tif (i == 0) begin\n\t\t\t\treversed[i*8 +: 8] = chunk[i];\n\t\t\tend else begin\n\t\t\t\treversed[(i-1)*8 +: 8] = chunk[i];\n\t\t\tend\n\t\tend\n\tend\n\n\tassign out = reversed;\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        if (r == 1'b1) begin\n            q_reg <= 1'b0;\n        end else begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "// XOR operation\n  assign temp1 = x ^ y;\n  \n  // AND operation\n  assign temp2 = temp1 & x;\n  \n  // Output\n  assign z = temp2;\n  \nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};\n                2'b01: q <= {q[55:0], 8'b0};\n                2'b10: q <= {1'b0, q[63:1]};\n                2'b11: q <= {8'b0, q[63:8]};\n                default: q <= q;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\n\t// Define the states\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\n\t// Define the outputs\n\toutput reg z_A;\n\toutput reg z_B;\n\toutput reg z_C;\n\toutput reg z_D;\n\toutput reg z_E;\n\toutput reg z_F;\n\n\t// Define the state register and next state logic\n\treg [1:0] state;\n\talways @ (posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tstate <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= D;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= E;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// Define the output logic\n\talways @ (state) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tz_A = 1'b1;\n\t\t\t\tz_B = 1'b0;\n\t\t\t\tz_C = 1'b0;\n\t\t\t\tz_D = 1'b0;\n\t\t\t\tz_E = 1'b0;\n\t\t\t\tz_F = 1'b0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tz_A = 1'b0;\n\t\t\t\tz_B = 1'b1;\n\t\t\t\tz_C = 1'b0;\n\t\t\t\tz_D = 1'b0;\n\t\t\t\tz_E = 1'b0;\n\t\t\t\tz_F = 1'b0;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tz_A = 1'b0;\n\t\t\t\tz_B = 1'b0;\n\t\t\t\tz_C = 1'b1;\n\t\t\t\tz_D = 1'b0;\n\t\t\t\tz_E = 1'b0;\n\t\t\t\tz_F = 1'b0;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tz_A = 1'b0;\n\t\t\t\tz_B = 1'b0;\n\t\t\t\tz_C = 1'b0;\n\t\t\t\tz_D = 1'b1;\n\t\t\t\tz_E = 1'b0;\n\t\t\t\tz_F = 1'b0;\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tz_A = 1'b0;\n\t\t\t\tz_B = 1'b0;\n\t\t\t\tz_C = 1'b0;\n\t\t\t\tz_D = 1'b0;\n\t\t\t\tz_E = 1'b1;\n\t\t\t\tz_F = 1'b0;\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tz_A = 1'b0"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n    // FSM states\n    parameter STATE_IDLE = 2'b00;\n    parameter STATE_WAIT_FOR_FIRST_BYTE = 2'b01;\n    parameter STATE_WAIT_FOR_SECOND_BYTE = 2'b10;\n    parameter STATE_WAIT_FOR_THIRD_BYTE = 2'b11;\n\n    // FSM signals\n    reg [1:0] state;\n    reg [7:0] byte_counter;\n    reg [7:0] byte_0;\n    reg [7:0] byte_1;\n    reg [7:0] byte_2;\n    reg done;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= STATE_IDLE;\n            byte_counter <= 0;\n            byte_0 <= 0;\n            byte_1 <= 0;\n            byte_2 <= 0;\n            done <= 0;\n        end\n        else begin\n            case (state)\n                STATE_IDLE: begin\n                    if (in[3] == 1) begin\n                        state <= STATE_WAIT_FOR_FIRST_BYTE;\n                        byte_counter <= 0;\n                    end\n                end\n                STATE_WAIT_FOR_FIRST_BYTE: begin\n                    if (byte_counter < 8) begin\n                        byte_0 <= {byte_0[6:0], in[7]};\n                        byte_counter <= byte_counter + 1;\n                    end\n                    else begin\n                        state <= STATE_WAIT_FOR_SECOND_BYTE;\n                        byte_counter <= 0;\n                    end\n                end\n                STATE_WAIT_FOR_SECOND_BYTE: begin\n                    if (byte_counter < 8) begin\n                        byte_1 <= {byte_1[6:0], in[7]};\n                        byte_counter <= byte_counter + 1;\n                    end\n                    else begin\n                        state <= STATE_WAIT_FOR_THIRD_BYTE;\n                        byte_counter <= 0;\n                    end\n                end\n                STATE_WAIT_FOR_THIRD_BYTE: begin\n                    if (byte_counter < 8) begin\n                        byte_2 <= {byte_2[6:0], in[7]};\n                        byte_counter <= byte_counter + 1;\n                    end\n                    else begin\n                        done <= 1;\n                        state <= STATE_IDLE;\n                        byte_counter <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out_bytes = {byte_2, byte_1, byte_0};\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "// State transition table:\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | A | B | C | D | E | F |   w   | y[0] | y[1] | y[2] | y[3] | y[4] | y[5] |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 0 | 0 | 0 | 0 | 0 | 0 | 1     | 0    | 0    | 0    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 0 | 0 | 0 | 1 | 0 | 1 | 1     | 0    | 0    | 0    | 1    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 0 | 1 | 1 | 0 | 1 | 0 | 0     | 0    | 1    | 1    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 0 | 0 | 0 | 0 | 1 | 0 | 0     | 1    | 0    | 0    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 1 | 0 | 0 | 1 | 0 | 1 | 0     | 0    | 0    | 0    | 1    | 1    | 1    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 1 | 0 | 1 | 0 | 0 | 0 | 0     | 0    | 0    | 0    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 1 | 1 | 0 | 0 | 0 | 0 | 0     | 0    | 1    | 1    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 1 | 1 | 1 | 0 | 0 | 0 | 0     | 1    | 0    | 0    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 1 | 1 | 1 | 1 | 1 | 1 | 0     | 0    | 0    | 0    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// | 1 | 1 | 0 | 0 | 0 | 0 | 0     | 0    | 0    | 0    | 0    | 0    | 0    |\n// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+ 6 rows\n// | 1 | 1 | 0 | 1 | 1 | 0 | 0     | 0    | 0    | 0    | 0    | 0    | 0    |\n// +---+---"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "Complete the Verilog code below:\n```verilog\n\tassign outv = vec;\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0];\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "// Karnaugh map\n//   abcd\n//   0000 0001 0011 0010\n//   0100 0101 0110 0111\n//   1000 1001 1010 1011\n//   1100 1101 1110 1111\n\n// Verilog code\nalways @(*) begin\n\tcase ({a,b,c,d})\n\t\t4'b0000: out = 1'b0;\n\t\t4'b0001: out = 1'b1;\n\t\t4'b0011: out = 1'b0;\n\t\t4'b0010: out = 1'b1;\n\t\t4'b0100: out = 1'b1;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0110: out = 1'b1;\n\t\t4'b0111: out = 1'b0;\n\t\t4'b1000: out = 1'b1;\n\t\t4'b1001: out = 1'b0;\n\t\t4'b1010: out = 1'b1;\n\t\t4'b1011: out = 1'b0;\n\t\t4'b1100: out = 1'b0;\n\t\t4'b1101: out = 1'b1;\n\t\t4'b1110: out = 1'b0;\n\t\t4'b1111: out = 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "assign out_hi = in[15:8];\n  assign out_lo = in[7:0];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n    assign out_assign = a ^ b;\n\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "// Next state logic for Y2\n\n`ifdef VERILATOR\n\tassign Y2 = w ? y[3] : y[1];\n`else\n\tassign Y2 = w ? y[3] : y[1];\n`endif\n\n// Next state logic for Y4\n\n`ifdef VERILATOR\n\tassign Y4 = w ? y[5] : y[4];\n`else\n\tassign Y4 = w ? y[5] : y[4];\n`endif\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "Remember to use meaningful names for your signals and modules, and to use the Verilog standard module names where possible.\nmodule top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\twire [7:0] sel_inv;\n\tassign sel_inv = ~sel;\n\n\twire [7:0] sel_inv_and_sel;\n\tassign sel_inv_and_sel = sel_inv & sel;\n\n\twire [7:0] sel_and_inv_sel;\n\tassign sel_and_inv_sel = sel & ~sel_inv;\n\n\twire [7:0] sel_and_inv_sel_inv;\n\tassign sel_and_inv_sel_inv = sel_and_inv_sel & ~sel_inv;\n\n\twire [7:0] sel_and_inv_sel_inv_inv;\n\tassign sel_and_inv_sel_inv_inv = ~sel_and_inv_sel_inv_inv;\n\n\twire [7:0] sel_and_inv_sel_inv_inv_and_sel;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_and_sel = sel_and_inv_sel_disp_inv_disp_inv_inv & sel;\n\n\twire [7:0] sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel = sel_and_inv_sel_disp_inv_disp_inv_inv_inv_and_sel;\n\n\twire [7:0] sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_inv;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_inv = sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_inv;\n\n\twire [7:0] sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_inv_inv;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_inv_inv = sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv;\n\n\twire [7:0] sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_inv_and_sel;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_inv_and_sel = sel_and_inv_sel_disp_inv_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_inv_and_sel;\n\n\twire [7:0] sel_and_inv_sel_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_inv_and_sel_inv_and_sel;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_and_sel_inv_and_sel = sel_and_inv_sel_disp_inv_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_and_sel_inv_and_sel;\n\n\twire [7:0] sel_and_inv_sel_disp_inv_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_and_sel_inv_and_sel;\n\tassign sel_and_inv_sel_disp_inv_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_inv_inv_and_sel_inv_and_sel = sel_and_inv_sel_disp_inv_disp_inv_disp_inv_inv_and_inv_sel_disp_inv_disp_"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module is an n-bit shift register circuit with one stage. The output Q is the value of the last stage of the shift register. Inputs R, E, L are used to load the shift register. The input w is the value to be loaded. The input clk is the clock signal.\n\nComplete the Verilog code below and return the complete module code.\n\nmodule top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (R) begin\n            Q <= w;\n        end else if (E) begin\n            if (L) begin\n                Q <= Q;\n            end else begin\n                Q <= {Q[n-2:0], w};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// D flip-flops\nreg dff1, dff2, dff3;\n\n// XOR gate\nxor xor1(dff1, x, dff1);\n\n// AND gate\nand and1(dff2, x, ~dff1);\n\n// OR gate\nor or1(dff3, x, ~dff1);\n\n// XNOR gate\nxnor xnor1(z, dff1, dff2, dff3);\n\n// Finite state machine\nreg [1:0] state;\nalways @(posedge clk) begin\n\tcase (state)\n\t\t2'b00: state <= 2'b01;\n\t\t2'b01: state <= 2'b10;\n\t\t2'b10: state <= 2'b00;\n\t\t2'b11: state <= 2'b00;\n\tendcase\nend\n\n// Output assignments\nassign dff1 = (state == 2'b00) ? 1'b0 : 1'b1;\nassign dff2 = (state == 2'b01) ? 1'b0 : 1'b1;\nassign dff3 = (state == 2'b10) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Clock generator\nreg clk_en;\ninitial begin\n\tclk_en = 0;\nend\nalways begin\n\tif (load) begin\n\t\tclk_en <= 1;\n\tend\nend\n\nreg [511:0] q_next;\nalways @(posedge clk) begin\n\tif (clk_en) begin\n\t\tq_next <= q;\n\t\tq <= q_next;\n\tend\nend\n\nalways @(*) begin\n\tq_next[0] = q[0] & q[1];\n\tq_next[1] = q[0] & q[2];\n\tq_next[2] = q[1] & q[2];\n\tq_next[3] = q[1] & q[3];\n\tq_next[4] = q[2] & q[3];\n\tq_next[5] = q[3] & q[4];\n\tq_next[6] = q[4] & q[5];\n\tq_next[7] = q[5] & q[6];\n\tq_next[8] = q[6] & q[7];\n\tq_next[9] = q[7] & q[8];\n\tq_next[10] = q[8] & q[9];\n\tq_next[11] = q[9] & q[10];\n\tq_next[12] = q[10] & q[11];\n\tq_next[13] = q[11] & q[12];\n\tq_next[14] = q[12] & q[13];\n\tq_next[15] = q[13] & q[14];\n\tq_next[16] = q[14] & q[15];\n\tq_next[17] = q[15] & q[16];\n\tq_next[18] = q[16] & q[17];\n\tq_next[19] = q[17] & q[18];\n\tq_next[20] = q[18] & q[19];\n\tq_next[21] = q[19] & q[20];\n\tq_next[22] = q[20] & q[21];\n\tq_next[23] = q[21] & q[22];\n\tq_next[24] = q[22] & q[23];\n\tq_next[25] = q[23] & q[24];\n\tq_next[26] = q[24] & q[25];\n\tq_next[27] = q[25] & q[26];\n\tq_next[28] = q[26] & q[27];\n\tq_next[29] = q[27] & q[28];\n\tq_next[30] = q[28] & q[29];\n\tq_next[31] = q[29] & q[30];\n\tq_next[32] = q[30] & q[31];\n\tq_next[33] = q[31] & q[32];\n\tq_next[34] = q[32] & q[33];\n\tq_next[35] = q[33] & q[34];\n\tq_next[36] = q[34] & q[35];\n\tq_next[37] = q[35] & q[36];\n\tq_next[38] = q[36] & q[37];\n\tq_next[39] = q[37] & q[38];\n\tq_next[40] = q[38] & q[39];\n\tq_next[41] = q[39] & q[40];\n\tq_next[42] = q[40] & q[41];\n\tq_next[43] = q[41] & q[42];\n\tq_next[44] = q[42] & q[43"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore FSM with one input, one output, and four states\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n\n// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register\nreg [1:0] state_reg = A;\n\n// Output register\nreg out_reg = 0;\n\n// Next state logic\nalways @ (posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate_reg <= A;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tA: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tstate_reg <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tstate_reg <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= D;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tstate_reg <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= B;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nalways @ (state_reg) begin\n\tcase (state_reg)\n\t\tA: out_reg = 0;\n\t\tB: out_reg = 0;\n\t\tC: out_reg = 0;\n\t\tD: out_reg = 1;\n\tendcase\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\nalways @(*) begin\n    case ({a,b,c,d,e})\n        5'b00000: q = 4'b0000;\n        5'b00001: q = 4'b0000;\n        5'b00010: q = 4'b0000;\n        5'b00011: q = 4'b0000;\n        5'b00100: q = 4'b0000;\n        5'b00101: q = 4'b0000;\n        5'b00110: q = 4'b0000;\n        5'b00111: q = 4'b0000;\n        5'b01000: q = 4'b0000;\n        5'b01001: q = 4'b0000;\n        5'b01010: q = 4'b0000;\n        5'b01011: q = 4'b0000;\n        5'b01100: q = 4'b0000;\n        5'b01101: q = 4'b0000;\n        5'b01110: q = 4'b0000;\n        5'b01111: q = 4'b0000;\n        5'b10000: q = 4'b0001;\n        5'b10001: q = 4'b0001;\n        5'b10010: q = 4'b0001;\n        5'b10011: q = 4'b0001;\n        5'b10100: q = 4'b0001;\n        5'b10101: q = 4'b0001;\n        5'b10110: q = 4'b0001;\n        5'b10111: q = 4'b0001;\n        5'b11000: q = 4'b0001;\n        5'b11001: q = 4'b0001;\n        5'b11010: q = 4'b0001;\n        5'b11011: q = 4'b0001;\n        5'b11100: q = 4'b0001;\n        5'b11101: q = 4'b0001;\n        5'b11110: q = 4'b0001;\n        5'b11111: q = 4'b0001;\n        default: q = 4'bxxxx;\n    endcase\nend\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel == 1'b0) begin\n            out = a;\n        end else begin\n            out = b;\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\nreg [2:0] q;\n\nalways @(posedge clk) begin\n    if (L) begin\n        q <= q_in;\n    end else begin\n        q <= {q[1] ^ q[2], q[0], q[2]};\n    end\nend\n\nsub_module sub_inst1(\n    .clk(clk),\n    .L(L),\n    .r_in(r_in),\n    .Q(q[0])\n);\n\nsub_module sub_inst2(\n    .clk(clk),\n    .L(L),\n    .r_in(r_in),\n    .Q(q[1])\n);\n\nsub_module sub_inst3(\n    .clk(clk),\n    .L(L),\n    .r_in(r_in),\n    .Q(q[2])\n);\n\nassign Q = q;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "Complete the following code:\n```verilog\nreg [31:0] prev_in;\nreg [31:0] curr_in;\nreg [31:0] diff;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tprev_in <= 0;\n\t\tcurr_in <= 0;\n\t\tdiff <= 0;\n\t\tout <= 0;\n\tend else begin\n\t\tprev_in <= curr_in;\n\t\tcurr_in <= in;\n\t\tdiff <= curr_in ^ prev_in;\n\t\tout <= diff & curr_in;\n\tend\nend\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "endmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "`state` is the current state and `S_next`, `S1_next`, `B3_next`, `Count_next`, `Wait_next`, are the next states.\n\n`S_next` is the next state of S, `S1_next` is the next state of S1, `B3_next` is the next state of B3, `Count_next` is the next state of Count, `Wait_next` is the next state of Wait.\n\n`done` is the output of the done flip-flop, `counting` is the output of the counting flip-flop, `shift_ena` is the output of the shift_ena flip-flop.\n\n`B3_next` is the next state of B3. B3 has only one possible next state which is Count.\n\n`S1_next` is the next state of S1. S1 has two possible next states which are S110 and S11.\n\n`S_next` is the next state of S. S has two possible next states which are S1 and B0.\n\n`Count_next` is the next state of Count. Count has two possible next states which are Wait and B3.\n\n`Wait_next` is the next state of Wait. Wait has two possible next states which are S and B1.\n\n`done` is the output of the done flip-flop which is set when the Wait state is entered.\n\n`counting` is the output of the counting flip-flop which is set when the Count state is entered.\n\n`shift_ena` is the output of the shift_ena flip-flop which is set when the B1 state is entered.\n\n// B3_next\nassign B3_next = (state == 10'b1000000000);\n\n// S_next\nassign S_next = (state == 10'b0000000001) ? ((d) ? 10'b0000000100 : 10'b0000000010) : 10'b0000000001;\n\n// S1_next\nassign S1_next = (state == 10'b0000000010) ? ((d) ? 10'b0000000001 : 10'b0000001000) : 10'b0000000100;\n\n// Count_next\nassign Count_next = (state == 10'b0000000001) ? ((d) ? 10'b1000000000 : 10'b0000000010) : 10'b0000000001;\n\n// Wait_next\nassign Wait_next = (state == 10'b0000001000) ? ((ack) ? 10'b0000000001 : 10'b0000001000) : 10'b0000001000;\n\n// done\nassign done = (state == 10'b0000001000);\n\n// counting\nassign counting = (state == 10'b0000000001);\n\n// shift_ena\nassign shift_ena = (state == 10'b0000000011);\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n  );\n\n    always_ff @ (posedge clk, posedge areset) begin\n      if (areset) begin\n        state <= 2'b01;\n      end else if (train_valid) begin\n        if (train_taken) begin\n          if (state == 2'b11) begin\n            state <= 2'b11;\n          end else begin\n            state <= state + 1;\n          end\n        end else begin\n          if (state == 2'b00) begin\n            state <= 2'b00;\n          end else begin\n            state <= state - 1;\n          end\n        end\n      end\n    end\n\n  endmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @(*) begin\n    pos = 3'd0;\n    for (pos = 3'd0; pos < 3'd8; pos = pos + 1) begin\n        if (in[pos] == 1'b1) begin\n            break;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n\nalways @ (scancode) begin\n\tcase (scancode)\n\t\t16'he06b: begin\n\t\t\tleft = 1;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\t\t16'he072: begin\n\t\t\tleft = 0;\n\t\t\tdown = 1;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\t\t16'he074: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 1;\n\t\t\tup = 0;\n\t\tend\n\t\t16'he075: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 1;\n\t\tend\n\t\tdefault: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n    wire [3:0] c;\n    wire [3:0] s;\n\n    full_adder fa0(x[0], y[0], 1'b0, s[0], c[0]);\n    full_adder fa1(x[1], y[1], c[0], s[1], c[1]);\n    full_adder fa2(x[2], y[2], c[1], s[2], c[2]);\n    full_adder fa3(x[3], y[3], c[2], s[3], c[3]);\n\n    assign sum = {c[3], s};\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\nreg [31:0] history [3:0];\nreg [31:0] next_history [3:0];\nreg [31:0] predict_history_reg;\nreg [31:0] mispredicted_history_reg;\nreg [31:0] next_predict_history_reg;\nreg [31:0] next_mispredicted_history_reg;\n\nassign predict_history = predict_history_reg;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        history[0] <= 0;\n        history[1] <= 0;\n        history[2] <= 0;\n        history[3] <= 0;\n        next_history[0] <= 0;\n        next_history[1] <= 0;\n        next_history[2] <= 0;\n        next_history[3] <= 0;\n        predict_history_reg <= 0;\n        mispredicted_history_reg <= 0;\n        next_predict_history_reg <= 0;\n        next_mispredicted_history_reg <= 0;\n    end else begin\n        if (predict_valid) begin\n            history[0] <= {predict_history_reg[0], history[0][30:1]};\n            history[1] <= {history[1][30:1], history[0][29:1]};\n            history[2] <= {history[2][30:1], history[1][29:1]};\n            history[3] <= {history[3][30:1], history[2][29:1]};\n            next_history[0] <= {predict_history_reg[0], next_history[0][30:1]};\n            next_history[1] <= {next_history[1][30:1], next_history[0][29:1]};\n            next_history[2] <= {next_history[2][30:1], next_history[1][29:1]};\n            next_history[3] <= {next_history[3][30:1], next_history[2][29:1]};\n            predict_history_reg <= {predict_taken, predict_history_reg[30:1]};\n        end\n        \n        if (train_mispredicted) begin\n            mispredicted_history_reg <= {train_history[31], mispredicted_history_reg[30:1]};\n            next_mispredicted_history_reg <= {train_history[31], next_mispredicted_history_reg[30:1]};\n        end\n    end\nend\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        next_predict_history_reg <= 0;\n        next_mispredicted_history_reg <= 0;\n    end else begin\n        if (predict_valid) begin\n            next_predict_history_reg <= next_history[3];\n        end\n        \n        if (train_mispredicted) begin\n            next_mispredicted_history_reg <= next_history[3];\n        end\n    end\nend\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history_reg <= 0;\n        mispredicted_history_reg <= 0;\n    end else begin\n        if (predict_valid) begin\n            predict_history_reg <= next_predict_history_reg;\n        end\n        \n        if (train_mispredicted) begin\n            mispredicted_history_reg <= next_mispredicted_history_reg;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    wire and1_out;\n    wire and2_out;\n\n    and and1(a, b, and1_out);\n    and and2(c, d, and2_out);\n    or or1(and1_out, and2_out, out);\n    not not1(out, out_n);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Define the state of the thermostat\n    reg [1:0] state;\n    parameter IDLE = 2'b00;\n    parameter HEATING = 2'b01;\n    parameter COOLING = 2'b10;\n\n    // Define the state machine\n    always @ (posedge clk) begin\n        case (state)\n            IDLE: begin\n                if (mode == 1) begin\n                    if (too_cold) begin\n                        state <= HEATING;\n                    end else if (too_hot) begin\n                        state <= COOLING;\n                    end\n                end\n            end\n            HEATING: begin\n                if (!too_cold) begin\n                    state <= IDLE;\n                end else if (fan_on) begin\n                    state <= HEATING;\n                end\n            end\n            COOLING: begin\n                if (!too_hot) begin\n                    state <= IDLE;\n                end else if (fan_on) begin\n                    state <= COOLING;\n                end\n            end\n        endcase\n    end\n\n    // Define the outputs\n    assign heater = (state == HEATING);\n    assign aircon = (state == COOLING);\n    assign fan = (heater || aircon || fan_on);\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products\n    assign out_sop = ~(a & b & c) & ~(a & b & d) & ~(a & c & d) & ~(b & c & d) & ~(a & b & c & d);\n\n    // Product of Sums\n    assign out_pos = (~a | b | c | d) & (~a | b | c | ~d) & (~a | b | ~c | d) & (~a | b | c | d) & (~a | b | c | ~d) & (~a | b | ~c | d) & (~a | b | c | d) & (~a | ~b | c | d) & (a | b | c | d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "(q[31] ^ q[22] ^ q[2] ^ q[1]) ^ 64'b1000001000000000000000000000000000000000000000000000000000000000;"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module is the same as for any Verilog code.\n// You can use the Verilog syntax to create inputs, outputs, and logic gates.\n// module top_module(\n//    input p1a, \n//    input p1b, \n//    input p1c, \n//    input p1d, \n//    output p1y, \n//    input p2a, \n//    input p2b, \n//    input p2c, \n//    input p2d, \n//    output p2y\n//);\n//\n//    // 7420 chip with two 4-input NAND gates\n//    nand(p1y, p1a, p1b, p1c, p1d);\n//    nand(p2y, p2a, p2b, p2c, p2d);\n//\n//endmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "**Do not** add comments, white spaces, or any additional code lines to the Verilog code below. Please adhere to the same style and formatting as the existing code.\n```verilog\nmodule top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n// Define intermediate wires\nwire [7:0] p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47, p48, p49, p50, p51, p52, p53, p54, p55, p56, p57, p58, p59, p60, p61, p62, p63, p64, p65, p66, p67, p68, p69, p70, p71, p72, p73, p74, p75, p76, p77, p78, p79, p80, p81, p82, p83, p84, p85, p86, p87, p88, p89, p90, p91, p92, p93, p94, p95, p96, p97, p98, p99, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111, p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125, p126, p127, p128, p129, p130, p131, p132, p133, p134, p135, p136, p137, p138, p139, p140, p141, p142, p143, p144, p145, p146, p147, p148, p149, p150, p151, p152, p153, p154, p155, p156, p157, p158, p159, p160, p161, p162, p163, p164, p165, p166, p167, p168, p169, p170, p171, p172, p173, p174, p175, p176, p177, p178, p179, p180, p181, p182, p183, p184, p185, p186, p187, p188, p189, p190, p191, p192, p193, p194, p195, p196, p197, p198, p199, p200, p201, p202, p203, p204, p205, p206, p207, p208"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'b1232;\n        3'b001: q = 16'baee;\n        3'b010: q = 16'27d4;\n        3'b011: q = 16'5a0e;\n        3'b100: q = 16'2066;\n        3'b101: q = 16'64ce;\n        3'b110: q = 16'c526;\n        3'b111: q = 16'2f19;\n        default: q = 16'b0000;\n    endcase\nend\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module\n 4. Inputs: clk, slowena, reset\n 5. Outputs: q\n 6. Verilog code:\n```verilog\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (slowena) begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    and gate (\n        out,\n        in1,\n        in2\n    );\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// States\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\n\n// State register\nreg [1:0] state;\n\n// Output register\nreg out_reg;\n\n// Initialize state to B\ninitial begin\n\tstate <= B;\nend\n\n// State transition and output logic\nalways @ (posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= B;\n\t\tout_reg <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= C;\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate <= B;\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n    \n    reg q_temp;\n    \n    always @(posedge clk)\n    begin\n        q_temp <= d;\n    end\n    \n    always @(negedge clk)\n    begin\n        q <= q_temp;\n    end\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "Use the Verilog code below to implement the XNOR gate:\n```verilog\n\tassign out = ~(a ^ b);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module A(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x ^ y) & x;\n\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x & y) | (x & ~y) | (~x & y);\n\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module code should be complete and correct. You can use the Verilog syntax and the style of your choice.\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if(load) begin\n            shift_reg <= data;\n        end\n        else begin\n            case(ena)\n                2'b01: shift_reg <= {shift_reg[0], shift_reg[99:1]};\n                2'b10: shift_reg <= {shift_reg[98:0], shift_reg[99]};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    assign q = shift_reg;\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    // State transition logic\n    always @(*) begin\n        case(state[9:0])\n            1'b000000001: next_state = 1'b000000010;\n            1'b000000010: next_state = 1'b000000100;\n            1'b000000100: next_state = 1'b000001000;\n            1'b000001000: next_state = 1'b000010000;\n            1'b000010000: next_state = 1'b000100000;\n            1'b000100000: next_state = 1'b001000000;\n            1'b001000000: next_state = 1'b010000000;\n            1'b010000000: next_state = 1'b100000000;\n            1'b100000000: next_state = 1'b000000000;\n            1'b000000000: next_state = 1'b000000001;\n            default: next_state = 1'b000000000;\n        endcase\n    end\n\n    // Output logic\n    assign out1 = (state[9:0] == 1'b000000000);\n    assign out2 = (state[9:0] == 1'b000000000);\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (j && k) begin\n            Q <= ~Q;\n        end else if (j) begin\n            Q <= 0;\n        end else if (k) begin\n            Q <= 1;\n        end\n    end\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "* 3-bit population count:\n```verilog\n\twire [2:0] count;\n\tassign count = {in[0], in[1], in[2]} + 2'b0; // add 2'b0 to count the 3rd bit\n\tassign out = count[1:0]; // output the 1's count\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "endianness: little-endian.\n\nModule top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out[ 0] = ~e ^ e;\n\tassign out[ 1] = ~e ^ d;\n\tassign out[ 2] = ~e ^ c;\n\tassign out[ 3] = ~e ^ b;\n\tassign out[ 4] = ~e ^ a;\n\tassign out[ 5] = ~d ^ e;\n\tassign out[ 6] = ~c ^ d;\n\tassign out[ 7] = ~b ^ c;\n\tassign out[ 8] = ~a ^ b;\n\tassign out[ 9] = ~a ^ c;\n\tassign out[10] = ~a ^ d;\n\tassign out[11] = ~a ^ e;\n\tassign out[12] = ~b ^ d;\n\tassign out[13] = ~b ^ e;\n\tassign out[14] = ~c ^ d;\n\tassign out[15] = ~c ^ e;\n\tassign out[16] = ~d ^ e;\n\tassign out[17] = ~a ^ b;\n\tassign out[18] = ~a ^ c;\n\tassign out[19] = ~a ^ d;\n\tassign out[20] = ~a ^ e;\n\tassign out[21] = ~b ^ c;\n\tassign out[22] = ~b ^ d;\n\tassign out[23] = ~b ^ e;\n\tassign out[24] = ~c ^ d;\n\tassign out[25] = ~c ^ e;\n\tassign out[26] = ~d ^ e;\n\tassign out[27] = ~a ^ b;\n\tassign out[28] = ~a ^ c;\n\tassign out[29] = ~a ^ d;\n\tassign out[30] = ~a ^ e;\n\tassign out[31] = ~b ^ c;\n\tassign out[32] = ~b ^ d;\n\tassign out[33] = ~b ^ e;\n\tassign out[34] = ~c ^ d;\n\tassign out[35] = ~c ^ e;\n\tassign out[36] = ~d ^ e;\n\tassign out[37] = ~a ^ b;\n\tassign out[38] = ~a ^ c;\n\tassign out[39] = ~a ^ d;\n\tassign out[40] = ~a ^ e;\n\tassign out[41] = ~b ^ c;\n\tassign out[42] = ~b ^ d;\n\tassign out[43] = ~b ^ e;\n\tassign out[44] = ~c ^ d;\n\tassign out[45] = ~c ^ e;\n\tassign out[46] = ~d ^ e;\n\tassign out[47] = ~a ^ b;\n\tassign out[48] = ~a ^ c;\n\tassign out[49] = ~a ^ d;\n\tassign out[50] = ~a ^ e;\n\tassign out[51] = ~b ^ c;\n\tassign out[52] = ~b ^ d;\n\tassign out[53] = ~b ^ e;\n\tassign out[54] = ~c ^ d;\n\tassign out[55] = ~c ^ e;\n\tassign out[56] = ~d ^ e;\n\tassign out[57] = ~a ^ b;\n\tassign out[58] = ~a ^ c;\n\tassign out[59] = ~a ^ d;\n\tassign out[60] = ~a ^ e;\n\tassign out[61] = ~b ^ c;\n\tassign out[62] = ~b ^ d;\n\tassign out[63] = ~b ^ e;\n\tassign out[64] = ~c ^ d;\n\tassign out[65] = ~c ^ e;\n\tassign out[66] = ~d ^ e;\n\tassign out[67] = ~a ^ b;\n\tassign out[68] = ~a ^ c;"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "// State encoding\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\t\n\t// State and input registers\n\treg [1:0] state;\n\treg bump_left_reg;\n\treg bump_right_reg;\n\t\n\t// Output registers\n\treg walk_left_reg;\n\treg walk_right_reg;\n\t\n\t// Moore state machine\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left_state;\n\t\t\tbump_left_reg <= 0;\n\t\t\tbump_right_reg <= 0;\n\t\t\twalk_left_reg <= 1;\n\t\t\twalk_right_reg <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\tif (bump_left_reg) begin\n\t\t\t\t\t\tstate <= walk_right_state;\n\t\t\t\t\t\tbump_left_reg <= 0;\n\t\t\t\t\t\tbump_right_reg <= 0;\n\t\t\t\t\t\twalk_left_reg <= 0;\n\t\t\t\t\t\twalk_right_reg <= 1;\n\t\t\t\t\tend else if (bump_right_reg) begin\n\t\t\t\t\t\tstate <= walk_left_state;\n\t\t\t\t\t\tbump_left_reg <= 0;\n\t\t\t\t\t\tbump_right_reg <= 0;\n\t\t\t\t\t\twalk_left_reg <= 1;\n\t\t\t\t\t\twalk_right_reg <= 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tbump_left_reg <= bump_left;\n\t\t\t\t\t\tbump_right_reg <= bump_right;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\tif (bump_left_reg) begin\n\t\t\t\t\t\tstate <= walk_left_state;\n\t\t\t\t\t\tbump_left_reg <= 0;\n\t\t\t\t\t\tbump_right_reg <= 0;\n\t\t\t\t\t\twalk_left_reg <= 1;\n\t\t\t\t\t\twalk_right_reg <= 0;\n\t\t\t\t\tend else if (bump_right_reg) begin\n\t\t\t\t\t\tstate <= walk_left_state;\n\t\t\t\t\t\tbump_left_reg <= 0;\n\t\t\t\t\t\tbump_right_reg <= 0;\n\t\t\t\t\t\twalk_left_reg <= 0;\n\t\t\t\t\t\twalk_right_reg <= 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tbump_left_reg <= bump_left;\n\t\t\t\t\t\tbump_right_reg <= bump_right;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Output assignments\n\tassign walk_left = walk_left_reg;\n\tassign walk_right = walk_right_reg;\n\t\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = (a & b) | (~a & b) | (a & ~b);\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire p1_and1;\nwire p1_and2;\nwire p1_and3;\nwire p1_and4;\nwire p2_and1;\nwire p2_and2;\n\nassign p1_and1 = p1a & p1b;\nassign p1_and2 = p1c & p1d;\nassign p1_and3 = p1e & p1f;\nassign p1_and4 = p1_and1 & p1_and2 & p1_and3;\nassign p1y = p1_and4;\n\nassign p2_and1 = p2a & p2b;\nassign p2_and2 = p2c & p2d;\nassign p2y = p2_and1 | p2_and2;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "// --------------------------------------------------------------------\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\n// --------------------------------------------------------------------\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "// D flip flop with asynchronous reset\n\treg q;\n\n\talways @(posedge clk or negedge ar) begin\n\t\tif (ar == 0) begin\n\t\t\tq <= 0;\n\t\tend\n\t\telse begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "// 6-to-1 MUX\nalways @(*) begin\n\tcase (sel)\n\t\t3'd0: out = data0;\n\t\t3'd1: out = data1;\n\t\t3'd2: out = data2;\n\t\t3'd3: out = data3;\n\t\t3'd4: out = data4;\n\t\t3'd5: out = data5;\n\t\tdefault: out = 4'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "assign tc = (cnt == 0);\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output start_shifting);\n\n    // State encoding\n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n    parameter S3 = 2'b11;\n\n    // State register\n    reg [1:0] state_reg;\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state_reg <= S0;\n        end else begin\n            case (state_reg)\n                S0: begin\n                    if (data) begin\n                        state_reg <= S1;\n                    end else begin\n                        state_reg <= S0;\n                    end\n                end\n                S1: begin\n                    if (data) begin\n                        state_reg <= S2;\n                    end else begin\n                        state_reg <= S0;\n                    end\n                end\n                S2: begin\n                    if (data) begin\n                        state_reg <= S3;\n                        start_shifting <= 1;\n                    end else begin\n                        state_reg <= S0;\n                    end\n                end\n                S3: begin\n                    if (~data) begin\n                        state_reg <= S0;\n                        start_shifting <= 0;\n                    end else begin\n                        state_reg <= S3;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        if (in != prev_in) begin\n            anyedge <= {anyedge[6:0], 1'b1};\n        end else begin\n            anyedge <= {anyedge[6:0], 1'b0};\n        end\n        prev_in <= in;\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'd1;\n\t\tend else if (q == 4'd10) begin\n\t\t\tq <= 4'd1;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\nalways @(posedge clk) begin\n    case(a)\n        1'b0: q <= 3'b001;\n        1'b1: q <= 3'b100;\n    endcase\nend\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "The output of the LFSR is the LSB.\n\n```verilog\n\treg [4:0] lfsr;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 5'b1;\n\t\t\tq <= 5'b1;\n\t\tend\n\t\telse begin\n\t\t\tif (lfsr[4] == 1'b0 && lfsr[3] == 1'b1)\n\t\t\t\tlfsr <= {lfsr[3:0], lfsr[4] ^ lfsr[3]};\n\t\t\telse\n\t\t\t\tlfsr <= {lfsr[3:0], lfsr[4]};\n\t\t\tq <= lfsr[0];\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        if (do_sub == 0) begin\n            out = a + b;\n            result_is_zero = ~(a + b);\n        end\n        else begin\n            out = a - b;\n            result_is_zero = ~(a - b);\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always_comb begin\n        case (x)\n            // 0000\n            4'b0000: f = 1'b0;\n            // 0001\n            4'b0001: f = 1'b0;\n            // 0010\n            4'b0010: f = 1'b1;\n            // 0011\n            4'b0011: f = 1'b1;\n            // 0100\n            4'b0100: f = 1'b1;\n            // 0101\n            4'b0101: f = 1'b1;\n            // 0110\n            4'b0110: f = 1'b1;\n            // 0111\n            4'b0111: f = 1'b0;\n            // 1000\n            4'b1000: f = 1'b1;\n            // 1001\n            4'b1001: f = 1'b1;\n            // 1010\n            4'b1010: f = 1'b0;\n            // 1011\n            4'b1011: f = 1'b0;\n            // 1100\n            4'b1100: f = 1'b0;\n            // 1101\n            4'b1101: f = 1'b0;\n            // 1110\n            4'b1110: f = 1'b1;\n            // 1111\n            4'b1111: f = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = {in[0], in[7], in[1], in[6], in[2], in[5], in[3], in[4]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case({a,b,c,d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b1;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b0111: out = 1'b1;\n            default: out = 1'b0; // don't care\n        endcase\n    end\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (count_ena) begin\n            q <= q - 1;\n        end\n        if (shift_ena) begin\n            q <= {q[2:0], data};\n        end\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "MODULE top_module(\n\tinput in,\n\toutput out\n);\n\n\tassign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "reg [3:0] state;\n\tparameter [3:0] S0 = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3 = 4'b0011, S4 = 4'b0100, S5 = 4'b0101, S6 = 4'b0110, S7 = 4'b0111;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tshift_ena <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tif (clk_count == 0) begin\n\t\t\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (reset) begin\n\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tif (clk_count == 1) begin\n\t\t\t\t\t\t\tstate <= S2;\n\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (clk_count == 2) begin\n\t\t\t\t\t\t\tstate <= S3;\n\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (clk_count == 3) begin\n\t\t\t\t\t\t\tstate <= S4;\n\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (clk_count == 4) begin\n\t\t\t\t\t\t\tstate <= S5;\n\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (clk_count == 5) begin\n\t\t\t\t\t\t\tstate <= S6;\n\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (clk_count == 6) begin\n\t\t\t\t\t\t\tstate <= S7;\n\t\t\t\t\t\t\tshift_ena <= 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (clk_count == 7) begin\n\t\t\t\t\t\t\tstate <= S0;\n\t\t\t\t\t\t\tshift_ena <= 1'b0;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tclk_count <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (state == S0) begin\n\t\t\t\tclk_count <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tclk_count <= clk_count + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\treg [1:0] shift_reg;\n\talways @(posedge clk)"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "// assign statements\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// procedural if\nalways @(*) begin\n\tif (sel_b1 && sel_b2) begin\n\t\tout_always = b;\n\tend else begin\n\t\tout_always = a;\n\tend\nend\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (a & ~b & ~c) | (~a & b & ~c) | (~a & ~b & c) | (a & b & c);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "// State codes\nlocalparam [1:0] S_A = 2'b00, S_B = 2'b01, S_C = 2'b10, S_D = 2'b11;\n\n// State register\nreg [1:0] state, next_state;\n\n// Output register\nreg [3:1] g_reg;\n\n// Output assign\nassign g = g_reg;\n\n// State table\nalways @ (posedge clk or negedge resetn) begin\n\tif (~resetn) begin\n\t\tstate <= S_A;\n\t\tg_reg <= 4'b0000;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\t\tg_reg <= (r != 3'b000) ? {r, 1'b0} : 4'b0000;\n\tend\nend\n\n// State flip-flop\nalways @ (state or r or g_reg) begin\n\tcase (state)\n\t\tS_A: begin\n\t\t\tnext_state = (r[0]) ? S_B : (r[1]) ? S_C : S_D;\n\t\tend\n\t\tS_B: begin\n\t\t\tnext_state = (r[0]) ? S_B : S_A;\n\t\tend\n\t\tS_C: begin\n\t\t\tnext_state = (r[1]) ? S_C : S_A;\n\t\tend\n\t\tS_D: begin\n\t\t\tnext_state = (r[2]) ? S_D : S_A;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "Follow the Verilog coding style guide and use meaningful names for your signals, variables, and modules. Indent your code properly and separate different parts of the code with empty lines.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n// Counter logic\nreg [3:0] counter;\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tcounter <= 0;\n\tend else begin\n\t\tif (counter == 9) begin\n\t\t\tcounter <= 0;\n\t\tend else begin\n\t\t\tcounter <= counter + 1;\n\t\tend\n\tend\nend\n\n// Output logic\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 0;\n\tend else begin\n\t\tq <= counter;\n\tend\nend\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "and end with:\n```verilog\n\talways_ff @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t0: begin\n\t\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\t\tstate <= 1;\n\t\t\t\t\t\tlast_in <= in;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t1: begin\n\t\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\t\tstate <= 2;\n\t\t\t\t\t\tlast_in <= in;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t2: begin\n\t\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\t\tstate <= 3;\n\t\t\t\t\t\tlast_in <= in;\n\t\t\t\t\t\tdone <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 0) ? a : b;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "Use the AND, OR, and XOR gates directly in the Verilog code. Avoid using intermediate variables.\n\n```verilog\n// 4-input AND gate\nassign out_and = in[0] & in[1] & in[2] & in[3];\n\n// 4-input OR gate\nassign out_or = in[0] | in[1] | in[2] | in[3];\n\n// 4-input XOR gate\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] y;\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 0;\n        end else begin\n            case (y)\n                3'b000: y <= {x, y[2]};\n                3'b001: y <= {x, y[2]};\n                3'b010: y <= {x, y[2]};\n                3'b011: y <= {x, y[2]};\n                3'b100: y <= {x, y[2]};\n                default: y <= 3'b000;\n            endcase\n            \n            case (y)\n                3'b000: z <= 0;\n                3'b001: z <= 0;\n                3'b010: z <= 0;\n                3'b011: z <= 1;\n                3'b100: z <= 1;\n                default: z <= 0;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "Your code should be concise and easy to read. Do not add unnecessary comments or redundant code. Use meaningful variable and state names.\n\n```verilog\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\t\n\tassign f = (state == B);\n\tassign g = (state == C);\n\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tstate <= A;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (y) begin\n\t\t\t\t\t\tstate <= D;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tstate <= A;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "and end with:\n```verilog\nalways @(negedge clk) begin\n\tif (reset) begin\n\t\tq <= 8'h34;\n\tend else begin\n\t\tq <= d;\n\tend\nend\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "assign parity = ~^in;"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "always @(*) begin\n    case(state)\n        2'b00: // A\n            begin\n                next_state = (in == 1) ? 2'b01 : 2'b00;\n                out = 1'b0;\n            end\n        2'b01: // B\n            begin\n                next_state = (in == 1) ? 2'b10 : 2'b01;\n                out = 1'b0;\n            end\n        2'b10: // C\n            begin\n                next_state = (in == 1) ? 2'b00 : 2'b10;\n                out = 1'b0;\n            end\n        2'b11: // D\n            begin\n                next_state = (in == 1) ? 2'b01 : 2'b11;\n                out = 1'b1;\n            end\n    endcase\nend"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x == 1'b0) ? ((y == 1'b0) ? 1'b1 : 1'b0) : 1'b1;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "endmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "Include the necessary Verilog primitives for D flip-flops and registers.\n\n```verilog\n\treg [15:0] q_reg;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tq_reg <= 16'b0;\n\t\tend else if (byteena[1]) begin\n\t\t\tq_reg[15:8] <= d[15:8];\n\t\tend\n\t\tif (byteena[0]) begin\n\t\t\tq_reg[7:0] <= d[7:0];\n\t\tend\n\tend\n\n\tassign q = q_reg;\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        if (in[0] && !prev_in[0]) begin\n            pedge[0] <= 1;\n        end else begin\n            pedge[0] <= 0;\n        end\n        if (in[1] && !prev_in[1]) begin\n            pedge[1] <= 1;\n        end else begin\n            pedge[1] <= 0;\n        end\n        if (in[2] && !prev_in[2]) begin\n            pedge[2] <= 1;\n        end else begin\n            pedge[2] <= 0;\n        end\n        if (in[3] && !prev_in[3]) begin\n            pedge[3] <= 1;\n        end else begin\n            pedge[3] <= 0;\n        end\n        if (in[4] && !prev_in[4]) begin\n            pedge[4] <= 1;\n        end else begin\n            pedge[4] <= 0;\n        end\n        if (in[5] && !prev_in[5]) begin\n            pedge[5] <= 1;\n        end else begin\n            pedge[5] <= 0;\n        end\n        if (in[6] && !prev_in[6]) begin\n            pedge[6] <= 1;\n        end else begin\n            pedge[6] <= 0;\n        end\n        if (in[7] && !prev_in[7]) begin\n            pedge[7] <= 1;\n        end else begin\n            pedge[7] <= 0;\n        end\n        prev_in <= in;\n    end\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg [1:0] state;\n\n    always @(posedge clock) begin\n        case(state)\n            2'b00: begin\n                p <= 0;\n                q <= 0;\n                if (a) begin\n                    state <= 2'b01;\n                end\n            end\n            2'b01: begin\n                p <= 1;\n                q <= 0;\n                state <= 2'b10;\n            end\n            2'b10: begin\n                p <= 0;\n                q <= 1;\n                state <= 2'b11;\n            end\n            2'b11: begin\n                p <= 0;\n                q <= 0;\n                state <= 2'b00;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "// 2-bit input\n\tassign z = (A == B) ? 1 : 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Compare A and B and set z to 1 if equal, otherwise 0.\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n// (1) out_both\ngenvar i;\ngenerate\n    for (i = 0; i < 99; i = i + 1) begin : out_both_gen\n        assign out_both[i] = (i > 0) ? in[i] & in[i-1] : 0;\n    end\nendgenerate\n\n// (2) out_any\ngenvar j;\ngenerate\n    for (j = 0; j < 100; j = j + 1) begin : out_any_gen\n        assign out_any[j] = (j > 0) ? (in[j] | in[j-1]) : 0;\n    end\nendgenerate\n\n// (3) out_different\nassign out_different[0] = (in[0] != in[99]);\ngenerate\n    for (i = 1; i < 99; i = i + 1) begin : out_different_gen\n        assign out_different[i] = (in[i] != in[i-1] && in[i] != in[i+1]);\n    end\nendgenerate\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module (\n    input d,\n    input ena,\n    output logic q\n);\n\n    always @(posedge ena) begin\n        if(ena) begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "The Verilog code below is an incomplete 9-to-1 multiplexer. Finish the code to select the appropriate input based on the value of sel. Set all output bits to '1' for unused cases.\n\n```verilog\nalways @(*) begin\n\tcase (sel)\n\t\t4'b0000: out = a;\n\t\t4'b0001: out = b;\n\t\t4'b0010: out = c;\n\t\t4'b0011: out = d;\n\t\t4'b0100: out = e;\n\t\t4'b0101: out = f;\n\t\t4'b0110: out = g;\n\t\t4'b0111: out = h;\n\t\t4'b1000: out = i;\n\t\tdefault: out = 16'b1111111111111111;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = (a != 0) || (b != 0);\n\n    // NOT of a and b\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n// State transition logic\nalways @ (state or in) begin\n    case (state)\n        4'b0001: begin // A\n            if (in == 0) next_state = 4'b0001;\n            else next_state = 4'b0010;\n            out = 0;\n        end\n        4'b0010: begin // B\n            if (in == 0) next_state = 4'b0100;\n            else next_state = 4'b0010;\n            out = 0;\n        end\n        4'b0100: begin // C\n            if (in == 0) next_state = 4'b0001;\n            else next_state = 4'b1000;\n            out = 0;\n        end\n        4'b1000: begin // D\n            if (in == 0) next_state = 4'b0100;\n            else next_state = 4'b0010;\n            out = 1;\n        end\n        default: begin\n            next_state = 4'b0001;\n            out = 0;\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "// Find the minimum of four unsigned numbers\n\nalways @(*) begin\n\tmin = a;\n\tif (b < min)\n\t\tmin = b;\n\tif (c < min)\n\t\tmin = c;\n\tif (d < min)\n\t\tmin = d;\nend\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    assign out = (a&b&c&d) | (~a&~b&c&d) | (a&~b&c&~d) | (~a&b&~c&~d) | (a&b&~c&d) | (a&~b&c&d) | (~a&b&c&~d) | (a&~b&~c&d);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // Define the state register and initialize to A\n    reg [1:0] state = A;\n\n    // Define the next state logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (s) begin\n                        state <= B;\n                    end\n                end\n                B: begin\n                    if (w == 1) begin\n                        state <= C;\n                    end else if (w == 0) begin\n                        state <= B;\n                    end\n                end\n                C: begin\n                    if (w == 1) begin\n                        state <= D;\n                    end else if (w == 0) begin\n                        state <= B;\n                    end\n                end\n                D: begin\n                    if (w == 0) begin\n                        state <= B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            z <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    z <= 0;\n                end\n                B: begin\n                    z <= 0;\n                end\n                C: begin\n                    z <= 0;\n                end\n                D: begin\n                    z <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    wire [23:0] sign_ext;\n    assign sign_ext = {24{in[7]}}, {in, 24'b0};\n    assign out = sign_ext;\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n    wire [3:0] next_state;\n\n    assign next_state = {shift_reg[2:0], in};\n\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn) begin\n            shift_reg <= 4'b0;\n        end\n        else begin\n            shift_reg <= next_state;\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "and end with:\n```verilog\nalways @(*) begin\n\tcase (in)\n\t\t4'b0000: pos = 2'd0;\n\t\t4'b0001: pos = 2'd1;\n\t\t4'b0010: pos = 2'd2;\n\t\t4'b0011: pos = 2'd3;\n\t\t4'b0100: pos = 2'd4;\n\t\t4'b0101: pos = 2'd5;\n\t\t4'b0110: pos = 2'd6;\n\t\t4'b0111: pos = 2'd7;\n\t\t4'b1000: pos = 2'd8;\n\t\t4'b1001: pos = 2'd9;\n\t\t4'b1010: pos = 2'd10;\n\t\t4'b1011: pos = 2'd11;\n\t\t4'b1100: pos = 2'd12;\n\t\t4'b1101: pos = 2'd13;\n\t\t4'b1110: pos = 2'd14;\n\t\t4'b1111: pos = 2'd15;\n\t\tdefault: pos = 2'd0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n\nreg [1:0] state;\nreg out_reg;\n\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= OFF;\n\t\tout_reg <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nassign out = (state == ON) ? 1 : 0;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    assign out = 0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "endmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "// Reverse the input vector\ngenvar i;\ngenerate\n\tfor (i = 0; i < 100; i = i + 1) begin : reverse_loop\n\t\tassign out[i] = in[99-i];\n\tend\nendgenerate\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    reg d;\n\n    always @(posedge clk) begin\n        d <= in ^ d;\n    end\n\n    assign out = d;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "// (1) areset: Resets shift register to zero.\nalways @(posedge areset) begin\n\tq <= 4'b0;\nend\n\n// (2) load: Loads shift register with data[3:0] instead of shifting.\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\n\telse if (ena) begin\n\t\tq <= {q[2:0], 1'b0};\n\tend\nend\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module and the signals.\n\nDo not use any variable names, do not explain your code. Let the code speak for itself.\n\nFollow the Verilog coding style and conventions.\n\nMODULE top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or negedge areset) begin\n        if (~areset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "// Half Adder\n\t\tassign sum = a ^ b;\n\t\tassign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "// Verilog code for shutting off the computer and keeping the car driving\n\n// Shut off the computer if it overheats\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\n    else\n        shut_off_computer = 0;\nend\n\n// Keep driving if the gas tank is not empty and the car has not arrived\nalways @(*) begin\n    if (~arrived && ~gas_tank_empty)\n        keep_driving = 1;\n    else\n        keep_driving = 0;\nend\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output.\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n\n// State encoding\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// State register\nreg [1:0] state_reg, state_next;\n\n// Output register\nreg out_reg;\n\n// Combinational logic\nalways @ (posedge clk) begin\n\tif (reset) begin\n\t\tstate_reg <= OFF;\n\t\tout_reg <= 1'b0;\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\t\tcase (state_reg)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate_next = ON;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = OFF;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate_next = OFF;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = ON;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\t\tcase (state_reg)\n\t\t\tOFF: out_reg <= 1'b0;\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Assign outputs\nassign out = out_reg;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "// Concatenate input vectors\nwire [29:0] input_concat;\nassign input_concat = {a,b,c,d,e,f};\n\n// Split concatenated input into output vectors\nwire [7:0] w_temp;\nwire [7:0] x_temp;\nwire [7:0] y_temp;\nwire [7:0] z_temp;\nassign w_temp = input_concat[29:22];\nassign x_temp = input_concat[21:14];\nassign y_temp = input_concat[13:8];\nassign z_temp = input_concat[7:0];\n\n// Add two 1 bits to the LSB positions of the output vectors\nwire [8:0] w_final;\nwire [8:0] x_final;\nwire [8:0] y_final;\nwire [8:0] z_final;\nassign w_final = {1'b1, w_temp};\nassign x_final = {1'b1, x_temp};\nassign y_final = {1'b1, y_temp};\nassign z_final = {1'b1, z_temp};\n\n// Output the final output vectors\nassign w = w_final;\nassign x = x_final;\nassign y = y_final;\nassign z = z_final;\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & ~b & ~c & ~d) | (~a & b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & ~b & ~c & d) | (~a & ~b & c & d) | (~a & b & c & ~d) | (~a & b & ~c & d) | (~a & ~b & c & d) | (~a & ~b & ~c & d) | (a & b & ~c & d) | (a & ~b & c & d) | (a & ~b & ~c & d) | (a & b & c & ~d) | (a & b & ~c & d) | (a & ~b & ~c & d) | (a & ~b & c & d) | (a & ~b & ~c & d) | (a & b & c & d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\n\n```verilog\nreg [1:0] state;\nreg out_reg;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 2'b10;\n\t\tout_reg <= 1'b1;\n\tend else begin\n\t\tcase (state)\n\t\t\t2'b10: begin // B\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b01: begin // A\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tout_reg <= 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tout_reg <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nassign out = out_reg;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    wire w1, w2, w3;\n\n    xor x1(sum, a, b);\n    and a1(w1, a, b);\n    and a2(w2, a, cin);\n    and a3(w3, b, cin);\n    or o1(cout, w1, w2, w3);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module code\nmodule top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    wire xnor_out;\n    wire xor_out;\n\n    xnor xnor_inst (\n        .a(in1),\n        .b(in2),\n        .out(xnor_out)\n    );\n\n    xor xor_inst (\n        .a(xnor_out),\n        .b(in3),\n        .out(xor_out)\n    );\n\n    assign out = xor_out;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "// Then, implement the 2-to-1 and 4-to-1 muxes. You can use the verilog mux2to1 and mux4to1 modules.\n```verilog\nwire a = c & d;\nwire b = ~c & d;\nwire ab = a | b;\nwire cd = c & ~d;\nwire cd1 = ~c & d;\nwire cd2 = c & d;\nwire cd3 = ~c & d;\nwire cd4 = c & ~d;\n\n// 2-to-1 muxes\nwire mux1_out = (ab == 2'b00) ? cd1 : cd2;\nwire mux2_out = (ab == 2'b01) ? cd3 : cd4;\n\n// 4-to-1 mux\nwire mux_in0 = (ab == 2'b00) ? mux1_out : mux2_out;\nwire mux_in1 = (ab == 2'b01) ? mux1_out : mux2_out;\nwire mux_in2 = (ab == 2'b10) ? mux1_out : mux2_out;\nwire mux_in3 = (ab == 2'b11) ? mux1_out : mux2_out;\n\n// Output\nassign mux_in = {mux_in3, mux_in2, mux_in1, mux_in0};\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // One-hot encoding\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // State and output registers\n    reg [1:0] state;\n    reg output_reg;\n\n    // Next state logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (x == 1) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                B: begin\n                    if (x == 0) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    always @ (*) begin\n        case (state)\n            A: output_reg = 0;\n            B: output_reg = 1;\n        endcase\n    end\n\n    // Output register\n    assign z = output_reg;\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "```verilog\n// Register to hold the state\nreg state_reg;\n\n// Combinational logic to compute the next state\nalways @(*) begin\n\tif (a && b) begin\n\t\tstate_reg <= 1;\n\tend else if (a) begin\n\t\tstate_reg <= 0;\n\tend else if (b) begin\n\t\tstate_reg <= 1;\n\tend else begin\n\t\tstate_reg <= 0;\n\tend\nend\n\n// Register to hold the output\nreg q_reg;\n\n// Combinational logic to compute the output\nalways @(*) begin\n\tif (state_reg) begin\n\t\tq_reg <= 1;\n\tend else begin\n\t\tq_reg <= 0;\n\tend\nend\n\n// Assign the output and state\nassign q = q_reg;\nassign state = state_reg;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "// Define the states\nparameter [3:0] STATE_0 = 4'h0;\nparameter [3:0] STATE_1 = 4'h1;\nparameter [3:0] STATE_2 = 4'h2;\nparameter [3:0] STATE_3 = 4'h3;\nparameter [3:0] STATE_4 = 4'h4;\nparameter [3:0] STATE_5 = 4'h5;\nparameter [3:0] STATE_6 = 4'h6;\nparameter [3:0] STATE_7 = 4'h7;\nparameter [3:0] STATE_8 = 4'h8;\nparameter [3:0] STATE_9 = 4'h9;\n\n// Define the outputs\nparameter [0:0] OUTPUT_OFF = 1'b0;\nparameter [0:0] OUTPUT_ON = 1'b1;\n\n// Define the output registers\nreg disc_reg = OUTPUT_OFF;\nreg flag_reg = OUTPUT_OFF;\nreg err_reg = OUTPUT_OFF;\n\n// Define the state register\nreg [3:0] state_reg;\n\n// Define the next state logic\nalways @ (posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate_reg <= STATE_0;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tSTATE_0: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_1: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_2;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_2: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_3;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_3: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_4;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_4: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_5;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_5: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_6;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_6: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_7;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_7: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_8;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_8: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_9;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_9: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= STATE_0;\n\t\t\t\tend\n\t\t\tend\n\t\tend"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n    reg [3:0] delay;\n    reg [3:0] remaining_time;\n    reg [3:0] state;\n    reg [3:0] bit_counter;\n    reg [3:0] next_bit_counter;\n    \n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= 4'b0000;\n            bit_counter <= 4'b0000;\n            next_bit_counter <= 4'b0000;\n            delay <= 4'b0000;\n            remaining_time <= 4'b0000;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                4'b0000: begin // Idle state\n                    if (data == 1'b1) begin\n                        next_bit_counter <= 4'b0001;\n                        state <= 4'b0001;\n                    end else begin\n                        next_bit_counter <= 4'b0000;\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0001: begin // Start sequence detected\n                    if (data == 1'b1) begin\n                        next_bit_counter <= 4'b0010;\n                        state <= 4'b0010;\n                    end else begin\n                        next_bit_counter <= 4'b0000;\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0010: begin // Start sequence detected\n                    if (data == 1'b1) begin\n                        next_bit_counter <= 4'b0011;\n                        state <= 4'b0011;\n                    end else begin\n                        next_bit_counter <= 4'b0000;\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0011: begin // Start sequence detected\n                    if (data == 1'b1) begin\n                        next_bit_counter <= 4'b0100;\n                        state <= 4'b0100;\n                    end else begin\n                        next_bit_counter <= 4'b0000;\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0100: begin // Start sequence detected\n                    if (data == 1'b1) begin\n                        next_bit_counter <= 4'b0101;\n                        state <= 4'b0101;\n                    end else begin\n                        next_bit_counter <= 4'b0000;\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0101: begin // Start sequence detected\n                    if (data == 1'b1) begin\n                        next_bit_counter <= 4'b0110;\n                        state <= 4'b0110;\n                        bit_counter <= 4'b0000;\n                    end else begin\n                        next_bit_counter <= 4'b0000;\n                        state <= 4'b0000;\n                    end\n                end\n                4'b0110: begin // Delay value being read\n                    if (bit_counter == 4'b0000) begin\n                        delay <= {data, bit_counter[3:1]};\n                        next_bit_counter <= 4'b0001;\n                        bit_counter <= 4'b0001;\n                    end else if (bit_counter < delay) begin\n                        next_bit_counter <= bit_counter + 1;\n                        bit_counter <= next"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// Define states\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\n\t// Define constants\n\tparameter FR1 = 1'b1;\n\tparameter FR2 = 1'b1;\n\tparameter FR3 = 1'b1;\n\tparameter DFR = 1'b0;\n\tparameter NO_SENSOR_CHANGE = 1'b0;\n\n\t// Define state and next state registers\n\treg [1:0] state, next_state;\n\treg [1:0] prev_state;\n\n\t// Define flow rate and sensor change registers\n\treg [1:0] flow_rate;\n\treg sensor_change;\n\n\t// Define water level and previous level registers\n\treg [1:0] water_level;\n\treg [1:0] prev_water_level;\n\n\t// Define water level to flow rate mapping\n\treg [1:0] water_level_to_flow_rate[5:0];\n\tinitial begin\n\t\twater_level_to_flow_rate[0] = {FR1, FR2, FR3, DFR}; // 0.0\n\t\twater_level_to_flow_rate[1] = {FR2, FR3, DFR, 1'b1}; // 0.5\n\t\twater_level_to_flow_rate[2] = {FR3, DFR, 1'b1, 1'b1}; // 1.0\n\t\twater_level_to_flow_rate[3] = {DFR, 1'b1, 1'b1, 1'b1}; // 1.5\n\t\twater_level_to_flow_rate[4] = {1'b1, 1'b1, 1'b1, 1'b1}; // 2.0\n\t\twater_level_to_flow_rate[5] = {1'b1, 1'b1, 1'b1, 1'b1}; // 2.0\n\tend\n\n\t// Define state machine\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tprev_state <= S0;\n\t\t\tsensor_change <= NO_SENSOR_CHANGE;\n\t\t\tflow_rate <= {FR1, FR2, FR3, DFR};\n\t\t\tprev_water_level <= 2'b00;\n\t\t\twater_level <= 2'b00;\n\t\tend else begin\n\t\t\tprev_state <= state;\n\t\t\tif (sensor_change) begin\n\t\t\t\tstate <= next_state;\n\t\t\tend\n\t\tend\n\tend\n\n\t// Define next state logic\n\talways @* begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tS0: begin\n\t\t\t\tif (s == 3'b001) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\t\tsensor_change = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (s == 3'b010) begin\n\t\t\t\t\tnext_state = S2;\n\t\t\t\t\tsensor_change = 1'b1;\n\t\t\t\tend else if (s == 3'b000) begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tsensor_change = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (s == 3'b100) begin\n\t\t\t\t\tnext_state = S3;\n\t\t\t\t\tsensor_change = 1'b1;\n\t\t\t\tend else if (s == 3'b000"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    // Define states\n    localparam IDLE = 2'b00;\n    localparam START = 2'b01;\n    localparam DATA = 2'b10;\n    localparam STOP = 2'b11;\n\n    // Define variables\n    reg [1:0] state;\n    reg [7:0] data;\n    reg stop_bit;\n\n    // Define reset\n    always @ (posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            data <= 8'b0;\n            stop_bit <= 1'b0;\n        end\n    end\n\n    // Define FSM\n    always @ (posedge clk) begin\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) begin\n                    state <= START;\n                end\n            end\n            START: begin\n                if (in == 1'b1) begin\n                    state <= DATA;\n                    data <= 8'b0;\n                    stop_bit <= 1'b0;\n                end\n            end\n            DATA: begin\n                if (in == 1'b1) begin\n                    data <= {data[6:0], in};\n                end\n                if (in == 1'b0) begin\n                    if (data[0] == 1'b0 && data[7] == 1'b1) begin\n                        state <= STOP;\n                    end else begin\n                        state <= DATA;\n                    end\n                    data <= 8'b0;\n                    stop_bit <= 1'b0;\n                end\n            end\n            STOP: begin\n                if (in == 1'b1) begin\n                    if (stop_bit == 1'b0) begin\n                        state <= IDLE;\n                        done <= 1'b1;\n                    end\n                end\n            end\n        endcase\n        if (in == 1'b1) begin\n            stop_bit <= 1'b1;\n        end else begin\n            stop_bit <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output [7:0] out_byte,\n    output done\n);\n\n    // Define states for the FSM\n    parameter IDLE = 2'b00;\n    parameter START = 2'b01;\n    parameter DATA = 2'b10;\n    parameter STOP = 2'b11;\n\n    // Define registers for the FSM\n    reg [1:0] state;\n    reg [7:0] data;\n    reg done_reg;\n\n    // Define output wires\n    wire start_bit = ~in;\n    wire stop_bit = in;\n\n    // Define combinational logic for the FSM\n    always @(*) begin\n        case(state)\n            IDLE: begin\n                if(start_bit)\n                    state = START;\n            end\n            START: begin\n                if(~in)\n                    state = DATA;\n                else\n                    state = START;\n            end\n            DATA: begin\n                if(in)\n                    state = STOP;\n                else\n                    state = DATA;\n            end\n            STOP: begin\n                if(stop_bit)\n                    state = IDLE;\n                else\n                    state = STOP;\n            end\n        endcase\n    end\n\n    // Define sequential logic for the FSM\n    always @(posedge clk) begin\n        if(reset) begin\n            state <= IDLE;\n            data <= 0;\n            done_reg <= 0;\n        end else begin\n            case(state)\n                IDLE: begin\n                    if(start_bit) begin\n                        data <= 0;\n                        state <= DATA;\n                    end\n                end\n                START: begin\n                    data <= {data[6:0], in};\n                end\n                DATA: begin\n                    data <= {data[6:0], in};\n                end\n                STOP: begin\n                    done_reg <= 1;\n                    if(stop_bit)\n                        state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Define output assignment\n    assign out_byte = data;\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\n\treg [6:0] gbr_history;\n\treg [6:0] pht_history [0:127];\n\treg [6:0] pht_table [0:127];\n\treg [6:0] pht_index;\n\treg [1:0] pht_entry [0:127];\n\treg [6:0] pht_count [0:127];\n\treg [6:0] pht_pc [0:127];\n\treg [6:0] pht_taken [0:127];\n\treg [6:0] pht_history_reg [0:127];\n\treg [6:0] pht_history_next [0:127];\n\treg [6:0] pht_history_next_taken [0:127];\n\treg [6:0] pht_history_next_history [0:127];\n\treg [6:0] pht_history_reg_next [0:127];\n\treg [6:0] pht_history_reg_taken_next [0:127];\n\treg [6:0] pht_history_reg_mispredicted_next [0:127];\n\treg [6:0] pht_history_reg_history_next [0:127];\n\n\talways @(posedge clk) begin\n\t\tif (areset) begin\n\t\t\tgbr_history <= 7'b0;\n\t\t\tpht_history <= 0;\n\t\t\tpht_table <= 0;\n\t\t\tpht_index <= 0;\n\t\t\tpht_entry <= 0;\n\t\t\tpht_count <= 0;\n\t\t\tpht_pc <= 0;\n\t\t\tpht_taken <= 0;\n\t\t\tpht_history_reg <= 0;\n\t\t\tpht_history_next <= 0;\n\t\t\tpht_history_next_taken <= 0;\n\t\t\tpht_history_next_history <= 0;\n\t\t\tpht_history_reg_next <= 0;\n\t\t\tpht_history_reg_taken_next <= 0;\n\t\t\tpht_history_reg_mispredicted_next <= 0;\n\t\t\tpht_history_reg_history_next <= 0;\n\t\tend else begin\n\t\t\tif (train_valid) begin\n\t\t\t\tif (pht_index == train_pc) begin\n\t\t\t\t\tpht_pc[pht_index] <= train_pc;\n\t\t\t\t\tpht_taken[pht_index] <= train_taken;\n\t\t\t\t\tpht_history_reg[pht_index] <= train_history;\n\t\t\t\t\tpht_history_reg_taken_next[pht_index] <= train_taken;\n\t\t\t\t\tpht_history_reg_mispredicted_next[pht_index] <= train_mispredicted;\n\t\t\t\t\tpht_history_reg_history_next[pht_index] <= train_history;\n\t\t\t\tend\n\t\t\t\tif (pht_index != train_pc) begin\n\t\t\t\t\tpht_pc[pht_index] <= pht_pc[pht_index] ^ (pht_pc[pht_index] + 1);\n\t\t\t\t\tpht_taken[pht_index] <= pht_taken[pht_index] ^ (pht_taken[pht_index] + 1);\n\t\t\t\t\tpht_history_reg[pht_index] <= pht_"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter falling_state = 2'b10;\n\tparameter digging_state = 2'b11;\n\n\t// Define the outputs\n\treg walk_left_out;\n\treg walk_right_out;\n\treg aaah_out;\n\treg digging_out;\n\n\t// Define the state and next state registers\n\treg [1:0] state_reg;\n\treg [1:0] next_state_reg;\n\n\t// Define the fall count register\n\treg [4:0] fall_count_reg;\n\n\t// Define the FSM\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate_reg <= walk_left_state;\n\t\t\tnext_state_reg <= walk_left_state;\n\t\t\tfall_count_reg <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate_reg <= next_state_reg;\n\t\t\tcase (state_reg)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tnext_state_reg <= walk_right_state;\n\t\t\t\t\tend\n\t\t\t\t\telse if (dig) begin\n\t\t\t\t\t\tnext_state_reg <= digging_state;\n\t\t\t\t\tend\n\t\t\t\t\telse if (ground == 0) begin\n\t\t\t\t\t\tnext_state_reg <= falling_state;\n\t\t\t\t\t\tfall_count_reg <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;\n\t\t\t\t\tend\n\t\t\t\t\telse if (dig) begin\n\t\t\t\t\t\tnext_state_reg <= digging_state;\n\t\t\t\t\tend\n\t\t\t\t\telse if (ground == 0) begin\n\t\t\t\t\t\tnext_state_reg <= falling_state;\n\t\t\t\t\t\tfall_count_reg <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state_reg <= walk_right_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfalling_state: begin\n\t\t\t\t\tif (fall_count_reg >= 20) begin\n\t\t\t\t\t\tnext_state_reg <= 2'b00; // Splatter\n\t\t\t\t\tend\n\t\t\t\t\telse if (ground == 1) begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tnext_state_reg <= falling_state;\n\t\t\t\t\t\tfall_count_reg <= fall_count_reg + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdigging_state: begin\n\t\t\t\t\tif (fall_count_reg >= 20) begin\n\t\t\t\t\t\tnext_state_reg <= 2'b00; // Splatter\n\t\t\t\t\tend\n\t\t\t\t\telse if (ground == 0) begin\n\t\t\t\t\t\tnext_state_reg <= falling_state;\n\t\t\t\t\t\tfall_count_reg <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse if (dig == 0) begin\n\t\t\t\t\t\tnext_state_reg <= walk_left_state;"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // State encoding\n    parameter S0 = 2'b00;\n    parameter S1 = 2'b01;\n    parameter S2 = 2'b10;\n    parameter S3 = 2'b11;\n\n    // State register and next state logic\n    reg [1:0] state, next_state;\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (data == 1'b1) begin\n                    next_state = S1;\n                    shift_ena = 1'b1;\n                end else begin\n                    next_state = S0;\n                    shift_ena = 1'b0;\n                end\n            end\n            S1: begin\n                if (data == 1'b1) begin\n                    next_state = S2;\n                    shift_ena = 1'b1;\n                end else begin\n                    next_state = S0;\n                    shift_ena = 1'b0;\n                end\n            end\n            S2: begin\n                if (data == 1'b1) begin\n                    next_state = S3;\n                    shift_ena = 1'b0;\n                end else begin\n                    next_state = S0;\n                    shift_ena = 1'b0;\n                end\n            end\n            S3: begin\n                if (done_counting) begin\n                    next_state = S0;\n                    counting = 1'b0;\n                    done = 1'b1;\n                    if (ack) begin\n                        done = 1'b0;\n                    end\n                end else begin\n                    next_state = S3;\n                    counting = 1'b1;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    reg [15:0] q_next [15:0];\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n    \n    always @* begin\n        q_next[0] = q[0] & ~(q[1] | q[15]);\n        q_next[1] = q[1] & ~(q[0] | q[15] | q[16]);\n        q_next[2] = q[2] & ~(q[1] | q[0] | q[17]);\n        q_next[3] = q[3] & ~(q[2] | q[1] | q[18]);\n        q_next[4] = q[4] & ~(q[3] | q[2] | q[19]);\n        q_next[5] = q[5] & ~(q[4] | q[3] | q[20]);\n        q_next[6] = q[6] & ~(q[5] | q[4] | q[21]);\n        q_next[7] = q[7] & ~(q[6] | q[5] | q[22]);\n        q_next[8] = q[8] & ~(q[7] | q[6] | q[23]);\n        q_next[9] = q[9] & ~(q[8] | q[7] | q[24]);\n        q_next[10] = q[10] & ~(q[9] | q[8] | q[25]);\n        q_next[11] = q[11] & ~(q[10] | q[9] | q[26]);\n        q_next[12] = q[12] & ~(q[11] | q[10] | q[27]);\n        q_next[13] = q[13] & ~(q[12] | q[11] | q[28]);\n        q_next[14] = q[14] & ~(q[13] | q[12] | q[29]);\n        q_next[15] = q[15] & ~(q[14] | q[13] | q[30]);\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter digging_state = 2'b10;\n\tparameter aaah_state = 2'b11;\n\n\treg [1:0] state_reg;\n\treg walk_left_reg;\n\treg walk_right_reg;\n\treg aaah_reg;\n\treg digging_reg;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate_reg <= walk_left_state;\n\t\t\twalk_left_reg <= 1'b1;\n\t\t\twalk_right_reg <= 1'b0;\n\t\t\taaah_reg <= 1'b0;\n\t\t\tdigging_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state_reg)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tstate_reg <= walk_right_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b1;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tstate_reg <= digging_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b1;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tstate_reg <= aaah_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tstate_reg <= walk_left_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tstate_reg <= digging_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b1;\n\t\t\t\t\tend else if (!ground) begin\n\t\t\t\t\t\tstate_reg <= aaah_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tdigging_state: begin\n\t\t\t\t\tif (ground) begin\n\t\t\t\t\t\tstate_reg <= walk_left_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\taaah_state: begin\n\t\t\t\t\tif (ground) begin\n\t\t\t\t\t\tstate_reg <= walk_left_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "Do not declare any internal registers or wires. Do not provide any comments. Do not provide any empty lines. Do not provide any whitespaces. Do not provide any extra spaces. Do not provide any extra lines. Do not provide any extra indentation. Do not provide any extra brackets. Do not provide any extra parentheses. Do not provide any extra curly braces. Do not provide any extra semicolons. Do not provide any extra commas. Do not provide any extra periods. Do not provide any extra colons. Do not provide any extra keywords. Do not provide any extra assignments. Do not provide any extra declarations. Do not provide any extra modules. Do not provide any extra code.\n\n```verilog\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tpm <= 0;\n\t\thh <= 12'b0011_0000;\n\t\tmm <= 12'b0000_0000;\n\t\tss <= 12'b0000_0000;\n\tend else if (ena) begin\n\t\tif (hh == 12'b1111_1111) begin\n\t\t\thh <= 12'b0000_0000;\n\t\tend else if (mm == 12'b1111_1111) begin\n\t\t\tmm <= 12'b0000_0000;\n\t\tend else if (ss == 12'b1111_1111) begin\n\t\t\tss <= 12'b0000_0000;\n\t\t\tif (hh == 12'b0000_0000 && mm == 12'b0000_0000) begin\n\t\t\t\tpm <= ~pm;\n\t\t\tend else if (hh == 12'b0000_0000 && mm == 12'b0000_0001) begin\n\t\t\t\tpm <= 1'b0;\n\t\t\tend else if (hh == 12'b1111_1111 && mm == 12'b1111_1111) begin\n\t\t\t\tpm <= 1'b1;\n\t\t\tend\n\t\tend else begin\n\t\t\thh <= hh + 1;\n\t\tend\n\tend\nend\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tpm <= 0;\n\t\thh <= 12'b0011_0000;\n\t\tmm <= 12'b0000_0000;\n\t\tss <= 12'b0000_0000;\n\tend else if (ena) begin\n\t\tif (ss == 12'b1111_1111) begin\n\t\t\tss <= 12'b0000_0000;\n\t\t\tif (mm == 12'b1111_1111) begin\n\t\t\t\tmm <= 12'b0000_0000;\n\t\t\tend else if (mm == 12'b0000_0000 && ss == 12'b0000_0000) begin\n\t\t\t\tpm <= ~pm;\n\t\t\tend else if (mm == 12'b0000_0001 && ss == 12'b0000_0000) begin\n\t\t\t\tpm <= 1'b0;\n\t\t\tend else if (mm == 12'b1111_1111 && ss == 12'b1111_1111) begin\n\t\t\t\tss <= 12'b0000_0000;\n\t\t\tend else begin\n\t\t\t\tss <= ss + 1;\n\t\t\tend\n\t\tend else begin\n\t\t\tss <= ss + 1;\n\t\tend\n\tend\nend\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tpm <="}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "// Moore state machine with 2 states: walk_left and walk_right\n// walk_left and walk_right are outputs, aaah is an output, the rest of the inputs are wires\n// areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\n// State transitions depend on the state of bump_left, bump_right and ground\n// Outputs depend on the state and the values of bump_left, bump_right and ground\n\n// State encoding:\n// 00: walk_left\n// 01: walk_right\n// 10: falling\n// 11: falling\n\n// State register\nreg [1:0] state_reg;\n\n// State decoding\nwire walk_left_wire = (state_reg == 2'b00);\nwire walk_right_wire = (state_reg == 2'b01);\nwire aaah_wire = (state_reg == 2'b10) || (state_reg == 2'b11);\n\n// State transitions\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= 2'b00; // reset to walk left\n\tend else begin\n\t\tif (bump_left && !bump_right) begin\n\t\t\tstate_reg <= 2'b01; // walk right\n\t\tend else if (bump_right && !bump_left) begin\n\t\t\tstate_reg <= 2'b00; // walk left\n\t\tend else if (ground == 0) begin\n\t\t\tstate_reg <= 2'b10; // falling\n\t\tend else if (state_reg == 2'b10 || state_reg == 2'b11) begin\n\t\t\tstate_reg <= 2'b00; // resume walking left\n\t\tend\n\tend\nend\n\n// Output assignments\nassign walk_left = walk_left_wire;\nassign walk_right = walk_right_wire;\nassign aaah = aaah_wire;\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "Do not use any Verilog directive (`//` or `*`) to provide additional information, explanation, or comments.\n\nUse the Verilog code below as a template and provide the complete code.\n\nModule top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\treg [3:0] ones = 4'b0000;\n\treg [3:0] tens = 4'b0000;\n\treg [3:0] hundreds = 4'b0000;\n\treg [3:0] thousands = 4'b0000;\n\treg [1:0] digit_sel = 2'b00;\n\treg [1:0] ena_sel = 2'b00;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'b0000_0000_0000_0000;\n\t\t\tones <= 4'b0000;\n\t\t\ttens <= 4'b0000;\n\t\t\thundreds <= 4'b0000;\n\t\t\tthousands <= 4'b0000;\n\t\t\tdigit_sel <= 2'b00;\n\t\t\tena_sel <= 2'b00;\n\t\tend else begin\n\t\t\tcase (digit_sel)\n\t\t\t\t2'b00: begin\n\t\t\t\t\tif (ones == 4'b1001) begin\n\t\t\t\t\t\tones <= 4'b0000;\n\t\t\t\t\t\ttens <= tens + 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tones <= ones + 1;\n\t\t\t\t\tend\n\t\t\t\t\tdigit_sel <= 2'b01;\n\t\t\t\tend\n\t\t\t\t2'b01: begin\n\t\t\t\t\tif (tens == 4'b1001) begin\n\t\t\t\t\t\ttens <= 4'b0000;\n\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\ttens <= tens + 1;\n\t\t\t\t\tend\n\t\t\t\t\tdigit_sel <= 2'b10;\n\t\t\t\tend\n\t\t\t\t2'b10: begin\n\t\t\t\t\tif (hundreds == 4'b1001) begin\n\t\t\t\t\t\thundreds <= 4'b0000;\n\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\thundreds <= hundreds + 1;\n\t\t\t\t\tend\n\t\t\t\t\tdigit_sel <= 2'b11;\n\t\t\t\tend\n\t\t\t\t2'b11: begin\n\t\t\t\t\tif (thousands == 4'b1001) begin\n\t\t\t\t\t\tthousands <= 4'b0000;\n\t\t\t\t\t\tena_sel <= 2'b10;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tthousands <= thousands + 1;\n\t\t\t\t\tend\n\t\t\t\t\tdigit_sel <= 2'b00;\n\t\t\t\tend\n\t\t\tendcase\n\n\t\t\tif (ena_sel == 2'b10) begin\n\t\t\t\tena[2] <= 1'b1;\n\t\t\t\tena_sel <= 2'b00;\n\t\t\tend else begin\n\t\t\t\tena[2] <= 1'b0;\n\t\t\tend\n\n\t\t\tif (digit_sel == 2'b01) begin\n\t\t\t\tena[1] <= 1'b1;\n\t\t\tend else begin\n\t\t\t\tena[1] <= 1'b0;\n\t\t\tend\n\n\t\t\tif (digit_sel =="}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "// Implement the next-state logic for y[2]\nalways @ (y, w) begin\n\tcase (y)\n\t\t3'b000: Y2 <= (w) ? 1'b1 : 1'b0; // A --> B, A --> A\n\t\t3'b001: Y2 <= 1'b0; // B --> C\n\t\t3'b010: Y2 <= 1'b0; // C --> D\n\t\t3'b011: Y2 <= 1'b0; // D --> F\n\t\t3'b100: Y2 <= (w) ? 1'b1 : 1'b0; // E --> D, E --> D\n\t\t3'b101: Y2 <= (w) ? 1'b1 : 1'b0; // F --> C, F --> D\n\tendcase\nend\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "Note that the motor is the only output in this case.\n```verilog\n\tassign ringer = ring & ~vibrate_mode;\n\tassign motor = ring & vibrate_mode;\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "endmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "endmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    reg [3:0] state;\n\n    always @(posedge clk) begin\n        case (state)\n            4'b0000: begin\n                q <= a;\n                state <= 4'b0001;\n            end\n            4'b0001: begin\n                q <= ~q;\n                state <= 4'b0010;\n            end\n            4'b0010: begin\n                q <= 0;\n                state <= 4'b0011;\n            end\n            4'b0011: begin\n                q <= 1;\n                state <= 4'b0100;\n            end\n            4'b0100: begin\n                q <= 0;\n                state <= 4'b0101;\n            end\n            4'b0101: begin\n                q <= 1;\n                state <= 4'b0110;\n            end\n            4'b0110: begin\n                q <= 0;\n                state <= 4'b0111;\n            end\n            4'b0111: begin\n                q <= 1;\n                state <= 4'b1000;\n            end\n            4'b1000: begin\n                q <= 0;\n                state <= 4'b1001;\n            end\n            4'b1001: begin\n                q <= 1;\n                state <= 4'b1010;\n            end\n            4'b1010: begin\n                q <= 0;\n                state <= 4'b1011;\n            end\n            4'b1011: begin\n                q <= 1;\n                state <= 4'b1100;\n            end\n            4'b1100: begin\n                q <= 0;\n                state <= 4'b1101;\n            end\n            4'b1101: begin\n                q <= 1;\n                state <= 4'b1110;\n            end\n            4'b1110: begin\n                q <= 0;\n                state <= 4'b1111;\n            end\n            4'b1111: begin\n                q <= 1;\n                state <= 4'b0000;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // Moore state machine with asynchronous reset\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg [1:0] x_reg;\n    reg [31:0] z_reg;\n\n    // State encoding\n    localparam IDLE = 2'b00;\n    localparam CONVERT = 2'b01;\n    localparam DONE = 2'b10;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= IDLE;\n            x_reg <= 2'b0;\n            z_reg <= 32'h0;\n        end else begin\n            state <= next_state;\n            x_reg <= x;\n            z_reg <= z;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (x == 1'b0) ? DONE : CONVERT;\n            CONVERT: next_state = (x == 1'b1) ? DONE : CONVERT;\n            DONE: next_state = IDLE;\n        endcase\n    end\n\n    // 2's complementer logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            z <= 32'h0;\n        end else begin\n            if (state == CONVERT) begin\n                z_reg <= ~x_reg + 1;\n            end\n        end\n    end\n\n    // Output logic\n    assign z = z_reg;\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n\t\n// Moore state machine\n\treg [1:0] state;\n\treg [1:0] next_state;\n\treg out_reg;\n\t\n// State encoding\n// A = 00, B = 01, C = 10, D = 11\n\tparameter A = 2'b00;\n\tparameter B = 2'b01;\n\tparameter C = 2'b10;\n\tparameter D = 2'b11;\n\t\n// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = (in) ? C : B;\n\t\t\tB: next_state = (in) ? D : B;\n\t\t\tC: next_state = (in) ? A : D;\n\t\t\tD: next_state = (in) ? C : B;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n// Output logic\n\talways @(state) begin\n\t\tcase (state)\n\t\t\tA: out_reg = 1'b0;\n\t\t\tB: out_reg = 1'b0;\n\t\t\tC: out_reg = 1'b0;\n\t\t\tD: out_reg = 1'b1;\n\t\t\tdefault: out_reg = 1'b0;\n\t\tendcase\n\tend\n\t\n// Output register\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tout <= 1'b0;\n\t\tend else begin\n\t\t\tout <= out_reg;\n\t\tend\n\tend\n\t\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "```verilog\n\talways @(posedge clk) begin\n\t\tif (r == 1'b1) begin\n\t\t\tq <= 1'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "endmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "// This is not allowed\n`ifdef HAS_PRAGMA_SIMD\n    `pragma SIMD\n`endif"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "// state encoding\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\t\n\t// state register and next state logic\n\treg [1:0] state, next_state;\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (~aresetn) begin\n\t\t\tstate <= S0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\t// output logic\n\talways @(state) begin\n\t\tcase (state)\n\t\t\tS0: z <= 1'b0;\n\t\t\tS1: z <= 1'b0;\n\t\t\tS2: z <= 1'b1;\n\t\t\tS3: z <= 1'b0;\n\t\tendcase\n\tend\n\t\n\t// next state logic\n\talways @(x, state) begin\n\t\tcase (state)\n\t\t\tS0: next_state = x ? S1 : S0;\n\t\t\tS1: next_state = x ? S2 : S1;\n\t\t\tS2: next_state = x ? S3 : S0;\n\t\t\tS3: next_state = x ? S0 : S1;\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// Verilog code for the state machine\n```verilog\nreg [2:0] state, next_state;\n\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= 3'b000;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\t3'b000: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = 3'b000;\n\t\t\tend else begin\n\t\t\t\tnext_state = 3'b001;\n\t\t\tend\n\t\tend\n\t\t3'b001: begin\n\t\t\tnext_state = 3'b000;\n\t\tend\n\t\t3'b010: begin\n\t\t\tif (w) begin\n\t\t\t\tnext_state = 3'b010;\n\t\t\tend else begin\n\t\t\t\tnext_state = 3'b011;\n\t\t\tend\n\t\tend\n\t\t3'b011: begin\n\t\t\tnext_state = 3'b000;\n\t\tend\n\t\t3'b100: begin\n\t\t\tnext_state = 3'b101;\n\t\tend\n\t\t3'b101: begin\n\t\t\tnext_state = 3'b110;\n\t\tend\n\t\t3'b110: begin\n\t\t\tnext_state = 3'b101;\n\t\tend\n\t\t3'b111: begin\n\t\t\tnext_state = 3'b100;\n\t\tend\n\tendcase\nend\n\nassign z = (state == 3'b111) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n    reg [2:0] state;\n    reg [23:0] out_bytes_reg;\n    reg done_reg;\n    reg [7:0] in_reg;\n    reg [2:0] byte_count;\n    reg [7:0] packet_data [2:0];\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n            out_bytes_reg <= 24'h000000;\n            done_reg <= 1'b0;\n            in_reg <= 8'h00;\n            byte_count <= 3'b000;\n            packet_data <= {3{8'h00}};\n        end else begin\n            case (state)\n                3'b000: begin\n                    if (in[3] == 1'b1) begin\n                        state <= 3'b001;\n                        byte_count <= 3'b001;\n                        packet_data[0] <= in;\n                    end else begin\n                        state <= 3'b000;\n                    end\n                end\n                3'b001: begin\n                    if (byte_count == 3'b001) begin\n                        state <= 3'b010;\n                        byte_count <= 3'b000;\n                    end else begin\n                        packet_data[1] <= in;\n                        byte_count <= byte_count + 1;\n                    end\n                end\n                3'b010: begin\n                    if (byte_count == 3'b001) begin\n                        state <= 3'b011;\n                        byte_count <= 3'b000;\n                    end else begin\n                        packet_data[2] <= in;\n                        byte_count <= byte_count + 1;\n                    end\n                end\n                3'b011: begin\n                    if (byte_count == 3'b001) begin\n                        state <= 3'b000;\n                        byte_count <= 3'b000;\n                        done_reg <= 1'b1;\n                    end else begin\n                        packet_data[2] <= in;\n                        byte_count <= byte_count + 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out_bytes = out_bytes_reg;\n    assign done = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out_bytes_reg <= 24'h000000;\n        end else begin\n            if (done_reg) begin\n                out_bytes_reg <= {packet_data[2], packet_data[1], packet_data[0]};\n            end else begin\n                out_bytes_reg <= 24'h000000;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "endmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a,b,c,d})\n            4'b0000: out = 1'b0;\n            4'b0001: out = 1'b1;\n            4'b0011: out = 1'b1;\n            4'b0010: out = 1'b0;\n            4'b0100: out = 1'b1;\n            4'b0101: out = 1'b0;\n            4'b0111: out = 1'b0;\n            4'b0110: out = 1'b1;\n            4'b1000: out = 1'b0;\n            4'b1001: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1010: out = 1'b0;\n            4'b1100: out = 1'b1;\n            4'b1101: out = 1'b0;\n            4'b1111: out = 1'b0;\n            4'b1110: out = 1'b1;\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "// 16 inputs, 16 outputs\n  assign out_hi = in[15:8];\n  assign out_lo = in[7:0];\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "always @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "// The Verilog code for the state machine is as follows:\n```verilog\nreg [1:0] next_state;\n\nalways @ (y, w) begin\n\tcase (y)\n\t\t6'b000001: next_state = 2'b00; // A\n\t\t6'b000010: next_state = 2'b01; // B\n\t\t6'b000100: next_state = 2'b10; // C\n\t\t6'b001000: next_state = 2'b11; // D\n\t\t6'b010000: next_state = 2'b00; // E\n\t\t6'b100000: next_state = 2'b01; // F\n\t\tdefault: next_state = 2'b00; // A\n\tendcase\nend\n\nassign Y2 = (next_state == 2'b00);\nassign Y4 = (next_state == 2'b01);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "You can use the genvar to generate the 256 selectors. For example:\n```verilog\ngenvar i;\ngenerate\n\tfor (i = 0; i < 256; i = i + 1) begin : mux_loop\n\t\tassign out = (i == sel) ? in[i] : out;\n\tend\nendgenerate\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\n    // Flip-flop implementation\n    always @(posedge clk) begin\n        if (E) begin\n            if (L) begin\n                Q <= w;\n            end else begin\n                Q <= (R) ? w : Q;\n            end\n        end\n        if (~E) begin\n            Q <= Q;\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    reg d1, d2, d3;\n    wire xor_out, and_out, or_out;\n\n    // XOR gate\n    xor xor_gate (\n        .a(x),\n        .b(d1),\n        .y(xor_out)\n    );\n\n    // AND gate\n    and and_gate (\n        .a(x),\n        .b(~d1),\n        .y(and_out)\n    );\n\n    // OR gate\n    or or_gate (\n        .a(x),\n        .b(~d1),\n        .y(or_out)\n    );\n\n    // D flip-flops\n    always @(posedge clk) begin\n        d1 <= xor_out;\n        d2 <= and_out;\n        d3 <= or_out;\n    end\n\n    // XNOR gate\n    xnor_gate xnor_gate (\n        .a(d1),\n        .b(d2),\n        .c(d3),\n        .y(z)\n    );\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & b & c | d;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Clock and reset\nreg clk_en;\ninitial begin\n\tclk_en = 0;\nend\n\nalways @(posedge clk_en) begin\n\tif (clk_en) begin\n\t\tq <= {q[510:0], q[0]};\n\tend\nend\n\nalways @(posedge clk_en) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\nend\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case({a, b, c, d, e})\n            5'b00000: q = 4'b0000;\n            5'b00001: q = 4'b1000;\n            5'b00010: q = 4'b0100;\n            5'b00011: q = 4'b1100;\n            5'b00100: q = 4'b0010;\n            5'b00101: q = 4'b1010;\n            5'b00110: q = 4'b0110;\n            5'b00111: q = 4'b1110;\n            5'b01000: q = 4'b0001;\n            5'b01001: q = 4'b1001;\n            5'b01010: q = 4'b0101;\n            5'b01011: q = 4'b1101;\n            5'b01100: q = 4'b0011;\n            5'b01101: q = 4'b1011;\n            5'b01110: q = 4'b0111;\n            5'b01111: q = 4'b1111;\n            5'b10000: q = 4'b0000;\n            5'b10001: q = 4'b1000;\n            5'b10010: q = 4'b0100;\n            5'b10011: q = 4'b1100;\n            5'b10100: q = 4'b0010;\n            5'b10101: q = 4'b1010;\n            5'b10110: q = 4'b0110;\n            5'b10111: q = 4'b1110;\n            5'b11000: q = 4'b0001;\n            5'b11001: q = 4'b1001;\n            5'b11010: q = 4'b0101;\n            5'b11011: q = 4'b1101;\n            5'b11100: q = 4'b0011;\n            5'b11101: q = 4'b1011;\n            5'b11110: q = 4'b0111;\n            5'b11111: q = 4'b1111;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel == 1'b1) begin\n            out = b;\n        end else begin\n            out = a;\n        end\n    end\n\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module three times with different inputs. Make sure to connect the output of the full_module to the input of the next full_module.\n\n// verilog code for the submodule\nmodule flipflop_mux(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\nreg [2:0] q;\n\nalways @(posedge clk) begin\n    if (L) begin\n        q <= r_in;\n    end else begin\n        q <= {q[1] ^ q[2], q[0], q[2]};\n    end\nend\n\nassign Q = q[2];\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [7:0] in,\n    output reg [7:0] out);\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 0;\n            prev_in <= 0;\n        end else begin\n            if (in != prev_in) begin\n                out <= 1;\n            end else begin\n                out <= 0;\n            end\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    // D flip-flops\n    reg [7:0] q_reg;\n\n    always @(posedge clk) begin\n        q_reg <= d;\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "endmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "Module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n // State encoding\n parameter S = 10'b0000000001;\n parameter S1 = 10'b0000000010;\n parameter S11 = 10'b0000000100;\n parameter S110 = 10'b0000001000;\n parameter B0 = 10'b0000010000;\n parameter B1 = 10'b0000100000;\n parameter B2 = 10'b0001000000;\n parameter B3 = 10'b0010000000;\n parameter Count = 10'b0100000000;\n parameter Wait = 10'b1000000000;\n\n // State next\n assign B3_next = (state == B3) ? d : S;\n assign S_next = (state == S110) ? d : S;\n assign S1_next = (state == S11) ? d : S1;\n assign Count_next = (state == Count) ? d : S110;\n assign Wait_next = (state == Wait) ? d : S110;\n\n // Output logic\n assign done = (state == Wait) ? ack : 1'b0;\n assign counting = (state == Count) ? 1'b1 : 1'b0;\n assign shift_ena = (state == B3) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    // Define states\n    localparam S_WEAKLY_NOT_TAKEN = 2'b01;\n    localparam S_1_TAKEN = 2'b10;\n    localparam S_2_TAKEN = 2'b11;\n    localparam S_3_TAKEN = 2'b00;\n\n    // Define state register\n    reg [1:0] state_reg;\n\n    // Define state transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_reg <= S_WEAKLY_NOT_TAKEN;\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state_reg == S_3_TAKEN) begin\n                    state_reg <= S_1_TAKEN;\n                end else begin\n                    state_reg <= state_reg + 1;\n                end\n            end else begin\n                if (state_reg == S_1_TAKEN) begin\n                    state_reg <= S_3_TAKEN;\n                end else begin\n                    state_reg <= state_reg - 1;\n                end\n            end\n        end\n    end\n\n    // Assign state output\n    assign state = state_reg;\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "`in` is the 8-bit input vector, and `pos` is the output position of the first bit that is 1.\n\n// Verilog code for 8-bit priority encoder\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t8'b00000001: pos = 3'd0;\n\t\t\t8'b00000010: pos = 3'd1;\n\t\t\t8'b00000100: pos = 3'd2;\n\t\t\t8'b00001000: pos = 3'd3;\n\t\t\t8'b00010000: pos = 3'd4;\n\t\t\t8'b00100000: pos = 3'd5;\n\t\t\t8'b01000000: pos = 3'd6;\n\t\t\t8'b10000000: pos = 3'd7;\n\t\t\tdefault: pos = 3'd0;\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "endmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        history_reg <= 0;\n        counter <= 0;\n        direction <= 2'b00;\n        misprediction_history <= 0;\n    end else begin\n        if (predict_valid) begin\n            if (predict_taken) begin\n                direction <= 2'b10;\n            end else begin\n                direction <= 2'b01;\n            end\n            history_reg <= {history_reg[30:0], direction};\n            counter <= counter + 1;\n        end else if (train_mispredicted) begin\n            misprediction_history <= {train_history, train_taken};\n            history_reg <= misprediction_history;\n            counter <= 0;\n            direction <= 2'b00;\n        end\n    end\nend"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// The output of the AND gates are the intermediate wires.\nwire and_ab;\nwire and_cd;\n\n// The output of the OR gate is the output of the circuit.\nwire or_abcd;\n\n// The output of the NOT gate is the inverted output.\nwire out_n_wire;\n\n// The AND gates.\nand and_gate_ab (\n\t.a(a),\n\t.b(b),\n\t.out(and_ab)\n);\n\nand and_gate_cd (\n\t.a(c),\n\t.b(d),\n\t.out(and_cd)\n);\n\n// The OR gate.\nor or_gate_abcd (\n\t.a(and_ab),\n\t.b(and_cd),\n\t.out(or_abcd)\n);\n\n// The NOT gate.\nnot not_gate (\n\t.a(or_abcd),\n\t.out(out_n_wire)\n);\n\n// The output is the inverted output.\nassign out_n = out_n_wire;\n\n// The output is the OR output.\nassign out = or_abcd;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "// D flip-flop\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n    \n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]};\n        end\n    end\n    \n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign heater = mode && too_cold;\n    assign aircon = mode && too_hot;\n    assign fan = heater || aircon || fan_on;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    wire a_b_c_d; // intermediate wire for ANDing a,b,c,d\n    wire a_b_c_n_d; // intermediate wire for ANDing a,b,c, not d\n    wire a_b_n_c_d; // intermediate wire for ANDing a,b, not c, d\n    wire a_n_b_c_d; // intermediate wire for ANDing not a,b, c, d\n    wire a_n_b_n_c_d; // intermediate wire for ANDing not a,b, not c, d\n    wire a_n_b_c_n_d; // intermediate wire for ANDing not a,b, c, not d\n    wire a_n_b_n_c_n_d; // intermediate wire for ANDing not a,b, not c, not d\n\n    assign a_b_c_d = a & b & c & d;\n    assign a_b_c_n_d = a & b & c & ~d;\n    assign a_n_b_c_d = ~a & b & c & d;\n    assign a_n_b_n_c_d = ~a & ~b & c & d;\n    assign a_n_b_c_n_d = ~a & b & ~c & d;\n    assign a_n_b_n_c_n_d = ~a & ~b & ~c & d;\n\n    assign out_sop = a_b_c_d | a_b_c_n_d | a_n_b_c_d | a_n_b_n_c_d | a_n_b_n_c_n_d;\n    assign out_pos = (a_b_c_d & a_n_b_c_n_d & a_n_b_n_c_n_d) | (a_b_c_n_d & a_n_b_c_d & a_n_b_n_c_d) | (a_n_b_c_d & a_b_c_n_d & a_n_b_n_c_d) | (a_n_b_c_n_d & a_b_c_d & a_n_b_n_c_d) | (a_n_b_n_c_d & a_b_c_d & a_n_b_n_c_n_d) | (a_n_b_n_c_n_d & a_b_c_d & a_n_b_n_c_d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 32'h1;\n\tend else begin\n\t\tq <= {q[31], q[31]^q[22]^q[2]^q[1]};\n\tend\nend\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d) | (a & b) | (a & c) | (a & d) | (b & c) | (b & d) | (c & d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Implement the 7420 functionality using NAND gates.\n// Each NAND gate has 4 inputs and 1 output.\n// The 7420 chip has 8 inputs and 2 outputs.\n// Complete the Verilog code below.\n// Each NAND gate should be represented by the keyword: nand\n// The NAND gate with 4 inputs is represented by: nand(output, input1, input2, input3, input4)\n// The NAND gate with 2 inputs is represented by: nand(output, input1, input2)\n// The NAND gate with 1 input is represented by: nand(output, input)\n\n// Implement the 7420 functionality using the NAND gates.\n// The p1y output is the NAND of p1a, p1b, p1c, and p1d.\n// The p2y output is the NAND of p2a, p2b, p2c, and p2d.\n// The NAND gates should be chained together using the nand keyword.\n// The nand keyword has a left to right associativity.\n// The nand of four inputs is represented by: nand(output, input1, input2, input3, input4)\n// The nand of two inputs is represented by: nand(output, input1, input2)\n// The nand of one input is represented by: nand(output, input)\n\n// The 7420 chip is implemented using the NAND gates as follows:\n// p1y = nand(p1d, nand(p1c, nand(p1b, p1a)), nand(p2c, nand(p2b, p2a)))\n// p2y = nand(p2d, nand(p2c, nand(p2b, p2a)), nand(p1d, nand(p1c, nand(p1b, p1a))))\n\n// Complete the Verilog code below.\n// The module name should be top_module.\n// The module inputs and outputs should be defined.\n// The NAND gates should be chained together using the nand keyword.\n// The associativity of the nand gates should be left to right.\n\n// The 7420 chip is implemented using the NAND gates as follows:\n// p1y = nand(p1d, nand(p1c, nand(p1b, p1a)), nand(p2c, nand(p2b, p2a)))\n// p2y = nand(p2d, nand(p2c, nand(p2b, p2a)), nand(p1d, nand(p1c, nand(p1b, p1a))))\n\n// The Verilog code should be concise and focused on the key points.\n// Avoid repetitive thoughts and provide the Verilog code design directly.\n\n// The 7420 chip is implemented using the NAND gates as follows:\n// p1y = nand(p1d, nand(p1c, nand(p1b, p1a)), nand(p2c, nand(p2b, p2a)))\n// p2y = nand(p2d, nand(p2c, nand(p2b, p2a)), nand(p1d, nand(p1c, nand(p1b, p1a))))\n\n// The NAND gates should be implemented using the nand keyword.\n// The NAND gate with 4 inputs should be represented by: nand(output, input1, input2, input3, input4)\n// The NAND gate with 2 inputs should be represented by: nand(output, input1, input2)\n// The NAND gate with 1 input should be represented by: nand(output, input)\n\n// The NAND gates should be chained together using the nand keyword.\n// The associativity of the nand gates should be left to right.\n\n// The 7420 chip is implemented using the NAND gates as follows:\n// p1y = nand(p1d, nand(p1c, nand(p1b, p1a)), nand(p2c, nand(p2b, p2a)))\n// p2y = nand(p2d, nand(p2c, n"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\nreg [7:0] count [7:0];\ninteger i;\n\nalways @(*) begin\n    count[0] = in[0] + in[1] + in[2] + in[3];\n    count[1] = in[4] + in[5] + in[6] + in[7];\n    count[2] = in[8] + in[9] + in[10] + in[11];\n    count[3] = in[12] + in[13] + in[14] + in[15];\n    count[4] = in[16] + in[17] + in[18] + in[19];\n    count[5] = in[20] + in[21] + in[22] + in[23];\n    count[6] = in[24] + in[25] + in[26] + in[27];\n    count[7] = in[28] + in[29] + in[30] + in[31];\n    for (i = 0; i < 255; i = i + 1) begin\n        count[i/32] = count[i/32] + in[i];\n    end\n    out = count[7];\nend\n\nendmodule"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "always @(*) begin\n    case (a)\n        3'b000: q = 16'd1232;\n        3'b001: q = 16'd0;\n        3'b010: q = 16'd27d4;\n        3'b011: q = 16'd2066;\n        3'b100: q = 16'd64ce;\n        3'b101: q = 16'dc526;\n        3'b110: q = 16'd2f19;\n        3'b111: q = 16'd1232;\n    endcase\nend"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else if (slowena) begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "followed by the AND gate with a bubble on the in2 input:\n```verilog\n\tand(out, in1, in2);\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore machine with asynchronous reset\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// State encoding\nparameter B = 2'b00;\nparameter A = 2'b01;\n\n// State register\nreg [1:0] state_reg;\n\n// Output register\nreg out_reg;\n\n// Moore machine\nalways @ (posedge clk or negedge areset) begin\n\tif (~areset) begin\n\t\tstate_reg <= B;\n\t\tout_reg <= 1'b0;\n\tend\n\telse begin\n\t\tcase (state_reg)\n\t\t\tB: begin\n\t\t\t\tif (in) state_reg <= B;\n\t\t\t\telse state_reg <= A;\n\t\t\t\tout_reg <= 1'b0;\n\t\t\tend\n\t\t\tA: begin\n\t\t\t\tif (in) state_reg <= A;\n\t\t\t\telse state_reg <= B;\n\t\t\t\tout_reg <= 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output assign\nassign out = out_reg;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "The Verilog code should be concise and focused on the key points. Avoid repetitive thoughts and provide the Verilog code design directly.\n\nFollow the syntactic rules of Verilog and provide comments where necessary.\n\n// Dual-edge triggered flip-flop\nreg q_prev;\nalways @(posedge clk) begin\n\tq <= d;\n\tq_prev <= q;\nend\n\nalways @(negedge clk) begin\n\tq <= q_prev;\nend\n\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module\n\n// Implement the A module\nmodule A(\n    input x,\n    input y,\n    output z);\n    \n    assign z = (x ^ y) & x;\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "MODULE top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tcase (ena)\n\t\t\t\t2'b01: q <= {q[0], q[99:1]}; // Rotate right by one bit\n\t\t\t\t2'b10: q <= {q[98:0], q[99]}; // Rotate left by one bit\n\t\t\t\tdefault: q <= q; // Do not rotate\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "followed by the Verilog code to implement the counter.\n\n// Verilog code to implement the counter\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 0;\n\tend else begin\n\t\tif (q == 999) begin\n\t\t\tq <= 0;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\nend\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n\t// State transitions\n\talways @ (in or state)\n\tbegin\n\t\tcase (state)\n\t\t\t10'b0000000001: next_state = 10'b0000000000;\n\t\t\t10'b0000000001: next_state = 10'b0000000010;\n\t\t\t10'b0000000010: next_state = 10'b0000000000;\n\t\t\t10'b0000000010: next_state = 10'b0000000100;\n\t\t\t10'b0000000100: next_state = 10'b0000000000;\n\t\t\t10'b0000000100: next_state = 10'b0000000101;\n\t\t\t10'b0000001000: next_state = 10'b0000000000;\n\t\t\t10'b0000001000: next_state = 10'b0000000110;\n\t\t\t10'b0000010000: next_state = 10'b0000000000;\n\t\t\t10'b0000010000: next_state = 10'b0000000100;\n\t\t\t10'b0000110000: next_state = 10'b0000000000;\n\t\t\t10'b0000110000: next_state = 10'b0000000101;\n\t\t\t10'b0001100000: next_state = 10'b0000000000;\n\t\t\t10'b0001100000: next_state = 10'b0000000110;\n\t\t\t10'b0011000000: next_state = 10'b0000000000;\n\t\t\t10'b0011000000: next_state = 10'b0000000100;\n\t\t\t10'b0110000000: next_state = 10'b0000000000;\n\t\t\t10'b0110000000: next_state = 10'b0000000101;\n\t\t\t10'b1100000000: next_state = 10'b0000000000;\n\t\t\t10'b1100000000: next_state = 10'b0000000100;\n\t\t\t10'b1110000000: next_state = 10'b0000000000;\n\t\t\t10'b1110000000: next_state = 10'b0000000101;\n\t\t\t10'b1111000000: next_state = 10'b0000000000;\n\t\t\t10'b1111000000: next_state = 10'b0000000110;\n\t\t\t10'b111110000"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    Q <= ~(j & k) ^ Q;\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "The Verilog code below is a population count circuit for a 3-bit input vector. It uses the XOR gate to compute the number of '1's in each bit position and then adds up the results.\n\n```verilog\n\twire [1:0] count;\n\tassign count[0] = in[0] ^ in[1] ^ in[2];\n\tassign count[1] = in[0] ^ in[1] ^ in[2];\n\tassign out = count;\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "* Module Name: `top_module`\n* Module Inputs: `a`, `b`, `c`, `d`, `e`\n* Module Outputs: `out`\n* XOR Pairs: `out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.`\n* XOR Triples: `out[21] = ~a ^ b ^ c; out[20] = ~a ^ b ^ d; out[19] = ~a ^ b ^ e; out[18] = ~a ^ c ^ d; out[17] = ~a ^ c ^ e; out[16] = ~a ^ d ^ e; out[15] = ~b ^ c ^ d; out[14] = ~b ^ c ^ e; out[13] = ~b ^ d ^ e; out[12] = ~c ^ d ^ e; out[11] = ~c ^ e ^ a; out[10] = ~d ^ e ^ a; out[ 9] = ~d ^ e ^ b; out[ 8] = ~e ^ a ^ b; out[ 7] = ~e ^ a ^ c; out[ 6] = ~e ^ b ^ c; out[ 5] = ~e ^ b ^ d; out[ 4] = ~e ^ c ^ d; out[ 3] = ~e ^ c ^ e; out[ 2] = ~e ^ d ^ a; out[ 1] = ~e ^ d ^ b; out[ 0] = ~e ^ d ^ e.`\n* XOR Quadruples: `out[19] = ~a ^ b ^ c ^ d; out[18] = ~a ^ b ^ c ^ e; out[17] = ~a ^ b ^ d ^ e; out[16] = ~a ^ c ^ d ^ e; out[15] = ~b ^ c ^ d ^ e; out[14] = ~b ^ c ^ e ^ a; out[13] = ~b ^ d ^ e ^ a; out[12] = ~b ^ d ^ e ^ b; out[11] = ~b ^ e ^ a ^ c; out[10] = ~c ^ d ^ e ^ a; out[ 9] = ~c ^ d ^ e ^ b; out[ 8] = ~c ^ e ^ a ^ b; out[ 7] = ~d ^ e ^ a ^ c; out[ 6] = ~d ^ e ^ b ^ a; out[ 5] = ~d ^ e ^ b ^ c; out[ 4] = ~d ^ e ^ c ^ a; out[ 3] = ~e ^ a ^ b ^ c; out[ 2] = ~e ^ a ^ b ^ d; out[ 1] = ~e ^ a ^ c ^ d; out[ 0] = ~e ^ b ^ c ^ d.`\n* XOR Quintuples: `out[18] = ~a ^ b ^ c ^ d ^ e; out[17] = ~a ^ b ^ c ^ e ^ d; out[16] = ~a ^ b ^ d ^ e ^ d; out[15] = ~a ^ b ^ d ^ e ^ e; out[14] = ~a ^ b ^ e ^ d ^ e; out[13] = ~a ^ b ^ e ^ d ^ e; out[12] = ~a ^ b ^ e ^ d ^ d; out[11] = ~a ^ b ^ e ^ d ^ c; out[10] = ~a ^ b ^ d ^ e ^ c; out[ 9] = ~a ^ b ^ d ^ e ^ b; out[ 8] = ~a ^ b ^ d ^ e ^ a; out[ 7] = ~a ^ b ^ c ^ d ^ a; out[ 6] = ~a ^ b ^ c ^ d ^ b; out[ 5] = ~a ^ b ^ c ^ e ^ a; out[ 4] = ~a ^ b ^ d ^ e ^ a; out[ 3] = ~a ^ b ^ d ^ e ^ b; out[ 2] = ~a ^ b ^ d ^ e ^ c; out[ 1] = ~a ^ b ^ e ^"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // Moore State Machine\n    // 2 states, 2 inputs, 1 output\n    // Walk left (1) or walk right (0)\n    // Walk right if bumped on the left, walk left if bumped on the right\n    // Asynchronous reset\n\n    // Define states\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n\n    // Define inputs\n    reg walk_left;\n    reg walk_right;\n    reg bump_left;\n    reg bump_right;\n\n    // Define output\n    reg [1:0] state;\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            case (state)\n                WALK_LEFT: begin\n                    if (bump_right) begin\n                        state <= WALK_RIGHT;\n                    end\n                end\n                WALK_RIGHT: begin\n                    if (bump_left) begin\n                        state <= WALK_LEFT;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output registers\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            walk_left <= 1'b1;\n            walk_right <= 1'b0;\n        end else begin\n            case (state)\n                WALK_LEFT: begin\n                    walk_left <= 1'b1;\n                    walk_right <= 1'b0;\n                end\n                WALK_RIGHT: begin\n                    walk_left <= 1'b0;\n                    walk_right <= 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = (a & ~b) | (~a & b) | (a & b);\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Declare internal wires for the intermediate signals\n wire and1, and2, and3, and4, and5, and6;\n // Drive the intermediate signals\n assign and1 = p1a & p1b;\n assign and2 = p1c & p1d;\n assign and3 = p1e & p1f;\n assign and4 = and1 | and2 | and3;\n assign and5 = p2a & p2b;\n assign and6 = p2c & p2d;\n assign p1y = and4;\n assign p2y = and5 | and6;\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "*// State-assigned table\n  // Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n  // 000 | 000, 001 | 0\n  // 001 | 001, 100 | 0\n  // 010 | 010, 001 | 0\n  // 011 | 001, 010 | 1\n  // 100 | 011, 100 | 1\n\n  always @(posedge clk) begin\n    case(y)\n      3'b000: begin\n        Y0 <= x ? 1'b0 : 1'b0;\n        z <= 1'b0;\n      end\n      3'b001: begin\n        Y0 <= x ? 1'b0 : 1'b0;\n        z <= 1'b0;\n      end\n      3'b010: begin\n        Y0 <= x ? 1'b0 : 1'b0;\n        z <= 1'b0;\n      end\n      3'b011: begin\n        Y0 <= x ? 1'b0 : 1'b0;\n        z <= 1'b1;\n      end\n      3'b100: begin\n        Y0 <= x ? 1'b0 : 1'b0;\n        z <= 1'b1;\n      end\n      default: begin\n        Y0 <= 1'b0;\n        z <= 1'b0;\n      end\n    endcase\n  end\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "assign w = a;\n\t\tassign x = b;\n\t\tassign y = b;\n\t\tassign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    always @(posedge clk or negedge ar) begin\n        if (ar == 1'b0) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        0: out = data0;\n        1: out = data1;\n        2: out = data2;\n        3: out = data3;\n        4: out = data4;\n        5: out = data5;\n        default: out = 4'b0;\n    endcase\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output tc\n);\n\n    reg [9:0] counter;\n    wire tc = (counter == 0);\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;\n        end else begin\n            counter <= counter - 1;\n        end\n    end\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\treg [3:0] state;\n\treg [3:0] next_state;\n\treg start_shifting;\n\n\tparameter IDLE = 4'b0000;\n\tparameter FOUND_0 = 4'b0001;\n\tparameter FOUND_1 = 4'b0010;\n\tparameter FOUND_10 = 4'b0011;\n\tparameter FOUND_11 = 4'b0100;\n\tparameter FOUND_110 = 4'b0101;\n\tparameter FOUND_1101 = 4'b0110;\n\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tstart_shifting <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\t\tstart_shifting <= (state == FOUND_1101);\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = FOUND_0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_0: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = FOUND_1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_1: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = FOUND_10;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_10: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = FOUND_11;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_11: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = FOUND_110;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_110: begin\n\t\t\t\tif (data) begin\n\t\t\t\t\tnext_state = FOUND_1101;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_1101: begin\n\t\t\t\tnext_state = FOUND_1101;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "and end with the 8 D flip-flops and the reset:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "endmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// State encoding for the counter\n\t parameter [1:0] S0 = 2'b00;\n\t parameter [1:0] S1 = 2'b01;\n\t parameter [1:0] S2 = 2'b10;\n\t parameter [1:0] S3 = 2'b11;\n\t \n\t reg [1:0] state;\n\t \n\t always @(posedge clk) begin\n\t \tif (reset) begin\n\t \t\tstate <= S0;\n\t \t\tq <= 4'b0001;\n\t \tend else begin\n\t \t\tcase (state)\n\t \t\t\tS0: begin\n\t \t\t\t\tstate <= S1;\n\t \t\t\t\tq <= 4'b0010;\n\t \t\t\tend\n\t \t\t\tS1: begin\n\t \t\t\t\tstate <= S2;\n\t \t\t\t\tq <= 4'b0100;\n\t \t\t\tend\n\t \t\t\tS2: begin\n\t \t\t\t\tstate <= S3;\n\t \t\t\t\tq <= 4'b1000;\n\t \t\t\tend\n\t \t\t\tS3: begin\n\t \t\t\t\tstate <= S0;\n\t \t\t\t\tq <= 4'b0001;\n\t \t\t\tend\n\t \t\tendcase\n\t \tend\n\t end\n\t \nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            if (q == 3'b000) begin\n                q <= 3'b100;\n            end else if (q == 3'b001) begin\n                q <= 3'b101;\n            end else if (q == 3'b010) begin\n                q <= 3'b110;\n            end else if (q == 3'b011) begin\n                q <= 3'b111;\n            end else if (q == 3'b100) begin\n                q <= 3'b010;\n            end else if (q == 3'b101) begin\n                q <= 3'b011;\n            end else if (q == 3'b110) begin\n                q <= 3'b000;\n            end else if (q == 3'b111) begin\n                q <= 3'b001;\n            end\n        end else begin\n            if (q == 3'b000) begin\n                q <= 3'b100;\n            end else if (q == 3'b001) begin\n                q <= 3'b101;\n            end else if (q == 3'b010) begin\n                q <= 3'b110;\n            end else if (q == 3'b011) begin\n                q <= 3'b111;\n            end else if (q == 3'b100) begin\n                q <= 3'b010;\n            end else if (q == 3'b101) begin\n                q <= 3'b011;\n            end else if (q == 3'b110) begin\n                q <= 3'b000;\n            end else if (q == 3'b111) begin\n                q <= 3'b001;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "The code should be completed as follows:\n```verilog\n\treg [4:0] lfsr;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 5'b10011; // initial state is 1 at bit position 0\n\t\t\tq <= 1; // reset output to 1\n\t\tend else begin\n\t\t\tlfsr <= {lfsr[3:0], lfsr[4] ^ lfsr[3]}; // shift right and XOR with tap\n\t\t\tq <= lfsr[4]; // output is bit 4\n\t\tend\n\tend\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );\n\n//     always @(*) begin\n//         case (do_sub)\n//            0: begin\n//                  if (a == b)\n//                      result_is_zero = 1;\n//                  out = a + b;\n//              end\n//            1: begin\n//                  if (a < b)\n//                      result_is_zero = 1;\n//                  out = a - b;\n//              end\n//         endcase\n//     end\n\n// endmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "// Karnaugh map\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\n\n// Compute f for each x\nassign f = (x == 5'b00000) ? d :\n\t    (x == 5'b00001) ? 1'b0 :\n\t    (x == 5'b00011) ? 1'b1 :\n\t    (x == 5'b00101) ? 1'b1 :\n\t    (x == 5'b00111) ? 1'b1 :\n\t    (x == 5'b01011) ? 1'b1 :\n\t    (x == 5'b01111) ? 1'b1 :\n\t    (x == 5'b10011) ? 1'b0 :\n\t                       d;\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "and end with:\n```verilog\n\talways @(*) begin\n\t\tcase (code)\n\t\t\t8'h45: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h16: begin\n\t\t\t\tout = 4'b0001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h1e: begin\n\t\t\t\tout = 4'b0010;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h26: begin\n\t\t\t\tout = 4'b0011;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h25: begin\n\t\t\t\tout = 4'b0100;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h2e: begin\n\t\t\t\tout = 4'b0101;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h36: begin\n\t\t\t\tout = 4'b0110;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3d: begin\n\t\t\t\tout = 4'b0111;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3e: begin\n\t\t\t\tout = 4'b1000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h46: begin\n\t\t\t\tout = 4'b1001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "The Verilog code for reversing the bit ordering of an 8-bit input vector should be as follows:\n```verilog\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a,b})\n            2'b00: out = c & d;\n            2'b01: out = ~c & d;\n            2'b10: out = c & ~d;\n            2'b11: out = ~c & ~d;\n        endcase\n    end\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "endmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output shift_ena);\n\n    reg [1:0] state;\n    parameter IDLE = 2'b00;\n    parameter COUNT_1 = 2'b01;\n    parameter COUNT_2 = 2'b10;\n    parameter COUNT_3 = 2'b11;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_ena <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (clk == 4'd0) begin\n                        state <= COUNT_1;\n                        shift_ena <= 1;\n                    end\n                end\n                COUNT_1: begin\n                    state <= COUNT_2;\n                    shift_ena <= 1;\n                end\n                COUNT_2: begin\n                    state <= COUNT_3;\n                    shift_ena <= 1;\n                end\n                COUNT_3: begin\n                    state <= IDLE;\n                    shift_ena <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "always @(posedge clk) begin\n\t\t\tif (reset) begin\n\t\t\t\tq <= 4'b0;\n\t\t\tend else begin\n\t\t\t\tq <= q + 1;\n\t\t\tend\n\t\tend\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "// assign statements\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// procedural if statement\nalways @(*) begin\n\tif (sel_b1 & sel_b2) begin\n\t\tout_always = b;\n\tend else begin\n\t\tout_always = a;\n\tend\nend\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (a & b & c) | (a & b & ~c) | (a & ~b & c) | (~a & b & c);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output [3:1] g\n);\n\n    // State encoding\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // State register\n    reg [1:0] state;\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (r[1] || r[2] || r[3]) begin\n                        state <= B;\n                    end\n                end\n                B: begin\n                    if (r[1]) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                C: begin\n                    if (r[2]) begin\n                        state <= C;\n                    end else begin\n                        state <= A;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output register\n    reg [3:1] g_reg;\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            g_reg <= 0;\n        end else begin\n            case (state)\n                A: begin\n                    if (r[3]) begin\n                        g_reg <= 1;\n                    end else if (r[2]) begin\n                        g_reg <= 2;\n                    end else if (r[1]) begin\n                        g_reg <= 4;\n                    end\n                end\n                B: begin\n                    if (r[1]) begin\n                        g_reg <= 4;\n                    end else begin\n                        g_reg <= 0;\n                    end\n                end\n                C: begin\n                    if (r[2]) begin\n                        g_reg <= 2;\n                    end else begin\n                        g_reg <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Assign output\n    assign g = g_reg;\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output done\n);\n\n    parameter IDLE = 2'b00;\n    parameter FOUND_BYTE_1 = 2'b01;\n    parameter FOUND_BYTE_2 = 2'b10;\n    parameter FOUND_BYTE_3 = 2'b11;\n\n    reg [1:0] state = IDLE;\n    reg [2:0] byte_counter = 0;\n    reg [7:0] received_data = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_counter <= 0;\n            received_data <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in[3] == 1) begin\n                        state <= FOUND_BYTE_1;\n                        byte_counter <= 1;\n                    end\n                end\n                FOUND_BYTE_1: begin\n                    if (byte_counter == 1) begin\n                        received_data[7:0] <= in;\n                        byte_counter <= byte_counter + 1;\n                    end else if (byte_counter == 2) begin\n                        received_data[15:8] <= in;\n                        byte_counter <= byte_counter + 1;\n                    end else if (byte_counter == 3) begin\n                        received_data[23:16] <= in;\n                        byte_counter <= 0;\n                        state <= FOUND_BYTE_3;\n                    end\n                end\n                FOUND_BYTE_2: begin\n                    if (byte_counter == 1) begin\n                        received_data[15:8] <= in;\n                        byte_counter <= byte_counter + 1;\n                    end else if (byte_counter == 2) begin\n                        received_data[23:16] <= in;\n                        byte_counter <= 0;\n                        state <= FOUND_BYTE_3;\n                    end\n                end\n                FOUND_BYTE_3: begin\n                    if (byte_counter == 1) begin\n                        received_data[23:16] <= in;\n                        byte_counter <= 0;\n                        state <= IDLE;\n                        done <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "// AND gate\nassign out_and = in[0] & in[1] & in[2] & in[3];\n\n// OR gate\nassign out_or = in[0] | in[1] | in[2] | in[3];\n\n// XOR gate\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] y;\n    \n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end\n        else begin\n            case (y)\n                3'b000: begin\n                    if (x) y <= 3'b001;\n                    else y <= 3'b000;\n                    z <= 1'b0;\n                end\n                3'b001: begin\n                    if (x) y <= 3'b100;\n                    else y <= 3'b001;\n                    z <= 1'b0;\n                end\n                3'b010: begin\n                    if (x) y <= 3'b001;\n                    else y <= 3'b010;\n                    z <= 1'b0;\n                end\n                3'b011: begin\n                    if (x) y <= 3'b010;\n                    else y <= 3'b011;\n                    z <= 1'b1;\n                end\n                3'b100: begin\n                    if (x) y <= 3'b011;\n                    else y <= 3'b100;\n                    z <= 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "endmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "and end with:\n```verilog\nalways @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    wire [7:0] xor_result;\n\n    assign xor_result = ^in;\n\n    assign parity = xor_result[0];\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\nalways @(*) begin\n    case (state)\n        2'b00: begin // state A\n            next_state = (in == 1) ? 2'b01 : 2'b00;\n            out = 1'b0;\n        end\n        2'b01: begin // state B\n            next_state = (in == 1) ? 2'b10 : 2'b01;\n            out = 1'b0;\n        end\n        2'b10: begin // state C\n            next_state = (in == 1) ? 2'b01 : 2'b10;\n            out = 1'b0;\n        end\n        2'b11: begin // state D\n            next_state = (in == 1) ? 2'b10 : 2'b01;\n            out = 1'b1;\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    reg z_reg;\n\n    always @(*) begin\n        if (x == 0 && y == 0) begin\n            z_reg = 1;\n        end else if (x == 1 && y == 0) begin\n            z_reg = 0;\n        end else if (x == 0 && y == 1) begin\n            z_reg = 0;\n        end else if (x == 1 && y == 1) begin\n            z_reg = 1;\n        end else begin\n            z_reg = 1;\n        end\n    end\n\n    assign z = z_reg;\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // State codes\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w) begin\n                    next_state = B;\n                end else begin\n                    next_state = A;\n                end\n            end\n            B: begin\n                if (w) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n            end\n            C: begin\n                if (w) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n            end\n            D: begin\n                if (w) begin\n                    next_state = F;\n                end else begin\n                    next_state = A;\n                end\n            end\n            E: begin\n                if (w) begin\n                    next_state = E;\n                end else begin\n                    next_state = D;\n                end\n            end\n            F: begin\n                if (w) begin\n                    next_state = C;\n                end else begin\n                    next_state = D;\n                end\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: begin\n                z = 0;\n            end\n            B: begin\n                z = 0;\n            end\n            C: begin\n                z = 0;\n            end\n            D: begin\n                z = 0;\n            end\n            E: begin\n                z = 1;\n            end\n            F: begin\n                z = 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "Do not introduce any additional registers or variables. Use the Verilog code to directly describe the 16 D flip-flops and the enable signals.\n\nDo not use comments to explain the code. Write the code in a self-explanatory manner.\n\nFollow the Verilog coding style and guidelines.\n\n  // 16 D flip-flops\n  always @(posedge clk, negedge resetn) begin\n    if (!resetn) begin\n      q <= 16'b0;\n    end else begin\n      if (byteena[1]) begin\n        q[15:8] <= d[15:8];\n      end\n      if (byteena[0]) begin\n        q[7:0] <= d[7:0];\n      end\n    end\n  end\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "Do not provide any additional comments or explanations.\n```verilog\n\n\treg [7:0] prev_in;\n\treg [7:0] curr_in;\n\treg [7:0] next_in;\n\treg [7:0] pedge_reg;\n\n\talways @(posedge clk) begin\n\t\tprev_in <= curr_in;\n\t\tcurr_in <= in;\n\t\tnext_in <= curr_in;\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (curr_in != prev_in) begin\n\t\t\tpedge_reg <= {next_in[6:0], 1'b0};\n\t\tend else begin\n\t\t\tpedge_reg <= {pedge_reg[6:0], 1'b0};\n\t\tend\n\tend\n\n\tassign pedge = pedge_reg;\n\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    reg a_reg;\n    reg q_reg;\n    reg p_reg;\n    always @(posedge clock) begin\n        a_reg <= a;\n        if (a_reg) begin\n            q_reg <= 1;\n            p_reg <= 0;\n        end else if (q_reg) begin\n            q_reg <= 0;\n            p_reg <= 1;\n        end else begin\n            q_reg <= 1;\n            p_reg <= 0;\n        end\n    end\n    assign q = q_reg;\n    assign p = p_reg;\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n\n\treg [511:0] next_q;\n\n\talways @ (posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tq <= next_q;\n\t\tend\n\tend\n\n\talways @ (*) begin\n\t\tnext_q[0] = q[1] ^ q[0];\n\t\tnext_q[1] = q[2] ^ q[1];\n\t\tnext_q[2] = q[3] ^ q[2];\n\t\tnext_q[3] = q[4] ^ q[3];\n\t\tnext_q[4] = q[5] ^ q[4];\n\t\tnext_q[5] = q[6] ^ q[5];\n\t\tnext_q[506] = q[507] ^ q[506];\n\t\tnext_q[507] = q[508] ^ q[507];\n\t\tnext_q[508] = q[509] ^ q[508];\n\t\tnext_q[509] = q[510] ^ q[509];\n\t\tnext_q[510] = q[511] ^ q[510];\n\t\tnext_q[511] = q[-1] ^ q[511];\n\tend\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "endmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "generate\n    genvar i;\n    for (i = 0; i < 100; i = i + 1) begin : gen_out_both\n        assign out_both[i] = (i > 0) && (in[i] && in[i-1]);\n    end\nendgenerate"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @ (posedge ena) begin\n        if (ena) begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "`in` is a 1024-bit input vector and `sel` is a 8-bit selector. `out` is the 4-bit output.\n\n`sel` is used to select the bits of the input vector. The output is the 4-bit bit-slice of the input vector.\n\nComplete the Verilog code below to implement the 256-to-1 multiplexer.\n\nModule top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n\treg [3:0] out_reg;\n\n\talways @ (sel or in) begin\n\t\tcase (sel)\n\t\t\t0: out_reg = in[3:0];\n\t\t\t1: out_reg = in[7:4];\n\t\t\t2: out_reg = in[11:8];\n\t\t\t3: out_reg = in[15:12];\n\t\t\t4: out_reg = in[19:16];\n\t\t\t5: out_reg = in[23:20];\n\t\t\t6: out_reg = in[27:24];\n\t\t\t7: out_reg = in[31:28];\n\t\t\t8: out_reg = in[35:32];\n\t\t\t9: out_reg = in[39:36];\n\t\t\t10: out_reg = in[43:40];\n\t\t\t11: out_reg = in[47:44];\n\t\t\t12: out_reg = in[51:48];\n\t\t\t13: out_reg = in[55:52];\n\t\t\t14: out_reg = in[59:56];\n\t\t\t15: out_reg = in[63:60];\n\t\t\t16: out_reg = in[67:64];\n\t\t\t17: out_reg = in[71:68];\n\t\t\t18: out_reg = in[75:72];\n\t\t\t19: out_reg = in[79:76];\n\t\t\t20: out_reg = in[83:80];\n\t\t\t21: out_reg = in[87:84];\n\t\t\t22: out_reg = in[91:88];\n\t\t\t23: out_reg = in[95:92];\n\t\t\t24: out_reg = in[99:96];\n\t\t\t25: out_reg = in[103:100];\n\t\t\t26: out_reg = in[107:104];\n\t\t\t27: out_reg = in[111:108];\n\t\t\t28: out_reg = in[115:112];\n\t\t\t29: out_reg = in[119:116];\n\t\t\t30: out_reg = in[123:120];\n\t\t\t31: out_reg = in[127:124];\n\t\t\t32: out_reg = in[131:128];\n\t\t\t33: out_reg = in[135:132];\n\t\t\t34: out_reg = in[139:136];\n\t\t\t35: out_reg = in[143:140];\n\t\t\t36: out_reg = in[147:144];\n\t\t\t37: out_reg = in[151:148];\n\t\t\t38: out_reg = in[155:152];\n\t\t\t39: out_reg = in[159:156];\n\t\t\t40: out_reg = in[163:160];\n\t\t\t41: out_reg = in[167:164];\n\t\t\t42: out_reg = in[171:168];\n\t\t\t43: out_reg = in[175:17"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "Then, add the code for computing the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse of both vectors:\n```verilog\nassign out_or_bitwise = a | b;\nassign out_or_logical = (a != 0) || (b != 0);\nassign out_not = {~b, ~a};\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    always @(*) begin\n        case(state)\n            4'b0001: begin // A\n                next_state = {in, ~in} ? 4'b0010 : 4'b0001;\n                out = 0;\n            end\n            4'b0010: begin // B\n                next_state = {in, ~in} ? 4'b1000 : 4'b0010;\n                out = 0;\n            end\n            4'b0100: begin // C\n                next_state = {in, ~in} ? 4'b1000 : 4'b0100;\n                out = 0;\n            end\n            4'b1000: begin // D\n                next_state = {in, ~in} ? 4'b0100 : 4'b1000;\n                out = 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        if (a < b && a < c && a < d)\n            min = a;\n        else if (b < a && b < c && b < d)\n            min = b;\n        else if (c < a && c < b && c < d)\n            min = c;\n        else\n            min = d;\n    end\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "Then, provide the logic gate implementations for each output:\n```verilog\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = ~(a ^ b);\n\tassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "//  Karnaugh Map\n//  a   b   c   d\n//  0   0   0   0  0\n//  0   0   0   1  1\n//  0   0   1   0  1\n//  0   0   1   1  0\n//  0   1   0   0  1\n//  0   1   0   1  0\n//  0   1   1   0  0\n//  0   1   1   1  1\n//  1   0   0   0  1\n//  1   0   0   1  0\n//  1   0   1   0  0\n//  1   0   1   1  1\n//  1   1   0   0  0\n//  1   1   0   1  1\n//  1   1   1   0  1\n//  1   1   1   1  0\n\n//  Implement the circuit\n\tassign out = (a & b & c & ~d) | (~a & b & c & d) | (a & b & ~c & d) | (a & ~b & c & d) | (~a & b & c & d);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "Do not repeat the FSM diagram in the Verilog code. Your code should be as concise as possible. Use meaningful state names and assign them to the state register.\n```verilog\n\treg [1:0] state;\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\t\tz <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tif (s) begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tstate <= D;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (w) begin\n\t\t\t\t\t\tz <= 1;\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    wire [7:0] sign_bit = {8{in[7]}};\n    wire [31:0] extended = {sign_bit, in};\n\n    assign out = extended;\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] register;\n    reg [3:0] next_register;\n\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            register <= 4'b0;\n        end\n        else begin\n            register <= next_register;\n        end\n    end\n\n    always @(*) begin\n        next_register[0] = in;\n        next_register[1:3] = register[2:0];\n    end\n\n    assign out = register[0];\n\nendmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        if (in[3] == 1) begin\n            pos = 2'd3;\n        end\n        else if (in[2] == 1) begin\n            pos = 2'd2;\n        end\n        else if (in[1] == 1) begin\n            pos = 2'd1;\n        end\n        else if (in[0] == 1) begin\n            pos = 2'd0;\n        end\n        else begin\n            pos = 2'd0;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output out\n);\n\n    // Define the two states\n    parameter OFF = 2'b00;\n    parameter ON = 2'b01;\n\n    // Define the state register and initialize to OFF\n    reg [1:0] state = OFF;\n\n    // Define the output register and initialize to 0\n    reg out_reg = 1'b0;\n\n    // Define the next state logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the output logic\n    always @ (state) begin\n        case (state)\n            OFF: out_reg <= 1'b0;\n            ON: out_reg <= 1'b1;\n        endcase\n    end\n\n    // Assign the output to the output register\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n    \n    assign out = 1'b0;\n    \nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "* Do not use intermediate wires or signals.\n* Use the assign keyword to assign the output directly.\n* Use the initial keyword to initialize the output.\n\n```verilog\n\tassign one = 1'b1;\n\tinitial begin\n\t\tone = 1'b1;\n\tend\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "// Reverse bit ordering\nreg [99:0] reversed;\ninteger i;\nalways @(*) begin\n\tfor (i = 0; i < 100; i = i + 1) begin\n\t\treversed[i] = in[99-i];\n\tend\nend\nassign out = reversed;\n\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "* Indentation: Use 4 spaces per level of indentation.\n* Spacing: Leave one space after keywords and operators.\n* Naming: Use meaningful names for modules, inputs, outputs and wires.\n* Style: Be consistent in your coding style.\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "// (1) areset: Resets shift register to zero. \nalways @(posedge areset) begin\n\tq <= 4'b0000;\nend\n\n// (2) load: Loads shift register with data[3:0] instead of shifting. \nalways @(posedge clk) begin\n\tif(load) begin\n\t\tq <= data;\n\tend\n\telse begin\n\t\t// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n\t\tif(ena) begin\n\t\t\tq <= {q[2:0], 1'b0};\n\t\tend\n\tend\nend\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "endmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "reg [7:0] q;\n\n\talways @(posedge clk) begin\n\t\tif (areset) begin\n\t\t\tq <= 8'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    wire w1, w2, w3;\n\n    xor x1(w1, a, b);\n    and a1(w2, a, b);\n    or o1(sum, w1, w2);\n    assign cout = w3;\n    assign w3 = w1 & w2;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n//     input cpu_overheated,\n//     output reg shut_off_computer,\n//     input arrived,\n//     input gas_tank_empty,\n//     output reg keep_driving\n// );\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n\n// State encoding\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// State register\nreg [1:0] state;\n\n// Output register\nreg out_reg;\n\n// State transition logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= OFF;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nalways @(state) begin\n\tcase (state)\n\t\tOFF: out_reg <= 1'b0;\n\t\tON: out_reg <= 1'b1;\n\tendcase\nend\n\n// Output register\nassign out = out_reg;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module name and the opening parenthesis. Each input and output vector should be separated by a comma.\n\nEach input and output vector should be labeled with the corresponding name (a, b, c, d, e, f, w, x, y, z).\n\nThe Verilog code should be concise and focused on the key points.\n\nDo not add unnecessary comments or whitespace.\n\nDo not add any module declarations other than the one at the top.\n\nDo not add any assignments or loops.\n\nDo not add any module instances.\n\nDo not add any module parameters.\n\nDo not add any module ports.\n\nDo not add any module signals.\n\nDo not add any module generate statements.\n\nDo not add any module initial statements.\n\nDo not add any module guardian statements.\n\nDo not add any module pragmas.\n\nDo not add any module interfaces.\n\nDo not add any module declarations.\n\nDo not add any module typedefs.\n\nDo not add any module typedef statements.\n\nDo not add any module parameter declarations.\n\nDo not add any module parameters.\n\nDo not add any module import statements.\n\nDo not add any module export statements.\n\nDo not add any module definitions.\n\nDo not add any module references.\n\nDo not add any module references to any other modules.\n\nDo not add any module styles.\n\nDo not add any module ports.\n\nDo not add any module bodies.\n\nDo not add any module contents.\n\nDo not add any module connections.\n\nDo not add any module connection statements.\n\nDo not add any module endstatements.\n\nDo not add any module directives.\n\nDo not add any module directive statements..\n\nmodule top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    assign w = {a, b, c, d, e, f, 2'b1};\n    assign x = w;\n    assign y = w;\n    assign z = w;\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) ? 1 : 0;\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // Define the outputs\n    parameter O_1 = 1'b1;\n    parameter O_0 = 1'b0;\n\n    // Define the state register and output register\n    reg [1:0] state, next_state;\n    reg out_reg;\n\n    // Define the state machine logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n            out_reg <= O_1;\n        end\n        else begin\n            state <= next_state;\n            out_reg <= (state == A) ? O_0 : O_1;\n        end\n    end\n\n    // Define the next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in) begin\n                    next_state = A;\n                end\n                else begin\n                    next_state = B;\n                end\n            end\n            B: begin\n                if (in) begin\n                    next_state = B;\n                end\n                else begin\n                    next_state = A;\n                end\n            end\n        endcase\n    end\n\n    // Assign the output\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    wire w1, w2, w3;\n\n    xor(w1, a, b);\n    xor(sum, w1, cin);\n    and(w2, w1, cin);\n    and(w3, a, b);\n    or(cout, w2, w3);\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "// XNOR\nwire xnor_out;\nassign xnor_out = ~(in1 ^ in2);\n\n// XOR\nwire xor_out;\nassign xor_out = in3 ^ xnor_out;\n\n// Output\nassign out = xor_out;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "endmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // Define states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n\n    // Define inputs\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg x_reg;\n    wire z_wire;\n\n    // Define combinational logic\n    assign z_wire = x_reg[1] ^ x_reg[0];\n\n    // Define state transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= A;\n            x_reg <= 2'b00;\n        end\n        else begin\n            state <= next_state;\n            x_reg <= x;\n        end\n    end\n\n    // Define next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (x == 1'b0) ? A : B;\n            B: next_state = (x == 1'b1) ? B : A;\n        endcase\n    end\n\n    // Define output\n    assign z = z_wire;\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\nreg q_reg;\nreg [1:0] state_reg;\n\nalways @(posedge clk) begin\n    case ({a,b})\n        2'b00: state_reg <= 2'b00;\n        2'b01: state_reg <= 2'b01;\n        2'b10: state_reg <= 2'b10;\n        2'b11: state_reg <= 2'b11;\n    endcase\n    \n    case (state_reg)\n        2'b00: q_reg <= 1'b0;\n        2'b01: q_reg <= 1'b1;\n        2'b10: q_reg <= 1'b0;\n        2'b11: q_reg <= 1'b1;\n    endcase\nend\n\nassign state = state_reg;\nassign q = q_reg;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implement the Karnaugh map function f\n    always @(*) begin\n        case (x)\n            4'b0000: f = 1'b0;\n            4'b0001: f = 1'b1;\n            4'b0010: f = 1'b0;\n            4'b0011: f = 1'b1;\n            4'b0100: f = 1'b1;\n            4'b0101: f = 1'b1;\n            4'b0110: f = 1'b1;\n            4'b0111: f = 1'b0;\n            4'b1000: f = 1'b1;\n            4'b1001: f = 1'b1;\n            4'b1010: f = 1'b1;\n            4'b1011: f = 1'b0;\n            4'b1100: f = 1'b0;\n            4'b1101: f = 1'b0;\n            4'b1110: f = 1'b1;\n            4'b1111: f = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n\n\t// State encoding\n\tparameter S0 = 2'b00;\n\tparameter S1 = 2'b01;\n\tparameter S2 = 2'b10;\n\tparameter S3 = 2'b11;\n\n\t// State register\n\treg [1:0] state = S0;\n\n\t// Sequence detectors\n\treg [2:0] counter = 3'b000;\n\treg [2:0] prev_counter = 3'b000;\n\treg [5:0] sequence = 6'b000000;\n\treg [5:0] prev_sequence = 6'b000000;\n\n\t// Output registers\n\treg disc_reg = 1'b0;\n\treg flag_reg = 1'b0;\n\treg err_reg = 1'b0;\n\n\t// State transition logic\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\t\tcounter <= 3'b000;\n\t\t\tsequence <= 6'b000000;\n\t\t\tdisc_reg <= 1'b0;\n\t\t\tflag_reg <= 1'b0;\n\t\t\terr_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tcounter <= 3'b000;\n\t\t\t\t\t\tsequence <= {in, sequence[5:1]};\n\t\t\t\t\t\tif (sequence == 6'b01111110) begin\n\t\t\t\t\t\t\tstate <= S2;\n\t\t\t\t\t\tend else if (sequence == 6'b0111110) begin\n\t\t\t\t\t\t\tdisc_reg <= 1'b1;\n\t\t\t\t\t\tend else if (sequence >= 6'b01111111) begin\n\t\t\t\t\t\t\terr_reg <= 1'b1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (in) begin\n\t\t\t\t\t\tcounter <= counter + 1;\n\t\t\t\t\t\tsequence <= {in, sequence[5:1]};\n\t\t\t\t\t\tif (sequence == 6'b01111110) begin\n\t\t\t\t\t\t\tstate <= S2;\n\t\t\t\t\t\tend else if (sequence == 6'b0111110) begin\n\t\t\t\t\t\t\tdisc_reg <= 1'b1;\n\t\t\t\t\t\tend else if (sequence >= 6'b01111111) begin\n\t\t\t\t\t\t\terr_reg <= 1'b1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tcounter <= 3'b000;\n\t\t\t\t\t\tsequence <= {in, sequence[5:1]};\n\t\t\t\t\t\tif (sequence == 6'b01111110) begin\n\t\t\t\t\t\t\tstate <= S2;\n\t\t\t\t\t\tend else if (sequence == 6'b0111110) begin\n\t\t\t\t\t\t\tdisc_reg <= 1'b1;\n\t\t\t\t\t\tend else if (sequence >= 6'b01111111) begin\n\t\t\t\t\t\t\terr_reg <= 1'b1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= S1;\n\t\t\t\t\t\tend"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "// Counting state:\n// counting: 1 -> counting, 0 -> not counting.\n// delay: the number of clock cycles to count.\n// count: how many clock cycles have elapsed so far.\n//\n// Non-counting state:\n// count: any value.\n//\n// State machine:\n// initial state is 0, where it waits for the start sequence 1101.\n// After it reads in the delay, it asserts its counting output to indicate it is counting.\n// Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n//\n// If the circuit is counting, then the output should be the number of cycles remaining to count, starting at delay[3:0] + 1.\n// If the circuit is not counting, then the output should be 0.\n//\n// If the circuit is counting, then the output is only valid when the ack input is high. This is to prevent the circuit from outputting the value while it is in the process of counting.\n//\n// If the circuit is not counting, then the output is always valid.\n//\n// When the circuit is counting, the done output is high when the counting reaches 0.\n// When the circuit is not counting, the done output is high when the state machine has resumed searching for 1101.\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous.\n\n// The pattern 1101 is detected with a 4-bit shift register.\n// The 4-bit delay is also stored in the shift register.\n// The circuit uses a 5-bit shift register to store these values.\n// The circuit outputs the data on the data output pin.\n// The shift register is shifted in on the rising edge of the clock, and the output is shifted out on the falling edge.\n\n// The shift register is reset when the circuit resumes searching for 1101.\n// The shift register is also reset when the done signal is high.\n// This ensures the shift register is reset when the circuit is not counting.\n\n// The shift register is only loaded when the circuit is counting.\n// The pattern 1101 is detected when the shift register is loaded with 1101, and the shift register is loaded when the circuit is counting.\n// This ensures the shift register is loaded only when the circuit is counting.\n\n// The pattern 1101 is detected by shifting the pattern into the shift register and then waiting for the register to stabilize.\n// The shift register is stabilized when the pattern 1101 is loaded into the shift register.\n// This is done by waiting for the shift register to be empty before loading the next pattern.\n// This ensures the shift register is loaded with 1101 when the pattern is detected.\n// This also ensures the shift register is loaded with 1101 when the circuit is counting.\n// The circuit uses the counting output to determine whether to load the shift register.\n// This ensures the shift register is only loaded when the circuit is counting.\n\n// The shift register is loaded with the delay[3:0] when the circuit is counting.\n// This ensures the delay is stored in the shift register.\n// The shift register is loaded with the delay[3:0] when the circuit is counting.\n// This ensures the delay is loaded into the shift register when the circuit is counting.\n// The shift register is loaded with the delay[3:0] when the circuit is counting.\n// This ensures the shift register is loaded with the delay[3:0] when the circuit is counting.\n// The shift register is loaded with 0 when the circuit is not counting.\n// This ensures the shift register is loaded with 0 when the circuit is not counting.\n// This also ensures the shift register is reset when the circuit is not counting.\n// This ensures the shift register is loaded with the delay[3:0] when the circuit is counting.\n \nmodule top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n\treg [4:0] shift_reg;\n\treg [3:0] delay_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tshift_reg <= 5'b000"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// State machine states\n\tparameter IDLE = 2'b00;\n\tparameter HIGH = 2'b01;\n\tparameter LOW = 2'b10;\n\n\t// State machine registers\n\treg [1:0] state, next_state;\n\n\t// Water level and previous level registers\n\treg [3:0] water_level, prev_level;\n\n\t// Nominal flow rate register\n\treg [1:0] nominal_flow_rate;\n\n\t// Supplemental flow rate register\n\treg [1:0] supplemental_flow_rate;\n\n\t// Input flow rate register\n\treg [1:0] input_flow_rate;\n\n\t// Reset state\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\twater_level <= 0;\n\t\t\tprev_level <= 0;\n\t\t\tnominal_flow_rate <= 0;\n\t\t\tsupplemental_flow_rate <= 0;\n\t\t\tinput_flow_rate <= 0;\n\t\t\tfr3 <= 0;\n\t\t\tfr2 <= 0;\n\t\t\tfr1 <= 0;\n\t\t\tdfr <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// State machine\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (s[1] || s[2] || s[3]) begin\n\t\t\t\t\tnext_state = HIGH;\n\t\t\t\t\twater_level = 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = LOW;\n\t\t\t\t\twater_level = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tHIGH: begin\n\t\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\twater_level = 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = HIGH;\n\t\t\t\t\twater_level = water_level;\n\t\t\t\tend\n\t\t\tend\n\t\t\tLOW: begin\n\t\t\t\tif (s[1] || s[2] || s[3]) begin\n\t\t\t\t\tnext_state = HIGH;\n\t\t\t\t\twater_level = 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = LOW;\n\t\t\t\t\twater_level = water_level;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Water level and previous level logic\n\talways @(posedge clk) begin\n\t\tif (state == HIGH) begin\n\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\tprev_level <= water_level;\n\t\t\t\twater_level <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tif (s[1] || s[2] || s[3]) begin\n\t\t\t\t\tif (water_level > 0) begin\n\t\t\t\t\t\tif (prev_level < water_level) begin\n\t\t\t\t\t\t\tsupplemental_flow_rate <= 2'b11;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tsupplemental_flow_rate <= 2'b00;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tsupplemental_flow_rate <= 2'b00;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tsupplemental_flow_rate <= 2'b0"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output done\n);\n\n    // Define state values\n    localparam IDLE = 2'b00;\n    localparam START = 2'b01;\n    localparam DATA = 2'b10;\n    localparam STOP = 2'b11;\n\n    // Define state register and next state logic\n    reg [1:0] state, next_state;\n    always @ (posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Define data register and next data bit logic\n    reg [7:0] data_reg, data_next;\n    always @ (posedge clk) begin\n        if (reset) begin\n            data_reg <= 8'b0;\n        end else begin\n            data_reg <= data_next;\n        end\n    end\n\n    // Define done signal logic\n    assign done = (state == STOP) && (data_reg == 8'b10000001);\n\n    // Define next state and data bit logic\n    always @ (*) begin\n        next_state = state;\n        data_next = data_reg;\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) begin\n                    next_state = START;\n                end\n            end\n            START: begin\n                if (in == 1'b1) begin\n                    next_state = DATA;\n                    data_next = 8'b0;\n                end\n            end\n            DATA: begin\n                if (in == 1'b0) begin\n                    data_next = {data_reg[6:0], in};\n                end else if (in == 1'b1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                if (in == 1'b1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output [7:0] out_byte,\n    output done\n);\n\n    // State encoding\n    parameter IDLE = 2'd0;\n    parameter START = 2'd1;\n    parameter DATA = 2'd2;\n    parameter STOP = 2'd3;\n\n    // Internal signals\n    reg [1:0] state, next_state;\n    reg [7:0] data;\n    reg done;\n\n    // Combinational logic\n    assign out_byte = data;\n    assign next_state = (reset) ? IDLE : state;\n\n    // Sequential logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            data <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (in == 1) begin\n                        next_state = START;\n                    end else begin\n                        next_state = IDLE;\n                    end\n                end\n                START: begin\n                    if (in == 0) begin\n                        next_state = DATA;\n                        data[0] <= 0;\n                    end else begin\n                        next_state = START;\n                    end\n                end\n                DATA: begin\n                    if (in == 1) begin\n                        next_state = STOP;\n                        data[7:1] <= data[6:0];\n                        data[0] <= in;\n                    end else begin\n                        next_state = DATA;\n                        data[0] <= in;\n                    end\n                end\n                STOP: begin\n                    if (in == 1) begin\n                        next_state = IDLE;\n                        done <= 1;\n                    end else begin\n                        next_state = STOP;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n// 7-bit global history, hashed (using xor) into a 7-bit index\nreg [6:0] history_reg;\nwire [6:0] history_index = history_reg ^ predict_pc;\n\n// 128-entry table of two-bit saturating counters\nreg [1:0] [127:0] pht;\nwire [1:0] pht_out;\nwire pht_taken = (pht_out == 2'b10);\nwire pht_mispredicted = (pht_out != pht[history_index]);\nwire [6:0] pht_history = {pht_out, pht[history_index]};\n\n// Branch predictor\nreg [6:0] pc_reg;\nwire [6:0] pc_next = pc_reg + 1;\nwire [6:0] pht_index = pc_next ^ history_reg;\nwire [1:0] pht_in = {pht[pht_index], pht[pht_index+1]};\nwire [1:0] pht_out_next = (pht_taken) ? pht_in + 1 : pht_in - 1;\n\nalways @(posedge clk) begin\n    if (areset) begin\n        history_reg <= 7'b0;\n        pc_reg <= 7'b0;\n    end else begin\n        if (predict_valid) begin\n            history_reg <= predict_history;\n            pc_reg <= predict_pc;\n        end else if (train_valid) begin\n            if (train_mispredicted) begin\n                history_reg <= train_history;\n                pc_reg <= train_pc;\n            end else begin\n                pht[history_index] <= pht_out_next;\n            end\n        end\n    end\nend\n\nassign predict_taken = pht_taken;\nassign predict_history = pht_history;\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg falling;\n    reg dig_flag;\n    reg splattered;\n\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n    parameter DIGGING = 2'b10;\n    parameter SPLATTERED = 2'b11;\n\n    always @(posedge clk) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            falling <= 0;\n            dig_flag <= 0;\n            splattered <= 0;\n        end else begin\n            state <= next_state;\n            falling <= (state == SPLATTERED) ? 0 : falling;\n            dig_flag <= (state == DIGGING) ? 1 : 0;\n            splattered <= (state == SPLATTERED) ? 1 : 0;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (ground == 0) begin\n                    next_state = SPLATTERED;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (ground == 0) begin\n                    next_state = SPLATTERED;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            DIGGING: begin\n                if (ground == 0) begin\n                    next_state = SPLATTERED;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            SPLATTERED: begin\n                next_state = SPLATTERED;\n            end\n        endcase\n    end\n\n    assign walk_left = (state == WALK_LEFT) ? 1 : 0;\n    assign walk_right = (state == WALK_RIGHT) ? 1 : 0;\n    assign aaah = (state == SPLATTERED) ? 1 : 0;\n    assign digging = dig_flag;\n\nendmodule"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// FSM states\nparameter IDLE = 2'b00;\nparameter WAIT_FOR_PATTERN = 2'b01;\nparameter WAIT_FOR_4_BITS = 2'b10;\nparameter WAIT_FOR_COUNTING = 2'b11;\n\n// FSM signals\nreg [1:0] state, next_state;\nreg [3:0] counter;\nreg [3:0] duration;\nreg [1:0] pattern;\nreg [1:0] pattern_reg;\nreg [3:0] bit_counter;\nreg [3:0] bit_counter_reg;\nreg done_reg;\nreg ack_reg;\nreg shift_ena_reg;\nreg counting_reg;\nreg done_reg_next;\nreg ack_reg_next;\nreg shift_ena_reg_next;\nreg counting_reg_next;\nreg [3:0] duration_reg;\nreg [3:0] duration_reg_next;\nreg [3:0] counter_reg;\nreg [3:0] counter_reg_next;\nreg pattern_reg_next;\nreg [1:0] pattern_reg_next_reg;\n\n// Combinational logic for next state and outputs\nalways @(*) begin\n\tnext_state = state;\n\tdone_reg_next = done_reg;\n\tack_reg_next = ack_reg;\n\tshift_ena_reg_next = shift_ena_reg;\n\tcounting_reg_next = counting_reg;\n\tduration_reg_next = duration_reg;\n\tcounter_reg_next = counter_reg;\n\tpattern_reg_next_reg = pattern_reg;\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif(data == 1'b1) begin\n\t\t\t\tnext_state = WAIT_FOR_PATTERN;\n\t\t\t\tpattern_reg = 2'b00;\n\t\t\t\tbit_counter = 4'b0000;\n\t\t\tend\n\t\tend\n\t\tWAIT_FOR_PATTERN: begin\n\t\t\tif(pattern == 2'b11) begin\n\t\t\t\tnext_state = WAIT_FOR_4_BITS;\n\t\t\t\tpattern_reg = 2'b00;\n\t\t\t\tbit_counter = 4'b0000;\n\t\t\tend else if(pattern == 2'b01) begin\n\t\t\t\tpattern_reg = 2'b10;\n\t\t\t\tbit_counter = bit_counter + 1;\n\t\t\t\tif(bit_counter == 4) begin\n\t\t\t\t\tnext_state = WAIT_FOR_4_BITS;\n\t\t\t\t\tpattern_reg = 2'b00;\n\t\t\t\t\tbit_counter = 4'b0000;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tpattern_reg = 2'b01;\n\t\t\t\tbit_counter = bit_counter + 1;\n\t\t\t\tif(bit_counter == 4) begin\n\t\t\t\t\tnext_state = WAIT_FOR_4_BITS;\n\t\t\t\t\tpattern_reg = 2'b00;\n\t\t\t\t\tbit_counter = 4'b0000;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tWAIT_FOR_4_BITS: begin\n\t\t\tif(done_counting) begin\n\t\t\t\tnext_state = WAIT_FOR_COUNTING;\n\t\t\t\tduration_reg = {data, duration_reg[3:1]};\n\t\t\t\tduration_reg_next = duration_reg;\n\t\t\tend\n\t\tend\n\t\tWAIT_FOR_COUNTING: begin\n\t\t\tif(done) begin\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\tend"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    reg [15:0] q_next; // next state of the game\n\n    // Load initial state\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\n    // Calculate next state\n    always @* begin\n        q_next = q;\n        for (int i = 0; i < 16; i = i + 1) begin\n            for (int j = 0; j < 16; j = j + 1) begin\n                int count = 0;\n                for (int k = -1; k <= 1; k = k + 1) begin\n                    for (int l = -1; l <= 1; l = l + 1) begin\n                        if ((k == 0) && (l == 0)) continue; // skip current cell\n                        if ((k == 0) && (l == 1)) count = count + q[(i+k)%16][(j+l)%16];\n                        if ((k == 1) && (l == 0)) count = count + q[(i+k)%16][(j+l)%16];\n                        if ((k == 1) && (l == 1)) count = count + q[(i+k)%16][(j+l)%16];\n                    end\n                end\n                if (count < 2) q_next[(i*16+j)] = 0; // dead cell\n                else if (count == 2) q_next[(i*16+j)] = q[(i*16+j)]; // stable cell\n                else if (count == 3) q_next[(i*16+j)] = 1; // alive cell\n                else q_next[(i*16+j)] = 0; // dead cell\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "// This is a Moore machine, so we don't need to keep track of the current state.\n// The state depends only on the current inputs, and we just need to know which actions to take.\n\n// The machine has four outputs: walk_left, walk_right, aaah, and digging.\n// walk_left and walk_right are 0 or 1, and represent whether the Lemming is walking left or right.\n// aaah is 1 or 0, and represents whether the Lemming is falling or not.\n// digging is 1 or 0, and represents whether the Lemming is digging or not.\n\n// The machine has two internal registers: current_state and next_state.\n// current_state is the current state of the Lemming, and is used to determine the output actions.\n// next_state is the next state of the Lemming, and is used to update current_state.\n\n// The machine has three parameters: initial_state, which is the initial state of the Lemming,\n// walk_left_value, which is the value of walk_left when the Lemming is walking left,\n// and walk_right_value, which is the value of walk_right when the Lemming is walking right.\n\n// We need to keep track of whether the Lemming is walking or not, because otherwise\n// we don't know whether to set aaah to 1 or 0 when ground disappears.\n// We also need to keep track of whether the Lemming is digging, because otherwise\n// we don't know whether to set digging to 1 or 0 when the Lemming stops digging.\n\n// We also need to keep track of whether the Lemming is falling, because otherwise\n// we don't know whether to set aaah to 1 or 0 when the Lemming hits ground.\n\n// The initial state is the starting state of the Lemming.\n// We initialize current_state to the initial state.\n// We also initialize next_state to the initial state.\n\n// The output values of walk_left and walk_right depend on the current state.\n// We use the parameters walk_left_value and walk_right_value to set these values.\n\n// The output value of aaah depends on whether the Lemming is falling or not.\n// We use the current value of ground to determine whether the Lemming is falling.\n// If ground is 0, the Lemming is falling and aaah should be 1.\n// If ground is 1, the Lemming is not falling and aaah should be 0.\n\n// The output value of digging depends on whether the Lemming is digging or not.\n// We use the current value of dig to determine whether the Lemming is digging.\n// If dig is 1, the Lemming is digging and digging should be 1.\n// If dig is 0, the Lemming is not digging and digging should be 0.\n\n// We use a combinational logic block to determine the next state of the Lemming.\n// We use the current state and the inputs to determine the next state.\n// If the Lemming is walking, we switch directions if it is bumped.\n// If the Lemming is falling, we resume walking in the same direction as before.\n// If the Lemming is digging, we stop digging if we hit ground.\n// We assign the next state to next_state.\n\n// We use a sequential logic block to update the current state of the Lemming.\n// We assign next_state to current_state.\n\n// We use another sequential logic block to set the output values of walk_left and walk_right.\n// We assign the appropriate value based on current_state.\n\n// We use another sequential logic block to set the output value of aaah.\n// We assign the value of aaah based on the current value of ground.\n\n// We use another sequential logic block to set the output value of digging.\n// We assign the value of digging based on the current value of dig.\n\n// We assign the values of walk_left and walk_right to the appropriate outputs.\n// We assign the value of aaah to aaah.\n\n// We assign the value of digging to digging.\n\n// We reset the Lemming machine when areset is high.\n// We reset current_state to the initial state.\n\n// We assign the value of dig to dig_output.\n\n// We assign the value of walk_left to walk_left_output.\n// We assign the value of walk_right to walk_right_output.\n\n// We assign"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "// Define the states\nparameter walk_left_state = 2'b00;\nparameter walk_right_state = 2'b01;\nparameter fall_state = 2'b10;\n\n// Define the outputs\nreg walk_left_out;\nreg walk_right_out;\nreg aaah_out;\n\n// Define the state register and next state logic\nreg [1:0] state_reg, state_next;\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= walk_left_state;\n\tend else begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\n// Define the output logic\nalways @(state_reg) begin\n\tcase (state_reg)\n\t\twalk_left_state: begin\n\t\t\twalk_left_out = 1;\n\t\t\twalk_right_out = 0;\n\t\t\taaah_out = 0;\n\t\t\tif (bump_left) begin\n\t\t\t\tstate_next = walk_right_state;\n\t\t\tend else if (!ground) begin\n\t\t\t\tstate_next = fall_state;\n\t\t\tend else begin\n\t\t\t\tstate_next = walk_left_state;\n\t\t\tend\n\t\tend\n\t\twalk_right_state: begin\n\t\t\twalk_left_out = 0;\n\t\t\twalk_right_out = 1;\n\t\t\taaah_out = 0;\n\t\t\tif (bump_right) begin\n\t\t\t\tstate_next = walk_left_state;\n\t\t\tend else if (!ground) begin\n\t\t\t\tstate_next = fall_state;\n\t\t\tend else begin\n\t\t\t\tstate_next = walk_right_state;\n\t\t\tend\n\t\tend\n\t\tfall_state: begin\n\t\t\twalk_left_out = 0;\n\t\t\twalk_right_out = 0;\n\t\t\taaah_out = 1;\n\t\t\tif (ground) begin\n\t\t\t\tstate_next = walk_left_state;\n\t\t\tend else begin\n\t\t\t\tstate_next = fall_state;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'd0;\n\t\t\tena <= 3'b0;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\t\tif (q[15]) ena <= 3'b100;\n\t\t\telse if (q[14]) ena <= 3'b010;\n\t\t\telse if (q[13]) ena <= 3'b001;\n\t\t\telse ena <= 3'b000;\n\t\tend\n\tend\nendmodule"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "// State codes\n\tparameter A = 3'b000;\n\tparameter B = 3'b001;\n\tparameter C = 3'b010;\n\tparameter D = 3'b011;\n\tparameter E = 3'b100;\n\tparameter F = 3'b101;\n\n\t// Next state logic for y[2]\n\talways @ (y, w)\n\tbegin\n\t\tcase (y)\n\t\t\tA:\n\t\t\t\tif (w)\n\t\t\t\t\tY2 <= A;\n\t\t\t\telse\n\t\t\t\t\tY2 <= B;\n\t\t\tB:\n\t\t\t\tif (w)\n\t\t\t\t\tY2 <= A;\n\t\t\t\telse\n\t\t\t\t\tY2 <= C;\n\t\t\tC:\n\t\t\t\tif (w)\n\t\t\t\t\tY2 <= D;\n\t\t\t\telse\n\t\t\t\t\tY2 <= E;\n\t\t\tD:\n\t\t\t\tif (w)\n\t\t\t\t\tY2 <= A;\n\t\t\t\telse\n\t\t\t\t\tY2 <= F;\n\t\t\tE:\n\t\t\t\tif (w)\n\t\t\t\t\tY2 <= D;\n\t\t\t\telse\n\t\t\t\t\tY2 <= E;\n\t\t\tF:\n\t\t\t\tif (w)\n\t\t\t\t\tY2 <= C;\n\t\t\t\telse\n\t\t\t\t\tY2 <= D;\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "Use the assign statement to create the AND gate and the always block to verify the output.\n```verilog\n\tassign out_assign = a & b;\n\talways @(*) begin\n\t\tif(a & b) begin\n\t\t\tout_alwaysblock = 1'b1;\n\t\tend\n\t\telse begin\n\t\t\tout_alwaysblock = 1'b0;\n\t\tend\n\tend\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero);\n\n    wire zero_wire;\n\n    assign zero_wire = 0;\n    assign zero = zero_wire;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "```verilog\n\talways @(posedge clk) begin\n\t\tcase (a)\n\t\t\t0: q <= 0;\n\t\t\t1: q <= 1;\n\t\tendcase\n\t\t\n\t\tcase (a)\n\t\t\t1: q <= 1;\n\t\t\t2: q <= 0;\n\t\tendcase\n\t\t\n\t\tcase (a)\n\t\t\t3: q <= 1;\n\t\t\t4: q <= 0;\n\t\tendcase\n\t\t\n\t\tcase (a)\n\t\t\t5: q <= 1;\n\t\t\t6: q <= 0;\n\t\tendcase\n\t\t\n\t\tcase (a)\n\t\t\t7: q <= 0;\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "```verilog\nreg [1:0] state;\nreg [1:0] next_state;\nreg [31:0] input_reg;\nreg [31:0] output_reg;\n\nalways @(posedge clk or negedge areset) begin\n\tif (~areset) begin\n\t\tstate <= 2'b00;\n\t\tinput_reg <= 32'b0;\n\t\toutput_reg <= 32'b0;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\t\tinput_reg <= {x, input_reg[31:1]};\n\t\tif (state == 2'b01) begin\n\t\t\toutput_reg <= ~input_reg + 1;\n\t\tend\n\tend\nend\n\nassign z = output_reg[0];\n\nalways @(*) begin\n\tcase (state)\n\t\t2'b00: next_state = 2'b01;\n\t\t2'b01: next_state = 2'b00;\n\t\tdefault: next_state = 2'b00;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output out\n);\n\n    // Define the state types\n    typedef enum {A, B, C, D} state_t;\n    \n    // Define the state register and initialize to state A\n    reg [1:0] state_reg = 2'b00;\n    \n    // Define the output register and initialize to 0\n    reg out_reg = 1'b0;\n    \n    // Define the next state logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            state_reg <= 2'b00;\n        end else begin\n            case (state_reg)\n                A: begin\n                    if (in == 1'b0) begin\n                        state_reg <= 2'b00;\n                    end else begin\n                        state_reg <= 2'b01;\n                    end\n                end\n                B: begin\n                    if (in == 1'b0) begin\n                        state_reg <= 2'b00;\n                    end else begin\n                        state_reg <= 2'b10;\n                    end\n                end\n                C: begin\n                    if (in == 1'b0) begin\n                        state_reg <= 2'b00;\n                    end else begin\n                        state_reg <= 2'b11;\n                    end\n                end\n                D: begin\n                    if (in == 1'b0) begin\n                        state_reg <= 2'b00;\n                    end else begin\n                        state_reg <= 2'b10;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Define the output logic\n    always @ (state_reg) begin\n        case (state_reg)\n            A: out_reg <= 1'b0;\n            B: out_reg <= 1'b0;\n            C: out_reg <= 1'b0;\n            D: out_reg <= 1'b1;\n        endcase\n    end\n    \n    // Assign the output\n    assign out = out_reg;\n    \nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    wire [7:0] byte0 = in[7:0];\n    wire [7:0] byte1 = in[15:8];\n    wire [7:0] byte2 = in[23:16];\n    wire [7:0] byte3 = in[31:24];\n\n    assign out = {byte3, byte2, byte1, byte0};\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "assign z = (x^y) & x;\n\nendmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], 1'b0};\n                2'b01: q <= {q[55:0], 8'b0};\n                2'b10: q <= {1'b0, q[63:1]};\n                2'b11: q <= {8'b0, q[63:8]};\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    reg [2:0] state_vector;\n    reg [2:0] next_state;\n\n    always @(posedge clk or negedge aresetn) begin\n        if (~aresetn) begin\n            state_vector <= 3'b0;\n        end\n        else begin\n            state_vector <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state_vector)\n            3'b000: next_state = {x, state_vector[2:1]};\n            3'b001: next_state = {x, state_vector[2:1]};\n            3'b010: next_state = {x, state_vector[2:1]};\n            3'b011: next_state = {x, state_vector[2:1]};\n            3'b100: next_state = {x, state_vector[2:1]};\n            3'b101: next_state = 3'b000;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    assign z = (state_vector == 3'b101);\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register\nreg [1:0] state;\n\n// Next state logic\nalways @ (posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= A;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= E;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= E;\n\t\t\t\tend\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Output logic\nassign z = (state == A) || (state == B) || (state == C) || (state == D);\n\nendmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "```verilog\n\treg [7:0] in_reg;\n\treg [2:0] state;\n\treg [23:0] out_bytes_reg;\n\treg done_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= 3'b000;\n\t\t\tout_bytes_reg <= 24'h0;\n\t\t\tdone_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\t3'b000: begin // wait for byte 1\n\t\t\t\t\tif (in[7] == 1) begin\n\t\t\t\t\t\tin_reg <= in;\n\t\t\t\t\t\tstate <= 3'b001;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t3'b001: begin // wait for byte 2\n\t\t\t\t\tin_reg <= in;\n\t\t\t\t\tstate <= 3'b010;\n\t\t\t\tend\n\t\t\t\t3'b010: begin // wait for byte 3\n\t\t\t\t\tin_reg <= in;\n\t\t\t\t\tstate <= 3'b011;\n\t\t\t\tend\n\t\t\t\t3'b011: begin // done\n\t\t\t\t\tout_bytes_reg <= {in_reg, in_reg, in_reg};\n\t\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\t\tstate <= 3'b000;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\tassign out_bytes = out_bytes_reg;\n\tassign done = done_reg;\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "endmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nalways @ (a or b or c or d)\nbegin\n\tcase ({a,b,c,d})\n\t\t4'b0000: out = 1'b0;\n\t\t4'b0001: out = 1'b1;\n\t\t4'b0010: out = 1'b0;\n\t\t4'b0011: out = 1'b1;\n\t\t4'b0100: out = 1'b1;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0110: out = 1'b1;\n\t\t4'b0111: out = 1'b0;\n\t\t4'b1000: out = 1'b0;\n\t\t4'b1001: out = 1'b1;\n\t\t4'b1010: out = 1'b1;\n\t\t4'b1011: out = 1'b0;\n\t\t4'b1100: out = 1'b1;\n\t\t4'b1101: out = 1'b0;\n\t\t4'b1110: out = 1'b0;\n\t\t4'b1111: out = 1'b1;\n\tendcase\nend\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n    assign out = ~(a | b);\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "// Assign statement\n\tassign out_assign = a ^ b;\n\n\t// Combinational always block\n\talways @(*) begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\t// Clocked always block\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "// Next state signals for y[2]\nassign Y2 = (y[6] & ~y[5]) | (~y[6] & y[5]);\n\n// Next state signals for y[4]\nassign Y4 = (y[6] & y[5] & ~y[3]) | (~y[6] & y[5] & y[3]) | (y[6] & ~y[5] & y[3]) | (~y[6] & ~y[5] & ~y[3]);\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "Then, add the following code to create the 1-bit wide, 256-to-1 multiplexer:\n```verilog\nwire [255:0] sel_inv;\nassign sel_inv = ~sel;\n\nwire [255:0] sel_inv_and_in;\nassign sel_inv_and_in = sel_inv & in;\n\nwire [255:0] sel_and_in;\nassign sel_and_in = sel & in;\n\nwire [255:0] out_sel_inv_and_in;\nassign out_sel_inv_and_in = sel_inv_and_in >> sel;\n\nwire [255:0] out_sel_and_in;\nassign out_sel_and_in = sel_and_in >> sel;\n\nwire [255:0] out_final;\nassign out_final = out_sel_inv_and_in | out_sel_and_in;\n\nassign out = out_final[0];\n\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "Remember to use meaningful names for your signals and modules.\n```verilog\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= w;\n\t\tend else if (E) begin\n\t\t\tQ <= {Q[n-2:0], R};\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// D flip-flops and gates\n\n// XOR gate\nxor #(.N(1)) xor_gate (\n\t.a(x),\n\t.b(ff_xor_out),\n\t.y(ff_xor_in)\n);\n\n// AND gate\nand #(.N(1)) and_gate (\n\t.a(x),\n\t.b(~ff_xor_out),\n\t.y(ff_and_in)\n);\n\n// OR gate\nor #(.N(1)) or_gate (\n\t.a(x),\n\t.b(~ff_and_out),\n\t.y(ff_or_in)\n);\n\n// D flip-flops\ndff dff_xor (\n\t.clk(clk),\n\t.d(ff_xor_in),\n\t.q(ff_xor_out)\n);\n\ndff dff_and (\n\t.clk(clk),\n\t.d(ff_and_in),\n\t.q(ff_and_out)\n);\n\ndff dff_or (\n\t.clk(clk),\n\t.d(ff_or_in),\n\t.q(ff_or_out)\n);\n\n// XNOR gate\nxnor #(.N(1)) xnor_gate (\n\t.a(ff_xor_out),\n\t.b(ff_and_out),\n\t.c(ff_or_out),\n\t.y(z)\n);\n\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & b & c & d;\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    always @ (posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q <= {q[510], q[511], q[0], q[1], q[2]} + 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\nalways @ (a or b or c or d or e) begin\n\tcase ({a,b,c,d,e})\n\t\t5'b00000: q = 4'b0000; // x\n\t\t5'b00001: q = 4'b0000; // x\n\t\t5'b00010: q = 4'b0000; // x\n\t\t5'b00011: q = 4'b0000; // x\n\t\t5'b00100: q = 4'b0000; // x\n\t\t5'b00101: q = 4'b0000; // x\n\t\t5'b00110: q = 4'b0000; // x\n\t\t5'b00111: q = 4'b0000; // x\n\t\t5'b01000: q = 4'b0000; // x\n\t\t5'b01001: q = 4'b0000; // x\n\t\t5'b01010: q = 4'b0000; // x\n\t\t5'b01011: q = 4'b0000; // x\n\t\t5'b01100: q = 4'b0000; // x\n\t\t5'b01101: q = 4'b0000; // x\n\t\t5'b01110: q = 4'b0000; // x\n\t\t5'b01111: q = 4'b0000; // x\n\t\t5'b10000: q = 4'b1100; // a\n\t\t5'b10001: q = 4'b1100; // a\n\t\t5'b10010: q = 4'b1100; // a\n\t\t5'b10011: q = 4'b1100; // a\n\t\t5'b10100: q = 4'b1100; // a\n\t\t5'b10101: q = 4'b1100; // a\n\t\t5'b10110: q = 4'b1100; // a\n\t\t5'b10111: q = 4'b1100; // a\n\t\t5'b11000: q = 4'b0100; // b\n\t\t5'b11001: q = 4'b0100; // b\n\t\t5'b11010: q = 4'b0100; // b\n\t\t5'b11011: q = 4'b0100; // b\n\t\t5'b11100: q = 4'b0100; // b\n\t\t5'b11101: q = 4'b0100; // b\n\t\t5'b11110: q = 4'b0100; // b\n\t\t5'b11111: q = 4'b0100; // b\n\t\t5'b00010: q = 4'b1010; // d\n\t\t5'b00100: q = 4'b1010; // d\n\t\t5'b00110: q = 4'b1010; // d\n\t\t5'b01000: q = 4'b1010; // d\n\t\t5'b01010: q = 4'b1010"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     reg [7:0] temp;\n\n//     always @(*) begin\n//         if (~sel) begin\n//             temp = a;\n//         end else begin\n//             temp = b;\n//         end\n//     end\n\n//     assign out = temp;\n\n// endmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module that instantiates the submodule three times.\nmodule top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n// instantiate the submodule three times\nsub_module sub1(\n    .clk(clk),\n    .L(L),\n    .q_in(q_in),\n    .r_in(r_in),\n    .Q(Q[0])\n);\n\nsub_module sub2(\n    .clk(clk),\n    .L(L),\n    .q_in(q_in),\n    .r_in(r_in),\n    .Q(Q[1])\n);\n\nsub_module sub3(\n    .clk(clk),\n    .L(L),\n    .q_in(q_in),\n    .r_in(r_in),\n    .Q(Q[2])\n);\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "Do not use any loop or complex logic, and do not change the code outside the module.\n```verilog\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tout <= 0;\n\t\tprev_in <= 0;\n\tend\n\telse begin\n\t\tout <= (in & ~prev_in);\n\t\tprev_in <= in;\n\tend\nend\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "then, add the following Verilog code to compute the sum and overflow:\n```verilog\n\twire [8:0] sum;\n\twire [8:0] a_ext;\n\twire [8:0] b_ext;\n\twire [8:0] s_ext;\n\twire carry_out;\n\tassign a_ext = {1'b0, a};\n\tassign b_ext = {1'b0, b};\n\tassign s_ext = {carry_out, sum};\n\tassign overflow = (a[7] == b[7] && sum[7] != a[7]) || (a[7] != b[7] && sum[7] == s[7]);\n\tassign sum = a_ext + b_ext;\n\tassign s = sum[7:0];\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "assign S_next = (state == 10'b0000000001) ? 1'b0 :\n                 (state == 10'b0000000010) ? 1'b1 :\n                 (state == 10'b0000000100) ? 1'b0 :\n                 (state == 10'b1000000000) ? 1'b1 : 1'b0;\n\nassign S1_next = (state == 10'b0000000001) ? 1'b1 :\n                 (state == 10'b0000000010) ? 1'b0 :\n                 (state == 10'b0000000100) ? 1'b1 :\n                 (state == 10'b1000000000) ? 1'b11 : 1'b0;\n\nassign Count_next = (state == 10'b0000000001) ? 1'b0 :\n                     (state == 10'b0000000010) ? 1'b1 :\n                     (state == 10'b0000000100) ? 1'b0 :\n                     (state == 10'b1000000000) ? 1'b10 : 1'b0;\n\nassign Wait_next = (state == 10'b0000000001) ? 1'b1 :\n                   (state == 10'b0000000010) ? 1'b1 :\n                   (state == 10'b0000000100) ? 1'b1 :\n                   (state == 10'b1000000000) ? 1'b0 : 1'b0;\n\nassign B3_next = (state == 10'b0000000001) ? 1'b0 :\n                 (state == 10'b0000000010) ? 1'b0 :\n                 (state == 10'b0000000100) ? 1'b0 :\n                 (state == 10'b1000000000) ? 1'b1 : 1'b0;"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    reg [1:0] counter;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            counter <= 2'b01; // weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (counter == 2'b11) begin\n                    counter <= 2'b11; // saturate at 3\n                end else begin\n                    counter <= counter + 1; // increment\n                end\n            end else begin\n                if (counter == 2'b00) begin\n                    counter <= 2'b00; // saturate at 0\n                end else begin\n                    counter <= counter - 1; // decrement\n                end\n            end\n        end\n    end\n\n    assign state = counter;\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "You should end your code with:\n```verilog\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n\nalways @(*) begin\n\tcase (scancode)\n\t\t16'he06b: begin\n\t\t\tleft = 1;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\t\t16'he072: begin\n\t\t\tleft = 0;\n\t\t\tdown = 1;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\t\t16'he074: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 1;\n\t\t\tup = 0;\n\t\tend\n\t\t16'he075: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 1;\n\t\tend\n\t\tdefault: begin\n\t\t\tleft = 0;\n\t\t\tdown = 0;\n\t\t\tright = 0;\n\t\t\tup = 0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    // 32-bit global history shift register\n    logic [31:0] history_reg;\n\n    // History counter\n    logic [4:0] history_count;\n\n    // History direction\n    logic history_dir;\n\n    // Pipeline flush (misprediction)\n    logic misprediction;\n\n    // Update history on prediction\n    always @(posedge clk) begin\n        if (predict_valid) begin\n            history_reg[0] <= predict_taken;\n            if (history_count > 0) begin\n                history_reg[history_count-1:1] <= history_reg[history_count-2:0];\n            end\n            history_dir <= predict_taken;\n            history_count <= history_count + 1;\n        end\n    end\n\n    // Update history on misprediction\n    always @(posedge clk) begin\n        if (train_mispredicted) begin\n            history_reg <= {train_history, train_taken};\n            history_count <= 0;\n            misprediction <= 1;\n        end\n        else begin\n            misprediction <= 0;\n        end\n    end\n\n    // Output history\n    assign predict_history = history_reg;\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    wire and1_out;\n    wire and2_out;\n    wire or_out;\n\n    and and1(and1_out, a, b);\n    and and2(and2_out, c, d);\n    or or1(or_out, and1_out, and2_out);\n    not not1(out_n, or_out);\n    assign out = out_n;\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if(enable) begin\n            Q <= {Q[6:0], S};\n        end\n    end\n\n    always @(*) begin\n        case({A,B,C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;\n        endcase\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign heater = (mode == 1 && too_cold == 1) ? 1 : 0;\n    assign aircon = (mode == 0 && too_hot == 1) ? 1 : 0;\n    assign fan = (heater == 1 || aircon == 1 || fan_on == 1) ? 1 : 0;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    wire AB;\n    wire CD;\n    wire ABCD;\n\n    assign AB = ~(a & b);\n    assign CD = ~(c & d);\n    assign ABCD = ~(AB & CD);\n\n    assign out_sop = AB | CD | ABCD;\n    assign out_pos = ~(~AB & ~CD & ~ABCD);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    reg [31:0] lfsr;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            lfsr <= 32'h1;\n            q <= 32'h1;\n        end else begin\n            lfsr[31] <= lfsr[32] ^ lfsr[22] ^ lfsr[2] ^ lfsr[1];\n            q <= lfsr;\n        end\n    end\n\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Define the internal signals\nwire nand1_out;\nwire nand2_out;\n\n// Instantiate the NAND gates\nnand nand1(nand1_out, p1a, p1b, p1c, p1d);\nnand nand2(nand2_out, p2a, p2b, p2c, p2d);\n\n// Define the output assignments\nassign p1y = ~nand1_out;\nassign p2y = ~nand2_out;\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "Do not add any extra comments or whitespace. Make your code easy to read and understand.\n\nUse the popcount function in the Verilog standard functions to count the number of '1's in a bit vector.\n\nDo not use any loops or iterators to count the number of '1's.\n\nModule top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\twire [7:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\twire [7:0] p8, p9, p10, p11, p12, p13, p14, p15;\n\twire [7:0] p16, p17, p18, p19, p20, p21, p22, p23;\n\twire [7:0] p24, p25, p26, p27, p28, p29, p30, p31;\n\twire [7:0] p32, p33, p34, p35, p36, p37, p38, p39;\n\twire [7:0] p40, p41, p42, p43, p44, p45, p46, p47;\n\twire [7:0] p48, p49, p50, p51, p52, p53, p54, p55;\n\twire [7:0] p56, p57, p58, p59, p60, p61, p62, p63;\n\twire [7:0] p64, p65, p66, p67, p68, p69, p70, p71;\n\twire [7:0] p72, p73, p74, p75, p76, p77, p78, p79;\n\twire [7:0] p80, p81, p82, p83, p84, p85, p86, p87;\n\twire [7:0] p88, p89, p90, p91, p92, p93, p94, p95;\n\twire [7:0] p96, p97, p98, p99, p100, p101, p102, p103;\n\twire [7:0] p104, p105, p106, p107, p108, p109, p110, p111;\n\twire [7:0] p112, p113, p114, p115, p116, p117, p118, p119;\n\twire [7:0] p120, p121, p122, p123, p124, p125, p126, p127;\n\twire [7:0] p128, p129, p130, p131, p132, p133, p134, p135;\n\twire [7:0] p136, p137, p138, p139, p140, p141, p142, p143;\n\twire [7:0] p144, p145, p146, p147, p148, p149, p150, p151;\n\twire [7:0] p152, p153, p154, p155, p156, p157, p158, p159;\n\twire [7:0] p160, p161, p162, p163, p164, p165, p166, p167;\n\twire [7:0] p168, p169, p170, p1"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "// (1) out_both:\n\tassign out_both[0] = 0;\n\tassign out_both[1] = in[0] & in[1];\n\tassign out_both[2] = in[1] & in[2];\n\tassign out_both[3] = 0;\n\t\n\t// (2) out_any:\n\tassign out_any[0] = 0;\n\tassign out_any[1] = in[0] | in[1];\n\tassign out_any[2] = in[1] | in[2];\n\tassign out_any[3] = 0;\n\t\n\t// (3) out_different:\n\tassign out_different[0] = in[0] != in[3];\n\tassign out_different[1] = in[1] != in[0];\n\tassign out_different[2] = in[2] != in[1];\n\tassign out_different[3] = in[3] != in[2];\n\t\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) begin\n\t\tcase (a)\n\t\t\t0: q = 1232;\n\t\t\t1: q = 27d4;\n\t\t\t2: q = 2066;\n\t\t\t3: q = 5a0e;\n\t\t\t4: q = 64ce;\n\t\t\t5: q = c526;\n\t\t\t6: q = 2f19;\n\t\t\t7: q = 1232;\n\t\t\t8: q = aee0;\n\t\t\t9: q = 5a0e;\n\t\t\t10: q = 64ce;\n\t\t\t11: q = c526;\n\t\t\t12: q = 2f19;\n\t\t\t13: q = 1232;\n\t\t\t14: q = aee0;\n\t\t\t15: q = 5a0e;\n\t\t\t16: q = 64ce;\n\t\t\t17: q = c526;\n\t\t\t18: q = 2f19;\n\t\t\t19: q = 1232;\n\t\t\t20: q = aee0;\n\t\t\t21: q = 27d4;\n\t\t\t22: q = 2066;\n\t\t\t23: q = 5a0e;\n\t\t\t24: q = 64ce;\n\t\t\t25: q = c526;\n\t\t\t26: q = 2f19;\n\t\t\t27: q = 1232;\n\t\t\t28: q = 27d4;\n\t\t\t29: q = 2066;\n\t\t\t30: q = 5a0e;\n\t\t\t31: q = 64ce;\n\t\t\t32: q = c526;\n\t\t\t33: q = 2f19;\n\t\t\t34: q = 1232;\n\t\t\t35: q = aee0;\n\t\t\t36: q = 27d4;\n\t\t\t37: q = 2066;\n\t\t\t38: q = 5a0e;\n\t\t\t39: q = 64ce;\n\t\t\t40: q = c526;\n\t\t\t41: q = 2f19;\n\t\t\t42: q = 1232;\n\t\t\t43: q = aee0;\n\t\t\t44: q = 27d4;\n\t\t\t45: q = 2066;\n\t\t\t46: q = 5a0e;\n\t\t\t47: q = 64ce;\n\t\t\t48: q = c526;\n\t\t\t49: q = 2f19;\n\t\t\t50: q = 1232;\n\t\t\t51: q = aee0;\n\t\t\t52: q = 27d4;\n\t\t\t53: q = 2066;\n\t\t\t54: q = 5a0e;\n\t\t\t55: q = 64ce;\n\t\t\t56: q = c526;\n\t\t\t57: q = 2f19;\n\t\t\t58: q = 1232;\n\t\t\t59: q = aee0;\n\t\t\t60: q = 27d4;\n\t\t\t61: q = 2066;\n\t\t\t62: q = 5a0e;\n\t\t\t63: q = 64ce;\n\t\t\t64: q = c526;\n\t\t\t65: q = 2f19;\n\t\t\t66: q = 1232;\n\t\t\t67: q = aee0;"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q);\n\n    reg [3:0] counter = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 0;\n        end else if (slowena) begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign q = counter;\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    wire and_out;\n\n    and gate (\n        .a(in1),\n        .b(in2),\n        .y(and_out)\n    );\n\n    assign out = and_out;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "Do not add any comments for the code. You should implement the following Verilog code:\n```verilog\n// Moore Machine\nreg [1:0] state;\nparameter A = 2'b00;\nparameter B = 2'b01;\n\nalways @(posedge clk or negedge areset) begin\n\tif (!areset) begin\n\t\tstate <= B;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nassign out = (state == A) ? 1'b0 : 1'b1;\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "// Create a latch to store the data\n\t\t\t\t\treg latch;\n\t\t\t\t\t\n\t\t\t\t\t// On positive edge of clock, store the data\n\t\t\t\t\talways @(posedge clk)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tlatch <= d;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\t// On negative edge of clock, output the stored data\n\t\t\t\t\talways @(negedge clk)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tq <= latch;\n\t\t\t\t\tend\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n    wire a1, b1, a2, b2;\n    \n    A a1_inst(.x(x), .y(y), .z(a1));\n    B b1_inst(.x(x), .y(y), .z(b1));\n    A a2_inst(.x(x), .y(y), .z(a2));\n    B b2_inst(.x(x), .y(y), .z(b2));\n    \n    OR or_inst(.a(a1), .b(b1), .y(z1));\n    AND and_inst(.a(a2), .b(b2), .y(z2));\n    XOR xor_inst(.a(z1), .b(z2), .y(z));\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n  reg [99:0] shift_reg;\n  \n  always @(posedge clk) begin\n    if (load) begin\n      shift_reg <= data;\n    end else if (ena == 2'b01) begin\n      shift_reg <= {shift_reg[0], shift_reg[99:1]};\n    end else if (ena == 2'b10) begin\n      shift_reg <= {shift_reg[98:0], shift_reg[99]};\n    end\n  end\n  \n  assign q = shift_reg;\n\nendmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;\n        end else if (q == 999) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\n\t// State transition logic\n\tassign next_state[0] = (state[9] & ~state[8]) | (state[8] & ~state[7]) | (state[7] & ~state[6]) | (state[6] & ~state[5]) | (state[5] & ~state[4]) | (state[4] & ~state[3]) | (state[3] & ~state[2]) | (state[2] & ~state[1]) | (state[1] & ~state[0]);\n\tassign next_state[1] = (state[9] & ~state[8]) | (state[8] & state[7]) | (state[7] & state[6]) | (state[6] & state[5]) | (state[5] & state[4]) | (state[4] & state[3]) | (state[3] & state[2]) | (state[2] & state[1]) | (state[1] & state[0]);\n\tassign next_state[2] = (state[9] & ~state[8]) | (state[8] & state[7]) | (state[7] & state[6]) | (state[6] & state[5]) | (state[5] & state[4]) | (state[4] & state[3]) | (state[3] & state[2]) | (state[2] & state[1]) | (state[1] & state[0]);\n\tassign next_state[3] = (state[9] & ~state[8]) | (state[8] & ~state[7]) | (state[7] & ~state[6]) | (state[6] & ~state[5]) | (state[5] & ~state[4]) | (state[4] & ~state[3]) | (state[3] & ~state[2]) | (state[2] & ~state[1]) | (state[1] & ~state[0]);\n\tassign next_state[4] = (state[9] & ~state[8]) | (state[8] & state[7]) | (state[7] & state[6]) | (state[6] & state[5]) | (state[5] & state[4]) | (state[4] & state[3]) | (state[3] & state[2]) | (state[2] & state[1]) | (state[1] & state[0]);\n\tassign next_state[5] = (state[9] & ~state[8]) | (state[8] & ~state[7]) | (state[7] & ~state[6]) | (state[6] & ~state[5]) | (state[5] & ~state[4]) | (state[4] & ~state[3]) | (state[3] & ~state[2]) | (state[2] & ~state[1]) | (state[1] & ~state[0]);\n\tassign next_state[6] = (state[9] & ~state[8]) | (state[8] & state[7]) | (state[7] & state[6]) | (state[6] & state[5]) | (state[5] & state[4]) | (state[4] & state[3]) | (state[3] & state[2]) | (state[2] & state[1]) | (state[1] & state[0]);\n\tassign next_state[7] = (state[9] & ~state[8]) | (state[8] & ~state[7]) | (state[7] & ~state[6]) | (state[6] & ~state[5]) | (state[5] & ~state[4]) | (state[4] & ~state[3]) | (state[3] & ~state[2]) | (state[2] & ~state[1]) | (state[1] & ~state[0]);\n\tassign next_state[8] = (state[9] & ~state[8]) | (state[8] & ~state[7]) | (state[7] & ~state[6]) | (state[6] & ~state[5]) | (state[5] & ~state["}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (j && k) begin\n        Q <= ~Q;\n    end else if (j) begin\n        Q <= 0;\n    end else if (k) begin\n        Q <= 1;\n    end\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\nwire [2:0] xor_out;\nwire [1:0] and_out;\n\nassign xor_out = {in[2]^in[1]^in[0], in[2]^in[0], in[1]^in[0]};\nassign and_out = {xor_out[2]&xor_out[1], xor_out[1]&xor_out[0]};\n\nassign out[1] = and_out[1];\nassign out[0] = and_out[0];\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    // Compute all 25 pairwise one-bit comparisons\n    assign out[0] = ~e ^ e;\n    assign out[1] = ~e ^ d;\n    assign out[2] = ~e ^ c;\n    assign out[3] = ~e ^ b;\n    assign out[4] = ~e ^ a;\n    assign out[5] = ~d ^ e;\n    assign out[6] = ~d ^ c;\n    assign out[7] = ~d ^ b;\n    assign out[8] = ~d ^ a;\n    assign out[9] = ~c ^ e;\n    assign out[10] = ~c ^ d;\n    assign out[11] = ~c ^ b;\n    assign out[12] = ~c ^ a;\n    assign out[13] = ~b ^ e;\n    assign out[14] = ~b ^ d;\n    assign out[15] = ~b ^ c;\n    assign out[16] = ~b ^ a;\n    assign out[17] = ~a ^ e;\n    assign out[18] = ~a ^ d;\n    assign out[19] = ~a ^ c;\n    assign out[20] = ~a ^ b;\n    assign out[21] = ~a ^ e;\n    assign out[22] = ~c ^ e;\n    assign out[23] = ~c ^ d;\n    assign out[24] = ~c ^ b;\n    assign out[25] = ~c ^ a;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // Define the two states\n    parameter walk_left_state = 2'b00;\n    parameter walk_right_state = 2'b01;\n\n    // Define the two outputs\n    reg walk_left;\n    reg walk_right;\n\n    // Define the state register and next state logic\n    reg [1:0] state_reg, state_next;\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state_reg <= walk_left_state;\n        end else begin\n            state_reg <= state_next;\n        end\n    end\n\n    // Define the output logic\n    always @(*) begin\n        case (state_reg)\n            walk_left_state: begin\n                if (bump_right) begin\n                    state_next = walk_right_state;\n                    walk_left = 1;\n                    walk_right = 0;\n                end else begin\n                    state_next = walk_left_state;\n                    walk_left = 1;\n                    walk_right = 0;\n                end\n            end\n            walk_right_state: begin\n                if (bump_left) begin\n                    state_next = walk_left_state;\n                    walk_left = 0;\n                    walk_right = 1;\n                end else begin\n                    state_next = walk_right_state;\n                    walk_left = 0;\n                    walk_right = 1;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = (a & b) | (~a & b) | (a & ~b) | (~a & ~b);\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = p1a & p1b & p1c & p1d & p1e & p1f;\n    assign p2y = p2a & p2b | p2c & p2d;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "// State-assigned table\n// y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\n// State encoding\nparameter S0 = 3'b000;\nparameter S1 = 3'b001;\nparameter S2 = 3'b010;\nparameter S3 = 3'b011;\nparameter S4 = 3'b100;\n\n// State register\nreg [2:0] state_reg;\nalways @(posedge clk) begin\n\tif (x == 1'b0) begin\n\t\tstate_reg <= {state_reg[1:0], 1'b0};\n\tend else begin\n\t\tstate_reg <= {state_reg[1:0], 1'b1};\n\tend\nend\n\n// Output register\nreg Y0_reg;\nalways @(posedge clk) begin\n\tcase (state_reg)\n\t\tS0: Y0_reg <= 1'b0;\n\t\tS1: Y0_reg <= 1'b0;\n\t\tS2: Y0_reg <= 1'b0;\n\t\tS3: Y0_reg <= 1'b1;\n\t\tS4: Y0_reg <= 1'b1;\n\t\tdefault: Y0_reg <= 1'b0;\n\tendcase\nend\n\n// Output logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tS0: z = 1'b0;\n\t\tS1: z = 1'b0;\n\t\tS2: z = 1'b0;\n\t\tS3: z = 1'b1;\n\t\tS4: z = 1'b1;\n\t\tdefault: z = 1'b0;\n\tendcase\nend\n\n// Output assign\nassign Y0 = Y0_reg;\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    always @(posedge clk) begin\n        if (ar) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "The Verilog code for the 6-to-1 multiplexer is as follows:\n```verilog\nalways @ (sel)\nbegin\n\tcase (sel)\n\t\t3'b000: out = data0;\n\t\t3'b001: out = data1;\n\t\t3'b010: out = data2;\n\t\t3'b011: out = data3;\n\t\t3'b100: out = data4;\n\t\t3'b101: out = data5;\n\t\tdefault: out = 4'b0000;\n\tendcase\nend\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "endmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "The Verilog code should be well-structured and modular, with each module performing a specific function. Do not repeat code unnecessarily.\n\nUse meaningful names for variables and modules.\n\nFollow the Verilog coding standards and guidelines.\n\n```verilog\nmodule top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\treg [3:0] state;\n\treg start_shifting_reg;\n\twire shift_right;\n\twire [3:0] shift_left;\n\twire [3:0] shift_left_reg;\n\twire [3:0] shift_right_reg;\n\twire [3:0] shift_left_reg_next;\n\twire [3:0] shift_right_reg_next;\n\twire [3:0] shift_left_reg_next_reg;\n\n\t// Define the states\n\tparameter S0 = 4'b0000;\n\tparameter S1 = 4'b0001;\n\tparameter S2 = 4'b0010;\n\tparameter S3 = 4'b0011;\n\tparameter S4 = 4'b0100;\n\n\t// Define the output\n\tassign start_shifting = start_shifting_reg;\n\n\t// Define the shift left and shift right signals\n\tassign shift_left = {state[2:0], data};\n\tassign shift_right = {data, state[3:1]};\n\n\t// Define the shift left and shift right registers\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tshift_left_reg <= S0;\n\t\t\tshift_right_reg <= S0;\n\t\tend else begin\n\t\t\tshift_left_reg <= shift_left_reg_next;\n\t\t\tshift_right_reg <= shift_right_reg_next;\n\t\tend\n\tend\n\n\t// Define the shift left and shift right next state logic\n\talways @(*) begin\n\t\tcase (shift_left_reg)\n\t\t\tS0: shift_left_reg_next = shift_left_reg_next_reg;\n\t\t\tS1: shift_left_reg_next = (shift_left_reg == S4) ? S0 : shift_left_reg_next_reg;\n\t\t\tS2: shift_left_reg_next = (shift_left_reg == S3) ? S0 : shift_left_reg_next_reg;\n\t\t\tS3: shift_left_reg_next = (shift_left_reg == S2) ? S0 : shift_left_reg_next_reg;\n\t\t\tS4: shift_left_reg_next = (shift_left_reg == S4) ? S0 : shift_left_reg_next_reg;\n\t\t\tdefault: shift_left_reg_next = S0;\n\t\tendcase\n\tend\n\n\t// Define the shift right next state logic\n\talways @(*) begin\n\t\tcase (shift_right_reg)\n\t\t\tS0: shift_right_reg_next = shift_right_reg_next_reg;\n\t\t\tS1: shift_right_reg_next = (shift_right_reg == S3) ? S0 : shift_right_reg_next_reg;\n\t\t\tS2: shift_right_reg_next = (shift_right_reg == S4) ? S0 : shift_right_reg_next_reg;\n\t\t\tS3: shift_right_reg_next = (shift_right_reg == S2) ? S0 : shift_right_reg_next_reg;\n\t\t\tS4: shift_right_reg_next = (shift_right_reg == S1) ? S0 : shift_right_reg_next_reg;\n\t\t\tdefault: shift_right_reg_next = S0;\n\t\tendcase\n\tend\n\n\t// Define the start shifting register\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstart_shifting_reg <= 1'b0;\n\t\tend else begin\n\t\t\tstart_shifting_reg <= (shift_left_reg_next_reg == S4) ? 1'b1 : start_shifting_reg"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "Follow the Verilog coding standard and use meaningful names. Indent your code properly.\n\nNo need to add comments to the code, they will just increase the size of the code.\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "module to store the input value from the previous cycle and then compares the current input with the stored input to detect any edge.\n\nThe `anyedge` output is set the cycle after a 0 to 1 transition occurs.\n\nmodule top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge);\n\n    reg [7:0] prev_in;\n\n    dff #(.INIT(1'b0)) dff_inst (\n        .D(in),\n        .CLK(clk),\n        .Q(prev_in)\n    );\n\n    always @(posedge clk) begin\n        if (in != prev_in) begin\n            anyedge <= 1'b1;\n        end else begin\n            anyedge <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// 32-bit counter\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0001;\n\t\tend else if (q == 4'b1010) begin\n\t\t\tq <= 4'b0001;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    reg [2:0] q_next;\n\n    always @(posedge clk) begin\n        q_next <= {q[1:0], a};\n    end\n\n    always @(negedge clk) begin\n        q <= q_next;\n    end\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "then have the following:\n```verilog\n\treg [4:0] lfsr;\n\tparameter [4:0] tap_pos = 5'b10101;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 5'b10001;\n\t\t\tq <= 1'b1;\n\t\tend\n\t\telse begin\n\t\t\tlfsr <= {lfsr[4:0], lfsr[4] ^ lfsr[3]};\n\t\t\tq <= lfsr[4];\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        if (do_sub == 0) begin\n            out = a + b;\n        end else begin\n            out = a - b;\n        end\n\n        if (out == 0) begin\n            result_is_zero = 1;\n        end else begin\n            result_is_zero = 0;\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "always_comb begin\n\t\tcase (x)\n\t\t\t4'b0000: f = 1'b0;\n\t\t\t4'b0001: f = 1'b1;\n\t\t\t4'b0010: f = 1'b0;\n\t\t\t4'b0011: f = 1'b1;\n\t\t\t4'b0100: f = 1'b1;\n\t\t\t4'b0101: f = 1'b0;\n\t\t\t4'b0110: f = 1'b1;\n\t\t\t4'b0111: f = 1'b1;\n\t\t\t4'b1000: f = 1'b1;\n\t\t\t4'b1001: f = 1'b1;\n\t\t\t4'b1010: f = 1'b0;\n\t\t\t4'b1011: f = 1'b1;\n\t\t\t4'b1100: f = 1'b1;\n\t\t\t4'b1101: f = 1'b0;\n\t\t\t4'b1110: f = 1'b1;\n\t\t\t4'b1111: f = 1'b1;\n\t\t\tdefault: f = 1'bx;\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "always @(*) begin\n\t\tcase(code)\n\t\t\t8'h45: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h16: begin\n\t\t\t\tout = 4'b0001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h1e: begin\n\t\t\t\tout = 4'b0010;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h26: begin\n\t\t\t\tout = 4'b0011;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h25: begin\n\t\t\t\tout = 4'b0100;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h2e: begin\n\t\t\t\tout = 4'b0101;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h36: begin\n\t\t\t\tout = 4'b0110;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3d: begin\n\t\t\t\tout = 4'b0111;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3e: begin\n\t\t\t\tout = 4'b1000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h46: begin\n\t\t\t\tout = 4'b1001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "// Karnaugh map\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\n\n// d is don't-care, which means you may choose to output whatever value is convenient.\n\nalways @ (a or b or c or d)\nbegin\n\tcase ({a,b,c,d})\n\t\t4'b0000: out = 1'b0;\n\t\t4'b0001: out = 1'b0;\n\t\t4'b0010: out = 1'b1;\n\t\t4'b0011: out = 1'b1;\n\t\t4'b0100: out = 1'b0;\n\t\t4'b0101: out = 1'b0;\n\t\t4'b0110: out = 1'b1;\n\t\t4'b0111: out = 1'b1;\n\t\t4'b1000: out = 1'b0;\n\t\t4'b1001: out = 1'b0;\n\t\t4'b1010: out = 1'b1;\n\t\t4'b1011: out = 1'b1;\n\t\t4'b1100: out = 1'b0;\n\t\t4'b1101: out = 1'b0;\n\t\t4'b1110: out = 1'b1;\n\t\t4'b1111: out = 1'b1;\n\t\tdefault: out = 1'b0; // d is don't-care\n\tendcase\nend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if(count_ena) begin\n            q <= q - 1;\n        end\n        if(shift_ena) begin\n            q <= {q[2:0], data};\n        end\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "assign out = in;"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output shift_ena);\n\n    reg [1:0] state;\n    parameter IDLE = 2'b00;\n    parameter COUNT_0 = 2'b01;\n    parameter COUNT_1 = 2'b10;\n    parameter COUNT_2 = 2'b11;\n    parameter COUNT_3 = 2'b00;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_ena <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (shift_ena) begin\n                        state <= COUNT_0;\n                        shift_ena <= 0;\n                    end\n                end\n                COUNT_0: begin\n                    if (shift_ena) begin\n                        state <= COUNT_1;\n                        shift_ena <= 0;\n                    end\n                end\n                COUNT_1: begin\n                    if (shift_ena) begin\n                        state <= COUNT_2;\n                        shift_ena <= 0;\n                    end\n                end\n                COUNT_2: begin\n                    if (shift_ena) begin\n                        state <= COUNT_3;\n                        shift_ena <= 0;\n                    end\n                end\n                COUNT_3: begin\n                    if (shift_ena) begin\n                        state <= IDLE;\n                        shift_ena <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "// Declare the input and output signals\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    always @(*) begin\n        if(sel_b1 & sel_b2) begin\n            out_always = b;\n        end\n        else begin\n            out_always = a;\n        end\n    end\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (a & b & c) | (~a & b & c) | (a & ~b & c) | (~a & ~b & c);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "// State codes:\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State register and next state logic\nreg [1:0] state, next_state;\nalways @(posedge clk, negedge resetn) begin\n\tif (~resetn) begin\n\t\tstate <= A;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\n// State table\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (r[0] == 1) begin\n\t\t\t\tnext_state = B;\n\t\t\tend else if (r[1] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\tend else if (r[2] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\tend else begin\n\t\t\t\tnext_state = D;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (r[0] == 1) begin\n\t\t\t\tnext_state = B;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (r[1] == 1) begin\n\t\t\t\tnext_state = C;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (r[2] == 1) begin\n\t\t\t\tnext_state = D;\n\t\t\tend else begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// State output logic\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (r[0] == 1) begin\n\t\t\t\tg[0] = 1;\n\t\t\tend else begin\n\t\t\t\tg[0] = 0;\n\t\t\tend\n\t\t\tif (r[1] == 1) begin\n\t\t\t\tg[1] = 0;\n\t\t\tend else begin\n\t\t\t\tg[1] = 1;\n\t\t\tend\n\t\t\tif (r[2] == 1) begin\n\t\t\t\tg[2] = 0;\n\t\t\tend else begin\n\t\t\t\tg[2] = 1;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tg[0] = 0;\n\t\t\tg[1] = 1;\n\t\t\tg[2] = 0;\n\t\tend\n\t\tC: begin\n\t\t\tg[0] = 0;\n\t\t\tg[1] = 0;\n\t\t\tg[2] = 1;\n\t\tend\n\t\tD: begin\n\t\t\tg[0] = 0;\n\t\t\tg[1] = 0;\n\t\t\tg[2] = 0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module\n* Inputs: clk, reset\n* Outputs: q\n* Verilog version: 1.0 (for now)\n* Decade counter that counts from 0 through 9, inclusive, with a period of 10.\n* Reset input is active high synchronous, and should reset the counter to 0.\n* q is the output of the decade counter.\n\n```verilog\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "// States\n\tlocalparam IDLE = 2'd0;\n\tlocalparam WAIT = 2'd1;\n\tlocalparam MESSAGE = 2'd2;\n\t\n\t// Signals\n\treg [7:0] in_reg;\n\treg [1:0] state_reg;\n\twire [1:0] next_state;\n\twire message_complete;\n\twire byte_done;\n\twire [7:0] in_next;\n\t\n\t// Assign next state\n\tassign next_state = (state_reg == IDLE) ? WAIT :\n\t\t\t\t\t\t(state_reg == WAIT) ? MESSAGE :\n\t\t\t\t\t\t(state_reg == MESSAGE) ? IDLE :\n\t\t\t\t\t\t2'd0;\n\t\n\t// Assign output\n\tassign done = message_complete;\n\t\n\t// Assign input\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tin_reg <= 8'b0;\n\t\t\tstate_reg <= IDLE;\n\t\tend else begin\n\t\t\tin_reg <= in;\n\t\t\tstate_reg <= next_state;\n\t\tend\n\tend\n\t\n\t// Assign in_next\n\talways @(*) begin\n\t\tin_next = in_reg;\n\tend\n\t\n\t// Assign message_complete\n\tassign message_complete = (state_reg == MESSAGE) && byte_done;\n\t\n\t// Assign byte_done\n\tassign byte_done = (in_next[3] == 1);\n\t\n\t// FSM\n\talways @(*) begin\n\t\tcase (state_reg)\n\t\t\tIDLE: begin\n\t\t\t\tif (in_next[3] == 1) begin\n\t\t\t\t\tstate_reg <= WAIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWAIT: begin\n\t\t\t\tif (in_next[3] == 1) begin\n\t\t\t\t\tstate_reg <= MESSAGE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tMESSAGE: begin\n\t\t\t\tif (byte_done) begin\n\t\t\t\t\tstate_reg <= (state_reg == 2'd0) ? IDLE : MESSAGE;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\t\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module code.\n\nDo not add any Verilog code outside the module.\n\nmodule top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = (sel == 1'b0) ? a : b;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "* Indent with 4 spaces.\n* Separate logic gates with a space.\n* Use consistent naming conventions."}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\ty <= 3'b000;\n\tend else begin\n\t\tcase (y)\n\t\t\t3'b000: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\ty <= 3'b001;\n\t\t\t\tend else begin\n\t\t\t\t\ty <= 3'b000;\n\t\t\t\tend\n\t\t\t\tz <= 0;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\ty <= 3'b100;\n\t\t\t\tend else begin\n\t\t\t\t\ty <= 3'b010;\n\t\t\t\tend\n\t\t\t\tz <= 0;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\ty <= 3'b001;\n\t\t\t\tend else begin\n\t\t\t\t\ty <= 3'b010;\n\t\t\t\tend\n\t\t\t\tz <= 0;\n\t\t\tend\n\t\t\t3'b011: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\ty <= 3'b010;\n\t\t\t\tend else begin\n\t\t\t\t\ty <= 3'b001;\n\t\t\t\tend\n\t\t\t\tz <= 1;\n\t\t\tend\n\t\t\t3'b100: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\ty <= 3'b100;\n\t\t\t\tend else begin\n\t\t\t\t\ty <= 3'b011;\n\t\t\t\tend\n\t\t\t\tz <= 1;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nreg [2:0] y;\ninitial begin\n\ty <= 3'b000;\nend\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output f,\n    output g\n);\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg f_reg;\n    reg g_reg;\n    reg [1:0] x_reg;\n    reg [1:0] y_reg;\n    reg [1:0] y_count;\n\n    // Define the states\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    // Define the outputs\n    assign f = f_reg;\n    assign g = g_reg;\n\n    // Define the next state logic\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            next_state <= A;\n            f_reg <= 0;\n            g_reg <= 0;\n            x_reg <= 0;\n            y_reg <= 0;\n            y_count <= 0;\n        end else begin\n            next_state <= state;\n            case (state)\n                A: begin\n                    f_reg <= 1;\n                    next_state <= B;\n                end\n                B: begin\n                    x_reg <= {x_reg[0], x};\n                    if (x_reg == 3'b101) begin\n                        g_reg <= 1;\n                        next_state <= C;\n                    end else begin\n                        next_state <= B;\n                    end\n                end\n                C: begin\n                    y_reg <= {y_reg[0], y};\n                    if (y_reg == 2'b11) begin\n                        g_reg <= 1;\n                        next_state <= D;\n                    end else if (y_reg == 2'b10) begin\n                        g_reg <= 0;\n                        next_state <= A;\n                    end else begin\n                        next_state <= C;\n                    end\n                end\n                D: begin\n                    next_state <= D;\n                end\n            endcase\n        end\n    end\n\n    // Define the y_count logic\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            y_count <= 0;\n        end else begin\n            if (state == C) begin\n                if (y_count == 2) begin\n                    g_reg <= 0;\n                    next_state <= A;\n                end else if (y_reg == 2'b11) begin\n                    y_count <= 0;\n                end else begin\n                    y_count <= y_count + 1;\n                end\n            end else begin\n                y_count <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "always @(negedge clk) begin\n    if (reset) begin\n        q <= q_next;\n    end else begin\n        q <= d;\n    end\nend"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\nalways @(*) begin\n    case(state)\n        2'b00: begin // A\n            if(in == 0) begin\n                next_state = 2'b00;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b01;\n                out = 1'b0;\n            end\n        end\n        2'b01: begin // B\n            if(in == 0) begin\n                next_state = 2'b00;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b10;\n                out = 1'b0;\n            end\n        end\n        2'b10: begin // C\n            if(in == 0) begin\n                next_state = 2'b00;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b11;\n                out = 1'b1;\n            end\n        end\n        2'b11: begin // D\n            if(in == 0) begin\n                next_state = 2'b10;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 2'b01;\n                out = 1'b1;\n            end\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    assign z = (x & y) | (~x & y) | (x & ~y) | (~x & ~y);\n\nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output z\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // Define the state register and initialize to state A\n    reg [1:0] state_reg = A;\n    always @(posedge clk) begin\n        if (reset) begin\n            state_reg <= A;\n        end else begin\n            case (state_reg)\n                A: begin\n                    if (w) begin\n                        state_reg <= B;\n                    end else begin\n                        state_reg <= A;\n                    end\n                end\n                B: begin\n                    if (w) begin\n                        state_reg <= C;\n                    end else begin\n                        state_reg <= D;\n                    end\n                end\n                C: begin\n                    if (w) begin\n                        state_reg <= E;\n                    end else begin\n                        state_reg <= D;\n                    end\n                end\n                D: begin\n                    if (w) begin\n                        state_reg <= F;\n                    end else begin\n                        state_reg <= A;\n                    end\n                end\n                E: begin\n                    if (w) begin\n                        state_reg <= E;\n                    end else begin\n                        state_reg <= D;\n                    end\n                end\n                F: begin\n                    if (w) begin\n                        state_reg <= C;\n                    end else begin\n                        state_reg <= D;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the state decoder and output register\n    reg [1:0] state_dec;\n    always @(state_reg) begin\n        case (state_reg)\n            A: state_dec <= 2'b00;\n            B: state_dec <= 2'b01;\n            C: state_dec <= 2'b10;\n            D: state_dec <= 2'b11;\n        endcase\n    end\n    reg z_reg;\n    always @(state_dec) begin\n        case (state_dec)\n            2'b00: z_reg <= 0;\n            2'b01: z_reg <= 1;\n            2'b10: z_reg <= 1;\n            2'b11: z_reg <= 0;\n        endcase\n    end\n    assign z = z_reg;\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk) begin\n\tif (~resetn) begin\n\t\tq <= 16'h0;\n\tend else begin\n\t\tif (byteena[1]) begin\n\t\t\tq[15:8] <= d[15:8];\n\t\tend\n\t\tif (byteena[0]) begin\n\t\t\tq[7:0] <= d[7:0];\n\t\tend\n\tend\nend\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    reg [3:0] state;\n\n    always @(posedge clock) begin\n        case (state)\n            0: begin\n                p <= 1'b0;\n                q <= 1'b0;\n                if (a) state <= 1;\n            end\n            1: begin\n                p <= 1'b1;\n                q <= 1'b1;\n                state <= 0;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// Create a 512-cell system\nreg [511:0] q;\n\n// Advance the system by one time step each clock cycle\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else begin\n\t\t// Apply the rule 90 logic\n\t\tq[0] <= q[1] ^ q[2];\n\t\tfor (i = 1; i < 511; i = i + 1) begin\n\t\t\tq[i] <= q[i-1] ^ q[i+1];\n\t\tend\n\t\tq[511] <= q[510] ^ q[0];\n\tend\nend\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    assign z = (A[0] == B[0]) && (A[1] == B[1]);\n\nendmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "No need to add the comment // (1), // (2), // (3) for each line.\n\nPlease follow the Verilog syntax and style guidelines as much as possible.\n\n module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both[0] = 1'b0;\n\tassign out_both[1] = in[0] & in[1];\n\tassign out_both[2] = in[1] & in[2];\n\tassign out_both[3] = in[2] & in[3];\n\tassign out_both[4] = in[3] & in[4];\n\tassign out_both[5] = in[4] & in[5];\n\tassign out_both[6] = in[5] & in[6];\n\tassign out_both[7] = in[6] & in[7];\n\tassign out_both[8] = in[7] & in[8];\n\tassign out_both[9] = in[8] & in[9];\n\tassign out_both[10] = in[9] & in[10];\n\tassign out_both[11] = in[10] & in[11];\n\tassign out_both[12] = in[11] & in[12];\n\tassign out_both[13] = in[12] & in[13];\n\tassign out_both[14] = in[13] & in[14];\n\tassign out_both[15] = in[14] & in[15];\n\tassign out_both[16] = in[15] & in[16];\n\tassign out_both[17] = in[16] & in[17];\n\tassign out_both[18] = in[17] & in[18];\n\tassign out_both[19] = in[18] & in[19];\n\tassign out_both[20] = in[19] & in[20];\n\tassign out_both[21] = in[20] & in[21];\n\tassign out_both[22] = in[21] & in[22];\n\tassign out_both[23] = in[22] & in[23];\n\tassign out_both[24] = in[23] & in[24];\n\tassign out_both[25] = in[24] & in[25];\n\tassign out_both[26] = in[25] & in[26];\n\tassign out_both[27] = in[26] & in[27];\n\tassign out_both[28] = in[27] & in[28];\n\tassign out_both[29] = in[28] & in[29];\n\tassign out_both[30] = in[29] & in[30];\n\tassign out_both[31] = in[30] & in[31];\n\tassign out_both[32] = in[31] & in[32];\n\tassign out_both[33] = in[32] & in[33];\n\tassign out_both[34] = in[33] & in[34];\n\tassign out_both[35] = in[34] & in[35];\n\tassign out_both[36] = in[35] & in[36];\n\tassign out_both[37] = in[36] & in[37];\n\tassign out_both[38] = in[37] & in[38];\n\tassign out_both[39] = in[38] & in[39];\n\tassign out_both[40] = in[39] & in[40];\n\tassign out_both[41] = in[40] & in[41];\n\tassign out_both[42] = in[41] & in[42];\n\tassign out_both[43] ="}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "// D latch implementation\nalways @(posedge ena) begin\n\tq <= d;\nend\n\nendmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "// 9-to-1 multiplexer\nalways @(*) begin\n\tcase(sel)\n\t\t4'h0: out = a;\n\t\t4'h1: out = b;\n\t\t4'h2: out = c;\n\t\t4'h3: out = d;\n\t\t4'h4: out = e;\n\t\t4'h5: out = f;\n\t\t4'h6: out = g;\n\t\t4'h7: out = h;\n\t\t4'h8: out = i;\n\t\tdefault: out = 16'hFFFF;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "endmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    always @(*) begin\n        case(state)\n            4'b0001: begin // A\n                if(in == 1'b0) begin\n                    next_state = 4'b0001;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b0010;\n                    out = 1'b0;\n                end\n            end\n            4'b0010: begin // B\n                if(in == 1'b0) begin\n                    next_state = 4'b0100;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b0010;\n                    out = 1'b0;\n                end\n            end\n            4'b0100: begin // C\n                if(in == 1'b0) begin\n                    next_state = 4'b0001;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b1000;\n                    out = 1'b1;\n                end\n            end\n            4'b1000: begin // D\n                if(in == 1'b0) begin\n                    next_state = 4'b0100;\n                    out = 1'b0;\n                end\n                else begin\n                    next_state = 4'b0010;\n                    out = 1'b1;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "// (1) out_and: a and b \nassign out_and = a & b;\n\n// (2) out_or: a or b \nassign out_or = a | b;\n\n// (3) out_xor: a xor b \nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b \nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b \nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b \nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b \nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "// Karnaugh map\n// abcd\n//  00 01 11 10\n// a | 1 | 1 | 0 | 1\n// b | 1 | 0 | 0 | 1\n// c | 0 | 1 | 1 | 1\n// d | 1 | 1 | 0 | 0\n\n// Verilog code\n// Compute a, b, c, d\nwire a_ = a ^ b;\nwire b_ = a & b;\nwire c_ = c ^ d;\nwire d_ = c & d;\n\n// Compute out\nassign out = a_ & b_ | c_ & d_ | a_ & d_ | b_ & c_;\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    reg [1:0] state;\n    reg [2:0] w_count;\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            state <= 2'b00;\n            w_count <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (state)\n                2'b00: begin\n                    if (s) begin\n                        state <= 2'b01;\n                        w_count <= 3'b000;\n                    end\n                end\n                2'b01: begin\n                    if (w) begin\n                        w_count <= w_count + 1;\n                        if (w_count == 3'b010) begin\n                            z <= 1'b1;\n                        end else begin\n                            z <= 1'b0;\n                        end\n                        if (w_count == 3'b100) begin\n                            state <= 2'b00;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = {24'b0, in, 8'b0} ^ {24'b0, in, 8'b0};\n\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "https://www.dickson.com/~dickson/verilog_style.html"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b0000: pos = 2'b00;\n        4'b0001: pos = 2'b01;\n        4'b0010: pos = 2'b10;\n        4'b0011: pos = 2'b11;\n        4'b0100: pos = 2'b01;\n        4'b0101: pos = 2'b10;\n        4'b0110: pos = 2'b11;\n        4'b0111: pos = 2'b00;\n        4'b1000: pos = 2'b10;\n        4'b1001: pos = 2'b01;\n        4'b1010: pos = 2'b11;\n        4'b1011: pos = 2'b00;\n        4'b1100: pos = 2'b01;\n        4'b1101: pos = 2'b10;\n        4'b1110: pos = 2'b11;\n        4'b1111: pos = 2'b00;\n        default: pos = 2'b00;\n    endcase\nend\n\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n\n// Define states\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// Define outputs\nparameter out_OFF = 1'b0;\nparameter out_ON = 1'b1;\n\n// Define inputs\nparameter j_off = 1'b0;\nparameter j_on = 1'b1;\nparameter k_off = 1'b0;\nparameter k_on = 1'b1;\n\n// Define state register\nreg [1:0] state_reg = OFF;\n\n// Define output register\nreg out_reg = out_OFF;\n\n// Define next state logic\nalways @ (posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= OFF;\n\tend else begin\n\t\tcase (state_reg)\n\t\t\tOFF: begin\n\t\t\t\tif (j == j_on) begin\n\t\t\t\t\tstate_reg <= ON;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k == k_off) begin\n\t\t\t\t\tstate_reg <= ON;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_reg <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Define output logic\nalways @ (state_reg) begin\n\tcase (state_reg)\n\t\tOFF: out_reg = out_OFF;\n\t\tON: out_reg = out_ON;\n\tendcase\nend\n\n// Assign output\nassign out = out_reg;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "Do not use comments in the Verilog code. They will not be compiled.\n\n```verilog\n\tassign one = 1;\n\nendmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "// Positive edge triggered D flip-flop\nreg d_ff;\nalways @(posedge clk) begin\n\td_ff <= in ^ out;\nend\n\n// Two-input XOR\nwire xor_out;\nassign xor_out = in ^ out;\n\n// Output\nassign out = d_ff;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "// (1) areset: Resets shift register to zero.\nalways @(posedge areset)\n\tq <= 4'b0;\n\n// (2) load: Loads shift register with data[3:0] instead of shifting.\nalways @(posedge clk)\n\tif(load)\n\t\tq <= data;\n\n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).\nalways @(posedge clk)\n\tif(ena)\n\t\tq[3:1] <= q[2:0];\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "endmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (areset) begin\n\t\t\tq <= 8'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "`in` is the input of 100-bits.\n`out_and`, `out_or`, `out_xor` are the outputs of 100-input AND, OR, XOR gates, respectively.\n\nComplete the Verilog code for the 100-input AND, OR, XOR gates and assign the outputs to the corresponding output ports.\n\n`out_and = &in;`\n\n`out_or = |in;`\n\n`out_xor = ^in;`\n\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "module top_module (\n//     input cpu_overheated,\n//     output reg shut_off_computer,\n//     input arrived,\n//     input gas_tank_empty,\n//     output reg keep_driving\n// );\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output out\n);\n\n    // Define the state encoding\n    parameter OFF = 2'b00;\n    parameter ON = 2'b01;\n\n    // Define the state register and initialize it to OFF\n    reg [1:0] state = OFF;\n\n    // Define the output register and initialize it to 0\n    reg out_reg = 0;\n\n    // Define the combinational logic for the output\n    assign out = out_reg;\n\n    // Define the state transition logic\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= OFF;\n        end\n        else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the output logic\n    always @(state) begin\n        case (state)\n            OFF: begin\n                out_reg <= 0;\n            end\n            ON: begin\n                out_reg <= 1;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & b & c & d;\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module names.\n\nUse meaningful variable and module names.\n\nUse consistent naming conventions.\n\nDo not use comments to explain your code.\n\nUse comments only to explain complex parts of the code or to provide additional information about the code.\n\nDo not use `//` for comments. Use `/* */` or `//` for single line comments.\n\nDo not use `//` for multiline comments. Use `/* */` for multiline comments.\n\nDo not use `//` for code.\n\nDo not use `/* */` for code.\n\nDo not use `//` for comments.\n\nDo not use `#` for comments.\n\nDo not use `//` for code.\n\nDo not use `/* */` for code.\n\nmodule top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, one input, and one output.\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\n// State encoding:\n// 00 - B (out=1)\n// 01 - A (out=0)\n// State transitions:\n// 00 --in=0--> 01\n// 00 --in=1--> 00\n// 01 --in=0--> 00\n// 01 --in=1--> 01\n// Output logic:\n// B (out=1)\n// A (out=0)\n// State register:\n// reg [1:0] state;\n// Next state logic:\n// always @ (posedge clk) begin\n// \tif (reset) begin\n// \t\tstate <= 2'b00; // B\n// \tend else begin\n// \t\tcase (state)\n// \t\t\t2'b00: begin\n// \t\t\t\tif (in == 1'b0) begin\n// \t\t\t\t\tstate <= 2'b01; // A\n// \t\t\t\tend else begin\n// \t\t\t\t\tstate <= 2'b00; // B\n// \t\t\t\tend\n// \t\t\tend\n// \t\t\t2'b01: begin\n// \t\t\t\tif (in == 1'b0) begin\n// \t\t\t\t\tstate <= 2'b00; // B\n// \t\t\t\tend else begin\n// \t\t\t\t\tstate <= 2'b01; // A\n// \t\t\t\tend\n// \t\t\tend\n// \t\tendcase\n// \tend\n// end\n// Output logic:\n// always @ (state) begin\n// \tcase (state)\n// \t\t2'b00: begin\n// \t\t\tout <= 1'b1; // B\n// \t\tend\n// \t\t2'b01: begin\n// \t\t\tout <= 1'b0; // A\n// \t\tend\n// \tendcase\n// end\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "module directly.\n\nmodule top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    full_adder fa1 (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(cout)\n    );\n\nendmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module xnor_gate (\n        input a,\n        input b,\n        output logic out\n    );\n        assign out = ~(a ^ b);\n    endmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // 2-to-1 muxes\n    wire w1, w2, w3, w4;\n    assign w1 = (c & ~d) | (~c & d);\n    assign w2 = (~c & ~d) | (c & d);\n    assign w3 = (~c & d) | (c & ~d);\n    assign w4 = (c & d) | (~c & ~d);\n\n    // 4-to-1 mux\n    wire [3:0] mux_in_temp;\n    assign mux_in_temp[0] = w1;\n    assign mux_in_temp[1] = w2;\n    assign mux_in_temp[2] = w3;\n    assign mux_in_temp[3] = w4;\n    assign mux_in = mux_in_temp;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// Mealy machine for 2's complementer\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\n\n// One-hot encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// States\nreg [1:0] state_reg, state_next;\n\n// Output\nreg z_reg;\n\n// Mealy machine\nalways @(posedge clk, posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= A;\n\t\tz_reg <= 1'b0;\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\t\tz_reg <= z_reg_next;\n\tend\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tA: begin\n\t\t\tif (x) begin\n\t\t\t\tstate_next = B;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = A;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (x) begin\n\t\t\t\tstate_next = B;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tstate_next = B;\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\tstate_next = A;\n\t\tend\n\tendcase\nend\n\n// Output logic\nalways @(*) begin\n\tcase (state_reg)\n\t\tA: begin\n\t\t\tz_reg_next = 1'b0;\n\t\tend\n\t\tB: begin\n\t\t\tz_reg_next = ~x;\n\t\tend\n\t\tdefault: begin\n\t\t\tz_reg_next = 1'b0;\n\t\tend\n\tendcase\nend\n\n// Output\nassign z = z_reg;\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg state_reg;\n    wire d;\n\n    assign d = a & b;\n\n    always @(posedge clk) begin\n        state_reg <= d;\n    end\n\n    assign q = state_reg;\n    assign state = state_reg;\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "Then, implement the Verilog code for the function f in the Karnaugh map.\n\n```verilog\nalways @*\nbegin\n\tcase(x)\n\t\t4'b0000: f = 1'b1;\n\t\t4'b0001: f = 1'b0;\n\t\t4'b0010: f = 1'b1;\n\t\t4'b0011: f = 1'b1;\n\t\t4'b0100: f = 1'b0;\n\t\t4'b0101: f = 1'b0;\n\t\t4'b0110: f = 1'b1;\n\t\t4'b0111: f = 1'b1;\n\t\t4'b1000: f = 1'b1;\n\t\t4'b1001: f = 1'b1;\n\t\t4'b1010: f = 1'b0;\n\t\t4'b1011: f = 1'b0;\n\t\t4'b1100: f = 1'b1;\n\t\t4'b1101: f = 1'b1;\n\t\t4'b1110: f = 1'b1;\n\t\t4'b1111: f = 1'b0;\n\tendcase\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "// Moore-type FSM with 4 states: 0 - default, 1 - flag, 2 - err, 3 - disc\n// State 0: Idle, default to 0\n// State 1: Flag (01111110)\n// State 2: Error (7 or more 1s)\n// State 3: Discard (0111110)\n// State 4: Flag (01111110)\n// State 5: Error (7 or more 1s)\n// State 6: Discard (0111110)\n\n// State 0: Default\n// State 1: Flag (01111110)\n// State 2: Error (7 or more 1s)\n// State 3: Discard (0111110)\n// State 4: Flag (01111110)\n// State 5: Error (7 or more 1s)\n// State 6: Discard (0111110)\n\n// 6 consecutive 1s in state 0 -> state 1 (flag)\n// 6 consecutive 1s in state 1 -> state 2 (error)\n// 6 consecutive 1s in state 2 -> state 5 (error)\n// 6 consecutive 1s in state 3 -> state 6 (discard)\n// 6 consecutive 1s in state 4 -> state 0 (default)\n// 7 or more consecutive 1s in state 0 -> state 2 (error)\n// 7 or more consecutive 1s in state 1 -> state 5 (error)\n// 7 or more consecutive 1s in state 2 -> state 5 (error)\n// 7 or more consecutive 1s in state 3 -> state 6 (discard)\n// 7 or more consecutive 1s in state 4 -> state 5 (error)\n// 7 or more consecutive 1s in state 5 -> state 5 (error)\n// 7 or more consecutive 1s in state 6 -> state 6 (discard)\n\n// Default state is 0.\n// State 1 is flag.\n// State 2 is error.\n// State 3 is discard.\n// State 4 is flag.\n// State 5 is error.\n// State 6 is discard.\n\n// Initialize the state and output registers.\nreg [2:0] state, next_state;\nreg disc, flag, err;\n\n// State transition and output logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= 3'b000;\n\t\tdisc <= 1'b0;\n\t\tflag <= 1'b0;\n\t\terr <= 1'b0;\n\tend else begin\n\t\tstate <= next_state;\n\t\tcase (state)\n\t\t\t3'b000: begin // Default\n\t\t\t\tif (in == 1'b0) next_state = 3'b000;\n\t\t\t\telse if (in == 1'b1) next_state = 3'b001;\n\t\t\t\telse next_state = 3'b100;\n\t\t\t\tdisc <= 1'b0;\n\t\t\t\tflag <= 1'b0;\n\t\t\t\terr <= 1'b0;\n\t\t\tend\n\t\t\t3'b001: begin // Flag\n\t\t\t\tif (in == 1'b0) next_state = 3'b000;\n\t\t\t\telse next_state = 3'b010;\n\t\t\t\tdisc <= 1'b0;\n\t\t\t\tflag <= 1'b1;\n\t\t\t\terr <= 1'b0;\n\t\t\tend\n\t\t\t3'b010: begin // Error\n\t\t\t\tif (in == 1'b0) next_state = 3'b000;\n\t\t\t\telse next_state = 3'b011;\n\t\t\t\tdisc <= 1'b0;\n\t\t\t\tflag <= 1'b0;\n\t\t\t\terr <= 1'b1;\n\t\t\tend"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n// Define states\nparameter IDLE = 2'b00;\nparameter LEVEL_1 = 2'b01;\nparameter LEVEL_2 = 2'b10;\nparameter LEVEL_3 = 2'b11;\n\n// Define state register and next state logic\nreg [1:0] state, next_state;\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Define outputs\nalways @(state, s) begin\n    case (state)\n        IDLE: begin\n            fr3 = 0;\n            fr2 = 0;\n            fr1 = 0;\n            dfr = 0;\n        end\n        LEVEL_1: begin\n            fr3 = 0;\n            fr2 = 1;\n            fr1 = 1;\n            dfr = 0;\n        end\n        LEVEL_2: begin\n            fr3 = 0;\n            fr2 = 1;\n            fr1 = 1;\n            dfr = 1;\n        end\n        LEVEL_3: begin\n            fr3 = 1;\n            fr2 = 1;\n            fr1 = 1;\n            dfr = 1;\n        end\n    endcase\nend\n\n// Define next state logic\nalways @(state, s) begin\n    case (state)\n        IDLE: begin\n            if (s == 3) begin\n                next_state = IDLE;\n            end else if (s == 2) begin\n                next_state = LEVEL_1;\n            end else if (s == 1) begin\n                next_state = LEVEL_2;\n            end else begin\n                next_state = LEVEL_3;\n            end\n        end\n        LEVEL_1: begin\n            if (s == 3) begin\n                next_state = IDLE;\n            end else if (s == 2) begin\n                next_state = LEVEL_1;\n            end else if (s == 1) begin\n                next_state = LEVEL_2;\n            end else begin\n                next_state = LEVEL_3;\n            end\n        end\n        LEVEL_2: begin\n            if (s == 3) begin\n                next_state = IDLE;\n            end else if (s == 2) begin\n                next_state = LEVEL_1;\n            end else if (s == 1) begin\n                next_state = LEVEL_2;\n            end else begin\n                next_state = LEVEL_3;\n            end\n        end\n        LEVEL_3: begin\n            if (s == 3) begin\n                next_state = IDLE;\n            end else if (s == 2) begin\n                next_state = LEVEL_1;\n            end else if (s == 1) begin\n                next_state = LEVEL_2;\n            end else begin\n                next_state = LEVEL_3;\n            end\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "// FSM states\n\tparameter IDLE = 2'b00;\n\tparameter START = 2'b01;\n\tparameter DATA = 2'b10;\n\tparameter STOP = 2'b11;\n\t\t\t\t\t\t\n\t// FSM outputs\n\tparameter IDLE_OUT = 2'b00;\n\tparameter DATA_OUT = 2'b01;\n\tparameter STOP_OUT = 2'b10;\n\t\t\t\t\t\t\n\t// Internal signals\n\treg [1:0] state;\n\treg [7:0] data;\n\treg [1:0] bit_counter;\n\treg done;\n\t\t\t\t\t\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tdata <= 8'b0;\n\t\t\tbit_counter <= 2'b0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= START;\n\t\t\t\t\t\tbit_counter <= 2'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTART: begin\n\t\t\t\t\tif (bit_counter == 2'b0) begin\n\t\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\t\tbit_counter <= bit_counter + 1;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= DATA;\n\t\t\t\t\t\tbit_counter <= 2'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_counter < 8) begin\n\t\t\t\t\t\tdata[bit_counter] <= in;\n\t\t\t\t\t\tbit_counter <= bit_counter + 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= STOP;\n\t\t\t\t\t\tbit_counter <= 2'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (bit_counter == 2'b0) begin\n\t\t\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= STOP;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tbit_counter <= 2'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\t\t\t\t\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tdata <= 8'b0;\n\t\t\tbit_counter <= 2'b0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tif (state == DATA) begin\n\t\t\t\tcase (bit_counter)\n\t\t\t\t\t2'b00: done <= 1'b0;\n\t\t\t\t\t2'b01: done <= 1'b0;\n\t\t\t\t\t2'b10: done <= 1'b0;\n\t\t\t\t\t2'b11: done <= 1'b0;\n\t\t\t\t\tdefault: done <= 1'b1;\n\t\t\t\tendcase\n\t\t\tend\n\t\t\tif (state == STOP) begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tbit_counter"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= IDLE;\n\t\tbit_count <= 0;\n\t\tdata_byte <= 0;\n\t\tdone <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\tstate <= START_BIT;\n\t\t\t\t\tbit_count <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART_BIT: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= DATA_BITS;\n\t\t\t\t\tbit_count <= 2;\n\t\t\t\tend\n\t\t\tend\n\t\t\tDATA_BITS: begin\n\t\t\t\tif (bit_count == 9) begin\n\t\t\t\t\tstate <= STOP_BIT;\n\t\t\t\t\tbit_count <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tdata_byte <= {data_byte[6:0], in};\n\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP_BIT: begin\n\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tout_byte <= data_byte;\n\t\t\t\t\tdone <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nreg [7:0] data_byte;\nreg [2:0] state;\nreg [3:0] bit_count;\nreg done;\n\nparameter IDLE = 3'b000;\nparameter START_BIT = 3'b001;\nparameter DATA_BITS = 3'b010;\nparameter STOP_BIT = 3'b011;\n\nendmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    reg [6:0] pht_state[0:127];\n    reg [6:0] history_reg;\n    reg [6:0] pht_index;\n    reg [6:0] pht_count;\n    reg pht_trained;\n    reg predict_trained;\n    reg predict_taken;\n    reg [6:0] predict_history;\n\n    assign predict_taken = pht_state[pht_index][1];\n    assign predict_history = pht_state[pht_index];\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            history_reg <= 0;\n            pht_index <= 0;\n            pht_count <= 0;\n            predict_trained <= 0;\n            predict_taken <= 0;\n            predict_history <= 0;\n            pht_trained <= 0;\n        end else begin\n            if (predict_valid) begin\n                pht_index <= {history_reg, predict_pc} ^ 7'b1111111;\n                predict_trained <= 1;\n                predict_taken <= pht_state[pht_index][1];\n                predict_history <= pht_state[pht_index];\n            end else if (predict_trained) begin\n                predict_trained <= 0;\n            end\n\n            if (train_valid) begin\n                if (train_pc == pht_index) begin\n                    pht_count[pht_index] <= (train_taken) ? min(pht_count[pht_index] + 1, 15) : max(pht_count[pht_index] - 1, 0);\n                    if (train_mispredicted) begin\n                        history_reg <= train_history;\n                    end\n                end\n                pht_trained <= 1;\n            end else if (pht_trained) begin\n                pht_trained <= 0;\n            end\n        end\n    end\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            history_reg <= 0;\n        end else begin\n            if (predict_valid) begin\n                history_reg <= predict_history[6:0];\n            end\n        end\n    end\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            pht_state <= 0;\n        end else begin\n            if (train_valid) begin\n                pht_state[train_pc] <= {pht_count[train_pc], train_taken};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter falling_state = 2'b10;\n\tparameter digging_state = 2'b11;\n\n\t// Define the outputs\n\tparameter walk_left_output = 1'b1;\n\tparameter walk_right_output = 1'b0;\n\tparameter aaah_output = 1'b1;\n\tparameter digging_output = 1'b1;\n\n\t// Define the state register and output registers\n\treg [1:0] state_reg;\n\treg walk_left_reg;\n\treg walk_right_reg;\n\treg aaah_reg;\n\treg digging_reg;\n\n\t// Define the state machine\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate_reg <= walk_left_state;\n\t\t\twalk_left_reg <= 1'b1;\n\t\t\twalk_right_reg <= 1'b0;\n\t\t\taaah_reg <= 1'b0;\n\t\t\tdigging_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state_reg)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tstate_reg <= walk_right_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b1;\n\t\t\t\t\t\taaah_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b0;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tstate_reg <= digging_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tstate_reg <= walk_left_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b1;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b0;\n\t\t\t\t\tend else if (dig) begin\n\t\t\t\t\t\tstate_reg <= digging_state;\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b0;\n\t\t\t\t\t\taaah_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\twalk_left_reg <= 1'b0;\n\t\t\t\t\t\twalk_right_reg <= 1'b1;\n\t\t\t\t\t\taaah_reg <= 1'b0;\n\t\t\t\t\t\tdigging_reg <= 1'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfalling_state: begin"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n\t// Define states\n\tparameter IDLE = 2'b00;\n\tparameter START = 2'b01;\n\tparameter PATTERN = 2'b10;\n\tparameter COUNTING = 2'b11;\n\n\t// Define state register and next state logic\n\treg [1:0] state, next_state;\n\talways @ (posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Define outputs\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tshift_ena = 0;\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tshift_ena = 1;\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tPATTERN: begin\n\t\t\t\tshift_ena = 1;\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tCOUNTING: begin\n\t\t\t\tshift_ena = 0;\n\t\t\t\tcounting = 1;\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Define next state logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (data == 1'b1) begin\n\t\t\t\t\tnext_state = START;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else if (data == 1'b1) begin\n\t\t\t\t\tnext_state = PATTERN;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = START;\n\t\t\t\tend\n\t\t\tend\n\t\t\tPATTERN: begin\n\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else if (data == 1'b1) begin\n\t\t\t\t\tnext_state = COUNTING;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = PATTERN;\n\t\t\t\tend\n\t\t\tend\n\t\t\tCOUNTING: begin\n\t\t\t\tif (done_counting) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = COUNTING;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Define done logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tPATTERN: begin\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tCOUNTING: begin\n\t\t\t\tif (done_counting) begin\n\t\t\t\t\tdone = 1;\n\t\t\t\tend else begin\n\t\t\t\t\tdone = 0;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Define ack logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (data == 1'b0) begin\n\t\t\t\t\tif (ack) begin\n\t\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "// (1) Load initial state:\nalways @ (posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend\n\telse begin\n\t\tq <= q; // no-op\n\tend\nend\n\n// (2) Advance game state:\nalways @ (posedge clk) begin\n\t// 16x16 toroid:\n\t// Cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), (1,15)\n\t// Cell (0,1) has 7 neighbours: (15,2), (14,1), (14,0), (14,15), (0,2), (1,2), (1,0)\n\t// Cell (0,2) has 5 neighbours: (15,3), (14,2), (14,1), (14,0), (14,15), (0,3), (1,3)\n\t// Cell (0,3) has 6 neighbours: (15,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,4), (1,4)\n\t// Cell (0,4) has 4 neighbours: (15,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,5)\n\t// Cell (0,5) has 3 neighbours: (15,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,6)\n\t// Cell (0,6) has 2 neighbours: (15,7), (14,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,7)\n\t// Cell (0,7) has 1 neighbour: (15,8), (14,7), (14,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,8)\n\t// Cell (0,8) has 0 neighbours: (15,9), (14,8), (14,7), (14,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,9)\n\t// Cell (0,9) has 1 neighbour: (15,10), (14,9), (14,8), (14,7), (14,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,10)\n\t// Cell (0,10) has 2 neighbours: (15,11), (14,10), (14,9), (14,8), (14,7), (14,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,11)\n\t// Cell (0,11) has 3 neighbours: (15,12), (14,11), (14,10), (14,9), (14,8), (14,7), (14,6), (14,5), (14,4), (14,3), (14,2), (14,1), (14,0), (14,15), (0,12)\n\t// Cell (0,12) has 4 neighbours: (15,1"}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output walk_left,\n    output walk_right,\n    output aaah,\n    output digging\n);\n\n    // Define states\n    parameter walk_left_state = 2'b00;\n    parameter walk_right_state = 2'b01;\n    parameter digging_state = 2'b10;\n    parameter falling_state = 2'b11;\n    // Define outputs\n    assign walk_left = (state == walk_left_state);\n    assign walk_right = (state == walk_right_state);\n    assign aaah = (state == falling_state);\n    assign digging = (state == digging_state);\n    // Define signals\n    reg [1:0] state;\n    reg digging_state_reg;\n    reg falling_state_reg;\n    // Define state transitions\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= walk_left_state;\n            digging_state_reg <= 0;\n            falling_state_reg <= 0;\n        end else begin\n            case (state)\n                walk_left_state: begin\n                    if (bump_right) begin\n                        state <= walk_right_state;\n                    end else if (dig) begin\n                        state <= digging_state;\n                        digging_state_reg <= 1;\n                    end else if (!ground) begin\n                        state <= falling_state;\n                        falling_state_reg <= 1;\n                    end\n                end\n                walk_right_state: begin\n                    if (bump_left) begin\n                        state <= walk_left_state;\n                    end else if (dig) begin\n                        state <= digging_state;\n                        digging_state_reg <= 1;\n                    end else if (!ground) begin\n                        state <= falling_state;\n                        falling_state_reg <= 1;\n                    end\n                end\n                digging_state: begin\n                    if (ground == 1) begin\n                        state <= walk_left_state;\n                        digging_state_reg <= 0;\n                    end\n                end\n                falling_state: begin\n                    if (ground == 1) begin\n                        state <= walk_left_state;\n                        falling_state_reg <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n    // Define digging state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            digging_state_reg <= 0;\n        end else begin\n            if (digging_state_reg && ground) begin\n                state <= digging_state;\n                digging_state_reg <= 1;\n            end else if (ground == 0) begin\n                state <= falling_state;\n                falling_state_reg <= 1;\n            end\n        end\n    end\n    // Define falling state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            falling_state_reg <= 0;\n        end else begin\n            if (falling_state_reg && ground) begin\n                state <= walk_left_state;\n                falling_state_reg <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "Be consistent with your coding style (e.g., indentation, naming conventions, etc.) and write code that is easy to understand and maintain.\n\nModule top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n\treg [3:0] hours;\n\treg [3:0] minutes;\n\treg [3:0] seconds;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\thours <= 4'b0010; // 12\n\t\t\tminutes <= 4'b0000;\n\t\t\tseconds <= 4'b0000;\n\t\t\tpm <= 1'b0;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tif (seconds == 4'b1011) begin\n\t\t\t\tseconds <= 4'b0000;\n\t\t\t\tif (minutes == 4'b1011) begin\n\t\t\t\t\tminutes <= 4'b0000;\n\t\t\t\t\tif (hours == 4'b1011) begin\n\t\t\t\t\t\thours <= 4'b0000;\n\t\t\t\t\t\tpm <= ~pm;\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\thours <= hours + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tminutes <= minutes + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tseconds <= seconds + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign hh = {pm, hours};\n\tassign mm = {1'b0, minutes};\n\tassign ss = {1'b0, seconds};\n\nendmodule"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output walk_left,\n    output walk_right,\n    output aaah\n);\n\n    reg [1:0] state;\n    reg walk_left_reg;\n    reg walk_right_reg;\n    reg aaah_reg;\n\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n    parameter FALLING = 2'b10;\n\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            walk_left_reg <= 1;\n            walk_right_reg <= 0;\n            aaah_reg <= 0;\n        end\n        else begin\n            case (state)\n                WALK_LEFT: begin\n                    if (bump_left) begin\n                        state <= WALK_RIGHT;\n                        walk_left_reg <= 0;\n                        walk_right_reg <= 1;\n                    end\n                    else if (!ground) begin\n                        state <= FALLING;\n                        walk_left_reg <= 0;\n                        walk_right_reg <= 0;\n                    end\n                end\n                WALK_RIGHT: begin\n                    if (bump_right) begin\n                        state <= WALK_LEFT;\n                        walk_left_reg <= 1;\n                        walk_right_reg <= 0;\n                    end\n                    else if (!ground) begin\n                        state <= FALLING;\n                        walk_left_reg <= 0;\n                        walk_right_reg <= 0;\n                    end\n                end\n                FALLING: begin\n                    if (ground) begin\n                        state <= WALK_LEFT;\n                        walk_left_reg <= walk_left_reg;\n                        walk_right_reg <= walk_right_reg;\n                    end\n                    else begin\n                        state <= FALLING;\n                        walk_left_reg <= walk_left_reg;\n                        walk_right_reg <= walk_right_reg;\n                    end\n                    if (bump_left) begin\n                        state <= WALK_RIGHT;\n                        walk_left_reg <= 0;\n                        walk_right_reg <= 1;\n                    end\n                    if (bump_right) begin\n                        state <= WALK_LEFT;\n                        walk_left_reg <= 1;\n                        walk_right_reg <= 0;\n                    end\n                    aaah_reg <= 1;\n                end\n            endcase\n        end\n    end\n\n    assign walk_left = walk_left_reg;\n    assign walk_right = walk_right_reg;\n    assign aaah = aaah_reg;\n\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "always @(posedge clk) begin\n    if (reset) begin\n        q <= 0;\n        ena <= 0;\n    end else begin\n        if (q[15] == 1) begin\n            q <= q + 1;\n        end\n        if (q[12:11] == 3'b11) begin\n            q <= q + 1;\n        end\n        if (q[9:8] == 2'b11) begin\n            q <= q + 1;\n        end\n        if (q[6:5] == 2'b11) begin\n            q <= q + 1;\n        end\n        if (q[3:0] == 4'b1011) begin\n            q <= q + 1;\n        end\n        if (q[15] == 1) begin\n            ena[3] <= 1;\n        end else begin\n            ena[3] <= 0;\n        end\n        if (q[12:11] == 2'b11) begin\n            ena[2] <= 1;\n        end else begin\n            ena[2] <= 0;\n        end\n        if (q[9:8] == 2'b11) begin\n            ena[1] <= 1;\n        end else begin\n            ena[1] <= 0;\n        end\n    end\nend"}
{"task_id": "mux2to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\n    assign out = (sel == 1'b0) ? a : b;\n\nendmodule"}
{"task_id": "m2014_q6b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\nalways @(*)\nbegin\n\tcase (y)\n\t\t3'b000: Y2 = (w) ? 1'b0 : 1'b1; // A\n\t\t3'b001: Y2 = (w) ? 1'b1 : 1'b0; // B\n\t\t3'b010: Y2 = 1'b0; // C\n\t\t3'b011: Y2 = 1'b1; // D\n\t\t3'b100: Y2 = 1'b0; // E\n\t\t3'b101: Y2 = 1'b1; // F\n\t\tdefault: Y2 = 1'bx; // Invalid state\n\tendcase\nend\n\nendmodule"}
{"task_id": "ringer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign ringer = ring & ~vibrate_mode;\n    assign motor = ring & vibrate_mode;\n\nendmodule"}
{"task_id": "alwaysblock1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an AND gate using both an assign statement and a combinational always block. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "module (i.e. and gate) to implement the AND gate. \nmodule top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n    assign out_assign = a & b;\n\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule"}
{"task_id": "zero", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that always outputs a LOW.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput zero);\n", "completion": "module top_module(\n    output zero);\n\n    assign zero = 1'b0;\n\nendmodule"}
{"task_id": "circuit7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= a;\n        q <= q;\n    end\n\nendmodule"}
{"task_id": "ece241_2014_q5a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "// Verilog code\n\t// Registers for state and output\n\treg [1:0] state;\n\treg [31:0] output_reg;\n\t// Register for input bit\n\treg input_bit;\n\t// Wires for subtracting and outputting\n\twire [31:0] subtract;\n\twire [31:0] output;\n\t// Output assignment\n\tassign z = output;\n\t// State machine\n\talways @(posedge clk or negedge areset) begin\n\t\tif (~areset) begin\n\t\t\tstate <= 2'b00;\n\t\t\toutput_reg <= 32'b0;\n\t\t\tinput_bit <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\t2'b00: begin // Idle state\n\t\t\t\t\tinput_bit <= x;\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\tend\n\t\t\t\t2'b01: begin // Convert state\n\t\t\t\t\toutput_reg <= {1'b1, input_bit, output_reg[31:1]};\n\t\t\t\t\tinput_bit <= x;\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\tend\n\t\t\t\t2'b10: begin // Output state\n\t\t\t\t\toutput <= subtract;\n\t\t\t\t\tstate <= 2'b00;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t// Subtraction logic\n\tassign subtract = output_reg + 1;\nendmodule"}
{"task_id": "fsm3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore state machine with one input, one output, and four states\n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\n\n// Moore state machine\nreg [1:0] state, next_state;\nreg out;\n\n// State encoding\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\nalways @(posedge clk or negedge areset) begin\n\tif (~areset) begin\n\t\tstate <= A;\n\t\tout <= 0;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\t\tout <= out;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (in == 0) begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (in == 0) begin\n\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend\n\t\tC: begin\n\t\t\tif (in == 0) begin\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = D;\n\t\t\tend\n\t\tend\n\t\tD: begin\n\t\t\tif (in == 0) begin\n\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = B;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "vector2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that reverses the byte order of a 32-bit vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule"}
{"task_id": "m2014_q4c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a simple D flip flop with active high synchronous reset (reset output to 0).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "module hierarchy.\n  * Do not add any Verilog code for Verilog module ports.\n  * Do not add any Verilog code for Verilog module body.\n\n  * Follow the Verilog code design directly.\n  * Be concise and focused on the key points.\n  * Do not introduce new variables or modules.\n  * Do not add any Verilog code for Verilog directives.\n  * Do not add any Verilog code for Verilog pre-processor.\n  * Do not add any Verilog code for Verilog module hierarchy.\n  * Do not add any Verilog code for Verilog module ports.\n  * Do not add any Verilog code for Verilog module statements.\n\n  * Do not add any Verilog code for Verilog module statements.\n  * Do not add any Verilog code for Verilog module body.\n  * Do not add any Verilog code for Verilog module guards.\n  * Do not add any Verilog code for Verilog module pragmas.\n  * Do not add any Verilog code for Verilog module types.\n  * Do not add any Verilog code for Verilog module generate.\n  * Do not add any Verilog code for Verilog module attributes.\n  * Do not add any Verilog code for Verilog module parameter.\n  * Do not add any Verilog code for Verilog module generate.\n  * Do not add any Verilog code for Verilog module concurrent.\n  * Do not add any Verilog code for Verilog module synchronizers.\n  * Do not add any Verilog code for Verilog module ports.\n  * Do not add any Verilog code for Verilog module ports.\n  * 32-bit or 64-bit width is ok.\n  * Do not add any Verilog code for Verilog module declarations..\n  * Do not add any Verilog code for Verilog module imports.\n  * Do not add any Verilog code for Verilog module exports..\n  * Do not add any Verilog code for Verilog module guarded statements..\n  * Do not add any Verilog code for Verilog module loops.\n  * Do not add any Verilog code for Verilog module selection.\n  * Do not add any Verilog code for Verilog module sequential.\n  * Do not add any Verilog code for Verilog module concurrent.\n module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    reg q_reg;\n\n    always @(posedge clk) begin\n        if (r) begin\n            q_reg <= 1'b0;\n        end\n        else begin\n            q_reg <= d;\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule"}
{"task_id": "mt2015_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the boolean function z = (x^y) & x.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "endmodule"}
{"task_id": "shift18", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.\n\n// Define constants\nparameter WIDTH = 64;\n\n// Define internal signals\nreg [63:0] shift_reg;\nreg [63:0] data_reg;\nreg [63:0] shifted_data;\nreg [1:0] shift_amount;\n\n// Define the Verilog code\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tshift_reg <= data;\n\t\tdata_reg <= data;\n\tend else if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00: begin\n\t\t\t\tshifted_data <= {shift_reg[62:0], 1'b0};\n\t\t\tend\n\t\t\t2'b01: begin\n\t\t\t\tshifted_data <= {shift_reg[55:0], 8'b0};\n\t\t\tend\n\t\t\t2'b10: begin\n\t\t\t\tshifted_data <= {1'b0, shift_reg[63:1]};\n\t\t\tend\n\t\t\t2'b11: begin\n\t\t\t\tshifted_data <= {8'b0, shift_reg[63:8]};\n\t\t\tend\n\t\tendcase\n\t\tshift_reg <= shifted_data;\n\t\tdata_reg <= shift_reg;\n\tend\nend\n\nassign q = data_reg;\n\nendmodule"}
{"task_id": "ece241_2013_q8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "// FSM state encoding\n\t\tparameter S0 = 3'b000;\n\t\tparameter S1 = 3'b001;\n\t\tparameter S2 = 3'b010;\n\t\tparameter S3 = 3'b011;\n\t\tparameter S4 = 3'b100;\n\t\tparameter S5 = 3'b101;\n\t\tparameter S6 = 3'b110;\n\t\tparameter S7 = 3'b111;\n\n\t\t// FSM state register and next state logic\n\t\treg [2:0] state, next_state;\n\t\talways @(posedge clk or negedge aresetn) begin\n\t\t\tif (~aresetn) begin\n\t\t\t\tstate <= S0;\n\t\t\tend else begin\n\t\t\t\tstate <= next_state;\n\t\t\tend\n\t\tend\n\n\t\t// FSM output logic\n\t\talways @(state or x) begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tend\n\t\t\t\t\tz = 0;\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S2;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tend\n\t\t\t\t\tz = 0;\n\t\t\t\tend\n\t\t\t\tS2: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S3;\n\t\t\t\t\t\tz = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS3: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S4;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tend\n\t\t\t\t\tz = 0;\n\t\t\t\tend\n\t\t\t\tS4: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S5;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tend\n\t\t\t\t\tz = 0;\n\t\t\t\tend\n\t\t\t\tS5: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S6;\n\t\t\t\t\t\tz = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS6: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S7;\n\t\t\t\t\t\tz = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tS7: begin\n\t\t\t\t\tif (x) begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = S0;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\nendmodule"}
{"task_id": "m2014_q6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "endmodule"}
{"task_id": "fsm_ps2data", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output [23:0] out_bytes,\n    output done\n);\n\n    reg [2:0] state;\n    reg [7:0] byte1;\n    reg [7:0] byte2;\n    reg [7:0] byte3;\n    reg [23:0] message;\n    reg done_reg;\n\n    // Define the states\n    parameter IDLE = 3'b000;\n    parameter FIND_START = 3'b001;\n    parameter READ_BYTE1 = 3'b010;\n    parameter READ_BYTE2 = 3'b011;\n    parameter READ_BYTE3 = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte1 <= 8'h00;\n            byte2 <= 8'h00;\n            byte3 <= 8'h00;\n            message <= 24'h000000;\n            done_reg <= 1'b0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (in[3] == 1) begin\n                        state <= FIND_START;\n                    end\n                end\n                FIND_START: begin\n                    if (in[3] == 1) begin\n                        byte1 <= in;\n                        state <= READ_BYTE1;\n                    end\n                end\n                READ_BYTE1: begin\n                    if (in[3] == 1) begin\n                        byte2 <= in;\n                        state <= READ_BYTE2;\n                    end\n                end\n                READ_BYTE2: begin\n                    if (in[3] == 1) begin\n                        byte3 <= in;\n                        state <= READ_BYTE3;\n                    end\n                end\n                READ_BYTE3: begin\n                    if (in[3] == 1) begin\n                        message <= {byte3, byte2, byte1};\n                        done_reg <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out_bytes = message;\n    assign done = done_reg;\n\nendmodule"}
{"task_id": "2012_q2b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\n\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "vector0", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "assign outv = vec;\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0];\n\nendmodule"}
{"task_id": "kmap4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @ (a or b or c or d)\nbegin\n    case ({a,b})\n        2'b00: out = (c&d);\n        2'b01: out = (~c&d);\n        2'b10: out = (c&~d);\n        2'b11: out = (~c&~d);\n    endcase\nend\n\nendmodule"}
{"task_id": "vector1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "module name 'top_module' for the Verilog code.\n\nmodule top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule"}
{"task_id": "norgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b);\n\nendmodule"}
{"task_id": "alwaysblock2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "// Assign statement\nassign out_assign = a ^ b;\n\n// Combinational always block\nalways @(*) begin\n\tout_always_comb = a ^ b;\nend\n\n// Clocked always block\nalways @(posedge clk) begin\n\tout_always_ff <= a ^ b;\nend\n\nendmodule"}
{"task_id": "m2014_q6c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "module code. Your code should start with:\n```verilog\nalways @ (y or w) begin\n    case (y)\n        // State A (000001)\n        6'b000001: begin\n            Y2 = 1'b0;\n            Y4 = 1'b0;\n        end\n        // State B (000010)\n        6'b000010: begin\n            Y2 = 1'b1;\n            Y4 = 1'b0;\n        end\n        // State C (000100)\n        6'b000100: begin\n            Y2 = 1'b0;\n            Y4 = 1'b1;\n        end\n        // State D (001000)\n        6'b001000: begin\n            Y2 = 1'b1;\n            Y4 = 1'b1;\n        end\n        // State E (010000)\n        6'b010000: begin\n            Y2 = 1'b0;\n            Y4 = 1'b0;\n        end\n        // State F (100000)\n        6'b100000: begin\n            Y2 = 1'b0;\n            Y4 = 1'b1;\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "mux256to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= w;\n    end else if (E) begin\n        Q <= Q;\n    end else begin\n        Q <= {Q[n-2:0], R};\n    end\nend\n\nendmodule"}
{"task_id": "ece241_2014_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "// Three D flip-flops\n\treg dff1, dff2, dff3;\n\t// Three gates\n\twire xor1, and1, or1;\n\t// XOR gate\n\txor xor1_inst (.a(x), .b(dff1), .y(xor1));\n\t// AND gate\n\tand and1_inst (.a(x), .b(~dff1), .y(and1));\n\t// OR gate\n\tor or1_inst (.a(x), .b(~dff1), .y(or1));\n\t// D flip-flops\n\talways @(posedge clk) begin\n\t\tdff1 <= xor1;\n\t\tdff2 <= and1;\n\t\tdff3 <= or1;\n\tend\n\t// XNOR gate\n\txnor xnor1_inst (.a(dff1), .b(dff2), .c(dff3), .y(z));\nendmodule"}
{"task_id": "circuit4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "rule110", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "// 512-cell system, advance by one time step each clock cycle.\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// Boundaries (q[-1] and q[512]) are both zero (off).\n\nreg [511:0] q_next;\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else begin\n\t\tq <= q_next;\n\tend\nend\n\nalways @(*) begin\n\tq_next[0] = q[1] & q[0];\n\tq_next[1:511] = q[2:510] & (q[1] | q[0]);\n\tq_next[511] = q[510] & q[511];\nend\n\nendmodule"}
{"task_id": "fsm3s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n\n    // State encoding\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Output register\n    reg out_reg;\n\n    // State transition logic\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @ (*) begin\n        case (state)\n            A: begin\n                if (in == 1'b0) begin\n                    next_state = A;\n                end else begin\n                    next_state = B;\n                end\n            end\n            B: begin\n                if (in == 1'b0) begin\n                    next_state = C;\n                end else begin\n                    next_state = B;\n                end\n            end\n            C: begin\n                if (in == 1'b0) begin\n                    next_state = A;\n                end else begin\n                    next_state = D;\n                end\n            end\n            D: begin\n                if (in == 1'b0) begin\n                    next_state = C;\n                end else begin\n                    next_state = B;\n                end\n            end\n        endcase\n    end\n\n    // Output logic\n    always @ (state) begin\n        case (state)\n            A: out_reg = 1'b0;\n            B: out_reg = 1'b0;\n            C: out_reg = 1'b0;\n            D: out_reg = 1'b1;\n        endcase\n    end\n\n    // Assign output\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "circuit5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @* begin\n        if (a == 4'b0000) begin\n            if (b == 4'b0000) begin\n                q = 4'b0000;\n            end else if (b == 4'b0001) begin\n                q = 4'b0001;\n            end else if (b == 4'b0010) begin\n                q = 4'b0010;\n            end else if (b == 4'b0011) begin\n                q = 4'b0011;\n            end else if (b == 4'b0100) begin\n                q = 4'b0100;\n            end else if (b == 4'b0101) begin\n                q = 4'b0101;\n            end else if (b == 4'b0110) begin\n                q = 4'b0110;\n            end else if (b == 4'b0111) begin\n                q = 4'b0111;\n            end else if (b == 4'b1000) begin\n                q = 4'b1000;\n            end else if (b == 4'b1001) begin\n                q = 4'b1001;\n            end else if (b == 4'b1010) begin\n                q = 4'b1010;\n            end else if (b == 4'b1011) begin\n                q = 4'b1011;\n            end else if (b == 4'b1100) begin\n                q = 4'b1100;\n            end else if (b == 4'b1101) begin\n                q = 4'b1101;\n            end else if (b == 4'b1110) begin\n                q = 4'b1110;\n            end else if (b == 4'b1111) begin\n                q = 4'b1111;\n            end\n        end else begin\n            q = 4'bxxxx;\n        end\n    end\n\nendmodule"}
{"task_id": "bugs_mux2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n    always @ (sel, a, b) begin\n        if (~sel)\n            out = a;\n        else\n            out = b;\n    end\nendmodule"}
{"task_id": "mt2015_muxdff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "module three times\ntop_module top_inst1(\n    .clk(clk),\n    .L(L),\n    .q_in(q_in),\n    .r_in(r),\n    .Q(q[0])\n);\n\ntop_module top_inst2(\n    .clk(clk),\n    .L(L),\n    .q_in(q_in),\n    .r_in(r),\n    .Q(q[1])\n);\n\ntop_module top_inst3(\n    .clk(clk),\n    .L(L),\n    .q_in(q_in),\n    .r_in(r),\n    .Q(q[2])\n);\n\n// Connect the q output of the top_module to the q output of the full_module\nassign full_module.q = q;\n\nendmodule"}
{"task_id": "edgecapture", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out);\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 0;\n            prev_in <= 0;\n        end else begin\n            out <= out & (prev_in ^ in);\n            prev_in <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "dff8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "Your code should end with:\n```verilog\nendmodule"}
{"task_id": "ece241_2014_q1c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    wire [8:0] temp_s;\n    wire carry_out;\n\n    assign temp_s = {1'b0, a} + {1'b0, b};\n    assign s = temp_s[7:0];\n    assign carry_out = temp_s[8];\n\n    assign overflow = (a[7] == b[7] && s[7] != a[7]) || (a[7] != b[7] && s[7] == carry_out);\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n    // Define state register for next state\n    reg [9:0] state_reg;\n\n    // Define state encoding for convenience\n    localparam S = 10'b0000000001;\n    localparam S1 = 10'b0000000010;\n    localparam S11 = 10'b0000000100;\n    localparam S110 = 10'b0000001000;\n    localparam B0 = 10'b0000010000;\n    localparam B1 = 10'b0000100000;\n    localparam B2 = 10'b0001000000;\n    localparam B3 = 10'b0010000000;\n    localparam Count = 10'b0100000000;\n    localparam Wait = 10'b1000000000;\n\n    // Define next state logic\n    always @ (posedge d, posedge done_counting, posedge ack)\n    begin\n        case (state_reg)\n            S: begin\n                B3_next = B0;\n                S_next = S1;\n                S1_next = S;\n                Count_next = S;\n                Wait_next = S;\n            end\n            S1: begin\n                B3_next = B1;\n                S_next = S11;\n                S1_next = S1;\n                Count_next = S11;\n                Wait_next = S1;\n            end\n            S11: begin\n                B3_next = B2;\n                S_next = S110;\n                S1_next = S11;\n                Count_next = S110;\n                Wait_next = S11;\n            end\n            S110: begin\n                B3_next = B3;\n                S_next = S;\n                S1_next = S110;\n                Count_next = S;\n                Wait_next = B0;\n            end\n            B0: begin\n                B3_next = B3;\n                S_next = S;\n                S1_next = S110;\n                Count_next = S;\n                Wait_next = B1;\n            end\n            B1: begin\n                B3_next = B3;\n                S_next = S;\n                S1_next = S110;\n                Count_next = S;\n                Wait_next = B2;\n            end\n            B2: begin\n                B3_next = B3;\n                S_next = S;\n                S1_next = S110;\n                Count_next = S;\n                Wait_next = B3;\n            end\n            B3: begin\n                B3_next = B3;\n                S_next = S;\n                S1_next = S110;\n                Count_next = S;\n                Wait_next = Count;\n            end\n            Count: begin\n                B3_next = B3;\n                S_next = S;\n                S1_next = S110;\n                Count_next = S;\n                Wait_next = (done_counting) ? Wait : Count;\n            end\n            Wait: begin\n                B3_next = B3;\n                S_next = (ack) ? S : Wait;\n                S1_next = S110;\n                Count_next = S;\n                Wait_"}
{"task_id": "counter_2bc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    // Define states\n    localparam [1:0] WNLT = 2'b01;\n    localparam [1:0] WNT = 2'b10;\n    localparam [1:0] WTT = 2'b11;\n\n    // Define state register and next state logic\n    reg [1:0] state_reg;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_reg <= WNLT;\n        end else begin\n            case ({train_valid, train_taken})\n                2'b01: state_reg <= WTT;\n                2'b10: state_reg <= WNT;\n                default: state_reg <= state_reg;\n            endcase\n        end\n    end\n\n    // Output state\n    assign state = state_reg;\n\nendmodule"}
{"task_id": "always_casez", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez(in)\n            8'b00000001: pos = 3'd0;\n            8'b00000010: pos = 3'd1;\n            8'b00000100: pos = 3'd2;\n            8'b00001000: pos = 3'd3;\n            8'b00010000: pos = 3'd4;\n            8'b00100000: pos = 3'd5;\n            8'b01000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "always_nolatches", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSuppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4j", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 4-bit adder with full adders. The output sum should include the overflow bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n    wire [3:0] s;\n    wire c1, c2;\n\n    // First half adder\n    half_adder ha1(.a(x[0]), .b(y[0]), .sum(s[0]), .cout(c1));\n\n    // Second half adder\n    half_adder ha2(.a(x[1]), .b(y[1]), .sum(s[1]), .cout(c2));\n\n    // XOR gate to compute the carry bit for the current bit position\n    xor_gate xg1(.a(c1), .b(c2), .sum(sum[3]));\n\n    // Full adders\n    full_adder fa1(.a(x[0]), .b(y[0]), .cin(c1), .sum(s[0]), .cout(sum[2]));\n    full_adder fa2(.a(x[1]), .b(y[1]), .cin(c2), .sum(s[1]), .cout(sum[1]));\n    full_adder fa3(.a(x[2]), .b(y[2]), .cin(sum[2]), .sum(s[2]), .cout(sum[0]));\n    full_adder fa4(.a(x[3]), .b(y[3]), .cin(sum[1]), .sum(s[3]), .cout(sum[4]));\n\nendmodule"}
{"task_id": "history_shift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    logic [31:0] history_reg;\n    logic [31:0] next_history_reg;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history_reg <= 32'b0;\n        end else begin\n            if (predict_valid) begin\n                history_reg <= {history_reg[30:0], predict_taken};\n            end else if (train_mispredicted) begin\n                history_reg <= {train_history, train_taken};\n            end\n        end\n    end\n\n    assign predict_history = history_reg;\n\nendmodule"}
{"task_id": "wire_decl", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "// Declare intermediate wires\nwire and1_out;\nwire and2_out;\n\n// AND gates\nand and1 (and1_out, a, b);\nand and2 (and2_out, c, d);\n\n// OR gate\nor or1 (out, and1_out, and2_out);\n\n// NOT gate\nnot not1 (out_n, out);\n\nendmodule"}
{"task_id": "dff", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a single D flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "module top_module(\n    input clk,\n    input d,\n    output reg q);\n\n    always @(posedge clk)\n    begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "ece241_2013_q12", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] Q;\n    reg [2:0] ABC;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q[7:1] <= Q[6:0];\n            Q[0] <= S;\n        end\n    end\n\n    always @(*) begin\n        case (ABC)\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (enable) begin\n            case (ABC)\n                3'b000: Q[0] <= S;\n                3'b001: Q[1] <= S;\n                3'b010: Q[2] <= S;\n                3'b011: Q[3] <= S;\n                3'b100: Q[4] <= S;\n                3'b101: Q[5] <= S;\n                3'b110: Q[6] <= S;\n                3'b111: Q[7] <= S;\n                default: Q <= Q;\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (enable) begin\n            case (ABC)\n                3'b000: ABC <= A;\n                3'b001: ABC <= B;\n                3'b010: ABC <= C;\n                3'b011: ABC <= ~A;\n                3'b100: ABC <= ~B;\n                3'b101: ABC <= ~C;\n                3'b110: ABC <= A & B;\n                3'b111: ABC <= A | B;\n                default: ABC <= ABC;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "thermostat", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Define internal signals\n    wire heater_on;\n    wire aircon_on;\n    wire fan_on_internal;\n\n    // Heater logic\n    assign heater = mode & too_cold & ~fan_on;\n    assign heater_on = mode & too_cold;\n\n    // Air conditioner logic\n    assign aircon = ~mode & too_hot & ~fan_on;\n    assign aircon_on = ~mode & too_hot;\n\n    // Fan logic\n    assign fan_on_internal = fan_on | (heater_on | aircon_on);\n    assign fan = fan_on_internal;\n\nendmodule"}
{"task_id": "ece241_2013_q2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // SOP (sum of products)\n    assign out_sop = ~(a & b & c & d) & ~(a & b & c & ~d) & ~(a & b & ~c & d) & ~(a & b & ~c & ~d) & ~(a & ~b & c & d) & ~(a & ~b & c & ~d) & ~(a & ~b & ~c & d) & ~(~a & b & c & d) & ~(~a & b & c & ~d) & ~(~a & b & ~c & d) & ~(~a & b & ~c & ~d) & ~(~a & ~b & c & d) & ~(~a & ~b & c & ~d) & ~(~a & ~b & ~c & d);\n\n    // POS (product of sums)\n    assign out_pos = (~a & b & c & d) & (~a & b & c & ~d) & (~a & b & ~c & d) & (~a & ~b & c & d) & (~a & ~b & c & ~d) & (~a & ~b & ~c & d);\n\nendmodule"}
{"task_id": "lfsr32", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "and end with:\n```verilog\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 32'h1;\n\tend else begin\n\t\tq <= {q[31], q[31] ^ q[22] ^ q[2] ^ q[1]};\n\tend\nend\nendmodule"}
{"task_id": "circuit3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = a & b & c & d;\n\nendmodule"}
{"task_id": "7420", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "module outputs p1y and p2y.\n\n// The Verilog code for the module is:\n```verilog\nmodule top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implement the two NAND gates using Verilog code.\n    // The Verilog code for the two NAND gates is:\n    // NAND1: ~(p1a & p1b & p1c & p1d)\n    // NAND2: ~(p2a & p2b & p2c & p2d)\n\n    // Assign the outputs of the two NAND gates to the module outputs p1y and p2y.\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule"}
{"task_id": "popcount255", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "Follow the naming convention for the Verilog code and use the '=' for assignment instead of ':' for the 'for' loop.\n\nmodule top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\nreg [7:0] count [8:0:0];\n\nalways @(*) begin\n\tcount[0] = in[0];\n\tcount[1] = in[1] ^ in[0];\n\tcount[2] = in[2] ^ in[1] ^ in[0];\n\tcount[3] = in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[4] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[5] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[8] = in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[9] = in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[10] = in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[11] = in[11] ^ in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[12] = in[12] ^ in[11] ^ in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[13] = in[13] ^ in[12] ^ in[11] ^ in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[14] = in[14] ^ in[13] ^ in[12] ^ in[11] ^ in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[15] = in[15] ^ in[14] ^ in[13] ^ in[12] ^ in[11] ^ in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[16] = in[16] ^ in[15] ^ in[14] ^ in[13] ^ in[12] ^ in[11] ^ in[10] ^ in[9] ^ in[8] ^ in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\tcount[17] = in[17] ^ in[16] ^ in[15] ^ in[14] ^ in[13]"}
{"task_id": "gatesv", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    assign out_both[0] = in[0] & in[1];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[2] = in[2] & in[3];\n\n    assign out_any[0] = in[0] | in[1];\n    assign out_any[1] = in[1] | in[2];\n    assign out_any[2] = in[2] | in[3];\n\n    assign out_different[0] = in[0] ^ in[1];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[3] = in[3] ^ in[0];\n\nendmodule"}
{"task_id": "circuit6", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'b1232;\n        3'b001: q = 16'baee;\n        3'b010: q = 16'27d4;\n        3'b011: q = 16'5a0e;\n        3'b100: q = 16'2066;\n        3'b101: q = 16'64ce;\n        3'b110: q = 16'c526;\n        3'b111: q = 16'2f19;\n    endcase\nend\n\nendmodule"}
{"task_id": "countslow", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "Also, add comments where necessary to make the code more readable and understandable.\n\nFollow the Verilog coding standards and write the code in a clean and organized manner.\n\nMODULE top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;\n\t\tend\n\t\telse if (slowena) begin\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "m2014_q4f", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    wire and_out;\n\n    assign and_out = in1 & (in2);\n    assign out = and_out;\n\nendmodule"}
{"task_id": "m2014_q4h", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module assigns the output port to the same value as the input port combinationally.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "module top_module(\n    input in,\n    output out);\n\n    assign out = in;\n\nendmodule"}
{"task_id": "fsm1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Declare states\nparameter A = 2'b00;\nparameter B = 2'b01;\n\n// Declare outputs\noutput reg out;\n\n// Declare states\nreg [1:0] state;\n\n// Define state transitions and outputs\nalways @(posedge clk, negedge areset) begin\n\tif (!areset) begin\n\t\tstate <= B;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Define output\nalways @(state) begin\n\tcase (state)\n\t\tA: out <= 1'b0;\n\t\tB: out <= 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "dualedge", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "// Synchronous reset\n    reg reset;\n    initial reset = 1;\n    always @(posedge clk) reset <= 0;\n    \n    // Dual-edge triggered flip-flop\n    reg q_reg;\n    always @(posedge clk or negedge clk) begin\n        if (reset) begin\n            q_reg <= 0;\n        end else if (d) begin\n            q_reg <= 1;\n        end else if (!q_reg) begin\n            q_reg <= 1;\n        end\n    end\n    \n    // Output\n    always @(posedge clk or negedge clk) begin\n        if (reset) q <= 0;\n        else q <= q_reg;\n    end\nendmodule"}
{"task_id": "xnorgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an XNOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input [1:0] a, \n    input [1:0] b,\n    output [1:0] out\n);\n\nassign out[0] = ~(a[0] ^ b[0]);\nassign out[1] = ~(a[1] ^ b[1]);\n\nendmodule"}
{"task_id": "mt2015_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nModule A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n    wire a1, a2, b1, b2;\n    \n    A a1_inst(.x(x), .y(y), .z(a1));\n    B b1_inst(.x(x), .y(y), .z(b1));\n    A a2_inst(.x(x), .y(y), .z(a2));\n    B b2_inst(.x(x), .y(y), .z(b2));\n    \n    OR or_inst(.a(a1), .b(b1), .z(z));\n    AND and_inst(.a(a2), .b(b2), .z(z));\nendmodule"}
{"task_id": "rotate100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else begin\n            if (ena == 2'b01) begin // right rotate\n                shift_reg <= {shift_reg[0], shift_reg[99:1]};\n            end else if (ena == 2'b10) begin // left rotate\n                shift_reg <= {shift_reg[98:0], shift_reg[99]};\n            end\n        end\n    end\n\n    assign q = shift_reg;\n\n endmodule"}
{"task_id": "review2015_count1k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "The counter should be designed with a 10-bit counter and a 1-bit carry-out. The carry-out should be used to increment the counter from 999 to 0.\n\nAs the counter reaches 999, the carry-out should be set to 1, and the counter should be reset to 0.\n\n```verilog\n\treg [9:0] counter;\n\treg carry_out;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcounter <= 0;\n\t\t\tcarry_out <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (counter == 999) begin\n\t\t\t\tcarry_out <= 1;\n\t\t\t\tcounter <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tcarry_out <= 0;\n\t\t\t\tcounter <= counter + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign q = counter;\n\nendmodule"}
{"task_id": "notgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements a NOT gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "module top_module(\n    input in,\n    output out\n);\n\n    assign out = ~in;\n\nendmodule"}
{"task_id": "fsm_onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    // State transition logic\n    assign next_state[0] = (state[0] & ~state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & ~state[8] & ~state[9]) | (state[0] & ~state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & state[8] & ~state[9]);\n    assign next_state[1] = (state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & ~state[8] & state[9]);\n    assign next_state[2] = (state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & state[8] & ~state[9]);\n    assign next_state[3] = (state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & state[8] & ~state[9]);\n    assign next_state[4] = (state[4] & ~state[5] & ~state[6] & ~state[7] & state[8] & ~state[9]);\n    assign next_state[5] = (state[5] & ~state[6] & ~state[7] & state[8] & ~state[9]);\n    assign next_state[6] = (state[6] & state[7] & ~state[8] & ~state[9]);\n    assign next_state[7] = (state[7] & state[8] & ~state[9]);\n    assign next_state[8] = (state[8] & state[9]);\n    assign next_state[9] = (state[9] & ~state[0] & ~state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & ~state[8] & state[9]);\n\n    // Output logic\n    assign out1 = (state[0] & ~state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & ~state[8] & ~state[9]);\n    assign out2 = (state[0] & ~state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & state[8] & ~state[9]);\n\nendmodule"}
{"task_id": "ece241_2013_q7", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (j && !k) begin\n        Q <= 1'b0;\n    end else if (j == 1'b0 && k == 1'b1) begin\n        Q <= 1'b1;\n    end else if (j == 1'b1 && k == 1'b1) begin\n        Q <= ~Q;\n    end\nend\n\nendmodule"}
{"task_id": "popcount3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    wire [2:0] count;\n    assign count = {in[0], in[1], in[2]} ^ {in[0], in[1], in[2]} ^ {in[0], in[1], in[2]};\n    assign out = {count[2], count[1]};\n\nendmodule"}
{"task_id": "vector5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n    assign out[14] = ~c ^ a;\n    assign out[13] = ~c ^ b;\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n    assign out[ 9] = ~d ^ a;\n    assign out[ 8] = ~d ^ b;\n    assign out[ 7] = ~d ^ c;\n    assign out[ 6] = ~d ^ d;\n    assign out[ 5] = ~d ^ e;\n    assign out[ 4] = ~e ^ a;\n    assign out[ 3] = ~e ^ b;\n    assign out[ 2] = ~e ^ c;\n    assign out[ 1] = ~e ^ d;\n    assign out[ 0] = ~e ^ e;\n\nendmodule"}
{"task_id": "lemmings1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output walk_left,\n    output walk_right\n);\n\n    // Define states\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n\n    // Define outputs\n    reg walk_left_out;\n    reg walk_right_out;\n\n    // Define state and output registers\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // Define state machine\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            walk_left_out <= 1'b1;\n            walk_right_out <= 1'b0;\n        end\n        else begin\n            state <= next_state;\n            walk_left_out <= (state == WALK_LEFT);\n            walk_right_out <= (state == WALK_RIGHT);\n        end\n    end\n\n    // Define next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end\n                else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end\n                else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = (a & b) | (~a & b) | (a & ~b) | (~a & ~b);\n\nendmodule"}
{"task_id": "7458", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "// Do not use the `and3` or `and2` functions from the `system` library; these functions are not portable.\n// Do not use the `or2` function from the `system` library; this function is not portable.\n// Use the `and` and `or` operators to create the logic gates.\n// Use `assign` to drive the output wires.\n// Use `wire` to declare intermediate wires.\n// Use `*` to represent the AND gate.\n// Use `|` to represent the OR gate.\n// Use `&` to represent the bitwise AND operator.\n// Use `|` to represent the bitwise OR operator.\n\twire p1a_and_p1b_and_p1c = p1a & p1b & p1c;\n\twire p1d_and_p1e_and_p1f = p1d & p1e & p1f;\n\twire p2a_and_p2b = p2a & p2b;\n\twire p2c_and_p2d = p2c & p2d;\n\n\tassign p1y = p1a_and_p1b_and_p1c | p1d_and_p1e_and_p1f;\n\tassign p2y = p2a_and_p2b | p2c_and_p2d;\n\nendmodule"}
{"task_id": "2014_q3c", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "// State-assigned table\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\n// State encoding\nparameter [2:0] S0 = 3'b000;\nparameter [2:0] S1 = 3'b001;\nparameter [2:0] S2 = 3'b010;\nparameter [2:0] S3 = 3'b011;\nparameter [2:0] S4 = 3'b100;\n\n// State register\nreg [2:0] state;\nalways @(posedge clk) begin\n\tcase (x)\n\t\t0: state <= state;\n\t\t1: state <= state + 1;\n\tendcase\nend\n\n// State decoding\nwire [2:0] next_state;\nassign next_state = (state == S0) ? (x ? S1 : S2) :\n\t\t     (state == S1) ? (x ? S0 : S3) :\n\t\t     (state == S2) ? (x ? S1 : S0) :\n\t\t     (state == S3) ? (x ? S2 : S1) :\n\t\t     (state == S4) ? (x ? S3 : S2) : 3'b0;\n\n// Output logic\nalways @(*) begin\n\tcase (state)\n\t\tS0: begin\n\t\t\tY0 = 0;\n\t\t\tz = 0;\n\t\tend\n\t\tS1: begin\n\t\t\tY0 = 0;\n\t\t\tz = 0;\n\t\tend\n\t\tS2: begin\n\t\t\tY0 = 0;\n\t\t\tz = 0;\n\t\tend\n\t\tS3: begin\n\t\t\tY0 = 0;\n\t\t\tz = 1;\n\t\tend\n\t\tS4: begin\n\t\t\tY0 = 1;\n\t\t\tz = 1;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": "m2014_q4e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a 2-input NOR gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "// NOR gate implementation\nassign out = ~(in1 | in2);\n\nendmodule"}
{"task_id": "wire4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "// --------------------------------------------------------------------\n// Wires that make these connections:\n// \n// a -> w ; b -> x ; b -> y ; c -> z \n// \n// --------------------------------------------------------------------\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule"}
{"task_id": "m2014_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "module for the D flip flop. It is a simple module and can be written directly in the top_module.\n\nAvoid the use of comments inside the Verilog code. Your code should be self-explanatory.\n\nDo not use the Verilog syntax for \"if-else\" blocks. Use the \"assign\" statement to set the value of q.\n\n```verilog\n    reg q_reg;\n    always @(posedge clk or negedge ar) begin\n        if (ar == 0) begin\n            q_reg <= 0;\n        end else begin\n            q_reg <= d;\n        end\n    end\n    assign q = q_reg;\nendmodule"}
{"task_id": "always_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "Use conditional statements to choose the data input based on sel.\n```verilog\nalways @(*)\nbegin\n\tif (sel == 0)\n\t\tout = data0;\n\telse if (sel == 1)\n\t\tout = data1;\n\telse if (sel == 2)\n\t\tout = data2;\n\telse if (sel == 3)\n\t\tout = data3;\n\telse if (sel == 4)\n\t\tout = data4;\n\telse if (sel == 5)\n\t\tout = data5;\n\telse\n\t\tout = 4'b0;\nend\n\nendmodule"}
{"task_id": "timer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "reg [9:0] counter;\n\t\treg tc;\n\n\t\talways @(posedge clk) begin\n\t\t\tif(load) begin\n\t\t\t\tcounter <= data;\n\t\t\t\ttc <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tcounter <= counter - 1;\n\t\t\t\tif(counter == 0) begin\n\t\t\t\t\ttc <= 1;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\ttc <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\nendmodule"}
{"task_id": "review2015_fsmseq", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "You can also use Verilog design patterns to make the code more readable.\n```verilog\nmodule top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\t// Define states\n\tparameter IDLE = 2'b00;\n\tparameter FOUND_1 = 2'b01;\n\tparameter FOUND_11 = 2'b10;\n\tparameter FOUND_110 = 2'b11;\n\n\t// Define outputs\n\toutput reg start_shifting;\n\n\t// Define state register\n\treg [1:0] state;\n\n\t// Define shift register\n\treg [3:0] shift_reg;\n\n\t// Initialize state and shift registers\n\tinitial begin\n\t\tstate <= IDLE;\n\t\tshift_reg <= 4'b0;\n\t\tstart_shifting <= 0;\n\tend\n\n\t// Define state machine\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tstart_shifting <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (data) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\tif (shift_reg == 4'b1101) begin\n\t\t\t\t\t\t\tstate <= FOUND_110;\n\t\t\t\t\t\t\tstart_shifting <= 1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b11) begin\n\t\t\t\t\t\t\tstate <= FOUND_11;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b01) begin\n\t\t\t\t\t\t\tstate <= FOUND_1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tFOUND_1: begin\n\t\t\t\t\tif (data) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\tif (shift_reg == 4'b1101) begin\n\t\t\t\t\t\t\tstate <= FOUND_110;\n\t\t\t\t\t\t\tstart_shifting <= 1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b11) begin\n\t\t\t\t\t\t\tstate <= FOUND_11;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b00) begin\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tFOUND_11: begin\n\t\t\t\t\tif (data) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\tif (shift_reg == 4'b1101) begin\n\t\t\t\t\t\t\tstate <= FOUND_110;\n\t\t\t\t\t\t\tstart_shifting <= 1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b00) begin\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tFOUND_110: begin\n\t\t\t\t\tif (data) begin\n\t\t\t\t\t\tshift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\t\tif (shift_reg == 4'b01) begin\n\t\t\t\t\t\t\tstate <= FOUND_1;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b11) begin\n\t\t\t\t\t\t\tstate <= FOUND_11;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse if (shift_reg == 4'b00"}
{"task_id": "dff8r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "Follow the Verilog coding style and conventions. Do not use any comments for now.\n\n 12/2/2018 2:11 PM\n\n================================================================================\n\nModule top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b0;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "edgedetect2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "followed by the following code:\n```verilog\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n\tprev_in <= in;\n\tanyedge <= (in & ~prev_in);\nend\n\nendmodule"}
{"task_id": "count1to10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nMake a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "and end with:\n```verilog\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0001;\n\t\tend else if (q == 4'b1010) begin\n\t\t\tq <= 4'b0001;\n\t\tend else begin\n\t\t\tq <= q + 1;\n\t\tend\n\tend\nendmodule"}
{"task_id": "circuit9", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\nreg [1:0] state;\nparameter [1:0] S0 = 2'b00;\nparameter [1:0] S1 = 2'b01;\nparameter [1:0] S2 = 2'b10;\nparameter [1:0] S3 = 2'b11;\n\nalways @(posedge clk) begin\n    case (state)\n        S0: begin\n            if (a) state <= S1;\n            else state <= S0;\n        end\n        S1: begin\n            state <= S2;\n        end\n        S2: begin\n            state <= S3;\n        end\n        S3: begin\n            state <= S0;\n        end\n    endcase\nend\n\nalways @(state) begin\n    case (state)\n        S0: q <= 3'b000;\n        S1: q <= 3'b001;\n        S2: q <= 3'b010;\n        S3: q <= 3'b011;\n    endcase\nend\n\nendmodule"}
{"task_id": "lfsr5", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n\n\treg [4:0] lfsr;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tlfsr <= 5'b10000;\n\t\t\tq <= 1'b1;\n\t\tend else begin\n\t\t\tlfsr <= {lfsr[3:0], lfsr[4] ^ lfsr[3]};\n\t\t\tq <= lfsr[4];\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "bugs_addsubz", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        if (do_sub == 1) begin\n            out = a - b;\n            result_is_zero = (out == 0);\n        end\n        else begin\n            out = a + b;\n            result_is_zero = (out == 0);\n        end\n    end\n\nendmodule"}
{"task_id": "m2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case(x)\n            4'b0000: f = 1'b0;\n            4'b0001: f = 1'b0;\n            4'b0010: f = 1'b1;\n            4'b0011: f = 1'b1;\n            4'b0100: f = 1'b1;\n            4'b0101: f = 1'b0;\n            4'b0110: f = 1'b1;\n            4'b0111: f = 1'b1;\n            4'b1000: f = 1'b1;\n            4'b1001: f = 1'b0;\n            4'b1010: f = 1'b1;\n            4'b1011: f = 1'b1;\n            4'b1100: f = 1'b1;\n            4'b1101: f = 1'b0;\n            4'b1110: f = 1'b1;\n            4'b1111: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "bugs_case", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "always @(*) begin\n\t\tcase (code)\n\t\t\t8'h45: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h16: begin\n\t\t\t\tout = 4'b0001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h1e: begin\n\t\t\t\tout = 4'b0010;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h26: begin\n\t\t\t\tout = 4'b0011;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h25: begin\n\t\t\t\tout = 4'b0100;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h2e: begin\n\t\t\t\tout = 4'b0101;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h36: begin\n\t\t\t\tout = 4'b0110;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3d: begin\n\t\t\t\tout = 4'b0111;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3e: begin\n\t\t\t\tout = 4'b1000;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h46: begin\n\t\t\t\tout = 4'b1001;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 4'b0000;\n\t\t\t\tvalid = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule"}
{"task_id": "vectorr", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule"}
{"task_id": "kmap3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "always @(*) begin\n\t\tcase({a,b,c,d})\n\t\t\t4'b0000: out = 1'b0;\n\t\t\t4'b0001: out = 1'b0;\n\t\t\t4'b0010: out = 1'b1;\n\t\t\t4'b0011: out = 1'b1;\n\t\t\t4'b0100: out = 1'b0;\n\t\t\t4'b0101: out = 1'b1;\n\t\t\t4'b0110: out = 1'b1;\n\t\t\t4'b0111: out = 1'b1;\n\t\t\tdefault: out = 1'bx;\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "review2015_shiftcount", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (count_ena) begin\n            q <= q - 1;\n        end else if (shift_ena) begin\n            q <= {q[2:0], data};\n        end\n    end\n\nendmodule"}
{"task_id": "wire", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module with one input and one output that behaves like a wire.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "assign out = w1;"}
{"task_id": "review2015_fsmshift", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "module names.\n\nDo not use any extra code to achieve the same functionality.\n\n```verilog\nreg [1:0] state;\nreg [1:0] next_state;\n\nparameter S0 = 2'b00;\nparameter S1 = 2'b01;\nparameter S2 = 2'b10;\nparameter S3 = 2'b11;\n\nassign shift_ena = (state == S2);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S0;\n    end\n    else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        S0: next_state = (reset) ? S0 : S1;\n        S1: next_state = (reset) ? S0 : S2;\n        S2: next_state = (reset) ? S0 : S3;\n        S3: next_state = (reset) ? S0 : S0;\n    endcase\nend\n\nendmodule"}
{"task_id": "count15", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "always_if", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "// 2-to-1 mux using assign statements\nassign out_assign = sel_b1 & sel_b2 ? b : a;\n\n// 2-to-1 mux using procedural if\nalways @(*) begin\n\tif (sel_b1 && sel_b2)\n\t\tout_always = b;\n\telse\n\t\tout_always = a;\nend\n\nendmodule"}
{"task_id": "kmap1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (a & b & c) | (~a & ~b & c) | (~a & b & ~c) | (a & ~b & ~c);\n\nendmodule"}
{"task_id": "2013_q2afsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "count10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            case (q)\n                4'b0000: q <= 4'b0001;\n                4'b0001: q <= 4'b0010;\n                4'b0010: q <= 4'b0011;\n                4'b0011: q <= 4'b0100;\n                4'b0100: q <= 4'b0101;\n                4'b0101: q <= 4'b0110;\n                4'b0110: q <= 4'b0111;\n                4'b0111: q <= 4'b1000;\n                4'b1000: q <= 4'b1001;\n                4'b1001: q <= 4'b1010;\n                4'b1010: q <= 4'b1011;\n                4'b1011: q <= 4'b1100;\n                4'b1100: q <= 4'b1101;\n                4'b1101: q <= 4'b1110;\n                4'b1110: q <= 4'b1111;\n                4'b1111: q <= 4'b0000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "fsm_ps2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "and end with the FSM:\n```verilog\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 0;\n\t\tdone <= 0;\n\tend else begin\n\t\tcase (state)\n\t\t\t0: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate <= 1;\n\t\t\t\t\tbyte_count <= 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t1: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate <= 2;\n\t\t\t\t\tbyte_count <= 2;\n\t\t\t\tend else if (byte_count == 0) begin\n\t\t\t\t\tstate <= 0;\n\t\t\t\t\tbyte_count <= 1;\n\t\t\t\tend else begin\n\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate <= 3;\n\t\t\t\t\tbyte_count <= 0;\n\t\t\t\t\tdone <= 1;\n\t\t\t\tend else if (byte_count == 0) begin\n\t\t\t\t\tstate <= 1;\n\t\t\t\t\tbyte_count <= 2;\n\t\t\t\tend else begin\n\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t3: begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tstate <= 0;\n\t\t\t\t\tbyte_count <= 1;\n\t\t\t\tend else if (byte_count == 0) begin\n\t\t\t\t\tstate <= 1;\n\t\t\t\t\tbyte_count <= 2;\n\t\t\t\tend else begin\n\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nreg [1:0] state;\nreg [1:0] byte_count;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 0;\n\t\tbyte_count <= 0;\n\t\tdone <= 0;\n\tend\nend\n\nendmodule"}
{"task_id": "mux2to1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}
{"task_id": "gates4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "endmodule"}
{"task_id": "2014_q3bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // Define the states\n    parameter [2:0] S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // Define the next state and output logic\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            z <= 0;\n            y <= S0;\n        end else begin\n            case (y)\n                S0: begin\n                    if (x) begin\n                        y <= S1;\n                        z <= 0;\n                    end else begin\n                        y <= S0;\n                        z <= 0;\n                    end\n                end\n                S1: begin\n                    if (x) begin\n                        y <= S0;\n                        z <= 0;\n                    end else begin\n                        y <= S2;\n                        z <= 0;\n                    end\n                end\n                S2: begin\n                    if (x) begin\n                        y <= S0;\n                        z <= 0;\n                    end else begin\n                        y <= S1;\n                        z <= 0;\n                    end\n                end\n                S3: begin\n                    if (x) begin\n                        y <= S0;\n                        z <= 1;\n                    end else begin\n                        y <= S2;\n                        z <= 0;\n                    end\n                end\n                S4: begin\n                    if (x) begin\n                        y <= S3;\n                        z <= 1;\n                    end else begin\n                        y <= S4;\n                        z <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the state register\n    reg [2:0] y;\n\nendmodule"}
{"task_id": "2013_q2bfsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output f,\n    output g\n);\n\n    // Define the states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg f_reg;\n    reg g_reg;\n\n    // Define the state transitions and outputs\n    always @(posedge clk, negedge resetn) begin\n        if (~resetn) begin\n            state <= A;\n            f_reg <= 0;\n            g_reg <= 0;\n        end\n        else begin\n            state <= next_state;\n            f_reg <= 0;\n            g_reg <= 0;\n            case (state)\n                A: begin\n                    f_reg <= 1;\n                    next_state <= B;\n                end\n                B: begin\n                    if (x == 1'b1) begin\n                        next_state <= C;\n                    end\n                    else begin\n                        next_state <= B;\n                    end\n                end\n                C: begin\n                    if (x == 1'b0) begin\n                        next_state <= D;\n                    end\n                    else begin\n                        next_state <= C;\n                    end\n                end\n                D: begin\n                    if (y == 1'b1) begin\n                        g_reg <= 1'b1;\n                        next_state <= D;\n                    end\n                    else begin\n                        g_reg <= 1'b0;\n                        next_state <= B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Assign the outputs\n    assign f = f_reg;\n    assign g = g_reg;\n\nendmodule"}
{"task_id": "dff8p", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q);\n\n    always @(negedge clk) begin\n        if (reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "reduction", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nParity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = ^in;\n\nendmodule"}
{"task_id": "fsm3comb", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "always @(*) begin\n    case (state)\n        2'b00: begin // state A\n            next_state = in ? 2'b01 : 2'b00;\n            out = 1'b0;\n        end\n        2'b01: begin // state B\n            next_state = in ? 2'b10 : 2'b01;\n            out = 1'b0;\n        end\n        2'b10: begin // state C\n            next_state = in ? 2'b00 : 2'b10;\n            out = 1'b0;\n        end\n        2'b11: begin // state D\n            next_state = in ? 2'b10 : 2'b01;\n            out = 1'b1;\n        end\n    endcase\nend"}
{"task_id": "mt2015_q4b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "module top_module(\n    input x,\n    input y,\n    output z);\n\n    reg [3:0] state;\n    parameter IDLE = 2'd0, CHARGE = 2'd1, DISCHARGE = 2'd2, DISCONNECT = 2'd3;\n    \n    always @(posedge clk) begin\n        case(state)\n            IDLE: begin\n                if(x && y) begin\n                    state <= CHARGE;\n                end\n            end\n            CHARGE: begin\n                if(x && y) begin\n                    state <= CHARGE;\n                end\n                else begin\n                    state <= DISCHARGE;\n                end\n            end\n            DISCHARGE: begin\n                if(x && y) begin\n                    state <= CHARGE;\n                end\n                else begin\n                    state <= DISCONNECT;\n                end\n            end\n            DISCONNECT: begin\n                if(!x && !y) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\n    \n    assign z = (state == CHARGE) ? 1'b1 : 1'b0;\n    \nendmodule"}
{"task_id": "2012_q2fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "// State table\nparameter A = 2'b00;\nparameter B = 2'b01;\nparameter C = 2'b10;\nparameter D = 2'b11;\n\n// State flip-flops\nreg [1:0] state;\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= A;\n\tend else begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= B;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= E;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= F;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= A;\n\t\t\t\tend\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= E;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tif (w) begin\n\t\t\t\t\tstate <= C;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= D;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// State output\nalways @(state) begin\n\tcase (state)\n\t\tA: z <= 1'b0;\n\t\tB: z <= 1'b1;\n\t\tC: z <= 1'b1;\n\t\tD: z <= 1'b1;\n\t\tE: z <= 1'b1;\n\t\tF: z <= 1'b1;\n\tendcase\nend\n\nendmodule"}
{"task_id": "dff16e", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "Do not introduce any additional variables or registers. Use the same variable names as the ones provided in the code.\n```verilog\n\treg [15:0] q;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (~resetn) begin\n\t\t\tq <= 16'h0000;\n\t\tend else begin\n\t\t\tif (byteena[1]) begin\n\t\t\t\tq[15:8] <= d[15:8];\n\t\t\tend\n\t\t\tif (byteena[0]) begin\n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\tend\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "edgedetect", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "Then for each bit in the 8-bit vector, do the following:\n```verilog\n\treg prev;\n\talways @(posedge clk) begin\n\t\tif (in[0] && !prev) begin\n\t\t\tpedge[0] <= 1;\n\t\tend else begin\n\t\t\tpedge[0] <= 0;\n\t\tend\n\t\tprev <= in[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[1] && !prev) begin\n\t\t\tpedge[1] <= 1;\n\t\tend else begin\n\t\t\tpedge[1] <= 0;\n\t\tend\n\t\tprev <= in[1];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[2] && !prev) begin\n\t\t\tpedge[2] <= 1;\n\t\tend else begin\n\t\t\tpedge[2] <= 0;\n\t\tend\n\t\tprev <= in[2];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[3] && !prev) begin\n\t\t\tpedge[3] <= 1;\n\t\tend else begin\n\t\t\tpedge[3] <= 0;\n\t\tend\n\t\tprev <= in[3];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[4] && !prev) begin\n\t\t\tpedge[4] <= 1;\n\t\tend else begin\n\t\t\tpedge[4] <= 0;\n\t\tend\n\t\tprev <= in[4];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[5] && !prev) begin\n\t\t\tpedge[5] <= 1;\n\t\tend else begin\n\t\t\tpedge[5] <= 0;\n\t\tend\n\t\tprev <= in[5];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[6] && !prev) begin\n\t\t\tpedge[6] <= 1;\n\t\tend else begin\n\t\t\tpedge[6] <= 0;\n\t\tend\n\t\tprev <= in[6];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (in[7] && !prev) begin\n\t\t\tpedge[7] <= 1;\n\t\tend else begin\n\t\t\tpedge[7] <= 0;\n\t\tend\n\t\tprev <= in[7];\n\tend\nendmodule"}
{"task_id": "circuit8", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "```verilog\n// Verilog code for sequential circuit\n\nreg a_reg;\nreg p_reg;\nreg q_reg;\n\nalways @(posedge clock) begin\n\ta_reg <= a;\n\tp_reg <= a_reg;\n\tq_reg <= p_reg;\nend\n\nassign p = p_reg;\nassign q = q_reg;\n\nendmodule"}
{"task_id": "rule90", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nRule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q);\n\n    reg [511:0] next_q;\n\n    always @ (posedge clk) begin\n        if (load) begin\n            next_q <= data;\n        end else begin\n            next_q[0] <= 1'b0;\n            next_q[511] <= 1'b0;\n            for (int i = 1; i < 511; i = i + 1) begin\n                next_q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\n    always @ (posedge clk) begin\n        q <= next_q;\n    end\n\nendmodule"}
{"task_id": "mt2015_eq2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "endmodule"}
{"task_id": "gatesv100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "Then, for each output vector, we just need to iterate through the input vector and check the corresponding conditions. Please see the code below:\n```verilog\n// out_both\ngenvar i;\ngenerate\n\tfor (i = 0; i < 100; i = i + 1) begin: out_both_gen\n\t\tassign out_both[i] = (i > 0) ? in[i] & in[i-1] : 1'b0;\n\tend\nendgenerate\n\n// out_any\ngenerate\n\tfor (i = 0; i < 100; i = i + 1) begin: out_any_gen\n\t\tassign out_any[i] = (i < 100) ? (in[i] | in[i+1]) : 1'b0;\n\tend\nendgenerate\n\n// out_different\ngenerate\n\tfor (i = 0; i < 100; i = i + 1) begin: out_different_gen\n\t\tassign out_different[i] = (i > 0) ? (in[i] ^ in[i-1]) : 1'b0;\n\tend\nendgenerate\n\nendmodule"}
{"task_id": "m2014_q4a", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a D latch using an always block.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "endmodule"}
{"task_id": "mux256to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    wire [255:0] sel_bits;\n    assign sel_bits = {sel, 8'b0};\n\n    wire [255:0] sel_inv;\n    assign sel_inv = ~sel_bits;\n\n    wire [255:0] sel_inv_and_in;\n    assign sel_inv_and_in = sel_inv & in;\n\n    wire [255:0] sel_and_in;\n    assign sel_and_in = sel & in;\n\n    wire [255:0] sel_or_sel_inv_and_in;\n    assign sel_or_sel_inv_and_in = sel | sel_inv_and_in;\n\n    wire [3:0] out_sel_or_sel_inv_and_in;\n    assign out_sel_or_sel_inv_and_in = sel_or_sel_inv_and_in[255:252];\n\n    assign out = out_sel_or_sel_inv_and_in;\n\nendmodule"}
{"task_id": "mux9to1v", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "Use the following Verilog code to complete the 9-to-1 multiplexer:\n```verilog\nalways @(*) begin\n\tcase(sel)\n\t\t0: out = a;\n\t\t1: out = b;\n\t\t2: out = c;\n\t\t3: out = d;\n\t\t4: out = e;\n\t\t5: out = f;\n\t\t6: out = g;\n\t\t7: out = h;\n\t\t8: out = i;\n\t\tdefault: out = 16'hffff;\n\tendcase\nend\n\nendmodule"}
{"task_id": "vectorgates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "// Compute bitwise-OR of a and b\nassign out_or_bitwise = a | b;\n\n// Compute logical-OR of a and b\nassign out_or_logical = (a != 0) || (b != 0);\n\n// Compute NOT of a and b\nassign out_not = ~a;\nassign out_not[5:3] = ~b;\n\nendmodule"}
{"task_id": "fsm3onehot", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\nalways @ (state or in) begin\n    case (state)\n        4'b0001: begin // A\n            if (in == 1'b0) begin\n                next_state = 4'b0001;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b0010;\n                out = 1'b0;\n            end\n        end\n        4'b0010: begin // B\n            if (in == 1'b0) begin\n                next_state = 4'b0100;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b0010;\n                out = 1'b0;\n            end\n        end\n        4'b0100: begin // C\n            if (in == 1'b0) begin\n                next_state = 4'b0001;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b1000;\n                out = 1'b1;\n            end\n        end\n        4'b1000: begin // D\n            if (in == 1'b0) begin\n                next_state = 4'b0100;\n                out = 1'b0;\n            end\n            else begin\n                next_state = 4'b0010;\n                out = 1'b1;\n            end\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "conditional", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "input [7:0] a, b, c, d;\n\toutput reg [7:0] min;\n\n\talways @(*) begin\n\t\tif(a < b && a < c && a < d) begin\n\t\t\tmin = a;\n\t\tend\n\t\telse if(b < a && b < c && b < d) begin\n\t\t\tmin = b;\n\t\tend\n\t\telse if(c < a && c < b && c < d) begin\n\t\t\tmin = c;\n\t\tend\n\t\telse begin\n\t\t\tmin = d;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": "gates", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "// Verilog code to implement the Karnaugh map\n\n```verilog\n\twire ab, cd;\n\twire a_not, b_not, c_not, d_not;\n\n\tassign ab = a & b;\n\tassign cd = c & d;\n\tassign a_not = ~a;\n\tassign b_not = ~b;\n\tassign c_not = ~c;\n\tassign d_not = ~d;\n\n\tassign out = (a_not & b & c & d_not) |\n\t\t\t\t(a_not & b & d & c_not) |\n\t\t\t\t(a_not & c & b & d_not) |\n\t\t\t\t(a_not & c & d & b_not) |\n\t\t\t\t(a_not & d & b & c_not) |\n\t\t\t\t(a_not & d & c & b_not) |\n\t\t\t\t(b_not & a & c & d_not) |\n\t\t\t\t(b_not & a & d & c_not) |\n\t\t\t\t(b_not & c & a & d_not) |\n\t\t\t\t(b_not & c & d & a_not) |\n\t\t\t\t(b_not & d & a & c_not) |\n\t\t\t\t(b_not & d & c & a_not) |\n\t\t\t\t(c_not & a & b & d_not) |\n\t\t\t\t(c_not & a & d & b_not) |\n\t\t\t\t(c_not & b & a & d_not) |\n\t\t\t\t(c_not & b & d & a_not) |\n\t\t\t\t(c_not & d & a & b_not) |\n\t\t\t\t(c_not & d & b & a_not) |\n\t\t\t\t(d_not & a & b & c_not) |\n\t\t\t\t(d_not & a & c & b_not) |\n\t\t\t\t(d_not & b & a & c_not) |\n\t\t\t\t(d_not & b & c & a_not) |\n\t\t\t\t(d_not & c & a & b_not) |\n\t\t\t\t(d_not & c & b & a_not);\n\nendmodule"}
{"task_id": "2014_q3fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "endmodule"}
{"task_id": "vector4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nOne common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "m2014_q4k", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement a shift register with four D flops. Reset is active-low synchronous resettable.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "endmodule"}
{"task_id": "always_case2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "and end with:\n```verilog\n\talways @(*) begin\n\t\tif(in == 4'b0000) begin\n\t\t\tpos = 2'b00;\n\t\tend\n\t\telse if(in[3] == 1) begin\n\t\t\tpos = 2'b11;\n\t\tend\n\t\telse if(in[2] == 1) begin\n\t\t\tpos = 2'b10;\n\t\tend\n\t\telse if(in[1] == 1) begin\n\t\t\tpos = 2'b01;\n\t\tend\n\t\telse begin\n\t\t\tpos = 2'b00;\n\t\tend\n\tend\nendmodule"}
{"task_id": "fsm2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output.\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n\n// State encoding\nlocalparam [1:0] OFF = 2'b00;\nlocalparam [1:0] ON = 2'b01;\n\n// State register and next state logic\nreg [1:0] state_reg, state_next;\nalways @(posedge clk, posedge areset) begin\n\tif (areset) begin\n\t\tstate_reg <= OFF;\n\tend else begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\n// Output register and combinational logic\nreg out_reg;\nalways @(state_reg, j, k) begin\n\tcase (state_reg)\n\t\tOFF: begin\n\t\t\tif (j) begin\n\t\t\t\tout_reg = ON;\n\t\t\tend else begin\n\t\t\t\tout_reg = OFF;\n\t\t\tend\n\t\tend\n\t\tON: begin\n\t\t\tif (k) begin\n\t\t\t\tout_reg = OFF;\n\t\t\tend else begin\n\t\t\t\tout_reg = ON;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Next state logic\nalways @(state_reg, j, k) begin\n\tcase (state_reg)\n\t\tOFF: begin\n\t\t\tif (j) begin\n\t\t\t\tstate_next = ON;\n\t\t\tend else begin\n\t\t\t\tstate_next = OFF;\n\t\t\tend\n\t\tend\n\t\tON: begin\n\t\t\tif (k) begin\n\t\t\t\tstate_next = OFF;\n\t\t\tend else begin\n\t\t\t\tstate_next = ON;\n\t\t\tend\n\t\tend\n\tendcase\nend\n\n// Output assignment\nassign out = out_reg;\n\nendmodule"}
{"task_id": "m2014_q4i", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 0 (or logic low).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput out);\n", "completion": "module top_module(\n    output out);\n\n    assign out = 1'b0;\n\nendmodule"}
{"task_id": "step_one", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a circuit with no inputs and one output. That output should always drive 1 (or logic high).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\toutput one);\n", "completion": "endmodule"}
{"task_id": "vector100r", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "// Reverse the bit ordering of the input vector\n\n\tinteger i;\n\talways @(*) begin\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tout[i] = in[99 - i];\n\t\tend\n\tend\nendmodule"}
{"task_id": "m2014_q4d", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "Be consistent with your code formatting and use the same style for all Verilog modules.\n\nFollow the Verilog syntax and conventions for naming, commenting, and spacing.\n\nThe Verilog code below is the design of the circuit. You can add comments to improve readability.\n\n// D flip-flop\nreg d_ff;\nalways @(posedge clk) begin\n\td_ff <= in ^ d_ff;\nend\n\n// XOR gate\nassign out = in ^ d_ff;\n\nendmodule"}
{"task_id": "shift4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "// (1) areset: Resets shift register to zero.\n always @ (posedge areset) begin\n \tq <= 4'b0000;\n end\n\n // (2) load: Loads shift register with data[3:0] instead of shifting.\n always @ (posedge clk) begin\n \tif (load) begin\n \t\tq <= data;\n \tend\n \telse if (ena) begin\n \t\tq <= {q[2:0], 1'b0};\n \tend\n end\n\nendmodule"}
{"task_id": "truthtable1", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "endmodule"}
{"task_id": "dff8ar", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q);\n\n    always @(posedge clk or negedge areset) begin\n        if (areset == 0) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule"}
{"task_id": "gates100", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "hadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b;\n    assign cout = a & b;\n\nendmodule"}
{"task_id": "always_if2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "// Verilog code design\n\n// Shut off the computer if it is overheated\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\nend\n\n// Keep driving if the gas tank is not empty and the destination has not been reached\nalways @(*) begin\n    if (~arrived)\n        keep_driving = ~gas_tank_empty;\nend\n\nendmodule"}
{"task_id": "fsm2s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "// Moore state machine with two states, two inputs, and one output.\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF\n// Reset is active-high synchronous reset to state OFF.\n\n// Define states\nparameter OFF = 2'b00;\nparameter ON = 2'b01;\n\n// Define outputs\nparameter out_OFF = 1'b0;\nparameter out_ON = 1'b1;\n\n// Define inputs\nparameter j_ON = 1'b1;\nparameter k_ON = 1'b1;\n\n// Define state register\nreg [1:0] state;\n\n// Define output register\nreg out_reg;\n\n// Define next state logic\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate <= OFF;\n\tend else begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) begin\n\t\t\t\t\tstate <= OFF;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= ON;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\n// Define output logic\nalways @(state, j, k) begin\n\tcase (state)\n\t\tOFF: out_reg <= out_OFF;\n\t\tON: out_reg <= out_ON;\n\tendcase\nend\n\n// Assign outputs\nassign out = out_reg;\n\nendmodule"}
{"task_id": "vector3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    wire [31:0] input_vector;\n    assign input_vector = {a, b, c, d, e, f};\n\n    wire [3:0] count;\n    assign count = $countones({input_vector[0], input_vector[1], input_vector[2], input_vector[3], input_vector[4], input_vector[5], input_vector[6], input_vector[7], input_vector[8], input_vector[9], input_vector[10], input_vector[11], input_vector[12], input_vector[13], input_vector[14], input_vector[15], input_vector[16], input_vector[17], input_vector[18], input_vector[19], input_vector[20], input_vector[21], input_vector[22], input_vector[23], input_vector[24], input_vector[25], input_vector[26], input_vector[27], input_vector[28], input_vector[29], input_vector[30], input_vector[31]});\n\n    wire [31:0] output_vector;\n    assign output_vector = {input_vector, 2'b01};\n\n    wire [7:0] w_temp;\n    wire [7:0] x_temp;\n    wire [7:0] y_temp;\n    wire [7:0] z_temp;\n\n    assign w_temp = output_vector[7:0];\n    assign x_temp = output_vector[15:8];\n    assign y_temp = output_vector[23:16];\n    assign z_temp = output_vector[31:24];\n\n    assign w = {w_temp, 1'b0};\n    assign x = {x_temp, 1'b0};\n    assign y = {y_temp, 1'b0};\n    assign z = {z_temp, 1'b0};\n\nendmodule"}
{"task_id": "circuit2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & c & d) | (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d);\n\nendmodule"}
{"task_id": "andgate", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a module that implements an AND gate.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = a & b;\n\nendmodule"}
{"task_id": "fsm1s", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "Do not add any comments for now. If the code is not clear, please add comments after the code is reviewed and approved.\n\n// Moore state machine with two states, one input, and one output.\n// State B is the reset state.\n// State A is the active state.\n// The output is high in state B and low in state A.\n// The input is used to toggle between states B and A.\n\nreg [1:0] state;\nreg out;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= 2'b10; // Reset to state B\n\t\tout <= 1'b1; // Set output high\n\tend else begin\n\t\tcase (state)\n\t\t\t2'b10: begin // State B\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tout <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tout <= 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\t2'b01: begin // State A\n\t\t\t\tif (in) begin\n\t\t\t\t\tstate <= 2'b01;\n\t\t\t\t\tout <= 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate <= 2'b10;\n\t\t\t\t\tout <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule"}
{"task_id": "fadd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "endmodule"}
{"task_id": "m2014_q4g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nImplement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    wire xnor_out;\n    wire xor_out;\n\n    xnor xnor_inst (\n        .a(in1),\n        .b(in2),\n        .out(xnor_out)\n    );\n\n    xor xor_inst (\n        .a(xnor_out),\n        .b(in3),\n        .out(xor_out)\n    );\n\n    assign out = xor_out;\n\nendmodule"}
{"task_id": "ece241_2014_q3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    wire ab_00;\n    wire ab_01;\n    wire ab_10;\n    wire ab_11;\n\n    assign ab_00 = ~c & ~d;\n    assign ab_01 = ~c & d;\n    assign ab_10 = c & ~d;\n    assign ab_11 = c & d;\n\n    // 4-to-1 mux\n    assign mux_in[0] = ab_00;\n    assign mux_in[1] = ab_01;\n    assign mux_in[2] = ab_10;\n    assign mux_in[3] = ab_11;\n\nendmodule"}
{"task_id": "ece241_2014_q5b", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output z\n);\n\n    // one-hot encoding for states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // state register\n    reg [1:0] state, next_state;\n\n    // output register\n    reg z_reg;\n\n    // combinational logic\n    assign z = z_reg;\n\n    // state transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? B : C;\n            C: next_state = x ? B : D;\n            D: next_state = x ? B : A;\n        endcase\n    end\n\n    // output logic\n    always @(*) begin\n        case (state)\n            A: z_reg = 1'b0;\n            B: z_reg = 1'b1;\n            C: z_reg = 1'b1;\n            D: z_reg = 1'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "circuit10", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThis is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        \nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "module top_module (\n    input clk,\n    input a,\n    input b,\n    output q,\n    output state\n);\n\n    reg [1:0] state_reg;\n    assign state = state_reg[1];\n\n    always @(posedge clk) begin\n        case ({a,b})\n            2'b00: state_reg <= 2'b00;\n            2'b01: state_reg <= 2'b01;\n            2'b10: state_reg <= 2'b10;\n            2'b11: state_reg <= 2'b11;\n        endcase\n    end\n\n    assign q = state_reg[0];\n\nendmodule"}
{"task_id": "2012_q1g", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nConsider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "always @* begin\n    case(x)\n        4'b0000: f = 1'b0;\n        4'b0001: f = 1'b1;\n        4'b0010: f = 1'b0;\n        4'b0011: f = 1'b1;\n        4'b0100: f = 1'b1;\n        4'b0101: f = 1'b0;\n        4'b0110: f = 1'b1;\n        4'b0111: f = 1'b1;\n        4'b1000: f = 1'b1;\n        4'b1001: f = 1'b1;\n        4'b1010: f = 1'b0;\n        4'b1011: f = 1'b1;\n        4'b1100: f = 1'b1;\n        4'b1101: f = 1'b0;\n        4'b1110: f = 1'b1;\n        4'b1111: f = 1'b0;\n    endcase\nend"}
{"task_id": "fsm_hdlc", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nSynchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "// FSM states\nparameter STATE_0 = 2'b00;\nparameter STATE_1 = 2'b01;\nparameter STATE_2 = 2'b10;\n\n// FSM outputs\nparameter DISC = 2'b01;\nparameter FLAG = 2'b10;\nparameter ERR = 2'b11;\n\n// FSM state register and next state logic\nreg [1:0] state_reg;\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tstate_reg <= STATE_0;\n\tend else begin\n\t\tstate_reg <= state_next;\n\tend\nend\n\n// FSM output register and output logic\nreg [1:0] out_reg;\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tout_reg <= 2'b00;\n\tend else begin\n\t\tout_reg <= out_next;\n\tend\nend\n\n// FSM outputs and next states\nparameter [1:0] STATE_0_NEXT = 2'b00;\nparameter [1:0] STATE_1_NEXT = 2'b01;\nparameter [1:0] STATE_2_NEXT = 2'b10;\n\n// FSM outputs and current state\nparameter [1:0] OUT_0 = 2'b01;\nparameter [1:0] OUT_1 = 2'b10;\nparameter [1:0] OUT_2 = 2'b11;\n\n// FSM output logic\nfunction [1:0] next_state;\n\tinput [1:0] current_state;\n\tinput [1:0] current_input;\n\tbegin\n\t\tcase (current_state)\n\t\t\tSTATE_0:\n\t\t\t\tbegin\n\t\t\t\t\tif (current_input == 2'b11) begin\n\t\t\t\t\t\tnext_state = STATE_1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = STATE_0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tSTATE_1:\n\t\t\t\tbegin\n\t\t\t\t\tif (current_input == 2'b11) begin\n\t\t\t\t\t\tnext_state = STATE_2;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = STATE_1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tSTATE_2:\n\t\t\t\tbegin\n\t\t\t\t\tif (current_input == 2'b11) begin\n\t\t\t\t\t\tnext_state = STATE_0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = STATE_2;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendfunction\n\n// FSM output logic\nfunction [1:0] next_output;\n\tinput [1:0] current_state;\n\tinput [1:0] current_input;\n\tbegin\n\t\tcase (current_state)\n\t\t\tSTATE_0:\n\t\t\t\tbegin\n\t\t\t\t\tif (current_input == 2'b11) begin\n\t\t\t\t\t\tnext_output = OUT_1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_output = OUT_0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tSTATE_1:\n\t\t\t\tbegin\n\t\t\t\t\tnext_output = OUT_1;\n\t\t\t\tend\n\t\t\tSTATE_2:\n\t\t\t\tbegin\n\t\t\t\t\tnext_output = OUT_2;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendfunction\n\n// FSM next state and output logic\nassign state_next = next_state;\nassign out_next = next_output;\n\n// FSM output decoding\nalways @(posedge clk, posedge reset) begin\n\tif (reset) begin\n\t\tdisc <= 1'b0;\n\t\tflag <= 1'b0;\n\t\terr <= 1'b0"}
{"task_id": "review2015_fancytimer", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "module code. Your code should end with:\n```verilog\nendmodule"}
{"task_id": "ece241_2013_q4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nA large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\n\t// Define states\n\tlocalparam IDLE = 2'b00;\n\tlocalparam LOW = 2'b01;\n\tlocalparam BETWEEN = 2'b10;\n\tlocalparam HIGH = 2'b11;\n\n\t// Define constants\n\tlocalparam FR1_THRESHOLD = 4'h3;\n\tlocalparam FR2_THRESHOLD = 4'h2;\n\tlocalparam FR3_THRESHOLD = 4'h1;\n\tlocalparam FR1_MIN = 4'h0;\n\tlocalparam FR1_MAX = 4'h7;\n\tlocalparam FR2_MIN = 4'h0;\n\tlocalparam FR2_MAX = 4'h7;\n\tlocalparam FR3_MIN = 4'h0;\n\tlocalparam FR3_MAX = 4'h7;\n\n\t// Define signals\n\treg [1:0] state;\n\treg [3:0] level;\n\treg [3:0] prev_level;\n\treg [3:0] fr1_target;\n\treg [3:0] fr2_target;\n\treg [3:0] fr3_target;\n\treg [3:0] fr1_actual;\n\treg [3:0] fr2_actual;\n\treg [3:0] fr3_actual;\n\treg dfr_target;\n\n\t// Define combinational logic\n\tassign fr3 = fr3_actual;\n\tassign fr2 = fr2_actual;\n\tassign fr1 = fr1_actual;\n\tassign dfr = dfr_target;\n\n\t// Define state machine\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tlevel <= 4'h0;\n\t\t\tprev_level <= 4'h0;\n\t\t\tfr1_target <= FR1_MIN;\n\t\t\tfr2_target <= FR2_MIN;\n\t\t\tfr3_target <= FR3_MIN;\n\t\t\tfr1_actual <= FR1_MIN;\n\t\t\tfr2_actual <= FR2_MIN;\n\t\t\tfr3_actual <= FR3_MIN;\n\t\t\tdfr_target <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (s == 3'b111) begin\n\t\t\t\t\t\tstate <= HIGH;\n\t\t\t\t\t\tprev_level <= level;\n\t\t\t\t\t\tfr1_actual <= FR1_MIN;\n\t\t\t\t\t\tfr2_actual <= FR2_MIN;\n\t\t\t\t\t\tfr3_actual <= FR3_MIN;\n\t\t\t\t\t\tdfr_target <= 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= LOW;\n\t\t\t\t\t\tprev_level <= level;\n\t\t\t\t\t\tfr1_actual <= FR1_MIN;\n\t\t\t\t\t\tfr2_actual <= FR2_MIN;\n\t\t\t\t\t\tfr3_actual <= FR3_MIN;\n\t\t\t\t\t\tdfr_target <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tLOW: begin\n\t\t\t\t\tif (s == 3'b100) begin\n\t\t\t\t\t\tstate <= BETWEEN;\n\t\t\t\t\t\tprev_level <= level;\n\t\t\t\t\t\tfr1_actual <= FR1_MIN;\n\t\t\t\t\t\tfr2_actual <= FR2_MIN;\n\t\t\t\t\t\tfr3_actual <= FR3_MIN;\n\t\t\t\t\t\tdfr_target <= 0;\n\t\t\t\t\tend else if (s == 3'b000) begin\n\t\t\t\t\t\tstate <= HIGH;\n\t\t\t\t\t\tprev_level <= level;"}
{"task_id": "fsm_serial", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n\n\t// Define states\n\tparameter IDLE = 2'b00;\n\tparameter START = 2'b01;\n\tparameter DATA = 2'b10;\n\tparameter STOP = 2'b11;\n\n\t// Define signals\n\treg [1:0] state;\n\treg [7:0] data_reg;\n\treg [1:0] bit_count;\n\treg start_bit;\n\treg stop_bit;\n\treg done_reg;\n\n\t// Initialize signals\n\tassign done = done_reg;\n\tinitial begin\n\t\tstate = IDLE;\n\t\tdata_reg = 8'b0;\n\t\tbit_count = 2'b00;\n\t\tstart_bit = 1'b0;\n\t\tstop_bit = 1'b1;\n\t\tdone_reg = 1'b0;\n\tend\n\n\t// State machine\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tdata_reg <= 8'b0;\n\t\t\tbit_count <= 2'b00;\n\t\t\tstart_bit <= 1'b0;\n\t\t\tstop_bit <= 1'b1;\n\t\t\tdone_reg <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (!in) begin\n\t\t\t\t\t\tstate <= START;\n\t\t\t\t\t\tbit_count <= 2'b00;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTART: begin\n\t\t\t\t\tif (bit_count == 2'b00) begin\n\t\t\t\t\t\tif (in) begin\n\t\t\t\t\t\t\tstart_bit <= 1'b1;\n\t\t\t\t\t\t\tbit_count <= 2'b01;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else if (bit_count == 2'b01) begin\n\t\t\t\t\t\tif (in) begin\n\t\t\t\t\t\t\tbit_count <= 2'b10;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else if (bit_count == 2'b10) begin\n\t\t\t\t\t\tdata_reg[0] <= in;\n\t\t\t\t\t\tbit_count <= 2'b11;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tDATA: begin\n\t\t\t\t\tif (bit_count == 2'b10) begin\n\t\t\t\t\t\tdata_reg[7] <= in;\n\t\t\t\t\t\tbit_count <= 2'b11;\n\t\t\t\t\tend else if (bit_count == 2'b11) begin\n\t\t\t\t\t\tif (in) begin\n\t\t\t\t\t\t\tbit_count <= 2'b00;\n\t\t\t\t\t\t\tstate <= STOP;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tdata_reg[bit_count-1] <= in;\n\t\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (bit_count == 2'b00) begin\n\t\t\t\t\t\tif (in) begin\n\t\t\t\t\t\t\tstop_bit <= 1'b0;\n\t\t\t\t\t\t\tbit_count <= 2'b01;\n\t\t\t\t\t\t\tif (!stop_bit) begin\n\t\t\t\t\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tstate <= IDLE;"}
{"task_id": "fsm_serialdata", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nIn many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "endmodule"}
{"task_id": "gshare", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Declare wires, registers, and internal signals\n    reg [6:0] history_reg;\n    reg [6:0] pht_table [0:127];\n    wire [6:0] pht_table_index;\n    wire [1:0] pht_table_value;\n    wire [6:0] pht_table_key;\n    wire [6:0] pht_table_history;\n    wire [1:0] pht_table_taken;\n\n    // Initialize PHT table\n    initial begin\n        for (int i = 0; i < 128; i = i + 1) begin\n            pht_table[i] = {2'b00, 7'b0};\n        end\n    end\n\n    // Generate PHT index\n    assign pht_table_index = history_reg ^ predict_pc;\n\n    // Generate PHT key\n    assign pht_table_key = pht_table_index ^ history_reg;\n\n    // Generate PHT history\n    assign pht_table_history = history_reg;\n\n    // Generate PHT taken\n    assign pht_table_taken = {2'b10, pht_table_value};\n\n    // Generate PHT table output\n    assign {pht_table_value, predict_taken, predict_history} = pht_table[pht_table_index];\n\n    // Update history register\n    always @(posedge clk) begin\n        if (areset) begin\n            history_reg <= 7'b0;\n        end\n        else if (predict_valid) begin\n            history_reg <= pht_table_history;\n        end\n        else if (train_valid && (train_pc == predict_pc)) begin\n            if (train_mispredicted) begin\n                history_reg <= train_history;\n            end\n            else begin\n                history_reg <= history_reg;\n            end\n        end\n    end\n\n    // Update PHT table\n    always @(posedge clk) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht_table[i] <= {2'b00, 7'b0};\n            end\n        end\n        else if (train_valid && (train_pc == predict_pc)) begin\n            if (train_mispredicted) begin\n                pht_table[pht_table_index] <= {pht_table_taken, train_history};\n            end\n            else begin\n                pht_table[pht_table_index] <= {pht_table_taken, pht_table_value};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "lemmings4", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tlocalparam [1:0] STATE_WALK_LEFT = 2'b00;\n\tlocalparam [1:0] STATE_WALK_RIGHT = 2'b01;\n\tlocalparam [1:0] STATE_DIG = 2'b10;\n\tlocalparam [1:0] STATE_FALL = 2'b11;\n\n\t// Define the output signals\n\treg walk_left;\n\treg walk_right;\n\treg aaah;\n\treg digging;\n\n\t// Define the state register and next state logic\n\treg [1:0] state, next_state;\n\talways @ (posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= STATE_WALK_LEFT;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Define the output logic\n\talways @ (state, bump_left, bump_right, ground, dig) begin\n\t\tcase (state)\n\t\t\tSTATE_WALK_LEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\tend else if (bump_right) begin\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\tend else if (ground == 0) begin\n\t\t\t\t\tnext_state = STATE_FALL;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = STATE_DIG;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_WALK_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\tend else if (bump_right) begin\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\tend else if (ground == 0) begin\n\t\t\t\t\tnext_state = STATE_FALL;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = STATE_DIG;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_DIG: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 1;\n\t\t\t\tif (ground == 0) begin\n\t\t\t\t\tnext_state = STATE_FALL;\n\t\t\t\tend else if (!dig) begin\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STATE_DIG;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_FALL: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 1;\n\t\t\t\tdigging = 0;\n\t\t\t\tif (ground) begin\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state"}
{"task_id": "review2015_fsm", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nWe want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "and end with:\n```verilog\nendmodule"}
{"task_id": "conwaylife", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "Module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n\n\treg [255:0] next_q;\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tnext_q <= data;\n\t\tend else begin\n\t\t\tnext_q <= q;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\t// Rule 1: 0-1 neighbours\n\t\tnext_q[0] <= q[15] & ~(q[1] | q[0]);\n\t\tnext_q[1] <= q[1] & ~(q[0] | q[15]);\n\t\tnext_q[2] <= q[2] & ~(q[1] | q[15] | q[0]);\n\t\tnext_q[3] <= q[3] & ~(q[2] | q[15] | q[0] | q[1]);\n\t\tnext_q[4] <= q[4] & ~(q[3] | q[15] | q[0] | q[1] | q[2] | q[14]);\n\t\tnext_q[5] <= q[5] & ~(q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[6] <= q[6] & ~(q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[7] <= q[7] & ~(q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[8] <= q[8] & ~(q[7] | q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[9] <= q[9] & ~(q[8] | q[7] | q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[10] <= q[10] & ~(q[9] | q[8] | q[7] | q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[11] <= q[11] & ~(q[10] | q[9] | q[8] | q[7] | q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[12] <= q[12] & ~(q[11] | q[10] | q[9] | q[8] | q[7] | q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q[13]);\n\t\tnext_q[13] <= q[13] & ~(q[12] | q[11] | q[10] | q[9] | q[8] | q[7] | q[6] | q[5] | q[4] | q[3] | q[15] | q[0] | q[1] | q[2] | q[14] | q["}
{"task_id": "lemmings3", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "Module state_machine (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\n\t// Define the states\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter falling_state = 2'b10;\n\tparameter digging_state = 2'b11;\n\n\t// Define the output signals\n\treg walk_left;\n\treg walk_right;\n\treg aaah;\n\treg digging;\n\n\t// Define the state and next state registers\n\treg [1:0] state, next_state;\n\n\t// Define the state transition logic\n\talways @ (posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left_state;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Define the next state logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\twalk_left_state: begin\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = walk_right_state;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\twalk_right_state: begin\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = walk_right_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\tfalling_state: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = falling_state;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdigging_state: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = falling_state;\n\t\t\t\tend else if (!dig) begin\n\t\t\t\t\tnext_state = walk_left_state;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = digging_state;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Define the output logic\n\talways @ (*) begin\n\t\tcase (state)\n\t\t\twalk_left_state: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\twalk_right_state: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\tfalling_state: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 1;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\tdigging_state: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 1;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule"}
{"task_id": "count_clock", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "Do not add any additional code outside the module. Your code should be well-formatted and use consistent indentation. Do not use tabs. Use four spaces for indentation. Follow the Verilog style guide for the language.\nmodule top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\n\t// Declare internal signals\n\treg [3:0] hours;\n\treg [3:0] minutes;\n\treg [3:0] seconds;\n\treg [1:0] state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n\t// Initialize signals\n\tinitial begin\n\t\thh = 8'b00000001;\n\t\tmm = 8'b00000000;\n\t\tss = 8'b00000000;\n\t\tpm = 1'b0;\n\t\tstate = S0;\n\tend\n\n\t// State machine\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\thh <= 8'b00000001;\n\t\t\tmm <= 8'b00000000;\n\t\t\tss <= 8'b00000000;\n\t\t\tpm <= 1'b0;\n\t\t\tstate <= S0;\n\t\tend else if (ena) begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (hh == 8'b1111) begin\n\t\t\t\t\t\thh <= 8'b0000;\n\t\t\t\t\t\tif (mm == 8'b1011) begin\n\t\t\t\t\t\t\tmm <= 8'b0000;\n\t\t\t\t\t\t\tif (ss == 8'b1011) begin\n\t\t\t\t\t\t\t\tss <= 8'b0000;\n\t\t\t\t\t\t\t\tif (pm) begin\n\t\t\t\t\t\t\t\t\tpm <= 1'b0;\n\t\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\t\tpm <= 1'b1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tss <= ss + 1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tmm <= mm + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\thh <= hh + 1;\n\t\t\t\t\tend\n\t\t\t\t\tstate <= S1;\n\t\t\t\tend\n\t\t\t\tS1: begin\n\t\t\t\t\thh <= hh;\n\t\t\t\t\tmm <= mm;\n\t\t\t\t\tss <= ss;\n\t\t\t\t\tstate <= S0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// Convert BCD to binary\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\thh <= 8'b00000001;\n\t\t\tmm <= 8'b00000000;\n\t\t\tss <= 8'b00000000;\n\t\tend else if (ena) begin\n\t\t\tcase (state)\n\t\t\t\tS0: begin\n\t\t\t\t\tif (hh == 8'b1111) begin\n\t\t\t\t\t\thh <= 8'b0000;\n\t\t\t\t\t\tif (mm == 8'b1011) begin\n\t\t\t\t\t\t\tmm <= 8'b0000;\n\t\t\t\t\t\t\tif (ss == 8'b1011) begin"}
{"task_id": "lemmings2", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nThe game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "reg [1:0] state;\n\tparameter walk_left_state = 2'b00;\n\tparameter walk_right_state = 2'b01;\n\tparameter fall_state = 2'b10;\n\t\n\tassign walk_left = (state == walk_left_state);\n\tassign walk_right = (state == walk_right_state);\n\tassign aaah = (state == fall_state);\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= walk_left_state;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\twalk_left_state: begin\n\t\t\t\t\tif (bump_right) begin\n\t\t\t\t\t\tstate <= walk_right_state;\n\t\t\t\t\tend else if (ground == 0) begin\n\t\t\t\t\t\tstate <= fall_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\twalk_right_state: begin\n\t\t\t\t\tif (bump_left) begin\n\t\t\t\t\t\tstate <= walk_left_state;\n\t\t\t\t\tend else if (ground == 0) begin\n\t\t\t\t\t\tstate <= fall_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfall_state: begin\n\t\t\t\t\tif (ground == 1) begin\n\t\t\t\t\t\tstate <= walk_left_state;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule"}
{"task_id": "countbcd", "description": "You are a Verilog expert. Be concise and focused on the key points and avoid repetitive thoughts. Provide the Verilog code design directly.\n\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.\nPlease complete the Verilog code below and return the complete module code. Your code should start with:\n```verilog\n", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "Do not use comments to explain the code. Write self-explanatory code. Avoid using unnecessary variables. Use meaningful names for variables and functions.\n\nFollow the Verilog coding standard and convention.\n\nDo not use any non-Verilog code such as C, C++, etc.\n\n \t// 4-digit BCD counter\n\treg [3:0] ones_digit;\n\treg [3:0] tens_digit;\n\treg [3:0] hundreds_digit;\n\treg [3:0] thousands_digit;\n\n\tassign ena = {0, ones_digit != 0, tens_digit != 0, hundreds_digit != 0};\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'd0;\n\t\tend else begin\n\t\t\tif (thousands_digit == 4'd9) begin\n\t\t\t\tthousands_digit <= 4'd0;\n\t\t\tend else begin\n\t\t\t\tthousands_digit <= thousands_digit + 1;\n\t\t\tend\n\n\t\t\tif (hundreds_digit == 4'd9 && tens_digit == 4'd9) begin\n\t\t\t\thundreds_digit <= 4'd0;\n\t\t\t\ttens_digit <= 4'd0;\n\t\t\tend else if (hundreds_digit == 4'd9) begin\n\t\t\t\thundreds_digit <= 4'd0;\n\t\t\t\ttens_digit <= tens_digit + 1;\n\t\t\tend else if (tens_digit == 4'd9) begin\n\t\t\t\ttens_digit <= 4'd0;\n\t\t\t\tones_digit <= ones_digit + 1;\n\t\t\tend else begin\n\t\t\t\ttens_digit <= tens_digit + 1;\n\t\t\tend\n\n\t\t\tif (ones_digit == 4'd9) begin\n\t\t\t\tones_digit <= 4'd0;\n\t\t\tend else begin\n\t\t\t\tones_digit <= ones_digit + 1;\n\t\t\tend\n\t\tend\n\tend\nendmodule"}
